--- TIMER VÀ TIMERTASK TRONG JAVA

1. TỔNG QUAN

Trong Java, Timer và TimerTask thuộc package:
java.util

Chúng được dùng để:
- Lập lịch (schedule) một công việc
- Chạy công việc đó ở:
  + Một thời điểm xác định trong tương lai
  + Sau một khoảng delay
  + Lặp lại theo chu kỳ cố định

Timer quản lý luồng (thread)
TimerTask là công việc cụ thể cần chạy


------------------------------------------------------------
2. TIMER LÀ GÌ?

Timer là một class:
- Quản lý một background thread duy nhất
- Thread này dùng để thực thi các TimerTask

Đặc điểm:
- Mỗi Timer chỉ có 1 thread
- Các TimerTask chạy tuần tự, không song song
- Nếu 1 task chạy lâu -> các task sau bị trễ


------------------------------------------------------------
3. TIMERTASK LÀ GÌ?

TimerTask là:
- Một abstract class
- Đại diện cho 1 công việc sẽ được Timer thực thi

Bạn phải:
- Kế thừa TimerTask
- Override phương thức run()

Cú pháp:
class MyTask extends TimerTask {
    public void run() {
        // logic cần chạy
    }
}


------------------------------------------------------------
4. MỐI QUAN HỆ TIMER – TIMERTASK

Timer:
- Lập lịch
- Quản lý thời gian
- Gọi run() của TimerTask

TimerTask:
- Chứa logic nghiệp vụ
- Không tự chạy
- Phải được đăng ký với Timer

Quan hệ:
1 Timer có thể quản lý nhiều TimerTask


------------------------------------------------------------
5. CÁC PHƯƠNG THỨC schedule()

Timer cung cấp nhiều overload của schedule().

5.1 Chạy 1 lần sau delay

timer.schedule(task, delay)

delay:
- Đơn vị: milliseconds
- Sau delay ms thì task chạy 1 lần

Ví dụ:
timer.schedule(task, 5000)
-> chạy sau 5 giây


----------------------------
5.2 Chạy 1 lần tại thời điểm xác định

timer.schedule(task, Date time)

Ví dụ:
Date date = new Date(System.currentTimeMillis() + 5000)
timer.schedule(task, date)


----------------------------
5.3 Chạy lặp với delay cố định (fixed-delay)

timer.schedule(task, delay, period)

Đặc điểm:
- Lần chạy tiếp theo = thời điểm KẾT THÚC lần trước + period
- Nếu task chạy lâu -> lịch bị trễ

Ví dụ:
timer.schedule(task, 1000, 2000)

Dòng thời gian:
- Chờ 1s
- Chạy task
- Sau khi task xong, chờ 2s
- Chạy tiếp


----------------------------
5.4 Chạy lặp với mốc thời gian cố định (fixed-rate)

timer.scheduleAtFixedRate(task, delay, period)

Đặc điểm:
- Dựa trên mốc thời gian ban đầu
- Cố gắng bù thời gian nếu bị trễ
- Phù hợp cho job định kỳ chính xác

Ví dụ:
timer.scheduleAtFixedRate(task, 1000, 2000)


------------------------------------------------------------
6. schedule() vs scheduleAtFixedRate()

So sánh:

schedule():
- Dựa vào thời điểm kết thúc task
- Dễ bị trễ nếu task chạy lâu
- An toàn hơn nếu task nặng

scheduleAtFixedRate():
- Dựa vào mốc thời gian cố định
- Có thể chạy liên tục nếu task bị trễ
- Phù hợp cho clock, polling


------------------------------------------------------------
7. VÒNG ĐỜI TIMERTASK

TimerTask có 3 trạng thái:
1. VIRGIN
   - Mới tạo
   - Chưa được schedule

2. SCHEDULED
   - Đã được Timer quản lý

3. CANCELLED
   - Bị hủy
   - Không thể schedule lại


------------------------------------------------------------
8. HỦY TASK VÀ TIMER

8.1 Hủy 1 TimerTask

task.cancel()

Tác dụng:
- Ngăn task chạy tiếp
- Không dừng nếu task đang chạy


----------------------------
8.2 Hủy toàn bộ Timer

timer.cancel()

Tác dụng:
- Dừng thread của Timer
- Hủy tất cả TimerTask
- Không thể dùng lại Timer này


------------------------------------------------------------
9. LƯU Ý QUAN TRỌNG (CỰC KỲ DỄ DÍNH LỖI)

1. Timer chỉ có 1 thread
   - 1 task lỗi -> cả Timer dừng

2. RuntimeException trong run()
   - Timer thread chết
   - Các task sau không chạy

3. Không phù hợp cho task nặng
   - Dễ gây delay dây chuyền

4. Không có thread pool
   - Không chạy song song


------------------------------------------------------------
10. TIMER vs SCHEDULED EXECUTOR SERVICE

Timer (cũ):
- 1 thread
- Dễ chết toàn bộ
- Ít được khuyên dùng

ScheduledExecutorService (mới):
- Thread pool
- Cách ly task
- An toàn hơn
- Nên dùng trong production


------------------------------------------------------------
11. KHI NÀO NÊN DÙNG TIMERTASK?

NÊN:
- Demo
- Bài tập
- Tool nhỏ
- Task rất nhẹ

KHÔNG NÊN:
- Production system
- Task nặng
- Hệ thống cần độ chính xác cao
- Microservice


------------------------------------------------------------
12. VÍ DỤ HOÀN CHỈNH

import java.util.Timer;
import java.util.TimerTask;

public class Demo {
    public static void main(String[] args) {
        Timer timer = new Timer();

        TimerTask task = new TimerTask() {
            @Override
            public void run() {
                System.out.println("Task running...");
            }
        };

        timer.schedule(task, 2000, 3000);
    }
}


------------------------------------------------------------
13. TÓM TẮT 1 DÒNG

Timer = bộ lập lịch
TimerTask = công việc
1 Timer = 1 thread
Task chạy tuần tự
Dễ lỗi -> nên thay bằng ScheduledExecutorService
------------------------------------------------------------


--- Hàm run() của timertask bao giờ được thực thi

GIẢI THÍCH CHI TIẾT: KHI NÀO HÀM run() CỦA TimerTask ĐƯỢC THỰC THI

--------------------------------------------------
1. TimerTask là gì?
--------------------------------------------------
- TimerTask là một lớp trừu tượng (abstract class) trong package java.util
- Nó đại diện cho MỘT CÔNG VIỆC (task) sẽ được thực thi TRONG TƯƠNG LAI
- Lớp này có duy nhất 1 phương thức cần override:
  
  public void run()

=> run() CHÍNH LÀ logic bạn muốn chương trình tự động chạy theo thời gian


--------------------------------------------------
2. run() CÓ TỰ ĐỘNG CHẠY KHÔNG?
--------------------------------------------------
CÂU TRẢ LỜI: KHÔNG ❌

- Việc tạo TimerTask KHÔNG làm run() chạy
- Việc override run() KHÔNG làm run() chạy
- run() KHÔNG BAO GIỜ được gọi trực tiếp bởi bạn

=> run() CHỈ được JVM gọi thông qua đối tượng Timer


--------------------------------------------------
3. Điều kiện ĐỂ run() được thực thi
--------------------------------------------------
Hàm run() của TimerTask CHỈ ĐƯỢC THỰC THI khi TẤT CẢ các điều kiện sau đúng:

1. Có một đối tượng Timer
2. TimerTask đã được đăng ký (schedule) với Timer
3. Thời điểm thực thi đã tới (hoặc tới chu kỳ lặp)
4. Timer vẫn đang hoạt động (chưa bị cancel)
5. TimerTask chưa bị cancel


--------------------------------------------------
4. Ai gọi run()?
--------------------------------------------------
- KHÔNG phải main thread
- KHÔNG phải thread của bạn
- MÀ LÀ: một thread nền (background thread) do Timer tự tạo

=> Timer sử dụng 1 THREAD DUY NHẤT để chạy TẤT CẢ TimerTask


--------------------------------------------------
5. Các cách schedule TimerTask và ảnh hưởng tới run()
--------------------------------------------------

--------------------------------------------------
5.1 schedule(task, delay)
--------------------------------------------------
timer.schedule(task, delay);

- delay: số mili-giây (ms) chờ trước khi chạy
- run() sẽ chạy MỘT LẦN DUY NHẤT
- run() được gọi SAU delay ms kể từ lúc schedule

Ví dụ:
delay = 5000
=> run() chạy sau 5 giây


--------------------------------------------------
5.2 schedule(task, date)
--------------------------------------------------
timer.schedule(task, date);

- run() chạy 1 lần tại thời điểm cụ thể
- Nếu thời điểm date < thời gian hiện tại:
  => run() chạy NGAY LẬP TỨC


--------------------------------------------------
5.3 schedule(task, delay, period)
--------------------------------------------------
timer.schedule(task, delay, period);

- run() chạy LẦN ĐẦU sau delay ms
- Sau đó CHẠY LẶP LẠI mỗi period ms
- Nếu run() chạy lâu hơn period:
  => LẦN SAU BỊ TRỄ (Timer không tạo thread mới)


--------------------------------------------------
5.4 scheduleAtFixedRate(task, delay, period)
--------------------------------------------------
timer.scheduleAtFixedRate(task, delay, period);

- run() chạy LẦN ĐẦU sau delay
- Các lần sau cố gắng bám sát chu kỳ period
- Nếu bị trễ:
  => Timer cố chạy BÙ cho các lần đã trễ


--------------------------------------------------
6. run() KHÔNG chạy trong các trường hợp sau
--------------------------------------------------
run() KHÔNG BAO GIỜ được gọi nếu:

- Timer chưa gọi schedule()
- Timer đã bị cancel()
- TimerTask đã bị cancel()
- JVM đã kết thúc
- Thread của Timer bị chết do Exception chưa bắt


--------------------------------------------------
7. Điều cực kỳ quan trọng về Exception
--------------------------------------------------
- Nếu run() NÉM RA RuntimeException hoặc Error
- Timer thread sẽ CHẾT
- TẤT CẢ TimerTask khác sẽ KHÔNG BAO GIỜ chạy nữa

=> Vì vậy: LUÔN try-catch bên trong run()

Ví dụ:
public void run() {
    try {
        // logic
    } catch (Exception e) {
        // handle
    }
}


--------------------------------------------------
8. Thời điểm chính xác run() được thực thi (timeline)
--------------------------------------------------
Giả sử:

- Thời gian hiện tại: T0
- Gọi timer.schedule(task, 3000)

Timeline:
T0        : gọi schedule
T0 + 3s   : Timer thread gọi run()
T0 + 3s+x : run() kết thúc


--------------------------------------------------
9. run() chạy song song không?
--------------------------------------------------
KHÔNG ❌

- Timer chỉ có 1 thread
- Các TimerTask chạy TUẦN TỰ
- Một task chạy lâu => task khác bị block


--------------------------------------------------
10. Tóm tắt ngắn gọn (cực quan trọng)
--------------------------------------------------
- run() KHÔNG tự chạy
- run() chỉ chạy khi Timer gọi
- run() chạy trong thread của Timer
- run() chạy khi:
  + Timer.schedule(...) được gọi
  + Đúng thời điểm delay / date / period
- Exception trong run() có thể làm Timer chết

--------------------------------------------------
11. Một câu ghi nhớ
--------------------------------------------------
"TimerTask chỉ là kế hoạch, Timer mới là người thực thi,
và run() chỉ chạy khi đến đúng thời điểm đã được schedule."


--- ChromeOptions trong Selenium

GIẢI THÍCH CHI TIẾT: CHROMEOPTIONS TRONG SELENIUM ĐƯỢC THỰC THI KHI NÀO

==================================================
1. ChromeOptions là gì?
==================================================
- ChromeOptions là một lớp trong Selenium dùng để:
  + Cấu hình hành vi của trình duyệt Chrome
  + Thay đổi cách Chrome KHỞI ĐỘNG
  + Truyền các tham số dòng lệnh (command-line arguments) cho Chrome

- ChromeOptions KHÔNG điều khiển Chrome sau khi đã mở
- ChromeOptions CHỈ có tác dụng TẠI THỜI ĐIỂM KHỞI TẠO Chrome


==================================================
2. ChromeOptions CÓ TỰ ĐỘNG THỰC THI KHÔNG?
==================================================
CÂU TRẢ LỜI: KHÔNG ❌

- Tạo đối tượng ChromeOptions KHÔNG làm gì xảy ra
- Gọi addArguments(), setExperimentalOption() KHÔNG làm Chrome thay đổi ngay
- ChromeOptions CHỈ được "thực thi" khi:
  
  -> WebDriver được khởi tạo với ChromeOptions


==================================================
3. THỜI ĐIỂM CHÍNH XÁC ChromeOptions ĐƯỢC THỰC THI
==================================================
ChromeOptions được thực thi DUY NHẤT tại thời điểm sau:

  new ChromeDriver(chromeOptions)

HOẶC

  new RemoteWebDriver(capabilities)

=> Ngay lúc ChromeDriver được tạo, Selenium sẽ:
  1. Đọc toàn bộ cấu hình trong ChromeOptions
  2. Chuyển chúng thành Chrome command-line flags
  3. Gửi cấu hình đó cho ChromeDriver
  4. ChromeDriver KHỞI ĐỘNG Chrome với các cấu hình này


==================================================
4. ChromeOptions ĐƯỢC THỰC THI TRƯỚC HAY SAU KHI CHROME MỞ?
==================================================
- ChromeOptions được thực thi TRƯỚC khi Chrome mở
- Sau khi Chrome đã mở:
  + ChromeOptions KHÔNG còn tác dụng
  + Không thể thay đổi headless, user-agent, profile, disable-gpu,...

=> ChromeOptions = CẤU HÌNH KHỞI ĐỘNG (startup configuration)


==================================================
5. DÒNG ĐỜI (LIFECYCLE) CỦA ChromeOptions
==================================================
Timeline:

Bước 1: new ChromeOptions()
        (chỉ tạo object, CHƯA có tác động)

Bước 2: options.addArguments(...)
        options.setExperimentalOption(...)
        (chỉ lưu cấu hình trong bộ nhớ)

Bước 3: new ChromeDriver(options)
        => ChromeOptions ĐƯỢC THỰC THI TẠI ĐÂY

Bước 4: Chrome process được spawn
        => Chrome chạy với các flags đã cấu hình

Bước 5: driver.get("url")
        => Chrome đã mở, options KHÔNG còn tác dụng


==================================================
6. ChromeOptions CÓ ĐƯỢC THỰC THI LẠI KHÔNG?
==================================================
KHÔNG ❌

- ChromeOptions CHỈ được đọc MỘT LẦN
- Không thể:
  + Thay đổi options giữa chừng
  + Gọi lại options để áp dụng lại
- Muốn thay đổi ChromeOptions:
  => PHẢI tắt Chrome và tạo WebDriver MỚI


==================================================
7. Ví dụ minh họa THỜI ĐIỂM THỰC THI
==================================================
ChromeOptions options = new ChromeOptions();
options.addArguments("--headless");
options.addArguments("--disable-gpu");

WebDriver driver = new ChromeDriver(options);

=> "--headless" và "--disable-gpu" được thực thi
   NGAY TẠI DÒNG new ChromeDriver(options)


==================================================
8. Điều gì xảy ra NẾU sửa ChromeOptions SAU KHI Chrome mở?
==================================================
Ví dụ:
driver = new ChromeDriver(options);
options.addArguments("--incognito");

=> "--incognito" KHÔNG có tác dụng
=> Chrome đã được khởi động rồi


==================================================
9. ChromeOptions có chạy trong thread nào?
==================================================
- ChromeOptions KHÔNG chạy trong thread
- Nó KHÔNG có run(), execute()
- Nó chỉ là CẤU HÌNH DỮ LIỆU (configuration object)

=> ChromeDriver mới là thành phần thực thi


==================================================
10. Phân biệt ChromeOptions và lệnh Selenium
==================================================
- ChromeOptions:
  + Áp dụng TRƯỚC khi Chrome mở
  + Ảnh hưởng tới môi trường trình duyệt

- Selenium commands (get, click, sendKeys):
  + Áp dụng SAU khi Chrome đã mở
  + Điều khiển hành vi trong phiên browser


==================================================
11. Các loại cấu hình được thực thi trong ChromeOptions
==================================================
ChromeOptions có thể thực thi:
- Command-line arguments
- User profile (user-data-dir)
- Extensions
- Experimental options
- Preferences (download, popup, notification)
- Headless mode
- Proxy
- User-Agent


==================================================
12. ChromeOptions KHÔNG ĐƯỢC THỰC THI TRONG CÁC TRƯỜNG HỢP SAU
==================================================
- Chỉ tạo ChromeOptions nhưng không truyền vào ChromeDriver
- Truyền ChromeOptions nhưng không tạo driver
- Sửa ChromeOptions sau khi driver đã khởi tạo
- Chrome crash và được Selenium attach lại


==================================================
13. Tóm tắt CỐT LÕI (rất quan trọng)
==================================================
- ChromeOptions KHÔNG tự thực thi
- ChromeOptions chỉ là cấu hình
- ChromeOptions được thực thi:
  + DUY NHẤT tại thời điểm new ChromeDriver(options)
- Mọi cấu hình phải hoàn tất TRƯỚC khi tạo WebDriver
- Muốn thay đổi ChromeOptions:
  => PHẢI tạo driver mới


==================================================
14. Một câu ghi nhớ
==================================================
"ChromeOptions không điều khiển Chrome đang chạy,
nó chỉ quyết định Chrome sẽ được sinh ra NHƯ THẾ NÀO."


--- CHROMEOPTIONS KHÁC GÌ VỚI WEBDRIVER

GIẢI THÍCH CHI TIẾT NHẤT:
CHROMEOPTIONS KHÁC GÌ VỚI WEBDRIVER
VÀ KHI NÀO MỖI CÁI ĐƯỢC THỰC THI

==================================================
1. BẢN CHẤT CỐT LÕI
==================================================

--------------------------------------------------
1.1 ChromeOptions là gì?
--------------------------------------------------
- ChromeOptions là ĐỐI TƯỢNG CẤU HÌNH (configuration object)
- Nhiệm vụ:
  + Quyết định Chrome sẽ được KHỞI ĐỘNG như thế nào
  + Truyền tham số khởi động cho Chrome

- ChromeOptions:
  + KHÔNG điều khiển Chrome
  + KHÔNG chạy logic
  + KHÔNG có thread
  + KHÔNG có execute()

=> ChromeOptions = "BẢN THIẾT KẾ CHO CHROME TRƯỚC KHI SINH RA"


--------------------------------------------------
1.2 WebDriver là gì?
--------------------------------------------------
- WebDriver là ĐỐI TƯỢNG ĐIỀU KHIỂN (controller)
- Nhiệm vụ:
  + Giao tiếp với trình duyệt đang chạy
  + Gửi lệnh click, get, sendKeys, executeScript
  + Quản lý vòng đời của browser session

=> WebDriver = "NGƯỜI ĐIỀU KHIỂN CHROME SAU KHI ĐÃ MỞ"


==================================================
2. SỰ KHÁC NHAU VỀ THỜI ĐIỂM THỰC THI
==================================================

--------------------------------------------------
2.1 ChromeOptions được thực thi khi nào?
--------------------------------------------------
ChromeOptions CHỈ được thực thi tại MỘT THỜI ĐIỂM DUY NHẤT:

  new ChromeDriver(chromeOptions)

Tại thời điểm này:
- Selenium đọc toàn bộ ChromeOptions
- Chuyển chúng thành command-line flags
- Gửi cho ChromeDriver
- ChromeDriver KHỞI ĐỘNG Chrome với cấu hình đó

=> SAU thời điểm này, ChromeOptions HẾT TÁC DỤNG


--------------------------------------------------
2.2 WebDriver được thực thi khi nào?
--------------------------------------------------
WebDriver bắt đầu thực thi:
- NGAY SAU khi Chrome được khởi động thành công
- Xuyên SUỐT vòng đời của browser session

Ví dụ:
driver.get()
driver.findElement()
driver.click()
driver.quit()

=> WebDriver hoạt động LIÊN TỤC cho đến khi driver.quit()


==================================================
3. TIMELINE TỔNG THỂ (RẤT QUAN TRỌNG)
==================================================

Timeline chuẩn:

Bước 1: new ChromeOptions()
        (CHƯA có tác động gì)

Bước 2: options.addArguments(...)
        options.setExperimentalOption(...)
        (CHỈ lưu cấu hình)

Bước 3: new ChromeDriver(options)
        => CHROMEOPTIONS ĐƯỢC THỰC THI

Bước 4: Chrome mở thành công
        => WebDriver BẮT ĐẦU CÓ QUYỀN ĐIỀU KHIỂN

Bước 5: driver.get(), click(), sendKeys()
        => WebDriver THỰC THI LỆNH

Bước 6: driver.quit()
        => WebDriver KẾT THÚC


==================================================
4. SO SÁNH TRỰC TIẾP CHROMEOPTIONS VS WEBDRIVER
==================================================

| Tiêu chí                | ChromeOptions                  | WebDriver                     |
|-------------------------|--------------------------------|-------------------------------|
| Bản chất                | Cấu hình                       | Điều khiển                    |
| Tác động lên Chrome     | Trước khi mở                   | Sau khi mở                    |
| Có thực thi logic không | Không                          | Có                            |
| Có thread không         | Không                          | Có (qua driver service)       |
| Thay đổi runtime được? | Không                          | Có                            |
| Sống trong bao lâu?     | Chỉ lúc khởi tạo               | Suốt session                  |


==================================================
5. VÍ DỤ SO SÁNH TRỰC QUAN
==================================================

ChromeOptions:
- headless
- incognito
- user-agent
- proxy
- profile
=> PHẢI quyết định TRƯỚC

WebDriver:
- mở URL
- click button
- nhập text
- scroll
- execute JavaScript
=> LÀM SAU KHI CHROME ĐÃ MỞ


==================================================
6. ĐIỀU GÌ XẢY RA NẾU DÙNG SAI?
==================================================

--------------------------------------------------
6.1 Dùng ChromeOptions để làm việc của WebDriver
--------------------------------------------------
options.addArguments("open url")

=> SAI HOÀN TOÀN
=> ChromeOptions KHÔNG điều khiển hành vi


--------------------------------------------------
6.2 Dùng WebDriver để làm việc của ChromeOptions
--------------------------------------------------
driver.setHeadless(true)

=> KHÔNG TỒN TẠI
=> Chrome đã mở, không thể đổi cách khởi động


==================================================
7. VÌ SAO SELENIUM THIẾT KẾ NHƯ VẬY?
==================================================
- ChromeOptions map trực tiếp vào:
  + Chrome command-line arguments
- Command-line arguments:
  + CHỈ có hiệu lực lúc process start
  + Không thể đổi khi process đang chạy

=> Selenium BẮT BUỘC tách:
- CẤU HÌNH KHỞI ĐỘNG (ChromeOptions)
- ĐIỀU KHIỂN RUNTIME (WebDriver)


==================================================
8. CHROMEOPTIONS CÓ BAO GIỜ ĐƯỢC THỰC THI LẠI?
==================================================
KHÔNG ❌

- Muốn thay đổi ChromeOptions:
  => driver.quit()
  => new ChromeDriver(newOptions)


==================================================
9. TÓM TẮT CỐT LÕI (CỰC QUAN TRỌNG)
==================================================
- ChromeOptions:
  + Quyết định Chrome SINH RA NHƯ THẾ NÀO
  + Thực thi DUY NHẤT lúc tạo ChromeDriver

- WebDriver:
  + Điều khiển Chrome ĐÃ SINH RA
  + Thực thi LIÊN TỤC cho đến khi quit


==================================================
10. MỘT CÂU GHI NHỚ
==================================================
"ChromeOptions quyết định CHROME ĐƯỢC SINH RA THẾ NÀO,
WebDriver quyết định CHROME SẼ LÀM GÌ SAU ĐÓ."


--- JAVA AWT:

GIẢI THÍCH CHI TIẾT NHẤT: JAVA AWT (ABSTRACT WINDOW TOOLKIT)

==================================================
1. JAVA AWT LÀ GÌ?
==================================================
- AWT (Abstract Window Toolkit) là thư viện GUI (Graphical User Interface)
  đầu tiên của Java
- Thuộc package: java.awt
- Dùng để:
  + Tạo cửa sổ (window)
  + Tạo nút bấm, textbox, label
  + Xử lý sự kiện chuột, bàn phím
  + Vẽ đồ họa cơ bản (2D)

=> AWT cho phép Java xây dựng ứng dụng CÓ GIAO DIỆN ĐỒ HỌA


==================================================
2. VÌ SAO GỌI LÀ "ABSTRACT WINDOW TOOLKIT"?
==================================================
- "Abstract":
  + AWT không tự vẽ giao diện
  + Nó TRỪU TƯỢNG HÓA các thành phần GUI

- "Window Toolkit":
  + Cung cấp bộ công cụ để làm việc với cửa sổ hệ điều hành

=> AWT đóng vai trò CẦU NỐI giữa Java và HỆ ĐIỀU HÀNH


==================================================
3. BẢN CHẤT HOẠT ĐỘNG CỦA AWT (RẤT QUAN TRỌNG)
==================================================
- AWT sử dụng thành phần GUI GỐC của hệ điều hành
  + Windows: button Windows
  + macOS: button macOS
  + Linux: button GTK/X11

=> AWT là thư viện "HEAVYWEIGHT COMPONENT"

Hệ quả:
- Giao diện phụ thuộc hệ điều hành
- Mỗi OS hiển thị KHÁC NHAU
- Khó kiểm soát giao diện đồng nhất


==================================================
4. KIẾN TRÚC TỔNG QUAN CỦA AWT
==================================================

AWT gồm 4 nhóm chính:
1. Container (chứa)
2. Component (thành phần giao diện)
3. Layout Manager (bố cục)
4. Event Handling (xử lý sự kiện)


==================================================
5. COMPONENT TRONG AWT
==================================================
- Component là lớp cha của MỌI thành phần giao diện

Các component phổ biến:
- Button      : nút bấm
- Label       : nhãn chữ
- TextField   : ô nhập 1 dòng
- TextArea    : ô nhập nhiều dòng
- Checkbox    : checkbox
- Choice      : dropdown
- List        : danh sách
- Canvas      : vùng vẽ tự do

=> Mọi component đều kế thừa java.awt.Component


==================================================
6. CONTAINER TRONG AWT
==================================================
- Container là component có thể CHỨA component khác

Các container quan trọng:
- Frame       : cửa sổ chính
- Dialog      : cửa sổ hộp thoại
- Panel       : nhóm component
- ScrollPane  : vùng cuộn

Ví dụ quan hệ:
Frame
 └── Panel
     ├── Button
     └── TextField


==================================================
7. FRAME – CỬA SỔ CHÍNH
==================================================
- Frame đại diện cho cửa sổ độc lập
- Có:
  + Thanh tiêu đề
  + Nút đóng / thu nhỏ
  + Border

- Thường là entry point của ứng dụng AWT

Ví dụ khái niệm:
Frame = "cái cửa sổ lớn bạn nhìn thấy"


==================================================
8. LAYOUT MANAGER (QUẢN LÝ BỐ CỤC)
==================================================
- AWT KHÔNG đặt vị trí bằng tọa độ cố định (khuyến nghị)
- Layout Manager tự động sắp xếp component

Các layout phổ biến:
- FlowLayout   : trái → phải
- BorderLayout : Bắc, Nam, Đông, Tây, Trung tâm
- GridLayout   : dạng bảng
- CardLayout   : dạng thẻ
- GridBagLayout: linh hoạt nhất (phức tạp)

=> Layout giúp giao diện co giãn theo kích thước cửa sổ


==================================================
9. EVENT HANDLING TRONG AWT
==================================================
- AWT hoạt động theo mô hình EVENT-DRIVEN

Luồng xử lý:
1. Người dùng thao tác (click, gõ phím)
2. Event được tạo ra
3. Listener bắt event
4. Code xử lý được gọi

Các event phổ biến:
- ActionEvent   : click button
- MouseEvent    : chuột
- KeyEvent      : bàn phím
- WindowEvent   : đóng/mở cửa sổ


==================================================
10. LISTENER TRONG AWT
==================================================
- Listener là interface
- Muốn xử lý event → phải implement listener

Ví dụ:
- ActionListener
- MouseListener
- KeyListener
- WindowListener

=> AWT dùng mô hình Observer (lắng nghe sự kiện)


==================================================
11. EVENT DISPATCH THREAD (EDT) – CỰC KỲ QUAN TRỌNG
==================================================
- AWT chạy GUI trên 1 thread riêng gọi là:
  EVENT DISPATCH THREAD (EDT)

- Mọi thao tác GUI:
  + Vẽ giao diện
  + Xử lý event
  PHẢI chạy trên EDT

- Nếu chạy tác vụ nặng trên EDT:
  => GUI bị đơ (freeze)


==================================================
12. AWT VẼ ĐỒ HỌA (GRAPHICS)
==================================================
- AWT cho phép vẽ 2D cơ bản qua lớp Graphics

Có thể vẽ:
- Line
- Rectangle
- Oval
- Text
- Image

Thường dùng trong:
- Canvas
- override phương thức paint()


==================================================
13. ƯU ĐIỂM CỦA AWT
==================================================
- Có sẵn trong Java (không cần thêm thư viện)
- Hiệu năng tốt (native)
- Phù hợp ứng dụng rất đơn giản
- Hiểu AWT giúp hiểu rõ nền tảng Swing/JavaFX


==================================================
14. NHƯỢC ĐIỂM CỦA AWT
==================================================
- Giao diện phụ thuộc hệ điều hành
- Ít component
- Khó tùy biến giao diện
- API cũ, thiết kế không linh hoạt
- Không phù hợp ứng dụng hiện đại


==================================================
15. AWT VS SWING VS JAVAFX
==================================================

- AWT:
  + Heavyweight
  + Native OS
  + Cũ nhất

- Swing:
  + Lightweight
  + Vẽ bằng Java
  + Mở rộng từ AWT

- JavaFX:
  + Hiện đại
  + CSS, FXML
  + Thay thế Swing


==================================================
16. AWT NGÀY NAY CÒN DÙNG KHÔNG?
==================================================
- HẦU NHƯ KHÔNG dùng để viết GUI mới
- Nhưng:
  + Vẫn tồn tại trong Java
  + Swing phụ thuộc AWT
  + Nhiều lớp nền tảng vẫn dùng AWT


==================================================
17. TÓM TẮT CỐT LÕI (RẤT QUAN TRỌNG)
==================================================
- AWT là thư viện GUI đầu tiên của Java
- AWT dùng component native của OS
- AWT hoạt động theo mô hình event-driven
- AWT chạy GUI trên Event Dispatch Thread
- AWT là nền móng của Swing


==================================================
18. MỘT CÂU GHI NHỚ
==================================================
"AWT là nền móng của GUI Java,
hiểu AWT là hiểu cách Java giao tiếp với hệ điều hành."


--- SO SÁNH JAVA AWT VÀ JAVA SWING

GIẢI THÍCH CHI TIẾT NHẤT:
SO SÁNH JAVA AWT VÀ JAVA SWING

==================================================
1. NGUỒN GỐC VÀ MỤC ĐÍCH RA ĐỜI
==================================================

--------------------------------------------------
1.1 Java AWT
--------------------------------------------------
- AWT (Abstract Window Toolkit) là thư viện GUI ĐẦU TIÊN của Java
- Xuất hiện từ những phiên bản Java đầu tiên
- Mục đích:
  + Cung cấp các thành phần giao diện cơ bản
  + Cho phép Java tạo cửa sổ và xử lý sự kiện

=> AWT là NỀN MÓNG ban đầu cho GUI Java


--------------------------------------------------
1.2 Java Swing
--------------------------------------------------
- Swing ra đời SAU AWT
- Thuộc package: javax.swing
- Mục đích:
  + Khắc phục hạn chế của AWT
  + Tạo GUI giàu tính năng hơn
  + Đồng nhất giao diện trên mọi hệ điều hành

=> Swing là BẢN NÂNG CẤP và MỞ RỘNG của AWT


==================================================
2. BẢN CHẤT KỸ THUẬT (CỰC KỲ QUAN TRỌNG)
==================================================

--------------------------------------------------
2.1 AWT – Heavyweight Components
--------------------------------------------------
- AWT sử dụng component NATIVE của hệ điều hành
- Mỗi component ánh xạ trực tiếp tới OS

Hệ quả:
- Giao diện phụ thuộc OS
- Hành vi khác nhau giữa Windows / Linux / macOS
- Khó kiểm soát chi tiết giao diện


--------------------------------------------------
2.2 Swing – Lightweight Components
--------------------------------------------------
- Swing KHÔNG dùng component native (trừ top-level container)
- Swing tự vẽ giao diện bằng Java (Graphics)

Hệ quả:
- Giao diện GIỐNG NHAU trên mọi OS
- Toàn quyền kiểm soát UI
- Dễ custom, theme, look & feel


==================================================
3. SO SÁNH VỀ KHẢ NĂNG CUNG CẤP COMPONENT
==================================================

--------------------------------------------------
3.1 AWT
--------------------------------------------------
- Số lượng component ÍT
- Chỉ có các thành phần cơ bản:
  + Button
  + Label
  + TextField
  + Checkbox
  + List

=> Phù hợp ứng dụng đơn giản


--------------------------------------------------
3.2 Swing
--------------------------------------------------
- RẤT NHIỀU component
- Component nâng cao:
  + JTable
  + JTree
  + JTabbedPane
  + JMenu
  + JOptionPane
  + JScrollPane

=> Phù hợp ứng dụng phức tạp


==================================================
4. SO SÁNH KIẾN TRÚC (MVC)
==================================================

--------------------------------------------------
4.1 AWT
--------------------------------------------------
- Không áp dụng MVC rõ ràng
- Logic, dữ liệu và giao diện thường trộn lẫn


--------------------------------------------------
4.2 Swing
--------------------------------------------------
- Thiết kế theo mô hình MVC (Model-View-Controller)
- Tách rõ:
  + Dữ liệu (Model)
  + Hiển thị (View)
  + Điều khiển (Controller)

=> Code dễ bảo trì, mở rộng


==================================================
5. LOOK AND FEEL (GIAO DIỆN HIỂN THỊ)
==================================================

--------------------------------------------------
5.1 AWT
--------------------------------------------------
- Look & Feel phụ thuộc hệ điều hành
- Không thể thay đổi đồng bộ


--------------------------------------------------
5.2 Swing
--------------------------------------------------
- Có thể đổi Look & Feel:
  + Metal
  + Nimbus
  + Windows
  + Custom L&F

=> Cùng 1 app, đổi toàn bộ giao diện chỉ bằng cấu hình


==================================================
6. HIỆU NĂNG
==================================================

--------------------------------------------------
6.1 AWT
--------------------------------------------------
- Hiệu năng tốt trong ứng dụng nhỏ
- Do dùng component native


--------------------------------------------------
6.2 Swing
--------------------------------------------------
- Có thể chậm hơn AWT trong vài trường hợp
- Nhưng bù lại:
  + Nhiều tính năng
  + Vẽ linh hoạt
  + Tối ưu tốt trong thực tế


==================================================
7. XỬ LÝ SỰ KIỆN (EVENT HANDLING)
==================================================

--------------------------------------------------
7.1 AWT
--------------------------------------------------
- Mô hình event cũ
- Ít tiện ích hỗ trợ


--------------------------------------------------
7.2 Swing
--------------------------------------------------
- Kế thừa event model của AWT
- Có thêm adapter, tiện ích
- Quản lý event tốt hơn


==================================================
8. KHẢ NĂNG TÙY BIẾN (CUSTOMIZATION)
==================================================

--------------------------------------------------
8.1 AWT
--------------------------------------------------
- Rất hạn chế
- Gần như không custom được giao diện


--------------------------------------------------
8.2 Swing
--------------------------------------------------
- Rất mạnh
- Có thể:
  + Override UI
  + Custom renderer
  + Vẽ lại component


==================================================
9. THREADING (EDT)
==================================================

--------------------------------------------------
9.1 AWT
--------------------------------------------------
- Sử dụng Event Dispatch Thread (EDT)
- Ít tài liệu hướng dẫn rõ ràng


--------------------------------------------------
9.2 Swing
--------------------------------------------------
- Cũng dùng EDT
- Quy định rõ:
  + Mọi cập nhật UI phải chạy trên EDT
- Có SwingUtilities hỗ trợ


==================================================
10. PACKAGE VÀ QUY ƯỚC ĐẶT TÊN
==================================================

--------------------------------------------------
10.1 AWT
--------------------------------------------------
- Package: java.awt
- Tên class ngắn:
  + Button
  + Frame
  + Label


--------------------------------------------------
10.2 Swing
--------------------------------------------------
- Package: javax.swing
- Tên class có tiền tố "J":
  + JButton
  + JFrame
  + JLabel

=> Giúp phân biệt rõ AWT và Swing


==================================================
11. MỨC ĐỘ PHỔ BIẾN HIỆN NAY
==================================================

--------------------------------------------------
11.1 AWT
--------------------------------------------------
- HẦU NHƯ KHÔNG dùng cho GUI mới
- Chủ yếu tồn tại vì tương thích ngược


--------------------------------------------------
11.2 Swing
--------------------------------------------------
- Vẫn được dùng trong:
  + Ứng dụng desktop nội bộ
  + Tool kỹ thuật
  + IDE (IntelliJ, Eclipse)


==================================================
12. BẢNG SO SÁNH TỔNG HỢP
==================================================

| Tiêu chí           | AWT                     | Swing                    |
|--------------------|-------------------------|--------------------------|
| Ra đời             | Sớm nhất                | Sau AWT                  |
| Component          | Ít                      | Rất nhiều                |
| Kiểu component     | Heavyweight             | Lightweight              |
| Phụ thuộc OS       | Có                      | Không                    |
| Look & Feel        | OS quyết định           | Tùy chọn                 |
| MVC                | Không rõ                | Rõ ràng                  |
| Custom UI          | Kém                     | Rất mạnh                 |
| Ứng dụng hiện đại  | Không phù hợp           | Phù hợp hơn              |


==================================================
13. KHI NÀO DÙNG AWT? KHI NÀO DÙNG SWING?
==================================================

- Dùng AWT khi:
  + Học nền tảng GUI Java
  + Ứng dụng rất đơn giản

- Dùng Swing khi:
  + Ứng dụng desktop thực tế
  + Cần nhiều component
  + Cần giao diện đồng nhất


==================================================
14. TÓM TẮT CỐT LÕI (CỰC QUAN TRỌNG)
==================================================
- AWT là nền móng GUI Java
- Swing là bản nâng cấp của AWT
- AWT = native, đơn giản
- Swing = Java thuần, mạnh, linh hoạt


==================================================
15. MỘT CÂU GHI NHỚ
==================================================
"AWT đặt nền móng,
Swing xây ngôi nhà hoàn chỉnh cho GUI Java."


--- new File(outPath).listFiles()

GIẢI THÍCH CHI TIẾT NHẤT:
CÚ PHÁP new File(outPath).listFiles()

==================================================
1. TỔNG QUAN CÚ PHÁP
==================================================

Cú pháp đầy đủ:
    new File(outPath).listFiles()

Thực chất gồm 3 phần:
1. outPath           : đường dẫn dạng String
2. new File(outPath): tạo đối tượng File đại diện cho path
3. listFiles()       : liệt kê các file/thư mục bên trong

=> Mục đích:
   LẤY DANH SÁCH FILE / THƯ MỤC CON TRONG MỘT THƯ MỤC


==================================================
2. PHẦN 1: outPath LÀ GÌ?
==================================================

- outPath là một String biểu diễn đường dẫn
- Có thể là:
  + Đường dẫn tuyệt đối
  + Đường dẫn tương đối

Ví dụ:
- "C:/data/output"
- "/home/user/logs"
- "./result"

=> outPath PHẢI trỏ tới MỘT THƯ MỤC nếu muốn listFiles()


==================================================
3. PHẦN 2: new File(outPath) LÀ GÌ?
==================================================

- java.io.File KHÔNG phải là file thật
- Nó chỉ là:
  + ĐỐI TƯỢNG ĐẠI DIỆN cho file hoặc thư mục trên hệ thống

- new File(outPath):
  + KHÔNG tạo file
  + KHÔNG kiểm tra file có tồn tại hay không
  + KHÔNG truy cập ổ đĩa ngay

=> Chỉ tạo object File trong bộ nhớ


==================================================
4. PHẦN 3: listFiles() LÀ GÌ?
==================================================

- listFiles() là method của class File
- Chức năng:
  + Truy cập hệ thống file
  + Lấy danh sách các file và thư mục CON

- Kiểu trả về:
    File[]

=> Mỗi phần tử trong mảng là 1 đối tượng File


==================================================
5. listFiles() ĐƯỢC THỰC THI KHI NÀO?
==================================================

- listFiles() được thực thi NGAY TẠI THỜI ĐIỂM GỌI METHOD
- Đây là lúc:
  + Java truy cập hệ thống file
  + OS trả về danh sách file

=> new File(outPath) KHÔNG truy cập disk
=> listFiles() MỚI LÀ CHỖ truy cập disk


==================================================
6. ĐIỀU KIỆN ĐỂ listFiles() HOẠT ĐỘNG
==================================================

listFiles() CHỈ trả về danh sách khi:

1. outPath tồn tại
2. outPath là THƯ MỤC (directory)
3. Chương trình có quyền READ thư mục đó

Nếu KHÔNG thỏa:
=> listFiles() trả về null


==================================================
7. TRƯỜNG HỢP listFiles() TRẢ VỀ null
==================================================

listFiles() trả về null khi:
- Đường dẫn không tồn tại
- Đường dẫn trỏ tới FILE (không phải thư mục)
- Không có quyền truy cập (permission)
- Lỗi I/O của hệ thống


==================================================
8. TRƯỜNG HỢP listFiles() TRẢ VỀ MẢNG RỖNG
==================================================

- Thư mục tồn tại
- Có quyền truy cập
- NHƯNG thư mục KHÔNG có file nào bên trong

=> Kết quả: new File[0]


==================================================
9. SỰ KHÁC NHAU GIỮA null VÀ MẢNG RỖNG
==================================================

- null:
  + Thư mục KHÔNG hợp lệ hoặc không đọc được

- File[0]:
  + Thư mục hợp lệ
  + Nhưng trống

=> PHẢI phân biệt rõ


==================================================
10. VÍ DỤ LUỒNG THỰC THI
==================================================

Giả sử:
outPath = "C:/logs"

Bước 1: new File(outPath)
        => Tạo object File (chưa truy cập disk)

Bước 2: gọi listFiles()
        => Java gọi OS
        => OS trả về danh sách file con

Bước 3: Java wrap mỗi file thành đối tượng File


==================================================
11. VÍ DỤ KẾT QUẢ listFiles()
==================================================

Thư mục C:/logs chứa:
- app.log
- error.log
- backup/

Kết quả:
File[0] -> C:/logs/app.log
File[1] -> C:/logs/error.log
File[2] -> C:/logs/backup


==================================================
12. listFiles() CÓ BAO GỒM FILE ẨN KHÔNG?
==================================================

- CÓ
- Miễn là:
  + OS cho phép đọc
  + Không bị filter

=> listFiles() KHÔNG tự lọc file ẩn


==================================================
13. listFiles() CÓ ĐỆ QUY KHÔNG?
==================================================

- KHÔNG ❌
- listFiles() CHỈ list CẤP 1

Muốn list đệ quy:
=> Phải tự gọi listFiles() cho từng thư mục con


==================================================
14. listFiles() CÓ SẮP XẾP KHÔNG?
==================================================

- KHÔNG đảm bảo thứ tự
- Thứ tự phụ thuộc OS

=> Muốn sort:
- Phải sort lại mảng File[]


==================================================
15. CÁC BIẾN THỂ CỦA listFiles()
==================================================

- listFiles()
- listFiles(FileFilter)
- listFiles(FilenameFilter)

=> Dùng để lọc file theo điều kiện


==================================================
16. LỖI THƯỜNG GẶP (RẤT QUAN TRỌNG)
==================================================

Lỗi 1: Không check null
=> NullPointerException

Lỗi 2: Dùng listFiles() cho file
=> Kết quả null

Lỗi 3: Nghĩ new File() là tạo file
=> HIỂU SAI


==================================================
17. TÓM TẮT CỐT LÕI
==================================================

- new File(outPath):
  + Chỉ tạo object đại diện

- listFiles():
  + Truy cập hệ thống file
  + Trả về File[] hoặc null

- listFiles() CHỈ list file con trực tiếp
- PHẢI check null trước khi dùng


==================================================
18. MỘT CÂU GHI NHỚ
==================================================

"new File() chỉ là tấm bản đồ,
listFiles() mới là lúc bạn bước ra ngoài để xem có gì."


--- ĐỂ CÓ THỂ CHẠY ĐƯỢC TEST VỚI SELENIUM BOT CẦN CÀI ĐẶT NHỮNG GÌ

GIẢI THÍCH CHI TIẾT NHẤT:
ĐỂ CÓ THỂ CHẠY ĐƯỢC TEST VỚI SELENIUM BOT
CẦN CÀI ĐẶT NHỮNG GÌ

==================================================
1. TỔNG QUAN TOÀN BỘ HỆ SINH THÁI
==================================================

Để Selenium bot chạy được, cần đầy đủ 5 nhóm thành phần:

1. NgÔN NGỮ LẬP TRÌNH + RUNTIME
2. TRÌNH DUYỆT (BROWSER)
3. BROWSER DRIVER
4. SELENIUM LIBRARY
5. TEST FRAMEWORK (khuyến nghị)

Nếu thiếu BẤT KỲ thành phần nào:
=> Selenium KHÔNG chạy được


==================================================
2. NGÔN NGỮ LẬP TRÌNH + RUNTIME
==================================================

--------------------------------------------------
2.1 Java (phổ biến nhất)
--------------------------------------------------
Cần cài:
- JDK (Java Development Kit)

Yêu cầu:
- Java 8 trở lên (khuyến nghị Java 11 hoặc 17)

Dùng để:
- Viết code Selenium
- Chạy test automation

Lưu ý:
- Cài JDK, KHÔNG phải chỉ JRE
- Phải cấu hình JAVA_HOME


--------------------------------------------------
2.2 Ngoài Java (tham khảo)
--------------------------------------------------
Selenium cũng hỗ trợ:
- Python
- C#
- JavaScript (Node.js)

Nhưng nếu dùng Java:
=> CHỈ CẦN JDK


==================================================
3. TRÌNH DUYỆT (BROWSER)
==================================================

Selenium KHÔNG tự có trình duyệt.
Bạn PHẢI cài browser thật.

Các browser phổ biến:
- Google Chrome
- Microsoft Edge
- Mozilla Firefox

Khuyến nghị:
- Chrome (ổn định, phổ biến, dễ debug)

Lưu ý quan trọng:
- Phiên bản browser ảnh hưởng trực tiếp tới browser driver
- Browser PHẢI được cài trước


==================================================
4. BROWSER DRIVER (CỰC KỲ QUAN TRỌNG)
==================================================

--------------------------------------------------
4.1 Browser Driver là gì?
--------------------------------------------------
- Browser driver là chương trình trung gian
- Là cầu nối giữa:
  Selenium code <--> Trình duyệt

Ví dụ:
- Chrome      -> ChromeDriver
- Edge        -> EdgeDriver
- Firefox     -> GeckoDriver

=> Selenium KHÔNG nói chuyện trực tiếp với browser


--------------------------------------------------
4.2 ChromeDriver (ví dụ Chrome)
--------------------------------------------------
Yêu cầu:
- Phiên bản ChromeDriver PHẢI tương thích với Chrome

Cách dùng:
- Download ChromeDriver
- Hoặc dùng WebDriverManager để tự động tải


--------------------------------------------------
4.3 Driver được dùng khi nào?
--------------------------------------------------
Driver được dùng khi gọi:
- new ChromeDriver()
- new EdgeDriver()
- new FirefoxDriver()

=> Tại thời điểm này:
   Browser process được khởi động


==================================================
5. SELENIUM LIBRARY
==================================================

--------------------------------------------------
5.1 Selenium là gì?
--------------------------------------------------
- Selenium là thư viện automation browser
- Cung cấp API:
  + Mở URL
  + Click
  + Nhập text
  + Wait
  + Execute JavaScript


--------------------------------------------------
5.2 Selenium cần cài như thế nào?
--------------------------------------------------
Với Java:
- Thêm dependency Selenium vào project

Ví dụ bản chất:
- selenium-java
- selenium-api
- selenium-remote-driver

=> Không có Selenium library:
   KHÔNG viết được code điều khiển browser


==================================================
6. TEST FRAMEWORK (RẤT KHUYẾN NGHỊ)
==================================================

--------------------------------------------------
6.1 Vì sao cần Test Framework?
--------------------------------------------------
Selenium CHỈ là tool điều khiển browser.
Nó KHÔNG:
- Quản lý test case
- Assert kết quả
- Generate report

=> Cần Test Framework hỗ trợ


--------------------------------------------------
6.2 Các framework phổ biến
--------------------------------------------------
- JUnit
- TestNG (rất phổ biến với Selenium)
- Cucumber (BDD)


--------------------------------------------------
6.3 Test Framework dùng để:
--------------------------------------------------
- Định nghĩa test case
- Setup / teardown
- Assert kết quả
- Chạy test theo suite
- Report pass / fail


==================================================
7. BUILD TOOL (KHUYẾN NGHỊ)
==================================================

--------------------------------------------------
7.1 Maven hoặc Gradle
--------------------------------------------------
Dùng để:
- Quản lý dependency
- Build project
- Chạy test tự động

Phổ biến nhất:
- Maven

=> Giúp không phải tải tay Selenium, TestNG, driver


==================================================
8. IDE (MÔI TRƯỜNG PHÁT TRIỂN)
==================================================

--------------------------------------------------
8.1 IDE phổ biến
--------------------------------------------------
- IntelliJ IDEA
- Eclipse
- VS Code

Dùng để:
- Viết code
- Debug test
- Chạy test dễ dàng


==================================================
9. CÁC THÀNH PHẦN HỖ TRỢ KHÁC (OPTIONAL)
==================================================

--------------------------------------------------
9.1 WebDriverManager
--------------------------------------------------
- Tự động tải browser driver
- Không cần quản lý version thủ công

--------------------------------------------------
9.2 Selenium Grid
--------------------------------------------------
- Chạy test song song
- Chạy test trên nhiều browser / OS

--------------------------------------------------
9.3 Report tool
--------------------------------------------------
- Allure
- Extent Report

--------------------------------------------------
9.4 Headless mode
--------------------------------------------------
- Chạy test không mở UI
- Phù hợp CI/CD


==================================================
10. THỨ TỰ CÀI ĐẶT KHUYẾN NGHỊ
==================================================

Thứ tự chuẩn:

1. Cài JDK
2. Cài Browser (Chrome)
3. Cài IDE
4. Tạo project Maven/Gradle
5. Thêm Selenium dependency
6. Thêm Test Framework
7. Cấu hình Browser Driver
8. Chạy test đầu tiên


==================================================
11. NHỮNG THỨ KHÔNG PHẢI CÀI (HAY HIỂU SAI)
==================================================

- KHÔNG cần cài Selenium Server khi chạy local
- KHÔNG cần cài Chrome extension Selenium
- KHÔNG cần cài browser automation plugin
- Selenium KHÔNG phải là tool record-only


==================================================
12. SƠ ĐỒ TƯ DUY LUỒNG HOẠT ĐỘNG
==================================================

Test Code
   |
   v
Selenium API
   |
   v
Browser Driver
   |
   v
Browser (Chrome / Edge / Firefox)
   |
   v
Website


==================================================
13. TÓM TẮT CỐT LÕI (CỰC QUAN TRỌNG)
==================================================

Để chạy được Selenium bot, BẮT BUỘC cần:

- JDK (runtime)
- Browser
- Browser Driver
- Selenium Library

Khuyến nghị thêm:
- Test Framework
- Build tool
- IDE


==================================================
14. MỘT CÂU GHI NHỚ
==================================================

"Selenium không tự chạy test,
nó chỉ là bộ não điều khiển trình duyệt –
bạn phải xây đủ cơ thể cho nó."


--- CÁCH CÀI ĐẶT PYTHON

HƯỚNG DẪN CHI TIẾT NHẤT:
CÁCH CÀI ĐẶT PYTHON (CHO NGƯỜI MỚI + NGƯỜI LÀM TEST / AUTOMATION)

==================================================
1. PYTHON LÀ GÌ? (NGẮN GỌN ĐỂ HIỂU BẢN CHẤT)
==================================================

- Python là ngôn ngữ lập trình:
  + Dễ học
  + Dễ đọc
  + Rất phổ biến

- Python thường dùng cho:
  + Automation test (Selenium, Playwright)
  + Script
  + Data
  + AI / ML
  + Backend

=> Để chạy Python, BẮT BUỘC phải cài PYTHON RUNTIME


==================================================
2. KIỂM TRA MÁY ĐÃ CÓ PYTHON CHƯA
==================================================

--------------------------------------------------
2.1 Trên Windows
--------------------------------------------------
Mở Command Prompt (CMD) hoặc PowerShell, gõ:

    python --version

HOẶC:

    py --version

- Nếu hiện version (ví dụ: Python 3.11.6):
  => MÁY ĐÃ CÓ PYTHON
- Nếu báo lỗi:
  => CHƯA CÀI PYTHON


--------------------------------------------------
2.2 Trên macOS / Linux
--------------------------------------------------
Mở Terminal, gõ:

    python3 --version

- Nếu có version:
  => Đã có Python
- Nếu không:
  => Cần cài


==================================================
3. PHIÊN BẢN PYTHON NÊN CÀI
==================================================

Khuyến nghị:
- Python 3.10+
- Python 3.11 (rất phổ biến, ổn định)

KHÔNG dùng:
- Python 2.x (đã end-of-life)


==================================================
4. CÀI ĐẶT PYTHON TRÊN WINDOWS (CHI TIẾT NHẤT)
==================================================

--------------------------------------------------
4.1 Tải Python
--------------------------------------------------
- Truy cập trang chính thức của Python
- Tải bản:
  "Python 3.x.x Windows installer (64-bit)"

LƯU Ý:
- Luôn tải từ trang chính thức
- Không tải từ trang lạ


--------------------------------------------------
4.2 Chạy file cài đặt (RẤT QUAN TRỌNG)
--------------------------------------------------
Khi mở file cài đặt:

BẮT BUỘC PHẢI:
☑ Tick vào ô:
    "Add Python to PATH"

SAU ĐÓ:
→ Chọn:
    "Install Now"


--------------------------------------------------
4.3 Quá trình cài đặt
--------------------------------------------------
- Trình cài đặt sẽ:
  + Copy file
  + Setup pip
  + Setup PATH
- Chờ đến khi hiện:
  "Setup was successful"


--------------------------------------------------
4.4 Kiểm tra sau khi cài
--------------------------------------------------
Mở CMD mới, gõ:

    python --version
    pip --version

Nếu thấy version:
=> CÀI ĐẶT THÀNH CÔNG


==================================================
5. CÀI ĐẶT PYTHON TRÊN macOS
==================================================

--------------------------------------------------
5.1 Kiểm tra Python có sẵn
--------------------------------------------------
macOS thường có Python cũ.
KHÔNG khuyến nghị dùng Python hệ thống.


--------------------------------------------------
5.2 Cài bằng Homebrew (khuyến nghị)
--------------------------------------------------
- Cài Homebrew trước
- Sau đó gõ:

    brew install python

--------------------------------------------------
5.3 Kiểm tra
--------------------------------------------------
Gõ:

    python3 --version
    pip3 --version


==================================================
6. CÀI ĐẶT PYTHON TRÊN LINUX (Ubuntu)
==================================================

--------------------------------------------------
6.1 Cài Python
--------------------------------------------------
Mở Terminal, gõ:

    sudo apt update
    sudo apt install python3 python3-pip

--------------------------------------------------
6.2 Kiểm tra
--------------------------------------------------
Gõ:

    python3 --version
    pip3 --version


==================================================
7. PYTHON ĐƯỢC CÀI Ở ĐÂU?
==================================================

--------------------------------------------------
7.1 Trên Windows
--------------------------------------------------
Thường nằm ở:
- C:\Users\<username>\AppData\Local\Programs\Python\Python3x\

--------------------------------------------------
7.2 Trên macOS / Linux
--------------------------------------------------
Thường nằm ở:
- /usr/local/bin/python3
- /usr/bin/python3


==================================================
8. PATH LÀ GÌ? VÌ SAO CỰC KỲ QUAN TRỌNG?
==================================================

- PATH là danh sách thư mục mà OS tìm lệnh
- Nếu Python KHÔNG nằm trong PATH:
  => Gõ "python" sẽ KHÔNG chạy

=> Trên Windows:
   BẮT BUỘC tick "Add Python to PATH" khi cài


==================================================
9. pip LÀ GÌ?
==================================================

- pip là package manager của Python
- Dùng để cài thư viện:

Ví dụ:
    pip install selenium
    pip install requests

=> pip được cài KÈM với Python


==================================================
10. KIỂM TRA CÀI ĐẶT BẰNG FILE TEST
==================================================

Tạo file:
    test.py

Nội dung:
    print("Python is working")

Chạy:
    python test.py

Nếu in ra:
    Python is working
=> PYTHON HOẠT ĐỘNG TỐT


==================================================
11. LỖI THƯỜNG GẶP & CÁCH HIỂU
==================================================

--------------------------------------------------
11.1 python is not recognized
--------------------------------------------------
Nguyên nhân:
- Python chưa add PATH

Cách xử lý:
- Cài lại
- Tick "Add Python to PATH"


--------------------------------------------------
11.2 Có python nhưng không có pip
--------------------------------------------------
Nguyên nhân:
- Cài thiếu component

Cách xử lý:
- Reinstall Python
- Đảm bảo pip được chọn


==================================================
12. PYTHON 2 VS PYTHON 3 (PHẢI BIẾT)
==================================================

- python   → có thể là Python 2 hoặc 3
- python3  → chắc chắn là Python 3

Khuyến nghị:
- Luôn dùng Python 3


==================================================
13. TÓM TẮT CỐT LÕI (CỰC KỲ QUAN TRỌNG)
==================================================

- Python KHÔNG có sẵn trên mọi máy
- Phải cài Python runtime
- Trên Windows:
  + BẮT BUỘC tick "Add Python to PATH"
- Kiểm tra bằng:
  + python --version
  + pip --version


==================================================
14. MỘT CÂU GHI NHỚ
==================================================

"Cài Python không khó,
nhưng quên add PATH là đau đầu nhất."


--- CITAD TRONG NGÂN HÀNG

CITAD TRONG NGÂN HÀNG – GIẢI THÍCH CHI TIẾT, DỄ HIỂU

==================================================
1. CITAD LÀ GÌ?
--------------------------------------------------
CITAD là viết tắt của:
Customer Interbank Transfer And Deposit

Hiểu đơn giản:
- CITAD là HỆ THỐNG THANH TOÁN LIÊN NGÂN HÀNG NỘI ĐỊA của Việt Nam
- Do NGÂN HÀNG NHÀ NƯỚC VIỆT NAM (SBV) quản lý và vận hành
- Dùng để CHUYỂN TIỀN GIỮA CÁC NGÂN HÀNG trong phạm vi lãnh thổ Việt Nam

Ví dụ:
- Bạn chuyển tiền từ Vietcombank sang BIDV
→ Giao dịch này có thể đi qua hệ thống CITAD

==================================================
2. MỤC ĐÍCH RA ĐỜI CỦA CITAD
--------------------------------------------------
Trước CITAD:
- Việc chuyển tiền giữa các ngân hàng chậm
- Phải xử lý thủ công, nhiều bước

CITAD ra đời để:
- Chuẩn hóa việc thanh toán liên ngân hàng
- Tăng tốc độ chuyển tiền
- Đảm bảo an toàn, chính xác
- Phục vụ các giao dịch giá trị lớn và trung bình

==================================================
3. CITAD DÙNG TRONG NHỮNG TRƯỜNG HỢP NÀO?
--------------------------------------------------
CITAD thường được dùng cho:
- Chuyển khoản liên ngân hàng trong nước
- Thanh toán giá trị LỚN
- Giao dịch KHÔNG yêu cầu realtime tức thì

Ví dụ:
- Doanh nghiệp thanh toán tiền hàng
- Chuyển lương số tiền lớn
- Giao dịch kế toán cuối ngày

==================================================
4. CITAD KHÁC GÌ NAPAS?
--------------------------------------------------
So sánh nhanh:

CITAD:
- Do Ngân hàng Nhà nước quản lý
- Dùng cho ngân hàng – ngân hàng
- Thường xử lý theo phiên (batch)
- Phù hợp giao dịch lớn
- Không ưu tiên realtime

NAPAS:
- Do Công ty NAPAS vận hành
- Dùng cho cá nhân, bán lẻ
- Chuyển tiền nhanh 24/7
- Số tiền nhỏ – trung bình
- Gần như realtime

Hiểu ngắn gọn:
- Chuyển tiền nhanh cho người quen → NAPAS
- Thanh toán nghiệp vụ ngân hàng → CITAD

==================================================
5. CƠ CHẾ HOẠT ĐỘNG CỦA CITAD
--------------------------------------------------
Luồng cơ bản:

1. Khách hàng tạo lệnh chuyển tiền tại Ngân hàng A
2. Ngân hàng A gửi lệnh vào hệ thống CITAD
3. CITAD kiểm tra:
   - Định dạng
   - Ngân hàng thụ hưởng
   - Tính hợp lệ
4. CITAD chuyển lệnh sang Ngân hàng B
5. Ngân hàng B ghi có cho người nhận

Lưu ý:
- CITAD xử lý theo CÁC PHIÊN TRONG NGÀY
- Không phải lúc nào cũng xử lý ngay lập tức

==================================================
6. THỜI GIAN XỬ LÝ CITAD
--------------------------------------------------
- Chỉ hoạt động trong GIỜ HÀNH CHÍNH
- Nghỉ cuối tuần, ngày lễ
- Thường có:
  - Phiên sáng
  - Phiên chiều

Vì vậy:
- Chuyển tiền sau giờ hành chính
→ Có thể sang ngày làm việc tiếp theo mới nhận

==================================================
7. CITAD CÓ PHẢI CHUYỂN TIỀN NHANH KHÔNG?
--------------------------------------------------
KHÔNG

CITAD:
- Không phải hệ thống realtime
- Không đảm bảo tiền đến ngay
- Ưu tiên:
  - An toàn
  - Chính xác
  - Đối soát rõ ràng

==================================================
8. VAI TRÒ CỦA CITAD TRONG HỆ THỐNG NGÂN HÀNG
--------------------------------------------------
CITAD đóng vai trò:
- XƯƠNG SỐNG thanh toán liên ngân hàng
- Kết nối tất cả ngân hàng thương mại với Ngân hàng Nhà nước
- Đảm bảo thanh khoản và cân đối tiền tệ toàn hệ thống

==================================================
9. CITAD TRONG NGHIỆP VỤ CNTT / CORE BANKING
--------------------------------------------------
Trong hệ thống ngân hàng:
- CITAD thường là một module hoặc kênh thanh toán
- Core Banking sẽ:
  - Tạo message chuẩn CITAD
  - Gửi sang hệ thống SBV
  - Nhận phản hồi (ACK / NACK)
  - Thực hiện đối soát cuối ngày

Lập trình viên ngân hàng thường làm việc với:
- File batch
- Message queue
- Đối soát giao dịch CITAD

==================================================
10. TÓM TẮT NGẮN GỌN
--------------------------------------------------
- CITAD = hệ thống chuyển tiền liên ngân hàng nội địa
- Do Ngân hàng Nhà nước quản lý
- Không realtime, xử lý theo phiên
- Phù hợp giao dịch lớn, nghiệp vụ ngân hàng
- Khác với NAPAS (chuyển tiền nhanh 24/7)

==================================================
11. MỘT CÂU NHỚ NHANH
--------------------------------------------------
"Nếu là xương sống thanh toán giữa các ngân hàng → CITAD
 Nếu là chuyển tiền nhanh cho người dùng cuối → NAPAS"


--- ScheduledExecutorService

SCHEDULEDEXECUTORSERVICE – GIẢI THÍCH CHI TIẾT NHẤT (JAVA CONCURRENCY)

==================================================
1. SCHEDULEDEXECUTORSERVICE LÀ GÌ?
--------------------------------------------------
ScheduledExecutorService là một INTERFACE trong package:
java.util.concurrent

Nó là một dạng MỞ RỘNG của ExecutorService, được dùng để:
- LÊN LỊCH chạy task
- Chạy task SAU MỘT KHOẢNG TRỄ (delay)
- Chạy task LẶP ĐỊNH KỲ (periodic)

Nó được xem là:
→ PHIÊN BẢN HIỆN ĐẠI, MẠNH HƠN, AN TOÀN HƠN của Timer / TimerTask

==================================================
2. VỊ TRÍ CỦA ScheduledExecutorService TRONG JAVA
--------------------------------------------------
Sơ đồ kế thừa:

Executor
   |
ExecutorService
   |
ScheduledExecutorService

Ý nghĩa:
- Executor: chạy task
- ExecutorService: quản lý vòng đời thread
- ScheduledExecutorService: chạy task CÓ LỊCH

==================================================
3. TẠI SAO KHÔNG DÙNG Timer / TimerTask?
--------------------------------------------------
Hạn chế của Timer:
- Chỉ có 1 thread → task lâu làm tắc toàn bộ
- Một task throw exception → Timer chết luôn
- Quản lý lỗi kém
- Khó scale

ScheduledExecutorService khắc phục:
- NHIỀU THREAD
- Task lỗi KHÔNG làm chết hệ thống
- Quản lý thread pool rõ ràng
- Linh hoạt, ổn định

==================================================
4. CÁCH TẠO ScheduledExecutorService
--------------------------------------------------
Thông thường dùng Executors:

Executors.newScheduledThreadPool(int corePoolSize)

Ví dụ:
- newScheduledThreadPool(1): giống Timer nhưng an toàn
- newScheduledThreadPool(5): chạy song song 5 task

==================================================
5. CÁC KIỂU LÊN LỊCH CHÍNH
--------------------------------------------------
ScheduledExecutorService hỗ trợ 3 kiểu:

1) schedule(...)
2) scheduleAtFixedRate(...)
3) scheduleWithFixedDelay(...)

==================================================
6. schedule() – CHẠY 1 LẦN SAU DELAY
--------------------------------------------------
Đặc điểm:
- Task chỉ chạy 1 lần
- Chạy sau thời gian delay

Luồng:
- Đợi delay
- Chạy task
- Kết thúc

Ứng dụng:
- Retry sau vài giây
- Gửi email trễ
- Xử lý tạm thời

==================================================
7. scheduleAtFixedRate() – CHẠY ĐỊNH KỲ THEO CHU KỲ CỐ ĐỊNH
--------------------------------------------------
Đặc điểm:
- Chu kỳ KHÔNG đổi
- Không quan tâm task chạy lâu bao nhiêu

Ví dụ:
- period = 10s
- Task chạy mất 12s
→ Task kế tiếp chạy NGAY khi thread rảnh

Ứng dụng:
- Đồng bộ dữ liệu
- Thu thập metrics
- Cron-like job

Lưu ý:
- Dễ gây quá tải nếu task chạy lâu

==================================================
8. scheduleWithFixedDelay() – CHẠY ĐỊNH KỲ CÓ KHOẢNG NGHỈ
--------------------------------------------------
Đặc điểm:
- Luôn đợi task chạy xong
- Sau đó chờ delay rồi mới chạy tiếp

Luồng:
Task chạy xong → chờ delay → chạy tiếp

Ứng dụng:
- Polling
- Retry API
- Xử lý nền an toàn

==================================================
9. SO SÁNH 2 KIỂU CHẠY ĐỊNH KỲ
--------------------------------------------------
scheduleAtFixedRate:
- Mục tiêu: đúng chu kỳ
- Có thể dồn task
- Phù hợp job ngắn, ổn định

scheduleWithFixedDelay:
- Mục tiêu: an toàn
- Không dồn task
- Phù hợp job dài, không ổn định

==================================================
10. QUẢN LÝ THREAD POOL
--------------------------------------------------
ScheduledExecutorService sử dụng:
ScheduledThreadPoolExecutor

Đặc điểm:
- Core pool size quyết định số task chạy song song
- Task vượt quá → xếp hàng

Không giống Timer:
- Timer chỉ có 1 thread duy nhất

==================================================
11. XỬ LÝ EXCEPTION
--------------------------------------------------
- Exception trong task KHÔNG làm chết executor
- Chỉ task đó bị dừng (đối với periodic task)

Đây là điểm cực kỳ quan trọng so với Timer

==================================================
12. SHUTDOWN ScheduledExecutorService
--------------------------------------------------
Phải shutdown để tránh leak thread:

- shutdown(): chờ task đang chạy xong
- shutdownNow(): cố gắng dừng ngay

Không shutdown:
- JVM không thoát
- Gây memory leak

==================================================
13. KHI NÀO NÊN DÙNG ScheduledExecutorService?
--------------------------------------------------
NÊN DÙNG KHI:
- Có task chạy định kỳ
- Cần delay task
- Cần nhiều thread
- Cần hệ thống ổn định

KHÔNG NÊN DÙNG KHI:
- Job cực đơn giản
- Không quan tâm lỗi
→ (Timer có thể tạm dùng)

==================================================
14. LIÊN HỆ VỚI HỆ THỐNG THỰC TẾ
--------------------------------------------------
Trong hệ thống thực:
- Cleanup session
- Refresh cache
- Gửi batch message
- Retry failed transaction
- Đối soát định kỳ (ngân hàng)

==================================================
15. TÓM TẮT NHỚ NHANH
--------------------------------------------------
- ScheduledExecutorService = Timer nâng cấp
- Hỗ trợ delay + định kỳ
- Nhiều thread, an toàn
- Exception không giết hệ thống
- Phải shutdown đúng cách

==================================================
16. MỘT CÂU NHỚ ĐỜI
--------------------------------------------------
"Có lịch + đa luồng + an toàn → ScheduledExecutorService
 Có mỗi lịch, 1 thread → Timer (đồ cổ)"

--- HOÀN TOÀN CÓ THỂ truyền một TimerTask làm đối số đầu tiên cho phương thức scheduleAtFixedRate() của lớp Timer.

CÓ THỂ TRUYỀN TimerTask LÀM ĐỐI SỐ ĐẦU TIÊN CHO scheduleAtFixedRate KHÔNG?
GIẢI THÍCH CHI TIẾT NHẤT (JAVA)

==================================================
1. CÂU TRẢ LỜI NGẮN GỌN
--------------------------------------------------
CÓ.

Trong Java, ta HOÀN TOÀN CÓ THỂ truyền một TimerTask
làm đối số đầu tiên cho phương thức scheduleAtFixedRate()
của lớp Timer.

Đây chính là cách dùng CHUẨN của Timer / TimerTask.

==================================================
2. NHẮC LẠI: TimerTask LÀ GÌ?
--------------------------------------------------
TimerTask là một ABSTRACT CLASS trong java.util.

Đặc điểm:
- Đại diện cho một công việc (task) sẽ được chạy theo lịch
- Bắt buộc override phương thức run()
- KHÔNG tự chạy được, phải được Timer gọi

Nói ngắn gọn:
TimerTask = việc cần làm
Timer = người lên lịch + gọi chạy

==================================================
3. scheduleAtFixedRate LÀ GÌ?
--------------------------------------------------
scheduleAtFixedRate() là phương thức của lớp Timer.

Mục đích:
- Lên lịch CHẠY ĐỊNH KỲ
- Cố gắng giữ chu kỳ chạy CỐ ĐỊNH (fixed rate)

==================================================
4. CÚ PHÁP scheduleAtFixedRate VỚI TimerTask
--------------------------------------------------
Chữ ký phương thức:

scheduleAtFixedRate(
    TimerTask task,
    long delay,
    long period
)

Giải thích:
- task   : TimerTask → công việc cần chạy
- delay  : thời gian chờ trước lần chạy đầu (ms)
- period : chu kỳ chạy lặp lại (ms)

Vì vậy:
→ ĐỐI SỐ ĐẦU TIÊN BẮT BUỘC LÀ TimerTask

==================================================
5. VÍ DỤ CỤ THỂ
--------------------------------------------------
Luồng logic:

1. Tạo Timer
2. Tạo TimerTask
3. Truyền TimerTask vào scheduleAtFixedRate

Ví dụ logic (diễn giải, không cần code):

- TimerTask:
  - Override run()
  - Bên trong run() là logic cần chạy định kỳ

- Timer:
  - Nhận TimerTask
  - Sau delay → gọi run()
  - Sau mỗi period → gọi run() tiếp

==================================================
6. KHI NÀO TimerTask.run() ĐƯỢC THỰC THI?
--------------------------------------------------
Trình tự thực tế:

1. Gọi scheduleAtFixedRate(task, delay, period)
2. Timer tạo 1 THREAD DUY NHẤT (background thread)
3. Sau delay:
   → Timer gọi task.run()
4. Sau mỗi period:
   → Timer tiếp tục gọi task.run()

Quan trọng:
- Bạn KHÔNG gọi run() thủ công
- Timer là thằng gọi run()

==================================================
7. CƠ CHẾ FIXED RATE HOẠT ĐỘNG RA SAO?
--------------------------------------------------
Fixed Rate nghĩa là:
- Lấy mốc thời gian BẮT ĐẦU
- Cố gắng chạy đúng theo chu kỳ đã định

Ví dụ:
- delay = 0
- period = 5s

Thời điểm chạy:
- 0s
- 5s
- 10s
- 15s

Nếu task chạy lâu:
- Timer sẽ cố bù thời gian
- Có thể chạy liên tiếp ngay khi thread rảnh

==================================================
8. LƯU Ý CỰC KỲ QUAN TRỌNG KHI DÙNG TimerTask
--------------------------------------------------
1) Timer CHỈ CÓ 1 THREAD
- Một task chạy lâu → task khác bị block

2) Exception trong run()
- Nếu run() throw RuntimeException
→ Timer chết luôn
→ TẤT CẢ task khác dừng

3) Không scale được
- Không chạy song song nhiều task nặng

==================================================
9. SO SÁNH NHANH VỚI ScheduledExecutorService
--------------------------------------------------
Timer + TimerTask:
- Đối số đầu tiên: TimerTask
- 1 thread
- Dễ chết khi lỗi
- Cũ

ScheduledExecutorService:
- Đối số đầu tiên: Runnable / Callable
- Nhiều thread
- An toàn hơn
- Khuyến nghị dùng

==================================================
10. KẾT LUẬN CUỐI CÙNG
--------------------------------------------------
- CÓ thể truyền TimerTask làm đối số đầu tiên cho scheduleAtFixedRate
- Thực tế: BẮT BUỘC phải truyền TimerTask
- Timer sẽ gọi run() của TimerTask theo lịch
- Nhưng trong hệ thống hiện đại:
  → NÊN DÙNG ScheduledExecutorService thay vì Timer

==================================================
11. MỘT CÂU NHỚ NHANH
--------------------------------------------------
"Timer không chạy task,
Timer CHỈ gọi run() của TimerTask theo lịch."



--- GETWINDOWHANDLE() TRONG SELENIUM WEBDRIVER (JAVA)

GETWINDOWHANDLE() TRONG SELENIUM WEBDRIVER (JAVA)

1. KHÁI NIỆM CƠ BẢN

getWindowHandle() là một phương thức của interface WebDriver trong Selenium.
Nó dùng để lấy ra "định danh duy nhất" (unique identifier) của cửa sổ (window) hoặc tab hiện tại mà WebDriver đang điều khiển.

Cú pháp:

    String currentWindow = driver.getWindowHandle();

Giá trị trả về:
    - Kiểu dữ liệu: String
    - Nội dung: một chuỗi đại diện cho cửa sổ hiện tại (window handle ID)

Mỗi cửa sổ hoặc tab trong trình duyệt sẽ có một handle riêng biệt.

------------------------------------------------------------

2. WINDOW HANDLE LÀ GÌ?

Window Handle là:
    - Một chuỗi (String)
    - Do trình duyệt sinh ra
    - Dùng để phân biệt giữa các cửa sổ hoặc tab khác nhau

Ví dụ:
    CDwindow-3F5A9B7E2C8D1234567890ABCDEF1234

Bạn không cần hiểu cấu trúc bên trong của chuỗi này.
Bạn chỉ cần biết:
    Mỗi window/tab có một handle duy nhất.
    Không có hai cửa sổ có cùng handle.

------------------------------------------------------------

3. SỰ KHÁC NHAU GIỮA getWindowHandle() VÀ getWindowHandles()

getWindowHandle()
    - Trả về handle của cửa sổ hiện tại
    - Kiểu trả về: String

getWindowHandles()
    - Trả về tất cả các handle của tất cả cửa sổ đang mở
    - Kiểu trả về: Set<String>

Ví dụ:

    String mainWindow = driver.getWindowHandle();
    Set<String> allWindows = driver.getWindowHandles();

------------------------------------------------------------

4. TẠI SAO CẦN getWindowHandle()?

Trong Selenium, khi:
    - Bạn click vào link mở tab mới
    - Hoặc click button mở popup window

Selenium KHÔNG tự động chuyển sang cửa sổ mới.

Bạn phải:
    1. Lưu lại handle của cửa sổ hiện tại
    2. Lấy danh sách tất cả cửa sổ
    3. So sánh để tìm cửa sổ mới
    4. Switch sang cửa sổ đó

Nếu không lưu handle ban đầu,
Bạn sẽ không biết cách quay lại cửa sổ cũ.

------------------------------------------------------------

5. VÍ DỤ MINH HỌA CHUYỂN TAB

Giả sử:
    - Trang chính có 1 cửa sổ
    - Click vào link mở tab mới

Ví dụ code:

    WebDriver driver = new ChromeDriver();
    driver.get("https://example.com");

    // 1. Lưu lại cửa sổ hiện tại
    String mainWindow = driver.getWindowHandle();

    // 2. Click mở tab mới
    driver.findElement(By.id("openTab")).click();

    // 3. Lấy tất cả window
    Set<String> allWindows = driver.getWindowHandles();

    // 4. Tìm cửa sổ mới
    for (String window : allWindows) {
        if (!window.equals(mainWindow)) {
            driver.switchTo().window(window);
            break;
        }
    }

    // Bây giờ driver đang ở tab mới

    // 5. Quay lại tab chính
    driver.switchTo().window(mainWindow);

------------------------------------------------------------

6. CƠ CHẾ HOẠT ĐỘNG BÊN TRONG

Khi WebDriver mở trình duyệt:

    - Mỗi cửa sổ được gán một ID nội bộ
    - WebDriver giữ danh sách các ID này
    - getWindowHandle() chỉ đơn giản trả về ID của window đang active

Quan trọng:
    getWindowHandle() KHÔNG mở cửa sổ mới
    KHÔNG chuyển cửa sổ
    Chỉ trả về ID của cửa sổ hiện tại

------------------------------------------------------------

7. KHI NÀO getWindowHandle() THAY ĐỔI GIÁ TRỊ?

Giá trị thay đổi khi:
    - Bạn gọi driver.switchTo().window(handleKhac)

Ví dụ:

    String w1 = driver.getWindowHandle();

    driver.switchTo().window(w2);

    String w2_current = driver.getWindowHandle();

Lúc này:
    w1 khác w2_current

------------------------------------------------------------

8. LƯU Ý QUAN TRỌNG

1) Handle không phải là URL
   Không dùng handle để truy cập trang web.

2) Handle không phải là title
   Không phải là tên tab.

3) Không nên hardcode handle
   Vì mỗi lần chạy test, handle có thể khác.

4) Nếu chỉ có 1 cửa sổ
   getWindowHandle() vẫn hoạt động bình thường.

5) Nếu cửa sổ bị đóng
   Handle đó sẽ không còn tồn tại.

------------------------------------------------------------

9. LỖI THƯỜNG GẶP

1) NoSuchWindowException
   Xảy ra khi:
       - Switch đến handle đã bị đóng
       - Handle không tồn tại

2) Quên lưu mainWindow
   Dẫn đến:
       - Không thể quay lại cửa sổ ban đầu

------------------------------------------------------------

10. TÓM TẮT NGẮN GỌN

getWindowHandle() dùng để:

    - Lấy ID duy nhất của cửa sổ hiện tại
    - Lưu lại cửa sổ gốc trước khi mở tab mới
    - Giúp chuyển qua lại giữa các cửa sổ

Kiểu trả về:
    String

Phân biệt:
    getWindowHandle()   -> 1 window hiện tại
    getWindowHandles()  -> tất cả windows

------------------------------------------------------------

11. MÔ HÌNH TƯ DUY ĐƠN GIẢN

Hãy tưởng tượng:

    Mỗi tab là một phòng
    Mỗi phòng có một mã số riêng
    getWindowHandle() = hỏi "Tôi đang ở phòng số mấy?"

    getWindowHandles() = hỏi "Hiện có những phòng nào đang mở?"

    switchTo().window(id) = bước sang phòng có mã đó

------------------------------------------------------------

KẾT LUẬN

getWindowHandle() là phương thức rất quan trọng khi làm automation với:
    - Multiple tabs
    - Popup window
    - Payment redirect
    - OAuth login (Google login, Facebook login)

Nó giúp bạn kiểm soát chính xác Selenium đang đứng ở cửa sổ nào.


--- LENH get() TRONG SELENIUM WEBDRIVER (JAVA)

LENH get() TRONG SELENIUM WEBDRIVER (JAVA)

1. KHÁI NIỆM CƠ BẢN

get() là một phương thức của interface WebDriver.
Nó dùng để mở một URL trong trình duyệt.

Cú pháp:

    driver.get("https://example.com");

Tham số:
    - Một chuỗi String đại diện cho URL đầy đủ (bao gồm http:// hoặc https://)

Kiểu trả về:
    - void (không trả về giá trị)

------------------------------------------------------------

2. MỤC ĐÍCH CỦA get()

Khi bạn viết automation test, bước đầu tiên thường là:

    - Mở trình duyệt
    - Điều hướng (navigate) tới một trang web

get() chính là lệnh thực hiện việc điều hướng đó.

Ví dụ:

    WebDriver driver = new ChromeDriver();
    driver.get("https://google.com");

Trình duyệt sẽ mở Google.

------------------------------------------------------------

3. CƠ CHẾ HOẠT ĐỘNG BÊN TRONG

Khi gọi:

    driver.get("https://example.com");

WebDriver sẽ:

    1. Gửi lệnh đến browser driver (ChromeDriver, GeckoDriver, ...)
    2. Browser driver yêu cầu trình duyệt load URL đó
    3. Trình duyệt thực hiện HTTP request
    4. Tải HTML, CSS, JS, tài nguyên
    5. Chờ trang load hoàn tất (theo pageLoadStrategy)
    6. Trả quyền điều khiển lại cho Selenium

Quan trọng:
    get() là lệnh blocking (đồng bộ).
    Nó sẽ chờ trang load xong mới chạy tiếp.

------------------------------------------------------------

4. get() CHỜ ĐẾN KHI NÀO?

Mặc định, get() sẽ chờ đến khi:

    document.readyState = "complete"

Tức là:
    - DOM đã load xong
    - Tài nguyên chính đã load xong

Tuy nhiên:
    - AJAX chạy sau đó thì get() không chờ
    - Animation cũng không chờ

------------------------------------------------------------

5. PHÂN BIỆT get() VÀ navigate().to()

Cách 1:

    driver.get("https://example.com");

Cách 2:

    driver.navigate().to("https://example.com");

Hai cách này gần như giống nhau.

Khác biệt:

    - navigate() cho phép:
        back()
        forward()
        refresh()

Ví dụ:

    driver.navigate().back();
    driver.navigate().forward();
    driver.navigate().refresh();

Còn get() chỉ đơn thuần mở URL.

------------------------------------------------------------

6. VÍ DỤ ĐẦY ĐỦ

    WebDriver driver = new ChromeDriver();

    driver.get("https://google.com");

    System.out.println(driver.getTitle());

    driver.quit();

Kết quả:
    - Chrome mở
    - Truy cập Google
    - In title ra console
    - Đóng trình duyệt

------------------------------------------------------------

7. YÊU CẦU VỀ URL

URL truyền vào phải hợp lệ:

Đúng:
    "https://google.com"
    "http://localhost:8080"
    "https://testsite.com/login"

Sai:
    "google.com"           (thiếu http/https)
    "htp://abc.com"        (sai protocol)

Nếu URL sai có thể gây:
    - InvalidArgumentException
    - Hoặc browser không load được

------------------------------------------------------------

8. LỖI THƯỜNG GẶP

1) TimeoutException

Nếu trang load quá lâu vượt quá pageLoadTimeout.

Có thể set timeout:

    driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));

2) UnreachableBrowserException

Xảy ra khi:
    - Driver bị crash
    - Browser bị đóng trước đó

3) InvalidArgumentException

Khi URL null hoặc sai định dạng.

------------------------------------------------------------

9. get() CÓ MỞ TAB MỚI KHÔNG?

KHÔNG.

get() chỉ load URL trong tab hiện tại.

Nếu muốn mở tab mới, bạn phải:

    - Dùng JavaScript
    - Hoặc dùng Window handle

Ví dụ mở tab mới bằng JavaScript:

    ((JavascriptExecutor)driver).executeScript("window.open()");

------------------------------------------------------------

10. get() CÓ TRẢ VỀ RESPONSE KHÔNG?

KHÔNG.

Selenium không phải là HTTP client.

Nó điều khiển trình duyệt, không trả về:
    - HTTP status code
    - Response body

Nếu cần kiểm tra status code:
    - Phải dùng thư viện khác (RestAssured, HttpClient, ...)

------------------------------------------------------------

11. get() TRONG THỰC TẾ TEST

Trong automation test, get() thường dùng:

    - Mở trang login
    - Mở homepage
    - Mở trang admin
    - Reset trạng thái test

Ví dụ:

    @BeforeEach
    public void setUp() {
        driver.get("https://mysite.com/login");
    }

------------------------------------------------------------

12. ẢNH HƯỞNG CỦA pageLoadStrategy

Selenium có cấu hình:

    NORMAL (mặc định)
    EAGER
    NONE

NORMAL:
    Chờ load hoàn tất

EAGER:
    Chờ DOMContentLoaded

NONE:
    Không chờ

Ví dụ cấu hình:

    ChromeOptions options = new ChromeOptions();
    options.setPageLoadStrategy(PageLoadStrategy.EAGER);

------------------------------------------------------------

13. get() VÀ SESSION

Mỗi WebDriver instance có một session riêng.

get() hoạt động trong session đó.

Nếu driver.quit():
    Session bị hủy
    Không thể gọi get() nữa

------------------------------------------------------------

14. TÓM TẮT NGẮN GỌN

get() dùng để:

    - Mở một URL trong tab hiện tại
    - Chờ trang load xong
    - Không trả về giá trị
    - Không mở tab mới

Kiểu trả về:
    void

Cú pháp:

    driver.get("URL");

------------------------------------------------------------

15. MÔ HÌNH TƯ DUY ĐƠN GIẢN

Hãy tưởng tượng:

    WebDriver = người lái xe
    Trình duyệt = chiếc xe
    get("URL") = bảo tài xế lái xe đến một địa chỉ mới

Khi đến nơi xong (trang load xong),
bạn mới tiếp tục làm việc (click, sendKeys, ...)

------------------------------------------------------------

KẾT LUẬN

get() là lệnh cơ bản và bắt buộc khi làm Selenium.
Nó là bước đầu tiên của hầu hết mọi test case.
Hiểu rõ get() giúp bạn hiểu cách Selenium điều khiển trình duyệt và cách trang web được load trong automation.


--- webdriver driver; driver.findElement(By.id("error"))

GIẢI THÍCH CHI TIẾT:

1) webdriver driver;

Đây là câu lệnh khai báo biến trong Java.

Phân tích từng phần:

- WebDriver:
  Đây là một interface (giao diện) trong Selenium.
  Nó định nghĩa các hành vi cơ bản để điều khiển trình duyệt như:
    + mở trang web (get)
    + tìm phần tử (findElement)
    + đóng trình duyệt (quit)
    + điều hướng (navigate)
    + quản lý cửa sổ (manage)
  WebDriver KHÔNG phải là một class cụ thể, mà là một interface.

- driver:
  Đây là tên biến.
  Biến này sẽ dùng để lưu đối tượng điều khiển trình duyệt thực tế.

Câu lệnh:
  WebDriver driver;

chỉ mới KHAI BÁO biến, chưa khởi tạo đối tượng.

Sau đó thường sẽ có:

  driver = new ChromeDriver();

Hoặc:

  WebDriver driver = new ChromeDriver();

Lúc này:
  - ChromeDriver là class triển khai (implements) WebDriver
  - driver sẽ điều khiển trình duyệt Chrome

Tóm lại:
  WebDriver driver;
  = khai báo một biến tham chiếu có kiểu WebDriver
  = biến này sẽ trỏ đến đối tượng trình duyệt thật (Chrome, Firefox, Edge...)

------------------------------------------------------------

2) driver.findElement(By.id("error"));

Lưu ý:
Cú pháp đúng phải là:
  driver.findElement(By.id("error"));

KHÔNG phải:
  driver.findElement(byId.("error"))

------------------------------------------------------------

Giải thích chi tiết:

- driver:
  Là đối tượng điều khiển trình duyệt.

- findElement(...):
  Là một phương thức của WebDriver.
  Dùng để tìm một phần tử trên trang web.

  Kiểu trả về:
    WebElement

  Nghĩa là:
    Nó trả về một đối tượng đại diện cho phần tử HTML tìm được.

------------------------------------------------------------

Cơ chế hoạt động của findElement:

Khi gọi:

  driver.findElement(By.id("error"));

Quá trình diễn ra như sau:

Bước 1:
  Selenium gửi lệnh xuống trình duyệt.

Bước 2:
  Trình duyệt tìm trong DOM (Document Object Model) phần tử có:
    id = "error"

Ví dụ HTML:

  <div id="error">Sai mật khẩu</div>

Bước 3:
  Nếu tìm thấy:
    Trả về một WebElement đại diện cho thẻ đó.

  Nếu KHÔNG tìm thấy:
    Ném ra ngoại lệ:
      NoSuchElementException

------------------------------------------------------------

3) By.id("error") là gì?

- By là một class trong Selenium.
- Nó chứa các phương thức tĩnh (static) để xác định cách tìm phần tử.

Các cách tìm phổ biến:

  By.id("...")
  By.name("...")
  By.className("...")
  By.tagName("...")
  By.cssSelector("...")
  By.xpath("...")

Trong trường hợp này:

  By.id("error")

nghĩa là:
  Tìm phần tử có thuộc tính id = "error"

------------------------------------------------------------

4) Kiểu trả về của findElement

Ví dụ:

  WebElement element = driver.findElement(By.id("error"));

Lúc này:
  element đại diện cho thẻ HTML đó.

Ta có thể:

  element.getText();
  element.click();
  element.sendKeys("abc");
  element.getAttribute("value");

------------------------------------------------------------

5) Sự khác nhau giữa findElement và findElements

findElement:
  - Trả về 1 phần tử
  - Nếu không tìm thấy -> ném exception

findElements:
  - Trả về List<WebElement>
  - Nếu không tìm thấy -> trả về danh sách rỗng
  - Không ném exception

------------------------------------------------------------

6) Tóm tắt logic tổng thể

WebDriver driver;
  -> khai báo biến điều khiển trình duyệt

driver.findElement(By.id("error"));
  -> yêu cầu trình duyệt tìm phần tử có id = "error"
  -> trả về WebElement
  -> nếu không tồn tại -> lỗi

------------------------------------------------------------

7) Luồng thực thi thực tế ví dụ đầy đủ:

WebDriver driver = new ChromeDriver();

driver.get("https://example.com/login");

WebElement errorMessage = driver.findElement(By.id("error"));

String text = errorMessage.getText();

System.out.println(text);

------------------------------------------------------------

8) Lưu ý quan trọng về lỗi

Nếu trang chưa load xong mà đã gọi findElement:
  -> có thể gây lỗi

Giải pháp:
  - dùng WebDriverWait
  - dùng implicit wait

------------------------------------------------------------

9) Bản chất kỹ thuật

WebDriver:
  gửi lệnh qua WebDriver Protocol
  trình duyệt thực thi
  trả kết quả về cho Java
  Java bọc phần tử thành WebElement

------------------------------------------------------------

KẾT LUẬN NGẮN GỌN:

WebDriver driver;
  = khai báo biến điều khiển trình duyệt

driver.findElement(By.id("error"));
  = tìm phần tử HTML có id = "error"
  = trả về WebElement
  = không tìm thấy sẽ gây lỗi

--- GIẢI THÍCH CHI TIẾT VỀ WEBELEMENT TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ WEBELEMENT TRONG SELENIUM

============================================================
1) WebElement là gì?
============================================================

WebElement là một interface trong Selenium.

Nó đại diện cho một phần tử HTML trên trang web (DOM).

Ví dụ phần tử HTML:

    <input id="username" type="text">
    <button id="login">Login</button>
    <div class="error">Sai mật khẩu</div>

Mỗi thẻ HTML như vậy khi được Selenium tìm thấy sẽ được biểu diễn
thành một đối tượng WebElement trong Java.

Nói đơn giản:

    WebElement = đại diện cho một thẻ HTML cụ thể trên trang web

============================================================
2) WebElement được tạo ra như thế nào?
============================================================

WebElement không được tạo bằng new.

Ta không viết:

    new WebElement();  // sai

Thay vào đó, WebElement được trả về từ WebDriver.

Ví dụ:

    WebElement element = driver.findElement(By.id("login"));

Quá trình xảy ra:

Bước 1:
    driver gửi lệnh xuống trình duyệt

Bước 2:
    Trình duyệt tìm trong DOM phần tử có id="login"

Bước 3:
    Selenium nhận lại thông tin và tạo một đối tượng WebElement
    đại diện cho phần tử đó

============================================================
3) Bản chất kỹ thuật của WebElement
============================================================

WebElement là một interface.

Trong nội bộ Selenium, nó được implement bởi class như:

    RemoteWebElement

RemoteWebElement giữ:

    - ID nội bộ của phần tử trong trình duyệt
    - Tham chiếu đến session WebDriver

Khi ta gọi:

    element.click();

Thực tế diễn ra:

    Java gửi lệnh qua WebDriver Protocol
    Trình duyệt nhận lệnh
    Trình duyệt click vào phần tử tương ứng
    Trả kết quả về

WebElement không chứa HTML thực sự.
Nó chỉ chứa "con trỏ" đến phần tử trong trình duyệt.

============================================================
4) Các phương thức quan trọng của WebElement
============================================================

4.1 click()

    element.click();

Dùng để click vào:
    - button
    - link
    - checkbox
    - radio button

------------------------------------------------------------

4.2 sendKeys(String text)

    element.sendKeys("admin");

Dùng để nhập dữ liệu vào:
    - input
    - textarea

------------------------------------------------------------

4.3 clear()

    element.clear();

Xóa nội dung trong ô input.

------------------------------------------------------------

4.4 getText()

    String text = element.getText();

Lấy nội dung hiển thị giữa thẻ HTML.

Ví dụ:

    <div>Hello</div>

getText() trả về:
    "Hello"

------------------------------------------------------------

4.5 getAttribute(String name)

    element.getAttribute("value");

Lấy giá trị thuộc tính HTML.

Ví dụ:

    <input value="abc">

getAttribute("value") trả về:
    "abc"

------------------------------------------------------------

4.6 isDisplayed()

    element.isDisplayed();

Trả về:
    true nếu phần tử hiển thị
    false nếu bị ẩn (display:none)

------------------------------------------------------------

4.7 isEnabled()

    element.isEnabled();

Kiểm tra phần tử có bị disabled không.

------------------------------------------------------------

4.8 isSelected()

    element.isSelected();

Dùng cho:
    - checkbox
    - radio button

============================================================
5) Vấn đề thường gặp: StaleElementReferenceException
============================================================

Xảy ra khi:

    - Trang được reload
    - DOM thay đổi
    - JavaScript cập nhật phần tử

Ví dụ:

    WebElement element = driver.findElement(By.id("login"));
    driver.navigate().refresh();
    element.click();   // lỗi StaleElementReferenceException

Lý do:
    WebElement đang giữ tham chiếu cũ
    nhưng DOM đã thay đổi

Giải pháp:
    tìm lại phần tử:

    element = driver.findElement(By.id("login"));

============================================================
6) Sự khác nhau giữa WebElement và WebDriver
============================================================

WebDriver:
    Điều khiển toàn bộ trình duyệt

WebElement:
    Đại diện cho một phần tử cụ thể

So sánh:

    WebDriver = điều khiển "cả ngôi nhà"
    WebElement = một "đồ vật trong nhà"

============================================================
7) Vòng đời của WebElement
============================================================

WebElement tồn tại:

    - Khi session WebDriver còn sống
    - Khi DOM chưa thay đổi

Khi driver.quit() được gọi:
    tất cả WebElement không còn hợp lệ

============================================================
8) Tương tác thực tế ví dụ hoàn chỉnh
============================================================

WebDriver driver = new ChromeDriver();

driver.get("https://example.com/login");

WebElement username = driver.findElement(By.id("username"));
WebElement password = driver.findElement(By.id("password"));
WebElement loginBtn = driver.findElement(By.id("login"));

username.sendKeys("admin");
password.sendKeys("123456");
loginBtn.click();

============================================================
9) WebElement có phải là dữ liệu tĩnh không?
============================================================

Không.

WebElement là proxy (đại diện) cho phần tử trong trình duyệt thật.

Mọi thao tác đều gửi xuống trình duyệt thực thi.

============================================================
10) Tóm tắt ngắn gọn
============================================================

WebElement:

    - Là interface trong Selenium
    - Đại diện cho một phần tử HTML
    - Được trả về từ findElement()
    - Cho phép:
        click()
        sendKeys()
        getText()
        getAttribute()
        clear()
        isDisplayed()
        isEnabled()
        isSelected()

    - Không chứa HTML thật
    - Chỉ giữ tham chiếu đến phần tử trong trình duyệt
    - Có thể bị lỗi nếu DOM thay đổi

============================================================

KẾT LUẬN:

WebElement là cầu nối giữa code Java và một phần tử HTML cụ thể.
Mọi thao tác trên WebElement thực chất là gửi lệnh xuống trình duyệt
thông qua WebDriver để tương tác với DOM.


--- GIẢI THÍCH CHI TIẾT VỀ HÀM getWindowHandle() TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ HÀM getWindowHandle() TRONG SELENIUM
============================================================

1) getWindowHandle() là gì?
------------------------------------------------------------

getWindowHandle() là một phương thức của WebDriver.

Cú pháp:

    String handle = driver.getWindowHandle();

Hàm này trả về:

    Một chuỗi (String) đại diện cho cửa sổ (window) hiện tại
    mà WebDriver đang điều khiển.

Nói đơn giản:

    getWindowHandle() = lấy ID của tab/cửa sổ hiện tại

============================================================

2) Window Handle là gì?
------------------------------------------------------------

Window Handle là một mã định danh (ID) duy nhất
cho mỗi cửa sổ hoặc tab mà trình duyệt mở.

Ví dụ:

    CDwindow-1A2B3C4D5E6F7G8H

Mỗi tab sẽ có một handle khác nhau.

Trình duyệt có thể có:

    - 1 cửa sổ chính
    - nhiều tab
    - popup window

Mỗi cái đều có handle riêng.

============================================================

3) Tại sao cần getWindowHandle()?
------------------------------------------------------------

Vì Selenium không tự động chuyển sang tab mới.

Khi mở tab mới:

    driver.switchTo() chưa được gọi
    driver vẫn đang đứng ở tab cũ

Ta cần:

    - Lưu lại handle hiện tại
    - Lấy danh sách tất cả handle
    - Chuyển sang handle khác

============================================================

4) Ví dụ cơ bản
------------------------------------------------------------

String parentHandle = driver.getWindowHandle();

Ý nghĩa:

    Lưu lại ID của tab hiện tại (tab cha)

============================================================

5) Phân biệt getWindowHandle và getWindowHandles
------------------------------------------------------------

getWindowHandle()
    - Trả về 1 String
    - Là handle của cửa sổ hiện tại

getWindowHandles()
    - Trả về Set<String>
    - Là tập hợp tất cả handle đang mở

Ví dụ:

Set<String> allHandles = driver.getWindowHandles();

============================================================

6) Kịch bản thực tế: mở tab mới
------------------------------------------------------------

Giả sử:

    driver.findElement(By.id("openNewTab")).click();

Trang web mở thêm 1 tab mới.

Luồng xử lý chuẩn:

Bước 1: Lưu handle hiện tại

    String parentHandle = driver.getWindowHandle();

Bước 2: Lấy tất cả handle

    Set<String> handles = driver.getWindowHandles();

Bước 3: Duyệt để tìm handle khác

    for (String handle : handles) {
        if (!handle.equals(parentHandle)) {
            driver.switchTo().window(handle);
        }
    }

Lúc này:
    driver đã chuyển sang tab mới

============================================================

7) Cách quay lại tab cũ
------------------------------------------------------------

Sau khi xử lý xong tab mới:

    driver.close();   // đóng tab hiện tại

Quay lại tab cha:

    driver.switchTo().window(parentHandle);

============================================================

8) Cơ chế hoạt động bên trong
------------------------------------------------------------

Khi gọi:

    driver.getWindowHandle();

Selenium:

    - Gửi lệnh qua WebDriver Protocol
    - Trình duyệt trả về ID của window hiện tại
    - Selenium nhận ID đó dưới dạng String

Window Handle thực chất là một ID nội bộ
do trình duyệt tạo và quản lý.

============================================================

9) Lỗi thường gặp
------------------------------------------------------------

9.1 Không lưu parent handle

Nếu không lưu parentHandle từ đầu,
bạn sẽ không biết quay lại tab nào.

------------------------------------------------------------

9.2 NoSuchWindowException

Xảy ra khi:

    - Bạn cố switch sang window đã bị đóng
    - Hoặc handle không tồn tại

------------------------------------------------------------

9.3 Không chuyển window mà vẫn thao tác

Nếu không gọi:

    driver.switchTo().window(handle);

Mọi thao tác tiếp theo vẫn xảy ra trên tab cũ.

============================================================

10) Ví dụ hoàn chỉnh
------------------------------------------------------------

WebDriver driver = new ChromeDriver();

driver.get("https://example.com");

String parentHandle = driver.getWindowHandle();

driver.findElement(By.id("open")).click();

Set<String> handles = driver.getWindowHandles();

for (String handle : handles) {
    if (!handle.equals(parentHandle)) {
        driver.switchTo().window(handle);
        break;
    }
}

System.out.println(driver.getTitle());

driver.close();

driver.switchTo().window(parentHandle);

============================================================

11) Tóm tắt ngắn gọn
------------------------------------------------------------

getWindowHandle():

    - Thuộc WebDriver
    - Trả về String
    - Là ID của tab/cửa sổ hiện tại
    - Dùng để lưu lại tab cha
    - Thường dùng khi làm việc với:
        popup
        tab mới
        multiple windows

============================================================

KẾT LUẬN:

getWindowHandle() dùng để lấy ID của cửa sổ hiện tại
để có thể chuyển đổi giữa các tab/cửa sổ
khi làm automation với Selenium.

--- GIẢI THÍCH CHI TIẾT VỀ driver.close() VÀ driver.quit() TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ driver.close() VÀ driver.quit() TRONG SELENIUM
=====================================================================

Áp dụng cho:

    WebDriver driver;

=====================================================================
1) driver.close() là gì?
=====================================================================

driver.close() là phương thức của WebDriver.

Chức năng:

    Đóng CỬA SỔ (window/tab) hiện tại mà driver đang điều khiển.

Quan trọng:

    - Chỉ đóng window hiện tại
    - Không đóng toàn bộ session (trừ khi đó là window cuối cùng)

---------------------------------------------------------------------

Ví dụ:

driver.close();

Nghĩa là:

    Selenium yêu cầu trình duyệt đóng tab hiện tại.

=====================================================================
2) driver.quit() là gì?
=====================================================================

driver.quit() là phương thức của WebDriver.

Chức năng:

    Đóng TẤT CẢ các cửa sổ
    Kết thúc toàn bộ session WebDriver
    Giải phóng tài nguyên

---------------------------------------------------------------------

Ví dụ:

driver.quit();

Nghĩa là:

    - Đóng toàn bộ trình duyệt
    - Kết thúc phiên làm việc
    - Driver không còn sử dụng được nữa

=====================================================================
3) So sánh trực tiếp close() và quit()
=====================================================================

driver.close()

    - Đóng 1 window hiện tại
    - Session vẫn còn (nếu còn window khác)
    - Có thể switch sang window khác
    - Không giải phóng toàn bộ driver

driver.quit()

    - Đóng tất cả window
    - Kết thúc session
    - Không thể sử dụng driver nữa
    - Giải phóng tài nguyên

=====================================================================
4) Ví dụ minh họa thực tế
=====================================================================

Giả sử trình duyệt có 3 tab:

    Tab 1
    Tab 2
    Tab 3

Driver đang đứng ở Tab 2.

------------------------------------------------------------
Trường hợp 1: driver.close()
------------------------------------------------------------

driver.close();

Kết quả:

    Tab 2 bị đóng
    Tab 1 và Tab 3 vẫn còn mở

Nhưng lúc này driver KHÔNG tự động chuyển sang tab khác.

Bạn cần:

    driver.switchTo().window(handleKhac);

Nếu không:
    sẽ dễ bị NoSuchWindowException

------------------------------------------------------------
Trường hợp 2: driver.quit()
------------------------------------------------------------

driver.quit();

Kết quả:

    Tab 1 đóng
    Tab 2 đóng
    Tab 3 đóng
    Session kết thúc
    Trình duyệt tắt hoàn toàn

=====================================================================
5) Điều gì xảy ra nội bộ khi gọi close()?
=====================================================================

Khi gọi:

    driver.close();

Selenium:

    1) Gửi lệnh qua WebDriver Protocol
    2) Trình duyệt đóng window hiện tại
    3) Nếu đó là window cuối cùng:
            session sẽ bị kết thúc tự động

=====================================================================
6) Điều gì xảy ra nội bộ khi gọi quit()?
=====================================================================

Khi gọi:

    driver.quit();

Selenium:

    1) Gửi lệnh terminate session
    2) Đóng tất cả window
    3) Hủy WebDriver session ID
    4) Giải phóng bộ nhớ
    5) Kill driver process (chromedriver.exe)

=====================================================================
7) Khi nào nên dùng close()?
=====================================================================

Dùng khi:

    - Làm việc với nhiều tab
    - Muốn đóng tab phụ (popup)
    - Sau đó quay lại tab chính

Ví dụ:

String parent = driver.getWindowHandle();

driver.findElement(By.id("openPopup")).click();

for (String handle : driver.getWindowHandles()) {
    if (!handle.equals(parent)) {
        driver.switchTo().window(handle);
        driver.close();   // đóng popup
    }
}

driver.switchTo().window(parent);

=====================================================================
8) Khi nào nên dùng quit()?
=====================================================================

Dùng khi:

    - Kết thúc test
    - Trong @After hoặc tearDown()
    - Muốn đảm bảo không còn tiến trình driver chạy nền

Ví dụ (JUnit):

@After
public void tearDown() {
    driver.quit();
}

=====================================================================
9) Lỗi thường gặp
=====================================================================

9.1 Gọi close() ở window cuối cùng

Nếu chỉ có 1 tab:

    driver.close();

Thực tế:

    Trình duyệt đóng
    Session bị kết thúc

Sau đó nếu gọi tiếp:

    driver.get("...");

Sẽ lỗi vì session không còn.

------------------------------------------------------------

9.2 Gọi quit() rồi vẫn dùng driver

driver.quit();
driver.get("https://google.com");

Sẽ gây lỗi:

    SessionNotFoundException

Vì driver đã bị hủy.

=====================================================================
10) So sánh theo bảng
=====================================================================

close()
    - Đóng 1 window
    - Session còn nếu còn window khác
    - Không kill toàn bộ driver process

quit()
    - Đóng tất cả window
    - Kết thúc session
    - Kill driver process
    - Giải phóng tài nguyên hoàn toàn

=====================================================================
11) Nguyên tắc best practice
=====================================================================

Luôn dùng:

    driver.quit();

ở cuối test.

Vì nếu chỉ dùng close(),
driver process có thể vẫn chạy ngầm,
gây tốn RAM và CPU.

=====================================================================
12) Kết luận ngắn gọn
=====================================================================

driver.close()
    = đóng tab hiện tại

driver.quit()
    = đóng toàn bộ trình duyệt
    = kết thúc session
    = giải phóng tài nguyên

Trong automation thực tế:

    close() dùng khi xử lý nhiều tab
    quit() dùng khi kết thúc toàn bộ test
=====================================================================

--- GIẢI THÍCH CHI TIẾT VỀ java.io.File

GIẢI THÍCH CHI TIẾT VỀ java.nio.file.File
============================================================

QUAN TRỌNG:
Trong Java KHÔNG tồn tại lớp:

    java.nio.file.File

Lớp File thuộc package:

    java.io.File

Còn trong java.nio.file có các lớp như:

    Path
    Paths
    Files
    FileSystem
    FileSystems

Vì vậy, khi nói về "java.nio.file File"
thực tế thường là đang nhầm giữa:

    java.io.File
    và
    java.nio.file.Path / Files

Tài liệu này sẽ giải thích rõ:

    1) java.io.File
    2) java.nio.file.Path
    3) Sự khác nhau giữa hai hệ thống

============================================================
PHẦN 1 — java.io.File LÀ GÌ?
============================================================

Package:

    java.io

File là một class đại diện cho:

    - đường dẫn file
    - hoặc thư mục

Nó KHÔNG chứa nội dung file.
Nó chỉ là một đối tượng đại diện cho path trong hệ thống file.

------------------------------------------------------------

Ví dụ:

    File file = new File("data.txt");

Điều này KHÔNG tạo file thật.
Nó chỉ tạo một đối tượng đại diện cho đường dẫn.

============================================================
1.1 File đại diện cho cái gì?
============================================================

File có thể đại diện cho:

    - file
    - thư mục
    - đường dẫn chưa tồn tại

Nó không phân biệt ngay từ đầu.

============================================================
1.2 Các phương thức quan trọng của java.io.File
============================================================

1) exists()

    file.exists();

Kiểm tra file có tồn tại không.

------------------------------------------------------------

2) createNewFile()

    file.createNewFile();

Tạo file vật lý trên ổ đĩa.

------------------------------------------------------------

3) delete()

    file.delete();

Xóa file hoặc thư mục rỗng.

------------------------------------------------------------

4) mkdir()

    file.mkdir();

Tạo thư mục.

------------------------------------------------------------

5) mkdirs()

    file.mkdirs();

Tạo thư mục và cả thư mục cha nếu chưa tồn tại.

------------------------------------------------------------

6) isFile()

    file.isFile();

Kiểm tra có phải file không.

------------------------------------------------------------

7) isDirectory()

    file.isDirectory();

Kiểm tra có phải thư mục không.

------------------------------------------------------------

8) length()

    file.length();

Trả về kích thước file (byte).

============================================================
1.3 Hạn chế của java.io.File
============================================================

- API cũ (trước Java 7)
- Thiết kế không tốt cho exception
- Không hỗ trợ tốt symbolic link
- Không tối ưu cho hệ thống file hiện đại

Vì vậy Java 7 giới thiệu NIO.2

============================================================
PHẦN 2 — java.nio.file (NIO.2)
============================================================

Từ Java 7, hệ thống file mới ra đời:

    java.nio.file

Thay thế dần java.io.File.

Thành phần chính:

    Path
    Files
    FileSystem

============================================================
2.1 Path là gì?
============================================================

Path thay thế File.

Ví dụ:

    Path path = Paths.get("data.txt");

Path đại diện cho đường dẫn giống File,
nhưng hiện đại hơn.

------------------------------------------------------------

So sánh:

    File file = new File("data.txt");
    Path path = Paths.get("data.txt");

============================================================
2.2 Files là gì?
============================================================

Files là class chứa các phương thức static
để thao tác với file.

Ví dụ:

    Files.exists(path);
    Files.createFile(path);
    Files.delete(path);
    Files.copy(source, target);

Khác với File:

    File có method bên trong object
    Files là static utility class

============================================================
2.3 Ví dụ tạo file bằng NIO
============================================================

Path path = Paths.get("data.txt");

if (!Files.exists(path)) {
    Files.createFile(path);
}

============================================================
PHẦN 3 — So sánh java.io.File và java.nio.file
============================================================

java.io.File

    - Xuất hiện từ Java 1.0
    - API cũ
    - Không tốt cho symbolic link
    - Không hỗ trợ WatchService
    - Không hỗ trợ thao tác nâng cao

java.nio.file

    - Xuất hiện từ Java 7
    - Hiện đại
    - Tách rõ Path và Files
    - Hỗ trợ exception tốt hơn
    - Hỗ trợ WatchService (theo dõi thay đổi file)
    - Hỗ trợ copy, move nâng cao

============================================================
PHẦN 4 — Khi nào dùng cái nào?
============================================================

Hiện nay nên dùng:

    java.nio.file.Path
    java.nio.file.Files

Chỉ dùng java.io.File khi:
    - Làm việc với API cũ
    - Thư viện cũ yêu cầu File

============================================================
PHẦN 5 — Ví dụ thực tế so sánh
============================================================

Cách cũ:

File file = new File("data.txt");
if (!file.exists()) {
    file.createNewFile();
}

------------------------------------------------------------

Cách mới:

Path path = Paths.get("data.txt");
if (!Files.exists(path)) {
    Files.createFile(path);
}

============================================================
PHẦN 6 — Kết luận quan trọng
============================================================

KHÔNG tồn tại:

    java.nio.file.File

File thuộc:

    java.io.File

Trong java.nio.file ta có:

    Path
    Files
    FileSystem
    FileSystems

============================================================

TÓM TẮT NGẮN GỌN:

java.io.File
    = class cũ đại diện cho file hoặc thư mục

java.nio.file.Path
    = đại diện đường dẫn hiện đại

java.nio.file.Files
    = utility class thao tác file

Trong lập trình Java hiện đại:
    nên dùng java.nio.file thay cho java.io.File
============================================================

--- GIẢI THÍCH CHI TIẾT VỀ Path TRONG JAVA (java.nio.file.Path)

GIẢI THÍCH CHI TIẾT VỀ Path TRONG JAVA (java.nio.file.Path)
===========================================================

1) Path là gì?
-----------------------------------------------------------

Path là một interface trong package:

    java.nio.file

Nó được giới thiệu từ Java 7 (NIO.2).

Path đại diện cho:

    - một đường dẫn (file path)
    - có thể là file
    - có thể là thư mục
    - có thể chưa tồn tại

Quan trọng:

    Path KHÔNG chứa dữ liệu file.
    Path chỉ đại diện cho đường dẫn trong hệ thống file.

===========================================================
2) Path thuộc package nào?
===========================================================

import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;

Path là interface.
Đối tượng Path được tạo thông qua:

    Paths.get(...)
hoặc
    Path.of(...)   (Java 11+)

===========================================================
3) Tạo một Path
===========================================================

Cách 1 (phổ biến):

    Path path = Paths.get("data.txt");

Cách 2 (Java 11+):

    Path path = Path.of("data.txt");

-----------------------------------------------------------

Tạo path tuyệt đối:

    Path path = Paths.get("C:\\Users\\Admin\\data.txt");

Hoặc trên Linux:

    Path path = Paths.get("/home/user/data.txt");

===========================================================
4) Path có tạo file thật không?
===========================================================

KHÔNG.

Khi viết:

    Path path = Paths.get("data.txt");

Nó chỉ tạo một đối tượng đại diện cho đường dẫn.
File có thể chưa tồn tại.

Để tạo file thật:

    Files.createFile(path);

===========================================================
5) Path khác gì java.io.File?
===========================================================

Path:
    - Hiện đại (Java 7+)
    - Linh hoạt
    - Hỗ trợ symbolic link
    - Kết hợp tốt với Files
    - Thiết kế chuẩn hơn

File:
    - API cũ
    - Tồn tại từ Java 1.0
    - Ít tính năng hơn

Hiện nay nên dùng Path + Files.

===========================================================
6) Các phương thức quan trọng của Path
===========================================================

6.1 getFileName()

    path.getFileName();

Trả về tên file cuối cùng.

Ví dụ:
    "C:/folder/data.txt"
Kết quả:
    "data.txt"

-----------------------------------------------------------

6.2 getParent()

    path.getParent();

Trả về thư mục cha.

-----------------------------------------------------------

6.3 getRoot()

    path.getRoot();

Trả về root (ví dụ C:\ hoặc /)

-----------------------------------------------------------

6.4 isAbsolute()

    path.isAbsolute();

Kiểm tra có phải đường dẫn tuyệt đối không.

-----------------------------------------------------------

6.5 toAbsolutePath()

    path.toAbsolutePath();

Chuyển sang đường dẫn tuyệt đối.

-----------------------------------------------------------

6.6 normalize()

    path.normalize();

Loại bỏ:
    ".."
    "."

Ví dụ:

    Path p = Paths.get("folder/../data.txt");
    p.normalize();

Kết quả:
    "data.txt"

-----------------------------------------------------------

6.7 resolve()

Ghép đường dẫn.

    Path folder = Paths.get("data");
    Path file = folder.resolve("test.txt");

Kết quả:
    data/test.txt

-----------------------------------------------------------

6.8 relativize()

Tạo đường dẫn tương đối giữa hai path.

===========================================================
7) Path không thao tác file trực tiếp
===========================================================

Path chỉ đại diện đường dẫn.

Để thao tác file phải dùng:

    Files

Ví dụ:

    Files.exists(path);
    Files.delete(path);
    Files.copy(source, target);
    Files.readAllLines(path);

===========================================================
8) Ví dụ hoàn chỉnh
===========================================================

import java.nio.file.*;

Path path = Paths.get("example.txt");

if (!Files.exists(path)) {
    Files.createFile(path);
}

System.out.println("Tên file: " + path.getFileName());
System.out.println("Đường dẫn tuyệt đối: " + path.toAbsolutePath());

===========================================================
9) Path và File có thể chuyển đổi qua lại
===========================================================

Từ Path sang File:

    File file = path.toFile();

Từ File sang Path:

    Path path = file.toPath();

===========================================================
10) Path có liên quan đến FileSystem
===========================================================

Mỗi Path thuộc về một FileSystem.

Ví dụ:

    FileSystem fs = FileSystems.getDefault();

Path được tạo từ FileSystem.

Điều này cho phép hỗ trợ:

    - Zip file system
    - Memory file system
    - Network file system

===========================================================
11) Ưu điểm quan trọng của Path
===========================================================

- Thiết kế hướng interface
- Hỗ trợ thao tác nâng cao
- Hoạt động tốt trên nhiều hệ điều hành
- Hỗ trợ WatchService (theo dõi thay đổi file)
- Hỗ trợ copy/move nâng cao

===========================================================
12) Tóm tắt ngắn gọn
===========================================================

Path là:

    - Interface trong java.nio.file
    - Đại diện cho đường dẫn file/thư mục
    - Không chứa dữ liệu
    - Không tạo file thật
    - Là nền tảng của hệ thống file hiện đại trong Java

Muốn thao tác file:

    Dùng Path + Files

===========================================================

KẾT LUẬN:

Path là đại diện trừu tượng cho đường dẫn trong hệ thống file,
thay thế cho java.io.File trong lập trình Java hiện đại.

-- GIẢI THÍCH CHI TIẾT VỀ driver.switchTo().frame() TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ driver.switchTo().frame() TRONG SELENIUM
================================================================

1) frame là gì trong HTML?
----------------------------------------------------------------

Frame (iframe) là một thẻ HTML cho phép nhúng một trang web khác
bên trong trang hiện tại.

Ví dụ:

    <iframe id="loginFrame" src="login.html"></iframe>

Trang chính gọi là:
    parent document

Trang bên trong iframe gọi là:
    child document

Quan trọng:

    DOM của iframe TÁCH BIỆT với DOM của trang chính.

================================================================
2) Tại sao cần switchTo().frame() ?
================================================================

Selenium mặc định chỉ làm việc với:

    DOM của trang chính (main document)

Nếu một phần tử nằm bên trong iframe,
Selenium sẽ KHÔNG tìm thấy nếu chưa chuyển vào frame.

Ví dụ sai:

    driver.findElement(By.id("username"));

Nếu "username" nằm trong iframe,
lệnh trên sẽ gây lỗi:

    NoSuchElementException

Vì Selenium chưa vào iframe.

================================================================
3) Cú pháp switchTo().frame()
================================================================

Có 3 cách chuyển vào frame:

------------------------------------------------------------
Cách 1: Theo index
------------------------------------------------------------

    driver.switchTo().frame(0);

0 là iframe đầu tiên trên trang.

------------------------------------------------------------
Cách 2: Theo name hoặc id
------------------------------------------------------------

    driver.switchTo().frame("loginFrame");

------------------------------------------------------------
Cách 3: Theo WebElement (khuyến nghị)
------------------------------------------------------------

    WebElement frameElement =
        driver.findElement(By.id("loginFrame"));

    driver.switchTo().frame(frameElement);

Cách này an toàn và rõ ràng nhất.

================================================================
4) Cơ chế hoạt động nội bộ
================================================================

Khi gọi:

    driver.switchTo().frame(...);

Selenium:

    1) Gửi lệnh qua WebDriver Protocol
    2) Trình duyệt chuyển context sang iframe đó
    3) Mọi findElement sau đó chỉ tìm trong iframe

Quan trọng:

    Sau khi switch,
    Selenium KHÔNG còn ở trang chính nữa.

================================================================
5) Ví dụ đầy đủ
================================================================

WebDriver driver = new ChromeDriver();

driver.get("https://example.com");

WebElement frame =
    driver.findElement(By.id("loginFrame"));

driver.switchTo().frame(frame);

driver.findElement(By.id("username")).sendKeys("admin");

================================================================
6) Cách quay lại trang chính
================================================================

Sau khi làm việc xong trong iframe:

    driver.switchTo().defaultContent();

defaultContent() đưa Selenium về:

    main document (trang gốc)

================================================================
7) Quay về frame cha (nếu nested frame)
================================================================

Nếu có iframe lồng nhau:

    driver.switchTo().parentFrame();

parentFrame() quay về frame cha gần nhất.

================================================================
8) Nested iframe (iframe lồng nhau)
================================================================

Ví dụ:

Trang chính
    -> iframe A
        -> iframe B

Muốn vào B:

    driver.switchTo().frame("A");
    driver.switchTo().frame("B");

Muốn quay lại trang chính:

    driver.switchTo().defaultContent();

================================================================
9) Lỗi thường gặp
================================================================

9.1 Không switch trước khi tìm element

Nếu element nằm trong iframe mà chưa switch:

    NoSuchElementException

------------------------------------------------------------

9.2 Frame chưa load xong

Có thể gây lỗi:

    NoSuchFrameException

Giải pháp:
    dùng WebDriverWait

Ví dụ:

    new WebDriverWait(driver, Duration.ofSeconds(10))
        .until(ExpectedConditions.frameToBeAvailableAndSwitchToIt("loginFrame"));

================================================================
10) So sánh các cách switch frame
================================================================

Theo index:
    - Dễ viết
    - Không ổn định nếu DOM thay đổi

Theo name/id:
    - Tốt nếu id ổn định

Theo WebElement:
    - An toàn nhất
    - Khuyến nghị dùng

================================================================
11) Nguyên tắc quan trọng
================================================================

- Selenium chỉ thao tác được trong context hiện tại
- iframe là một context riêng
- Phải switch vào trước khi thao tác
- Sau khi xong phải switch ra

================================================================
12) Tóm tắt ngắn gọn
================================================================

driver.switchTo().frame(...)

    - Dùng để chuyển vào iframe
    - Cho phép thao tác với phần tử bên trong iframe
    - Có 3 cách:
        frame(index)
        frame(nameOrId)
        frame(WebElement)
    - Quay về trang chính bằng:
        driver.switchTo().defaultContent()
    - Quay về frame cha:
        driver.switchTo().parentFrame()

================================================================

KẾT LUẬN:

switchTo().frame() thay đổi "ngữ cảnh làm việc"
của Selenium từ trang chính sang một iframe cụ thể,
vì mỗi iframe có DOM riêng biệt.
================================================================

--- GIẢI THÍCH CHI TIẾT VỀ HÀM getWindowHandles() TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ HÀM getWindowHandles() TRONG SELENIUM
============================================================

1) getWindowHandles() là gì?
------------------------------------------------------------

getWindowHandles() là một phương thức của WebDriver.

Cú pháp:

    Set<String> handles = driver.getWindowHandles();

Hàm này trả về:

    Một tập hợp (Set<String>) chứa TẤT CẢ
    window handle (ID cửa sổ/tab) hiện đang mở.

Nói đơn giản:

    getWindowHandles() = lấy danh sách tất cả tab/cửa sổ đang tồn tại.

============================================================

2) Window Handle là gì?
------------------------------------------------------------

Window Handle là một ID duy nhất
được trình duyệt tạo ra cho mỗi tab/cửa sổ.

Ví dụ:

    CDwindow-12AB34CD56EF

Mỗi tab có một handle riêng.
Không có hai tab nào có cùng handle.

============================================================

3) Kiểu dữ liệu trả về
------------------------------------------------------------

getWindowHandles() trả về:

    Set<String>

Lý do dùng Set:

    - Không cho phép trùng lặp
    - Không đảm bảo thứ tự

Điều này có nghĩa:

    Bạn không nên dựa vào thứ tự khi duyệt.

============================================================

4) Khi nào cần dùng getWindowHandles()?
------------------------------------------------------------

Dùng khi:

    - Trang web mở tab mới
    - Có popup window
    - Có nhiều cửa sổ
    - Cần chuyển qua lại giữa các tab

Vì Selenium không tự động chuyển tab.

============================================================

5) Sự khác nhau giữa getWindowHandle và getWindowHandles
------------------------------------------------------------

getWindowHandle()
    - Trả về 1 String
    - Là handle của tab hiện tại

getWindowHandles()
    - Trả về Set<String>
    - Là tất cả handle đang mở

============================================================

6) Ví dụ cơ bản
------------------------------------------------------------

Giả sử:

driver.get("https://example.com");

String parentHandle = driver.getWindowHandle();

driver.findElement(By.id("openTab")).click();

Sau khi click, có thêm 1 tab mới.

Lấy tất cả handle:

Set<String> handles = driver.getWindowHandles();

============================================================
7) Cách chuyển sang tab mới
============================================================

String parent = driver.getWindowHandle();

driver.findElement(By.id("openTab")).click();

Set<String> handles = driver.getWindowHandles();

for (String handle : handles) {
    if (!handle.equals(parent)) {
        driver.switchTo().window(handle);
        break;
    }
}

Lúc này:
    Selenium đã chuyển sang tab mới.

============================================================
8) Cơ chế hoạt động nội bộ
============================================================

Khi gọi:

    driver.getWindowHandles();

Selenium:

    1) Gửi lệnh tới trình duyệt
    2) Trình duyệt trả về danh sách tất cả window ID
    3) Selenium chuyển thành Set<String> trong Java

Handle thực chất là ID nội bộ do browser quản lý.

============================================================
9) Ví dụ hoàn chỉnh với nhiều tab
============================================================

WebDriver driver = new ChromeDriver();

driver.get("https://example.com");

String parentHandle = driver.getWindowHandle();

driver.findElement(By.id("openTab")).click();

Set<String> handles = driver.getWindowHandles();

for (String handle : handles) {
    if (!handle.equals(parentHandle)) {
        driver.switchTo().window(handle);
        System.out.println("Title tab mới: " + driver.getTitle());
        driver.close();
    }
}

driver.switchTo().window(parentHandle);

============================================================
10) Lỗi thường gặp
============================================================

10.1 Không lưu parent handle

Nếu không lưu handle ban đầu,
bạn sẽ không biết quay lại tab nào.

------------------------------------------------------------

10.2 Giả định thứ tự của Set

Không nên viết:

    String newTab = handles.toArray()[1];

Vì Set không đảm bảo thứ tự.

------------------------------------------------------------

10.3 Chưa đợi tab mở xong

Nếu gọi getWindowHandles() quá sớm,
tab mới có thể chưa xuất hiện.

Giải pháp:
    dùng WebDriverWait

============================================================
11) Best Practice
============================================================

Luôn:

    1) Lưu parent handle trước khi mở tab mới
    2) Lấy danh sách handles sau khi tab mở
    3) So sánh handle để tìm tab mới
    4) Sau khi xong, switch về parent

============================================================
12) Tóm tắt ngắn gọn
============================================================

getWindowHandles():

    - Thuộc WebDriver
    - Trả về Set<String>
    - Chứa tất cả ID cửa sổ/tab đang mở
    - Dùng để xử lý multiple windows
    - Không đảm bảo thứ tự
    - Thường dùng kết hợp với switchTo().window()

============================================================

KẾT LUẬN:

getWindowHandles() là phương thức giúp Selenium
quản lý và chuyển đổi giữa nhiều tab/cửa sổ
bằng cách lấy toàn bộ danh sách window handle hiện có.
============================================================
```}

--- Properties prop; prop.setProperty(...);

GIẢI THÍCH CHI TIẾT VỀ:

    Properties prop;
    prop.setProperty(...);

============================================================
1) Properties là gì?
============================================================

Properties là một class trong Java thuộc package:

    java.util

Khai báo import:

    import java.util.Properties;

Properties được dùng để:

    - Lưu trữ dữ liệu dạng key - value
    - Cấu hình hệ thống
    - Đọc/ghi file .properties

Ví dụ dữ liệu dạng properties:

    username=admin
    password=123456
    url=https://example.com

Mỗi dòng là một cặp:

    key=value

============================================================
2) Khai báo:

    Properties prop;
============================================================

Câu lệnh:

    Properties prop;

chỉ là khai báo biến.

Nó chưa tạo đối tượng thật.

Sau đó cần khởi tạo:

    prop = new Properties();

Hoặc viết gọn:

    Properties prop = new Properties();

============================================================
3) setProperty là gì?
============================================================

Cú pháp:

    prop.setProperty(String key, String value);

Chức năng:

    Thêm hoặc cập nhật một cặp key - value
    vào trong đối tượng Properties.

Quan trọng:

    - key phải là String
    - value phải là String

============================================================
4) Ví dụ đơn giản
============================================================

Properties prop = new Properties();

prop.setProperty("username", "admin");
prop.setProperty("password", "123456");

Sau đó trong prop sẽ có:

    username -> admin
    password -> 123456

============================================================
5) Nếu key đã tồn tại thì sao?
============================================================

Nếu key đã tồn tại:

    prop.setProperty("username", "admin");
    prop.setProperty("username", "root");

Giá trị cũ sẽ bị ghi đè.

Kết quả:

    username -> root

============================================================
6) setProperty hoạt động như thế nào?
============================================================

Properties thực chất kế thừa từ:

    Hashtable<Object, Object>

Nhưng setProperty đảm bảo:

    - key là String
    - value là String

Bên trong:

    setProperty gọi put(key, value)

============================================================
7) Lấy lại giá trị đã set
============================================================

Dùng:

    prop.getProperty("username");

Ví dụ:

    String user = prop.getProperty("username");

Nếu key không tồn tại:

    getProperty trả về null

Có thể truyền giá trị mặc định:

    prop.getProperty("age", "18");

Nếu không có key "age"
nó trả về "18"

============================================================
8) Lưu Properties ra file
============================================================

Ví dụ ghi ra file config.properties:

import java.io.FileOutputStream;

Properties prop = new Properties();

prop.setProperty("username", "admin");
prop.setProperty("password", "123456");

FileOutputStream fos =
    new FileOutputStream("config.properties");

prop.store(fos, "User Config");

File config.properties sẽ có nội dung:

    #User Config
    username=admin
    password=123456

============================================================
9) Đọc file properties
============================================================

import java.io.FileInputStream;

Properties prop = new Properties();

FileInputStream fis =
    new FileInputStream("config.properties");

prop.load(fis);

String username = prop.getProperty("username");

============================================================
10) Khi nào dùng Properties?
============================================================

Thường dùng trong:

    - Automation testing (Selenium)
    - Lưu cấu hình môi trường
    - Lưu URL, username, password
    - Lưu config database
    - Lưu config hệ thống

Ví dụ trong Selenium:

    prop.setProperty("browser", "chrome");
    prop.setProperty("baseUrl", "https://example.com");

============================================================
11) Sự khác nhau giữa put và setProperty
============================================================

put(Object key, Object value)
    - Có thể dùng Object
    - Không đảm bảo là String

setProperty(String key, String value)
    - Chỉ dùng String
    - Phù hợp với file properties

Nên dùng setProperty cho cấu hình.

============================================================
12) Tóm tắt ngắn gọn
============================================================

Properties prop;
    -> khai báo biến kiểu Properties

prop = new Properties();
    -> tạo đối tượng thật

prop.setProperty(key, value);
    -> thêm hoặc cập nhật cặp key-value
    -> key và value đều là String
    -> ghi đè nếu key đã tồn tại

Dùng Properties để:
    - quản lý cấu hình
    - đọc/ghi file .properties
    - lưu dữ liệu dạng key=value

============================================================

KẾT LUẬN:

Properties là một lớp chuyên dùng để quản lý dữ liệu cấu hình
dưới dạng key-value (String-String).
setProperty dùng để thêm hoặc cập nhật dữ liệu đó
trong bộ nhớ trước khi lưu ra file hoặc sử dụng trong chương trình.
============================================================

--- setProperty() CÓ ghi vào file config không?

GIẢI THÍCH CHI TIẾT:

setProperty() CÓ ghi vào file config không?

============================================================
1) CÂU TRẢ LỜI NGẮN GỌN
============================================================

KHÔNG.

setProperty() KHÔNG ghi dữ liệu vào file.

Nó chỉ lưu dữ liệu trong bộ nhớ (RAM).

Muốn ghi ra file phải dùng:

    prop.store(...)

============================================================
2) HIỂU ĐÚNG CƠ CHẾ HOẠT ĐỘNG
============================================================

Khi bạn viết:

    Properties prop = new Properties();
    prop.setProperty("username", "admin");

Điều này chỉ làm:

    - Tạo một đối tượng Properties trong RAM
    - Thêm key "username"
    - Thêm value "admin"

Lúc này file config.properties trên ổ đĩa
VẪN KHÔNG THAY ĐỔI.

============================================================
3) VÌ SAO setProperty() KHÔNG GHI FILE?
============================================================

Vì Properties hoạt động theo 2 bước:

BƯỚC 1: Làm việc trong bộ nhớ
    - setProperty()
    - getProperty()

BƯỚC 2: Ghi xuống file (nếu muốn)
    - store()

Java không tự động ghi file vì:
    - Tránh ghi file liên tục gây chậm
    - Cho phép chỉnh sửa nhiều lần rồi mới ghi

============================================================
4) VÍ DỤ CHỨNG MINH
============================================================

Giả sử file config.properties ban đầu có:

    username=oldUser

Code:

    Properties prop = new Properties();
    prop.load(new FileInputStream("config.properties"));

    prop.setProperty("username", "admin");

KẾT QUẢ:

    Trong RAM:
        username = admin

    Nhưng file config.properties trên ổ đĩa vẫn là:
        username=oldUser

============================================================
5) MUỐN GHI RA FILE PHẢI LÀM GÌ?
============================================================

Phải dùng:

    prop.store(OutputStream, comment);

Ví dụ đầy đủ:

    Properties prop = new Properties();

    prop.setProperty("username", "admin");
    prop.setProperty("password", "123456");

    FileOutputStream fos =
        new FileOutputStream("config.properties");

    prop.store(fos, "Updated config");

Sau khi gọi store():

    File trên ổ đĩa mới được cập nhật.

============================================================
6) TÓM TẮT LUỒNG ĐÚNG
============================================================

prop.load(file)
    -> Đọc từ file vào RAM

prop.setProperty(key, value)
    -> Chỉnh sửa trong RAM

prop.store(file)
    -> Ghi từ RAM xuống file

============================================================
7) SAI LẦM THƯỜNG GẶP
============================================================

Sai lầm:

    prop.setProperty("username", "admin");

Và nghĩ rằng file đã được cập nhật.

Thực tế:
    File chưa thay đổi nếu chưa gọi store().

============================================================
8) PHÂN BIỆT RÕ 3 KHÁI NIỆM
============================================================

RAM:
    Là nơi Properties giữ dữ liệu khi chạy chương trình.

File:
    Là nơi lưu dữ liệu lâu dài trên ổ cứng.

setProperty():
    Chỉ thay đổi RAM.

store():
    Ghi RAM xuống File.

============================================================
9) KẾT LUẬN NGẮN GỌN
============================================================

setProperty():

    - KHÔNG ghi vào file config
    - Chỉ cập nhật dữ liệu trong bộ nhớ

Muốn ghi file phải dùng:

    prop.store(...)

Nếu không gọi store():
    File trên ổ đĩa sẽ không thay đổi.

============================================================

--- MÃ HÓA MẬT KHẨU BẰNG AES

GIẢI THÍCH CHI TIẾT VỀ MÃ HÓA MẬT KHẨU BẰNG AES
============================================================

QUAN TRỌNG TRƯỚC KHI BẮT ĐẦU

AES KHÔNG phải là cách đúng để lưu mật khẩu người dùng.

Mật khẩu nên được:
    - HASH (băm 1 chiều)
    - Không được mã hóa rồi giải mã lại

AES là mã hóa 2 chiều (có thể giải mã).
Hash là 1 chiều (không thể khôi phục mật khẩu gốc).

Tuy nhiên, ta vẫn cần hiểu AES vì:
    - Mã hóa file
    - Mã hóa dữ liệu nhạy cảm
    - Mã hóa token
    - Mã hóa cấu hình

============================================================
1) AES LÀ GÌ?
============================================================

AES = Advanced Encryption Standard

Là thuật toán:
    - Mã hóa đối xứng (symmetric encryption)
    - Cùng một key dùng cho:
        mã hóa (encrypt)
        giải mã (decrypt)

AES thay thế DES và 3DES.

============================================================
2) AES HOẠT ĐỘNG NHƯ THẾ NÀO?
============================================================

Đầu vào:
    - plaintext (mật khẩu gốc)
    - secret key

Quá trình:
    plaintext + key -> thuật toán AES -> ciphertext

Giải mã:
    ciphertext + key -> AES -> plaintext

Nếu mất key:
    không thể giải mã.

============================================================
3) CÁC KÍCH THƯỚC KEY AES
============================================================

AES hỗ trợ:

    - 128-bit
    - 192-bit
    - 256-bit

Hiện nay nên dùng:
    AES-256

============================================================
4) CÁC MODE CỦA AES
============================================================

AES không dùng một mình.
Nó cần mode hoạt động:

    ECB  (KHÔNG nên dùng)
    CBC
    GCM  (khuyến nghị)
    CFB
    OFB

------------------------------------------------------------
ECB (Electronic Codebook)
------------------------------------------------------------
    - Không an toàn
    - Dễ bị phân tích pattern
    - Không nên dùng

------------------------------------------------------------
CBC (Cipher Block Chaining)
------------------------------------------------------------
    - Cần IV (Initialization Vector)
    - An toàn hơn ECB

------------------------------------------------------------
GCM (Galois Counter Mode)
------------------------------------------------------------
    - Hiện đại
    - Có xác thực dữ liệu (authentication)
    - Khuyến nghị dùng

============================================================
5) QUY TRÌNH MÃ HÓA MẬT KHẨU BẰNG AES
============================================================

Bước 1: Tạo Secret Key
Bước 2: Tạo IV (nếu dùng CBC/GCM)
Bước 3: Khởi tạo Cipher
Bước 4: Encrypt
Bước 5: Encode Base64 để lưu trữ

============================================================
6) VÍ DỤ MÃ HÓA AES TRONG JAVA
============================================================

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

------------------------------------------------------------
Tạo key 128-bit
------------------------------------------------------------

KeyGenerator keyGen = KeyGenerator.getInstance("AES");
keyGen.init(128);
SecretKey secretKey = keyGen.generateKey();

------------------------------------------------------------
Mã hóa mật khẩu
------------------------------------------------------------

String password = "123456";

Cipher cipher = Cipher.getInstance("AES");

cipher.init(Cipher.ENCRYPT_MODE, secretKey);

byte[] encryptedBytes =
    cipher.doFinal(password.getBytes());

String encryptedBase64 =
    Base64.getEncoder().encodeToString(encryptedBytes);

------------------------------------------------------------
Giải mã
------------------------------------------------------------

cipher.init(Cipher.DECRYPT_MODE, secretKey);

byte[] decryptedBytes =
    cipher.doFinal(Base64.getDecoder().decode(encryptedBase64));

String decryptedPassword =
    new String(decryptedBytes);

============================================================
7) TẠI SAO KHÔNG NÊN DÙNG AES ĐỂ LƯU MẬT KHẨU?
============================================================

Vì AES có thể giải mã.

Nếu hacker lấy được:
    - database
    - secret key

Thì toàn bộ mật khẩu bị lộ.

Cách đúng để lưu mật khẩu:

    - BCrypt
    - Argon2
    - PBKDF2
    - scrypt

Những thuật toán này là HASH, không phải mã hóa.

============================================================
8) So sánh AES và Hash
============================================================

AES:
    - 2 chiều
    - Có key
    - Có thể decrypt
    - Dùng để bảo mật dữ liệu truyền đi

Hash:
    - 1 chiều
    - Không thể phục hồi mật khẩu
    - Dùng để lưu mật khẩu

============================================================
9) LỖI BẢO MẬT THƯỜNG GẶP
============================================================

1) Dùng AES ở mode ECB
2) Hard-code secret key trong code
3) Không dùng IV
4) Lưu key chung với database

============================================================
10) KẾT LUẬN QUAN TRỌNG
============================================================

AES là:

    - Thuật toán mã hóa đối xứng mạnh
    - Dùng cùng key để encrypt và decrypt
    - Phù hợp cho mã hóa dữ liệu nhạy cảm

NHƯNG:

    Không nên dùng AES để lưu mật khẩu người dùng.

Thay vào đó:
    dùng thuật toán hash chuyên dụng.

============================================================
TÓM TẮT NGẮN GỌN
============================================================

AES:

    - Là mã hóa 2 chiều
    - Dùng secret key
    - Có thể giải mã
    - Hỗ trợ 128/192/256 bit
    - Nên dùng mode GCM

Lưu mật khẩu:

    Không dùng AES
    Dùng Hash (BCrypt, Argon2...)

============================================================

--- WebElement.sendKeys() TRONG SELENIUM

GIẢI THÍCH CHI TIẾT VỀ WebElement.sendKeys() TRONG SELENIUM
==========================================================

1) sendKeys() là gì?
----------------------------------------------------------

sendKeys() là một phương thức (method) của WebElement.

Cú pháp:

    element.sendKeys("text");

Chức năng:

    Mô phỏng hành động người dùng gõ phím
    vào một phần tử trên trang web.

Nói đơn giản:

    sendKeys() = nhập dữ liệu vào ô input giống như người dùng gõ bàn phím.

==========================================================
2) sendKeys() dùng cho phần tử nào?
==========================================================

Thường dùng cho:

    - <input type="text">
    - <input type="password">
    - <textarea>
    - Một số element có thể nhận keyboard event

Ví dụ HTML:

    <input id="username" type="text">
    <input id="password" type="password">

==========================================================
3) Ví dụ cơ bản
==========================================================

WebElement username =
    driver.findElement(By.id("username"));

username.sendKeys("admin");

Kết quả:

    Ô input username sẽ hiển thị:
        admin

==========================================================
4) Cơ chế hoạt động nội bộ
==========================================================

Khi gọi:

    element.sendKeys("admin");

Selenium:

    1) Gửi lệnh qua WebDriver Protocol
    2) Trình duyệt focus vào element
    3) Mô phỏng từng ký tự được gõ:
            a
            d
            m
            i
            n
    4) Trigger các sự kiện:
            keydown
            keypress
            keyup
            input

Điều này giống hệt người dùng thật gõ phím.

==========================================================
5) sendKeys() có thay thế value trực tiếp không?
==========================================================

KHÔNG.

sendKeys() sẽ:

    Thêm nội dung vào cuối giá trị hiện tại.

Ví dụ:

Input đang có:
    "abc"

Gọi:

    element.sendKeys("123");

Kết quả:
    "abc123"

Muốn xóa trước khi nhập:

    element.clear();
    element.sendKeys("123");

==========================================================
6) sendKeys() có thể gửi phím đặc biệt
==========================================================

Selenium hỗ trợ class:

    Keys

Ví dụ:

    element.sendKeys(Keys.ENTER);
    element.sendKeys(Keys.TAB);
    element.sendKeys(Keys.BACK_SPACE);

Có thể kết hợp:

    element.sendKeys("admin", Keys.TAB);

==========================================================
7) sendKeys() với file upload
==========================================================

Nếu input có type="file":

    <input type="file">

Có thể upload file bằng:

    element.sendKeys("C:\\path\\file.txt");

Không cần click.

==========================================================
8) Lỗi thường gặp
==========================================================

8.1 ElementNotInteractableException

Xảy ra khi:

    - Element bị ẩn
    - Element bị disable
    - Element chưa load xong

----------------------------------------------------------

8.2 StaleElementReferenceException

Xảy ra khi:

    - DOM thay đổi
    - Trang reload

Cần tìm lại element.

----------------------------------------------------------

8.3 Không clear trước khi nhập

Dẫn đến dữ liệu bị nối thêm.

==========================================================
9) So sánh sendKeys() và JavaScript set value
==========================================================

sendKeys():

    - Mô phỏng người dùng thật
    - Trigger đầy đủ event
    - An toàn và đúng chuẩn

JavaScript setAttribute("value", "..."):

    - Không mô phỏng gõ phím
    - Có thể không trigger event
    - Không nên dùng nếu không cần thiết

==========================================================
10) Ví dụ đầy đủ
==========================================================

WebDriver driver = new ChromeDriver();

driver.get("https://example.com/login");

WebElement username =
    driver.findElement(By.id("username"));

WebElement password =
    driver.findElement(By.id("password"));

username.clear();
username.sendKeys("admin");

password.clear();
password.sendKeys("123456");

password.sendKeys(Keys.ENTER);

==========================================================
11) Tóm tắt ngắn gọn
==========================================================

sendKeys():

    - Là method của WebElement
    - Dùng để nhập dữ liệu vào input/textarea
    - Mô phỏng hành động gõ phím thật
    - Có thể gửi phím đặc biệt (Keys)
    - Không tự xóa nội dung cũ
    - Có thể dùng để upload file

==========================================================

KẾT LUẬN:

WebElement.sendKeys() là phương thức mô phỏng
việc người dùng gõ bàn phím vào một phần tử HTML,
được sử dụng chủ yếu để nhập dữ liệu trong automation Selenium.
==========================================================

--- CLICK VÀO ĐOẠN VĂN CÓ TEXT = "abc" TRÊN MÀN HÌNH BẰNG SELENIUM

GIẢI THÍCH CHI TIẾT:
CLICK VÀO ĐOẠN VĂN CÓ TEXT = "abc" TRÊN MÀN HÌNH BẰNG SELENIUM
=================================================================

1) VẤN ĐỀ ĐẶT RA
-----------------------------------------------------------------

Hiện tại trên trang web có một đoạn văn hiển thị:

    abc

Bạn muốn Selenium:

    - Tìm đúng đoạn văn có nội dung "abc"
    - Click vào nó

=================================================================
2) NGUYÊN TẮC HOẠT ĐỘNG
=================================================================

Selenium không click theo “nhìn thấy bằng mắt”.

Nó click dựa vào:

    - HTML tag
    - Attribute
    - Text
    - XPath
    - CSS selector

Vì vậy bạn phải xác định element đó trong DOM.

=================================================================
3) CÁCH 1: DÙNG XPath THEO TEXT (PHỔ BIẾN NHẤT)
=================================================================

Giả sử HTML:

    <p>abc</p>

Hoặc:

    <div>abc</div>

Bạn có thể dùng XPath:

    //*[text()='abc']

Ví dụ code:

    WebElement element =
        driver.findElement(By.xpath("//*[text()='abc']"));

    element.click();

-----------------------------------------------------------------

Giải thích:

    //*           -> tìm mọi tag
    text()='abc'  -> nội dung chính xác bằng abc

=================================================================
4) CÁCH 2: DÙNG contains() NẾU TEXT KHÔNG CHÍNH XÁC 100%
=================================================================

Nếu đoạn văn là:

    "abc testing"

Bạn có thể dùng:

    //*[contains(text(),'abc')]

Code:

    WebElement element =
        driver.findElement(By.xpath("//*[contains(text(),'abc')]"));

    element.click();

=================================================================
5) CÁCH 3: CHỈ ĐỊNH RÕ TAG (TỐT HƠN)
=================================================================

Nếu biết chắc là thẻ <p>:

    //p[text()='abc']

Hoặc:

    //div[text()='abc']

Ví dụ:

    WebElement element =
        driver.findElement(By.xpath("//p[text()='abc']"));

    element.click();

=================================================================
6) TRƯỜNG HỢP TEXT CÓ KHOẢNG TRẮNG
=================================================================

Nếu HTML là:

    <p>  abc   </p>

Nên dùng:

    //p[normalize-space()='abc']

Code:

    WebElement element =
        driver.findElement(By.xpath("//p[normalize-space()='abc']"));

    element.click();

=================================================================
7) TRƯỜNG HỢP TEXT BỊ CHIA NHIỀU NODE
=================================================================

Ví dụ:

    <p><span>a</span><span>b</span><span>c</span></p>

text() sẽ không hoạt động.

Nên dùng:

    //p[contains(.,'abc')]

Dấu chấm (.) nghĩa là:
    toàn bộ text bên trong element.

=================================================================
8) NẾU ELEMENT KHÔNG CLICK ĐƯỢC
=================================================================

Có thể do:

    - Element bị che
    - Element chưa load xong
    - Element không phải clickable

Cách xử lý:

8.1 Chờ element xuất hiện

    WebDriverWait wait =
        new WebDriverWait(driver, Duration.ofSeconds(10));

    WebElement element =
        wait.until(ExpectedConditions
        .elementToBeClickable(
            By.xpath("//*[text()='abc']")
        ));

    element.click();

-----------------------------------------------------------------

8.2 Dùng JavaScript click

    WebElement element =
        driver.findElement(By.xpath("//*[text()='abc']"));

    JavascriptExecutor js =
        (JavascriptExecutor) driver;

    js.executeScript("arguments[0].click();", element);

=================================================================
9) TRƯỜNG HỢP CÓ NHIỀU "abc"
=================================================================

Nếu trang có nhiều chữ "abc",
findElement sẽ lấy cái đầu tiên.

Muốn lấy cái thứ 2:

    (//*[text()='abc'])[2]

Code:

    WebElement element =
        driver.findElement(
            By.xpath("(//*[text()='abc'])[2]")
        );

=================================================================
10) TỔNG KẾT
=================================================================

Muốn click vào đoạn văn có chữ "abc":

Cách đơn giản nhất:

    driver.findElement(
        By.xpath("//*[text()='abc']")
    ).click();

-----------------------------------------------------------------

Nếu có khoảng trắng:

    //*[normalize-space()='abc']

Nếu chỉ cần chứa:

    //*[contains(text(),'abc')]

Nếu text nằm sâu bên trong:

    //*[contains(.,'abc')]

=================================================================

KẾT LUẬN:

Để click vào đoạn văn "abc", bạn phải:
    - Xác định element trong DOM
    - Dùng XPath tìm theo text
    - Gọi .click()

Selenium không click theo vị trí màn hình,
mà click theo element trong HTML.
=================================================================

--- element = driver.findElement(By.id("abc")); element.clear(); element.sendKeys("abc");

GIẢI THÍCH CHI TIẾT ĐOẠN CODE:

element = driver.findElement(By.id("abc"));
element.clear();
element.sendKeys("abc");

===============================================================
1) PHÂN TÍCH TỪNG DÒNG
===============================================================

DÒNG 1:
---------------------------------------------------------------
element = driver.findElement(By.id("abc"));

Ý nghĩa:

    - Tìm một phần tử (element) trên trang web
    - Dựa theo thuộc tính id = "abc"
    - Gán phần tử tìm được vào biến element

Giải thích chi tiết:

driver:
    Là đối tượng WebDriver (ví dụ ChromeDriver)

findElement(...):
    Là method dùng để tìm một phần tử trên DOM

By.id("abc"):
    Là cách định vị (locator)
    Nghĩa là tìm phần tử có:

        id="abc"

Ví dụ HTML:

    <input id="abc" type="text">

Kết quả:

    element sẽ trỏ tới ô input đó.

---------------------------------------------------------------
Lưu ý:
Nếu không tìm thấy id="abc"
Selenium sẽ ném lỗi:

    NoSuchElementException

===============================================================
DÒNG 2:
---------------------------------------------------------------
element.clear();

Ý nghĩa:

    Xóa toàn bộ nội dung hiện có trong input.

Ví dụ:

Trước khi clear:
    value = "old text"

Sau khi clear:
    value = ""

clear() thường dùng cho:

    - input type="text"
    - input type="password"
    - textarea

Nếu không clear mà gọi sendKeys(),
nội dung mới sẽ được nối thêm vào cuối.

===============================================================
DÒNG 3:
---------------------------------------------------------------
element.sendKeys("abc");

(Lưu ý: phải là sendKeys, không phải sendKey)

Ý nghĩa:

    Nhập chuỗi "abc" vào element.

Hoạt động nội bộ:

    - Selenium focus vào element
    - Gõ từng ký tự:
            a
            b
            c
    - Trigger các event:
            keydown
            keypress
            keyup
            input

Kết quả:

    Ô input sẽ hiển thị:

        abc

===============================================================
2) QUY TRÌNH HOẠT ĐỘNG TOÀN BỘ
===============================================================

Giả sử HTML:

    <input id="abc" type="text" value="hello">

Thực thi:

    element = driver.findElement(By.id("abc"));
    element.clear();
    element.sendKeys("abc");

Quy trình:

    1) Tìm input có id="abc"
    2) Xóa "hello"
    3) Nhập "abc"

Kết quả cuối cùng:

    value = "abc"

===============================================================
3) NẾU KHÔNG DÙNG clear()
===============================================================

Nếu viết:

    element.sendKeys("abc");

Trong khi value ban đầu là:

    "hello"

Kết quả sẽ là:

    "helloabc"

===============================================================
4) LỖI THƯỜNG GẶP
===============================================================

4.1 Sai tên method

Sai:
    element.sendKey("abc");

Đúng:
    element.sendKeys("abc");

---------------------------------------------------------------

4.2 Element chưa sẵn sàng

Nếu element chưa load xong,
có thể bị:

    ElementNotInteractableException

Cách xử lý:

    WebDriverWait wait =
        new WebDriverWait(driver, Duration.ofSeconds(10));

    WebElement element =
        wait.until(ExpectedConditions
            .elementToBeClickable(By.id("abc")));

---------------------------------------------------------------

4.3 Element nằm trong frame

Nếu input nằm trong iframe,
phải switch trước:

    driver.switchTo().frame("frameId");

===============================================================
5) MỞ RỘNG: GỬI PHÍM ĐẶC BIỆT
===============================================================

Có thể gửi phím đặc biệt:

    element.sendKeys("abc", Keys.ENTER);

===============================================================
6) TÓM TẮT NGẮN GỌN
===============================================================

driver.findElement(By.id("abc"));
    -> Tìm element có id="abc"

element.clear();
    -> Xóa nội dung hiện tại

element.sendKeys("abc");
    -> Nhập chữ "abc" vào input

===============================================================

KẾT LUẬN:

Đoạn code trên dùng để:
    - Tìm một ô input
    - Xóa nội dung cũ
    - Nhập nội dung mới vào

Đây là pattern phổ biến nhất khi nhập dữ liệu trong Selenium.
===============================================================
```}

--- LÀM SAO BIẾT driver.findElement ĐÃ LẤY ĐÚNG THẺ HTML?

GIẢI THÍCH CHI TIẾT:
LÀM SAO BIẾT driver.findElement ĐÃ LẤY ĐÚNG THẺ HTML?
=================================================================

1) VẤN ĐỀ ĐẶT RA
-----------------------------------------------------------------

Khi bạn viết:

    WebElement element =
        driver.findElement(By.id("abc"));

Làm sao biết:

    - Selenium đã lấy đúng thẻ HTML mình cần?
    - Không bị nhầm element khác?
    - Không bị lấy nhầm element trùng id/class?

=================================================================
2) NGUYÊN TẮC CƠ BẢN
=================================================================

Nếu findElement tìm sai:

    - Có thể bạn dùng sai locator
    - Hoặc DOM thay đổi
    - Hoặc có nhiều element giống nhau

Vì vậy cần xác minh lại element đã lấy.

=================================================================
3) CÁCH 1: IN RA THÔNG TIN ELEMENT
=================================================================

3.1 Kiểm tra tag name

    System.out.println(element.getTagName());

Ví dụ kết quả:
    input
    div
    span

Nếu bạn mong muốn là <input>
mà kết quả là div -> bạn đã lấy sai.

---------------------------------------------------------------

3.2 Kiểm tra attribute

    System.out.println(element.getAttribute("id"));
    System.out.println(element.getAttribute("class"));
    System.out.println(element.getAttribute("type"));

Ví dụ:

    element.getAttribute("id") phải là "abc"

---------------------------------------------------------------

3.3 Kiểm tra text

    System.out.println(element.getText());

Nếu bạn muốn click đoạn văn "abc"
mà getText() không phải "abc"
=> bạn đã lấy sai element.

=================================================================
4) CÁCH 2: SO SÁNH VỚI DEVTOOLS (F12)
=================================================================

Bước kiểm tra chuẩn:

    1) Mở Chrome
    2) Nhấn F12
    3) Inspect element
    4) Xem HTML thật sự

Sau đó copy XPath hoặc CSS
và test trực tiếp trong DevTools:

    Ctrl + F
    Dán XPath vào

Nếu DevTools highlight đúng 1 element,
thì locator của bạn đúng.

=================================================================
5) CÁCH 3: KIỂM TRA SỐ LƯỢNG ELEMENT
=================================================================

Thay vì:

    driver.findElement(...);

Bạn dùng:

    List<WebElement> list =
        driver.findElements(By.xpath("..."));

    System.out.println(list.size());

Nếu:

    size > 1

=> locator chưa đủ chính xác.

=================================================================
6) CÁCH 4: DÙNG isDisplayed()
=================================================================

    System.out.println(element.isDisplayed());

Nếu trả về false:
    element có thể đang ẩn
    hoặc bạn lấy nhầm element hidden

=================================================================
7) CÁCH 5: HIGHLIGHT ELEMENT TRÊN TRÌNH DUYỆT
=================================================================

Cách mạnh nhất để xác nhận:

Dùng JavaScript làm nổi bật element:

    JavascriptExecutor js =
        (JavascriptExecutor) driver;

    js.executeScript(
        "arguments[0].style.border='3px solid red'",
        element
    );

Khi chạy test,
element đúng sẽ có viền đỏ trên màn hình.

Nếu bạn thấy viền đỏ sai chỗ,
bạn biết locator sai.

=================================================================
8) CÁCH 6: KIỂM TRA HTML BÊN NGOÀI (outerHTML)
=================================================================

In toàn bộ HTML của element:

    System.out.println(
        element.getAttribute("outerHTML")
    );

Bạn sẽ thấy:

    <input id="abc" type="text" value="...">

So sánh với DevTools.

=================================================================
9) CÁCH 7: DÙNG ASSERT TRONG TEST
=================================================================

Ví dụ với JUnit:

    Assert.assertEquals(
        "abc",
        element.getAttribute("id")
    );

Hoặc:

    Assert.assertEquals(
        "input",
        element.getTagName()
    );

Nếu sai, test sẽ fail.

=================================================================
10) LỖI PHỔ BIẾN KHI LẤY SAI ELEMENT
=================================================================

- Locator quá chung chung
    Ví dụ: //div

- Có nhiều element giống nhau

- Element dynamic thay đổi id

- Element nằm trong frame nhưng chưa switch

=================================================================
11) CHECKLIST XÁC MINH ĐÚNG ELEMENT
=================================================================

Sau khi findElement:

    1) In tagName
    2) In id/class
    3) In outerHTML
    4) Kiểm tra getText()
    5) Highlight element
    6) So sánh với DevTools

Nếu tất cả khớp,
bạn đã lấy đúng element.

=================================================================
12) TÓM TẮT NGẮN GỌN
=================================================================

Để biết driver.findElement lấy đúng thẻ:

    - Kiểm tra tagName
    - Kiểm tra attribute
    - Kiểm tra text
    - In outerHTML
    - Highlight trên màn hình
    - So sánh với DevTools

=================================================================

KẾT LUẬN:

Selenium không "biết" bạn muốn element nào.
Nó chỉ lấy element theo locator bạn cung cấp.

Vì vậy muốn chắc chắn đúng,
bạn phải xác minh lại bằng getTagName(),
getAttribute(), getText(), hoặc highlight.
=================================================================

--- Files.write TRONG JAVA

GIẢI THÍCH CHI TIẾT VỀ CÚ PHÁP Files.write TRONG JAVA

I. GIỚI THIỆU

Files.write là một phương thức (method) static thuộc lớp Files trong package:

    java.nio.file.Files

Nó được dùng để ghi dữ liệu vào file theo cách đơn giản, nhanh gọn, thuộc NIO.2 (Java 7 trở lên).

Đây là cách hiện đại thay thế cho FileOutputStream, FileWriter trong nhiều trường hợp.

------------------------------------------------------------
II. CÁC OVERLOAD (CÁC PHIÊN BẢN) QUAN TRỌNG

1) Ghi byte[]

    Files.write(Path path, byte[] bytes, OpenOption... options)

2) Ghi List<String>

    Files.write(Path path, Iterable<? extends CharSequence> lines, 
                Charset cs, OpenOption... options)

3) Ghi List<String> (mặc định UTF-8)

    Files.write(Path path, Iterable<? extends CharSequence> lines,
                OpenOption... options)

4) Ghi byte[] (không truyền options)

    Files.write(Path path, byte[] bytes)

------------------------------------------------------------
III. PHÂN TÍCH CHI TIẾT TỪNG THAM SỐ

1) Path path

Đây là đường dẫn đến file cần ghi.

Tạo Path bằng:

    Path path = Paths.get("data.txt");

Hoặc:

    Path path = Path.of("data.txt");  // Java 11+

Nếu file chưa tồn tại:
- Mặc định Files.write sẽ tự tạo file mới.

Nếu file đã tồn tại:
- Mặc định sẽ ghi đè nội dung cũ.

------------------------------------------------------------
2) byte[] bytes

Dùng khi bạn muốn ghi dữ liệu dạng nhị phân (binary):
- Ảnh
- File zip
- PDF
- Hoặc String đã convert sang byte

Ví dụ:

    String content = "Hello";
    byte[] data = content.getBytes(StandardCharsets.UTF_8);
    Files.write(path, data);

------------------------------------------------------------
3) Iterable<? extends CharSequence> lines

Dùng khi ghi nhiều dòng text.

Ví dụ:

    List<String> lines = List.of(
        "Dong 1",
        "Dong 2",
        "Dong 3"
    );

    Files.write(path, lines);

Mỗi phần tử trong List sẽ thành 1 dòng riêng trong file.

------------------------------------------------------------
4) Charset cs

Dùng để chỉ định bảng mã (encoding).

Ví dụ:

    Files.write(path, lines, StandardCharsets.UTF_8);

Nếu không truyền Charset:
- Mặc định là UTF-8 (từ Java 11)
- Trước Java 11 là charset hệ điều hành

------------------------------------------------------------
5) OpenOption... options

Đây là phần rất quan trọng.
Nó quyết định cách ghi file.

Một số StandardOpenOption thường dùng:

- CREATE
  Tạo file nếu chưa tồn tại

- CREATE_NEW
  Tạo file mới, nếu đã tồn tại sẽ ném exception

- WRITE
  Mở file để ghi

- APPEND
  Ghi tiếp vào cuối file (không ghi đè)

- TRUNCATE_EXISTING
  Xóa nội dung cũ trước khi ghi

------------------------------------------------------------
IV. HÀNH VI MẶC ĐỊNH

Nếu bạn chỉ viết:

    Files.write(path, data);

Thì tương đương với:

    CREATE
    TRUNCATE_EXISTING
    WRITE

Nghĩa là:
- Nếu file chưa tồn tại → tạo mới
- Nếu file tồn tại → xóa nội dung cũ và ghi lại

------------------------------------------------------------
V. VÍ DỤ CỤ THỂ

1) Ghi đè file

    Path path = Path.of("test.txt");
    String content = "Hello Java";

    Files.write(path, content.getBytes(StandardCharsets.UTF_8));

------------------------------------------------------------
2) Ghi thêm vào cuối file (append)

    Files.write(
        path,
        "Dong moi\n".getBytes(StandardCharsets.UTF_8),
        StandardOpenOption.CREATE,
        StandardOpenOption.APPEND
    );

------------------------------------------------------------
3) Ghi nhiều dòng text

    List<String> lines = List.of("A", "B", "C");

    Files.write(
        path,
        lines,
        StandardCharsets.UTF_8,
        StandardOpenOption.CREATE,
        StandardOpenOption.APPEND
    );

------------------------------------------------------------
VI. Files.write HOẠT ĐỘNG NHƯ THẾ NÀO BÊN TRONG?

Bên trong, Files.write sẽ:

1) Mở file thông qua FileChannel
2) Ghi toàn bộ dữ liệu một lần
3) Đóng file ngay lập tức

Nó không giữ stream mở như FileOutputStream.

Điều này có nghĩa:

- Phù hợp với file nhỏ và vừa
- Không phù hợp với file cực lớn (vì cần giữ toàn bộ byte[] trong memory)

------------------------------------------------------------
VII. SO SÁNH Files.write VS FileOutputStream

Files.write:
- Code ngắn gọn
- Tự động đóng file
- Phù hợp ghi nhanh, đơn giản

FileOutputStream:
- Kiểm soát tốt hơn
- Phù hợp khi ghi từng phần
- Tốt cho file lớn

------------------------------------------------------------
VIII. CÁC EXCEPTION CÓ THỂ XẢY RA

Files.write ném IOException nếu:

- Không có quyền ghi file
- Đường dẫn không hợp lệ
- Ổ đĩa đầy
- File đang bị lock

Ví dụ xử lý:

    try {
        Files.write(path, data);
    } catch (IOException e) {
        e.printStackTrace();
    }

------------------------------------------------------------
IX. KHI NÀO NÊN DÙNG Files.write?

Nên dùng khi:

- Ghi file cấu hình
- Ghi log đơn giản
- Ghi file text nhỏ
- Export dữ liệu nhỏ

Không nên dùng khi:

- Ghi file rất lớn (vài GB)
- Ghi streaming liên tục
- Cần hiệu năng cực cao

------------------------------------------------------------
X. TÓM TẮT NGẮN GỌN

Files.write là phương thức tiện lợi trong NIO.2 để:

- Ghi byte[] hoặc List<String> vào file
- Tự động tạo file nếu chưa tồn tại
- Mặc định ghi đè nội dung cũ
- Có thể cấu hình append bằng OpenOption

Đây là cách ghi file hiện đại, sạch, gọn trong Java.

--- FileReader VÀ BufferedReader TRONG JAVA

GIẢI THÍCH CHI TIẾT VỀ FileReader VÀ BufferedReader TRONG JAVA

============================================================
I. TỔNG QUAN

FileReader và BufferedReader đều dùng để đọc file text trong Java.

Chúng thuộc nhóm java.io (IO cổ điển, trước NIO).

Quan trọng:
- FileReader: đọc ký tự trực tiếp từ file
- BufferedReader: thêm bộ đệm (buffer) để đọc nhanh và hiệu quả hơn

Hai class này thường được dùng chung với nhau.

============================================================
II. FILE READER LÀ GÌ?

1) Vị trí:

    java.io.FileReader

2) Kế thừa:

    FileReader
        -> InputStreamReader
            -> Reader

3) Mục đích:

Dùng để đọc dữ liệu dạng ký tự (character) từ file text.

Nó tự động chuyển byte từ file thành ký tự (char).

------------------------------------------------------------
III. FILE READER HOẠT ĐỘNG NHƯ THẾ NÀO?

Bên trong:

File -> FileInputStream -> InputStreamReader -> FileReader

Nó đọc từng byte từ file, sau đó chuyển thành ký tự dựa trên charset mặc định của hệ điều hành.

Quan trọng:
FileReader KHÔNG phù hợp cho file nhị phân (ảnh, video, zip).

------------------------------------------------------------
IV. CÁCH DÙNG FileReader

Ví dụ đọc từng ký tự:

    FileReader reader = new FileReader("data.txt");

    int ch;
    while ((ch = reader.read()) != -1) {
        System.out.print((char) ch);
    }

    reader.close();

Giải thích:
- read() trả về int
- -1 nghĩa là hết file
- Mỗi lần read() đọc 1 ký tự

------------------------------------------------------------
V. NHƯỢC ĐIỂM CỦA FileReader

1) Không có buffer
   -> Mỗi lần đọc là truy cập hệ thống file
   -> Chậm nếu file lớn

2) Dùng charset mặc định hệ điều hành
   -> Có thể lỗi khi đọc tiếng Việt

3) Không có phương thức readLine()

Vì vậy ta thường kết hợp với BufferedReader.

============================================================
VI. BUFFERED READER LÀ GÌ?

1) Vị trí:

    java.io.BufferedReader

2) Kế thừa:

    BufferedReader
        -> Reader

3) Mục đích:

Thêm bộ đệm (buffer) để đọc dữ liệu hiệu quả hơn.

------------------------------------------------------------
VII. BUFFER LÀ GÌ?

Buffer là vùng nhớ tạm trong RAM.

Thay vì:
- Mỗi lần đọc 1 ký tự từ ổ cứng

BufferedReader sẽ:
- Đọc một khối lớn (ví dụ 8KB)
- Lưu vào RAM
- Sau đó trả ký tự từ RAM

Điều này:
- Giảm số lần truy cập ổ cứng
- Tăng tốc độ đáng kể

------------------------------------------------------------
VIII. CÁCH DÙNG BufferedReader

BufferedReader KHÔNG đọc file trực tiếp.

Nó cần một Reader bên dưới, thường là FileReader.

Ví dụ:

    BufferedReader br = new BufferedReader(
        new FileReader("data.txt")
    );

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();

------------------------------------------------------------
IX. PHƯƠNG THỨC QUAN TRỌNG CỦA BufferedReader

1) read()
   Đọc 1 ký tự

2) read(char[] cbuf)
   Đọc nhiều ký tự vào mảng

3) readLine()
   Đọc 1 dòng (rất quan trọng)

4) close()
   Đóng stream

------------------------------------------------------------
X. SO SÁNH FileReader VS BufferedReader

1) FileReader
   - Đọc ký tự trực tiếp từ file
   - Không có buffer
   - Không có readLine()
   - Chậm nếu file lớn

2) BufferedReader
   - Có buffer
   - Có readLine()
   - Nhanh hơn nhiều
   - Thường bọc ngoài FileReader

------------------------------------------------------------
XI. TẠI SAO NÊN DÙNG CẢ HAI?

Cách chuẩn để đọc file text:

    BufferedReader br =
        new BufferedReader(
            new FileReader("data.txt")
        );

Vì:
- FileReader: kết nối file
- BufferedReader: tăng hiệu năng

============================================================
XII. VẤN ĐỀ ENCODING (QUAN TRỌNG)

FileReader dùng charset mặc định hệ điều hành.

Điều này nguy hiểm nếu:
- File là UTF-8
- Máy đang dùng Windows-1258

Cách an toàn hơn:

    BufferedReader br =
        new BufferedReader(
            new InputStreamReader(
                new FileInputStream("data.txt"),
                StandardCharsets.UTF_8
            )
        );

Cách này kiểm soát encoding rõ ràng.

============================================================
XIII. TRY-WITH-RESOURCES (KHUYẾN NGHỊ)

Luôn dùng:

    try (BufferedReader br =
             new BufferedReader(
                 new FileReader("data.txt"))) {

        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }

    } catch (IOException e) {
        e.printStackTrace();
    }

Tự động đóng file.

============================================================
XIV. KHI NÀO DÙNG FileReader?

Hầu như không dùng riêng lẻ.

Chỉ dùng khi:
- File rất nhỏ
- Không cần readLine
- Không quan tâm hiệu năng

============================================================
XV. KHI NÀO DÙNG BufferedReader?

Gần như luôn dùng khi đọc file text.

Phù hợp:
- Đọc file lớn
- Đọc theo dòng
- Đọc cấu hình
- Đọc log
- Đọc CSV

============================================================
XVI. FILE TEXT VS FILE BINARY

FileReader / BufferedReader:
- Chỉ dùng cho file TEXT

Không dùng cho:
- Ảnh (.jpg, .png)
- Video
- File .zip
- File .pdf

File binary phải dùng:
- FileInputStream
- BufferedInputStream

============================================================
XVII. TÓM TẮT NGẮN GỌN

FileReader:
- Đọc ký tự từ file
- Không có buffer
- Dùng charset mặc định

BufferedReader:
- Thêm buffer
- Tăng tốc độ
- Có readLine()
- Thường bọc ngoài FileReader

Thực tế chuẩn:

    BufferedReader + InputStreamReader + FileInputStream + Charset rõ ràng

Đây là cách đọc file text an toàn và chuyên nghiệp trong Java.

--- new File(filePath) LÀ ĐÃ TẠO FILE TRÊN MÁY HAY CHƯA?

GIẢI THÍCH CHI TIẾT:
new File(filePath) LÀ ĐÃ TẠO FILE TRÊN MÁY HAY CHƯA?

============================================================
I. CÂU TRẢ LỜI NGẮN GỌN

KHÔNG.

new File(filePath) CHƯA tạo file thật trên ổ đĩa.

Nó chỉ tạo một đối tượng (object) trong bộ nhớ RAM đại diện cho đường dẫn đó.

============================================================
II. GIẢI THÍCH BẢN CHẤT

Khi bạn viết:

    File file = new File("data.txt");

Điều gì xảy ra?

1) JVM tạo một object kiểu File trong RAM.
2) Object này chỉ lưu:
   - Đường dẫn
   - Tên file
   - Một số metadata logic
3) KHÔNG có file nào được tạo trên ổ cứng.

Nói cách khác:
File object chỉ là "đại diện cho đường dẫn", không phải file thật.

============================================================
III. TẠI SAO THIẾT KẾ NHƯ VẬY?

Class File trong Java:

- Không phải là file thật
- Không mở file
- Không tạo file
- Không đọc ghi dữ liệu

Nó chỉ là một abstraction (đại diện trừu tượng cho đường dẫn).

Điều này cho phép bạn:

- Kiểm tra file tồn tại hay không
- Kiểm tra quyền truy cập
- Tạo file nếu muốn
- Xóa file nếu muốn

Nhưng phải gọi method riêng.

============================================================
IV. VÍ DỤ THỰC TẾ

    File file = new File("abc.txt");

Sau dòng này:

- Nếu abc.txt chưa tồn tại
  → Vẫn không có file nào được tạo

Kiểm tra:

    System.out.println(file.exists());

Kết quả:
false

============================================================
V. KHI NÀO FILE THẬT SỰ ĐƯỢC TẠO?

1) Khi gọi createNewFile()

    file.createNewFile();

Lúc này:
- Nếu file chưa tồn tại → tạo file thật trên ổ đĩa
- Nếu đã tồn tại → trả về false

2) Khi dùng FileWriter, FileOutputStream, Files.write

Ví dụ:

    FileWriter fw = new FileWriter(file);

Nếu file chưa tồn tại:
→ Java sẽ tự tạo file thật.

============================================================
VI. SO SÁNH ĐỂ DỄ HIỂU

new File("data.txt")

Giống như:
- Bạn viết địa chỉ nhà ra giấy

Nó không xây nhà.

createNewFile()

Giống như:
- Bạn thực sự xây ngôi nhà đó.

============================================================
VII. BẢNG SO SÁNH RÕ RÀNG

Lệnh                               Có tạo file thật không?

new File("a.txt")                  KHÔNG
file.exists()                      KHÔNG
file.delete()                      KHÔNG tạo (chỉ xóa nếu có)
file.createNewFile()               CÓ
new FileWriter(file)               CÓ (nếu chưa tồn tại)
Files.write(path, bytes)           CÓ (nếu chưa tồn tại)

============================================================
VIII. TRƯỜNG HỢP ĐẶC BIỆT: THƯ MỤC

    File dir = new File("myFolder");

Cũng tương tự:
- Không tạo folder

Phải gọi:

    dir.mkdir();      // tạo 1 cấp
    dir.mkdirs();     // tạo nhiều cấp

============================================================
IX. LƯU Ý QUAN TRỌNG

1) new File() không kiểm tra file có tồn tại hay không.
2) Không gây lỗi nếu đường dẫn sai.
3) Không chiếm tài nguyên hệ thống.
4) Không mở file descriptor.

============================================================
X. MINH HỌA BẰNG CODE

    File file = new File("test.txt");

    System.out.println(file.exists()); 
    // false nếu file chưa tồn tại

    file.createNewFile();

    System.out.println(file.exists());
    // true

============================================================
XI. KẾT LUẬN

new File(filePath):

- CHỈ tạo object đại diện đường dẫn trong RAM
- KHÔNG tạo file trên ổ đĩa
- KHÔNG truy cập hệ thống file
- KHÔNG mở file

File chỉ được tạo thật sự khi:
- Gọi createNewFile()
- Hoặc ghi dữ liệu vào nó

============================================================
XII. TÓM TẮT 1 DÒNG

new File(...) chỉ là "khai báo ý định sử dụng file", 
chứ chưa hề tạo file thật trên máy.

--- while ((line = inputStream.readLine()) != null)

GIẢI THÍCH CHI TIẾT CÚ PHÁP:

while ((line = inputStream.readLine()) != null)

============================================================
I. VIẾT ĐÚNG CÚ PHÁP TRƯỚC

Cú pháp đúng phải là:

    while ((line = inputStream.readLine()) != null)

KHÔNG phải:

    while ((line = inputStream.readLine() != null))

Vì nếu đặt ngoặc sai, chương trình sẽ lỗi hoặc logic sai.

============================================================
II. PHÂN TÍCH TỪNG PHẦN

Câu lệnh gồm 3 phần:

1) inputStream.readLine()
2) line = ...
3) != null

Chúng ta phân tích từ trong ra ngoài.

============================================================
III. readLine() LÀ GÌ?

readLine() là phương thức của:

- BufferedReader
- Hoặc các class tương tự

Chức năng:
- Đọc 1 dòng văn bản từ file
- Trả về kiểu String
- Nếu đã đọc hết file → trả về null

Ví dụ:
File:
----------------
A
B
C
----------------

Mỗi lần readLine() sẽ trả:

Lần 1 → "A"
Lần 2 → "B"
Lần 3 → "C"
Lần 4 → null

============================================================
IV. PHẦN (line = inputStream.readLine())

Đây là phép gán.

Nó làm 2 việc:

1) Gọi readLine()
2) Gán giá trị trả về cho biến line

Quan trọng:
Trong Java, phép gán có giá trị trả về.

Ví dụ:

    String line;
    String result = (line = "Hello");

Khi đó:
- line = "Hello"
- result cũng = "Hello"

Tức là:
Biểu thức (line = something) sẽ trả về chính giá trị được gán.

============================================================
V. PHẦN ((line = inputStream.readLine()) != null)

Sau khi gán xong, Java sẽ:

- Lấy giá trị vừa gán
- So sánh với null

Nếu khác null → điều kiện TRUE
Nếu bằng null → điều kiện FALSE

============================================================
VI. TOÀN BỘ CÂU LỆNH HOẠT ĐỘNG NHƯ SAU

Giả sử file có 3 dòng:

Vòng lặp 1:
- readLine() → "A"
- line = "A"
- "A" != null → true
→ vào vòng while

Vòng lặp 2:
- readLine() → "B"
- line = "B"
- "B" != null → true
→ tiếp tục

Vòng lặp 3:
- readLine() → "C"
- line = "C"
- "C" != null → true
→ tiếp tục

Vòng lặp 4:
- readLine() → null
- line = null
- null != null → false
→ dừng vòng lặp

============================================================
VII. TẠI SAO KHÔNG VIẾT THEO CÁCH KHÁC?

Ta có thể viết tách ra:

    String line = inputStream.readLine();

    while (line != null) {
        System.out.println(line);
        line = inputStream.readLine();
    }

Cách này dài hơn nhưng dễ hiểu hơn.

Cách viết gộp giúp:

- Ngắn gọn
- Tránh lặp code
- Chuẩn trong Java

============================================================
VIII. LƯU Ý QUAN TRỌNG VỀ NGOẶC

CÚ PHÁP ĐÚNG:

    while ((line = inputStream.readLine()) != null)

Sai nếu viết:

    while (line = inputStream.readLine() != null)

Vì:

- inputStream.readLine() != null
  sẽ được tính trước
- Kết quả là boolean
- line = boolean → lỗi kiểu dữ liệu

Do đó cần ngoặc để đảm bảo:

1) Thực hiện gán trước
2) Sau đó mới so sánh với null

============================================================
IX. DÒNG LỆNH NÀY GIẢI QUYẾT VẤN ĐỀ GÌ?

Nó giúp:

- Đọc file từng dòng
- Dừng chính xác khi hết file
- Không bị NullPointerException
- Không cần đếm số dòng

============================================================
X. ĐÂY LÀ PATTERN CHUẨN TRONG JAVA

Hầu như mọi ví dụ đọc file text đều dùng:

    while ((line = reader.readLine()) != null)

Đây được coi là "idiom" (mẫu chuẩn) trong Java.

============================================================
XI. TÓM TẮT NGẮN GỌN

while ((line = inputStream.readLine()) != null)

Hoạt động theo thứ tự:

1) Đọc 1 dòng
2) Gán vào biến line
3) Kiểm tra có khác null không
4) Nếu khác null → tiếp tục vòng lặp
5) Nếu null → dừng

Đây là cách đọc file theo từng dòng an toàn và chuẩn nhất trong Java.

--- driver.findElement(By.xpath("//input[@value='STATUS']")

GIẢI THÍCH CHI TIẾT:

driver.findElement(By.xpath("//input[@value='STATUS']"))

============================================================
I. TỔNG QUAN

Câu lệnh này thuộc Selenium WebDriver.

Mục đích:
- Tìm một phần tử (element) trên trang web
- Sử dụng XPath làm cách định vị (locator)

Cấu trúc gồm 3 phần chính:

1) driver
2) findElement(...)
3) By.xpath("...")

============================================================
II. PHÂN TÍCH TỪNG THÀNH PHẦN

------------------------------------------------------------
1) driver

driver là một đối tượng WebDriver.

Ví dụ:

    WebDriver driver = new ChromeDriver();

Nó đại diện cho:
- Trình duyệt đang được điều khiển (Chrome, Firefox, Edge...)

driver chịu trách nhiệm:
- Mở trang web
- Tìm phần tử
- Click
- Nhập dữ liệu
- Thực hiện thao tác tự động

------------------------------------------------------------
2) findElement(...)

Đây là method của WebDriver.

Chức năng:
- Tìm một phần tử duy nhất trên trang
- Trả về kiểu WebElement

Cú pháp:

    WebElement element = driver.findElement(By.something());

Quan trọng:

- Nếu tìm thấy → trả về WebElement
- Nếu KHÔNG tìm thấy → ném NoSuchElementException

Khác với:

    findElements()

findElements() trả về List<WebElement>
Nếu không tìm thấy → trả về list rỗng (không lỗi)

------------------------------------------------------------
3) By.xpath("...")

By là class cung cấp các cách định vị phần tử.

Một số cách định vị phổ biến:

- By.id("idValue")
- By.name("nameValue")
- By.className("classValue")
- By.cssSelector("...")
- By.xpath("...")

Ở đây ta dùng XPath.

============================================================
III. PHÂN TÍCH XPATH

XPath đang dùng:

    "//input[@value='STATUS']"

Ta phân tích từng phần.

------------------------------------------------------------
1) //

Dấu // nghĩa là:

- Tìm ở bất kỳ đâu trong DOM
- Không cần biết nó nằm trong thẻ nào

Nó có nghĩa là:
"tìm từ root xuống toàn bộ cây DOM"

------------------------------------------------------------
2) input

Chỉ định tên thẻ HTML.

Ở đây là:

    <input>

Ví dụ:

    <input type="submit" value="STATUS">

XPath sẽ chỉ tìm các thẻ input.

------------------------------------------------------------
3) [@value='STATUS']

Đây là điều kiện lọc (predicate).

Ý nghĩa:

- @value → thuộc tính value
- 'STATUS' → giá trị cần khớp

Nghĩa đầy đủ:

"Tìm thẻ input có thuộc tính value bằng STATUS"

------------------------------------------------------------
IV. TOÀN BỘ XPATH CÓ NGHĨA LÀ GÌ?

    "//input[@value='STATUS']"

Có nghĩa:

"Tìm tất cả các thẻ <input> trong trang có thuộc tính value bằng STATUS"

Nhưng vì dùng findElement() nên:

- Selenium chỉ lấy phần tử đầu tiên tìm được.

============================================================
V. VÍ DỤ HTML THỰC TẾ

Giả sử trang có:

    <input type="button" value="STATUS">
    <input type="button" value="CANCEL">

XPath trên sẽ tìm:

    <input type="button" value="STATUS">

============================================================
VI. CÁCH LỆNH HOẠT ĐỘNG TỪNG BƯỚC

1) Selenium gửi yêu cầu xuống browser driver
2) Browser driver tìm trong DOM
3) Duyệt toàn bộ DOM
4) Tìm thẻ input có value="STATUS"
5) Trả về WebElement tương ứng
6) Nếu không có → ném exception

============================================================
VII. NHỮNG TRƯỜNG HỢP CÓ THỂ LỖI

1) Không tồn tại phần tử
→ NoSuchElementException

2) Phần tử chưa load xong
→ Cần dùng WebDriverWait

3) Có nhiều phần tử trùng
→ findElement chỉ lấy cái đầu tiên

============================================================
VIII. CÁCH VIẾT TƯƠNG ĐƯƠNG BẰNG CSS SELECTOR

XPath:

    //input[@value='STATUS']

CSS tương đương:

    input[value='STATUS']

Viết bằng Selenium:

    driver.findElement(By.cssSelector("input[value='STATUS']"));

CSS thường nhanh hơn XPath.

============================================================
IX. CÁC BIẾN THỂ KHÁC CỦA XPATH

1) Tìm chứa giá trị

    //input[contains(@value,'STAT')]

2) Tìm chính xác text

    //button[text()='STATUS']

3) Tìm theo id

    //input[@id='statusBtn']

============================================================
X. KHI NÀO NÊN DÙNG XPATH?

Dùng XPath khi:

- Không có id
- Không có name
- Cấu trúc DOM phức tạp
- Cần đi theo quan hệ cha-con

Nếu có id duy nhất → nên dùng:

    By.id()

Vì nhanh và ổn định hơn.

============================================================
XI. TÓM TẮT NGẮN GỌN

driver.findElement(By.xpath("//input[@value='STATUS']"))

Hoạt động như sau:

1) driver điều khiển trình duyệt
2) findElement tìm 1 phần tử
3) By.xpath dùng XPath làm cách định vị
4) XPath tìm thẻ input có value="STATUS"
5) Trả về WebElement đầu tiên tìm được
6) Nếu không có → ném exception

Đây là cách Selenium xác định phần tử dựa trên XPath trong DOM.

--- myElement1.getAttribute("id").replace("fieldName", "value")

GIẢI THÍCH CHI TIẾT:

myElement1.getAttribute("id").replace("fieldName", "value")

============================================================
I. TỔNG QUAN

Câu lệnh này thường xuất hiện trong Selenium WebDriver.

Nó gồm 3 bước liên tiếp:

1) Lấy giá trị thuộc tính "id" của một WebElement
2) Trả về chuỗi (String)
3) Thay thế một phần chuỗi bằng giá trị khác

============================================================
II. PHÂN TÍCH TỪNG PHẦN

------------------------------------------------------------
1) myElement1

Đây là một đối tượng WebElement.

Ví dụ:

    WebElement myElement1 = driver.findElement(By.id("username"));

WebElement đại diện cho một phần tử HTML trên trang.

------------------------------------------------------------
2) getAttribute("id")

Phương thức của WebElement.

Cú pháp:

    String value = element.getAttribute("attributeName");

Chức năng:
- Lấy giá trị của thuộc tính HTML

Ví dụ HTML:

    <input id="user_fieldName_123" type="text">

Khi gọi:

    myElement1.getAttribute("id");

Kết quả trả về:

    "user_fieldName_123"

Lưu ý:
- Nếu không có thuộc tính đó → trả về null

------------------------------------------------------------
3) .replace("fieldName", "value")

Đây là phương thức của class String.

Cú pháp:

    String newString = oldString.replace("old", "new");

Chức năng:
- Thay tất cả chuỗi "old" bằng "new"
- Trả về chuỗi mới
- KHÔNG làm thay đổi chuỗi ban đầu (String là immutable)

Ví dụ:

    "abc_fieldName_xyz".replace("fieldName", "value");

Kết quả:

    "abc_value_xyz"

============================================================
III. TOÀN BỘ CÂU LỆNH HOẠT ĐỘNG NHƯ SAU

Giả sử HTML:

    <input id="user_fieldName_123" type="text">

Bước 1:
    myElement1.getAttribute("id")

Trả về:
    "user_fieldName_123"

Bước 2:
    "user_fieldName_123".replace("fieldName", "value")

Trả về:
    "user_value_123"

Kết quả cuối cùng của toàn bộ biểu thức:

    "user_value_123"

============================================================
IV. LƯU Ý QUAN TRỌNG

1) replace() trả về chuỗi mới

Nó không thay đổi DOM.
Nó không thay đổi thuộc tính id trên trang.

Chỉ xử lý chuỗi trong Java.

------------------------------------------------------------
2) Nếu getAttribute trả về null

Ví dụ:

    myElement1.getAttribute("id") == null

Thì gọi:

    null.replace(...)

Sẽ gây:
    NullPointerException

Vì vậy nên kiểm tra:

    String id = myElement1.getAttribute("id");
    if (id != null) {
        id = id.replace("fieldName", "value");
    }

------------------------------------------------------------
3) replace() thay thế tất cả

Ví dụ:

    "fieldName_fieldName".replace("fieldName", "value")

Kết quả:
    "value_value"

============================================================
V. TẠI SAO LÀM NHƯ VẬY TRONG SELENIUM?

Trường hợp phổ biến:

Trang web có ID động (dynamic ID).

Ví dụ:

    user_fieldName_001
    user_fieldName_002
    user_fieldName_003

Ta muốn tạo ID khác dựa trên ID hiện tại.

Ví dụ:
- Lấy ID hiện tại
- Thay "fieldName" bằng "value"
- Dùng ID mới để tìm phần tử khác

Ví dụ:

    String newId = myElement1.getAttribute("id")
                             .replace("fieldName", "value");

    WebElement newElement = driver.findElement(By.id(newId));

============================================================
VI. PHÂN TÍCH VỀ STRING IMMUTABLE

String trong Java là immutable.

Nghĩa là:

    String s = "abc";
    s.replace("a", "x");

Sau lệnh này:
- s vẫn là "abc"

Phải gán lại:

    s = s.replace("a", "x");

============================================================
VII. TỔNG HỢP THEO TỪNG BƯỚC LOGIC

myElement1.getAttribute("id")
    ↓
Trả về String ID của phần tử

.replace("fieldName", "value")
    ↓
Tạo chuỗi mới bằng cách thay "fieldName" thành "value"

============================================================
VIII. TÓM TẮT NGẮN GỌN

myElement1.getAttribute("id").replace("fieldName", "value")

Hoạt động theo thứ tự:

1) Lấy thuộc tính id của phần tử HTML
2) Trả về một chuỗi
3) Thay thế tất cả "fieldName" bằng "value"
4) Trả về chuỗi mới

Nó không:
- Thay đổi DOM
- Thay đổi thuộc tính id trên trang
- Thay đổi String gốc

Chỉ tạo ra một chuỗi mới trong Java.

--- driver.findElement(By.linkText("Find")) CÓ tìm được button có name="find" hay không?

GIẢI THÍCH CHI TIẾT:

driver.findElement(By.linkText("Find")) 
CÓ tìm được button có name="find" hay không?

============================================================
I. CÂU TRẢ LỜI NGẮN GỌN

KHÔNG.

By.linkText("Find") CHỈ tìm được thẻ <a> (anchor tag),
KHÔNG tìm được <button> có name="find".

============================================================
II. PHÂN TÍCH TỪNG THÀNH PHẦN

------------------------------------------------------------
1) driver.findElement(...)

Tìm một phần tử duy nhất trên trang.
Nếu không tìm thấy → ném NoSuchElementException.

------------------------------------------------------------
2) By.linkText("Find")

Đây là cách định vị phần tử theo:

NỘI DUNG TEXT hiển thị của thẻ <a>.

Quan trọng:
By.linkText chỉ hoạt động với thẻ <a>.

============================================================
III. By.linkText HOẠT ĐỘNG NHƯ THẾ NÀO?

Selenium sẽ:

1) Duyệt toàn bộ DOM
2) Tìm các thẻ <a>
3) So sánh text hiển thị giữa cặp thẻ
4) Nếu text EXACTLY bằng "Find" → match

Ví dụ HTML hợp lệ:

    <a href="/search">Find</a>

Lệnh này sẽ tìm được phần tử trên.

============================================================
IV. TRƯỜNG HỢP BUTTON

Giả sử HTML là:

    <button name="find">Find</button>

Câu hỏi:
By.linkText("Find") có tìm được không?

Câu trả lời:
KHÔNG.

Vì:

- Đây là thẻ <button>
- Không phải thẻ <a>
- linkText chỉ áp dụng cho <a>

============================================================
V. TRƯỜNG HỢP INPUT TYPE=SUBMIT

Ví dụ:

    <input type="submit" name="find" value="Find">

By.linkText("Find") có tìm được không?

KHÔNG.

Vì:

- Không phải thẻ <a>
- linkText không dựa vào value
- Chỉ dựa vào text bên trong thẻ <a>

============================================================
VI. SỰ KHÁC NHAU GIỮA TEXT VÀ NAME

1) TEXT
Là nội dung hiển thị giữa thẻ:

    <a>Find</a>
       ^^^^

2) NAME
Là thuộc tính:

    <button name="find">

Hai thứ này hoàn toàn khác nhau.

============================================================
VII. MUỐN TÌM BUTTON name="find" THÌ PHẢI LÀM GÌ?

Cách đúng:

1) By.name("find")

    driver.findElement(By.name("find"));

Hoặc

2) XPath

    driver.findElement(By.xpath("//button[@name='find']"));

Hoặc

3) CSS Selector

    driver.findElement(By.cssSelector("button[name='find']"));

============================================================
VIII. SO SÁNH CÁC CÁCH ĐỊNH VỊ

By.linkText("Find")
→ Chỉ tìm <a> có text = "Find"

By.name("find")
→ Tìm bất kỳ thẻ nào có name="find"

By.id("find")
→ Tìm phần tử có id="find"

By.xpath(...)
→ Tìm linh hoạt theo cấu trúc DOM

============================================================
IX. TRƯỜNG HỢP ĐẶC BIỆT

Nếu HTML là:

    <a name="find">Find</a>

By.linkText("Find") sẽ tìm được,
NHƯNG vì text = "Find",
KHÔNG phải vì name="find".

============================================================
X. TÓM TẮT NGẮN GỌN

driver.findElement(By.linkText("Find"))

- Chỉ tìm thẻ <a>
- Dựa vào TEXT hiển thị
- Không dựa vào thuộc tính name
- Không tìm được <button name="find">

Muốn tìm button name="find" phải dùng:

    By.name("find")
    hoặc XPath / CSS selector

============================================================
XI. KẾT LUẬN CUỐI CÙNG

By.linkText("Find") 
KHÔNG tìm được button có name="find".

Nó chỉ tìm anchor tag (<a>) có text hiển thị là "Find".

--- DOWNLOAD VÀ EXPORT KHÁC NHAU NHƯ THẾ NÀO?

GIẢI THÍCH CHI TIẾT:

TRONG MỘT TRANG WEB, DOWNLOAD VÀ EXPORT KHÁC NHAU NHƯ THẾ NÀO?

============================================================
I. TỔNG QUAN

Download và Export đều liên quan đến việc người dùng nhận file từ hệ thống.

Tuy nhiên bản chất và mục đích của chúng KHÁC nhau.

------------------------------------------------------------
TÓM TẮT NHANH:

Download = Tải một file đã tồn tại sẵn.

Export = Hệ thống tạo file mới từ dữ liệu hiện tại rồi cho tải về.

============================================================
II. DOWNLOAD LÀ GÌ?

Download nghĩa là:

Người dùng tải xuống một file đã tồn tại sẵn trên server.

File này:
- Đã được tạo trước đó
- Được lưu sẵn trong hệ thống

------------------------------------------------------------
Ví dụ:

1) Tải file PDF hướng dẫn sử dụng
2) Tải ảnh
3) Tải file cài đặt
4) Tải file mẫu (template)

------------------------------------------------------------
Ví dụ thực tế:

Server có sẵn file:

    /files/user_guide.pdf

Khi người dùng click "Download":

- Server chỉ gửi file đó về
- Không tạo file mới

------------------------------------------------------------
Đặc điểm của Download:

1) File đã tồn tại trước đó
2) Không phụ thuộc vào dữ liệu người dùng hiện tại
3) Thường là file cố định

============================================================
III. EXPORT LÀ GÌ?

Export nghĩa là:

Hệ thống tạo một file mới từ dữ liệu hiện tại rồi cho người dùng tải về.

------------------------------------------------------------
Ví dụ:

1) Export danh sách khách hàng ra Excel
2) Export báo cáo doanh thu ra PDF
3) Export log ra CSV

------------------------------------------------------------
Quy trình Export:

1) Người dùng bấm nút "Export"
2) Hệ thống truy vấn dữ liệu từ database
3) Hệ thống tạo file (Excel / PDF / CSV...)
4) Trả file đó về cho người dùng

File này:
- Không tồn tại trước đó
- Được tạo theo thời điểm bấm nút

============================================================
IV. SO SÁNH CHI TIẾT

1) Về bản chất

Download:
- Lấy file có sẵn

Export:
- Tạo file mới từ dữ liệu

------------------------------------------------------------
2) Về dữ liệu

Download:
- Nội dung cố định
- Không thay đổi theo user

Export:
- Nội dung thay đổi theo:
  + Bộ lọc
  + Thời gian
  + Tài khoản người dùng

------------------------------------------------------------
3) Về xử lý server

Download:
- Gửi file có sẵn
- Xử lý nhẹ

Export:
- Truy vấn database
- Xử lý dữ liệu
- Tạo file
- Có thể tốn tài nguyên

------------------------------------------------------------
4) Về thời gian xử lý

Download:
- Gần như ngay lập tức

Export:
- Có thể mất vài giây hoặc vài phút
- Thường có loading

============================================================
V. VÍ DỤ CỤ THỂ TRONG ỨNG DỤNG

------------------------------------------------------------
TRƯỜNG HỢP 1: Download

Trang web có:

    <button>Download User Manual</button>

Hành động:
- Tải file user_manual.pdf có sẵn

------------------------------------------------------------
TRƯỜNG HỢP 2: Export

Trang web có:

    <button>Export to Excel</button>

Hành động:
- Lấy danh sách hiện tại trên màn hình
- Tạo file Excel chứa dữ liệu đó
- Trả về file mới tạo

============================================================
VI. TRONG THỰC TẾ, NHIỀU HỆ THỐNG DÙNG LẪN LỘN

Nhiều website gọi:

"Download Report"

Nhưng thực tế là:

- Hệ thống đang EXPORT report rồi cho tải xuống

Do đó:
Tên gọi có thể gây nhầm lẫn.

============================================================
VII. VỀ MẶT KỸ THUẬT

------------------------------------------------------------
Download thường:

- Server trả file tĩnh
- Content-Type: application/pdf, image/png, etc.
- File đã có sẵn trên disk

------------------------------------------------------------
Export thường:

- Server generate file trong RAM
- Có thể dùng:
  + Apache POI (Excel)
  + iText (PDF)
  + CSV writer
- Trả file trực tiếp qua HTTP response

============================================================
VIII. VÍ DỤ LUỒNG XỬ LÝ

------------------------------------------------------------
DOWNLOAD

Client click
→ HTTP request
→ Server đọc file có sẵn
→ Gửi file về
→ Client lưu file

------------------------------------------------------------
EXPORT

Client click
→ HTTP request
→ Server query database
→ Xử lý dữ liệu
→ Tạo file mới
→ Gửi file về
→ Client lưu file

============================================================
IX. TÓM TẮT SO SÁNH NGẮN GỌN

Download:
- Tải file có sẵn
- Không tạo mới
- Nhanh
- Nội dung cố định

Export:
- Tạo file từ dữ liệu hiện tại
- Nội dung thay đổi theo người dùng
- Tốn tài nguyên hơn
- Có bước xử lý dữ liệu

============================================================
X. KẾT LUẬN CUỐI CÙNG

Download và Export đều dẫn đến việc người dùng nhận file.

Nhưng:

Download = Lấy file có sẵn.

Export = Tạo file mới từ dữ liệu rồi cho tải về.

Sự khác biệt nằm ở bản chất xử lý phía server.

--- File a = new File(aPath); a.lastModified();

GIẢI THÍCH CHI TIẾT:

File a = new File(aPath);
a.lastModified();

============================================================
I. TỔNG QUAN

Hai dòng lệnh này dùng để:

1) Tạo một đối tượng File đại diện cho một đường dẫn
2) Lấy thời điểm chỉnh sửa cuối cùng của file đó

============================================================
II. PHÂN TÍCH DÒNG 1

    File a = new File(aPath);

------------------------------------------------------------
1) File là gì?

File thuộc package:

    java.io.File

Nó đại diện cho:
- Một file
- Hoặc một thư mục
- Trên hệ thống file (file system)

------------------------------------------------------------
2) new File(aPath) có tạo file thật không?

KHÔNG.

Nó chỉ tạo một object trong RAM đại diện cho đường dẫn aPath.

Ví dụ:

    String aPath = "C:\\data\\report.txt";
    File a = new File(aPath);

Sau dòng này:
- Không có file nào được tạo
- Không mở file
- Không đọc file
- Không kiểm tra file tồn tại

Chỉ tạo object đại diện đường dẫn.

------------------------------------------------------------
3) aPath là gì?

aPath là chuỗi String chứa đường dẫn file.

Ví dụ:

    "report.txt"
    "C:\\data\\report.txt"
    "/home/user/file.txt"

============================================================
III. PHÂN TÍCH DÒNG 2

    a.lastModified();

------------------------------------------------------------
1) lastModified() là gì?

Là phương thức của class File.

Cú pháp:

    long lastModified()

------------------------------------------------------------
2) Nó trả về gì?

Trả về kiểu:

    long

Giá trị là:

Số mili-giây (milliseconds) kể từ
01/01/1970 00:00:00 GMT (Unix Epoch)

Đến thời điểm file được chỉnh sửa lần cuối.

------------------------------------------------------------
3) Ví dụ:

Giả sử:

    long time = a.lastModified();

Giá trị có thể là:

    1708045302000

Đây là timestamp.

============================================================
IV. Ý NGHĨA CỦA GIÁ TRỊ TRẢ VỀ

Giá trị long này không phải là ngày giờ dạng dễ đọc.

Nó là:

Epoch time (milliseconds).

Muốn chuyển sang dạng ngày giờ:

    Date date = new Date(a.lastModified());
    System.out.println(date);

Hoặc dùng:

    Instant.ofEpochMilli(a.lastModified());

============================================================
V. TRƯỜNG HỢP FILE KHÔNG TỒN TẠI

Nếu file KHÔNG tồn tại:

    a.lastModified()

sẽ trả về:

    0

Vì vậy nên kiểm tra trước:

    if (a.exists()) {
        long time = a.lastModified();
    }

============================================================
VI. VÍ DỤ THỰC TẾ

    File a = new File("test.txt");

    if (a.exists()) {
        long lastTime = a.lastModified();
        System.out.println("Last modified: " + lastTime);
    } else {
        System.out.println("File does not exist");
    }

============================================================
VII. lastModified() HOẠT ĐỘNG NHƯ THẾ NÀO?

Bên trong:

1) JVM gọi hệ điều hành
2) Hệ điều hành đọc metadata của file
3) Lấy thuộc tính "last modified time"
4) Trả về dưới dạng milliseconds

Metadata bao gồm:
- Kích thước file
- Thời điểm tạo
- Thời điểm sửa cuối
- Quyền truy cập

============================================================
VIII. KHÁC BIỆT GIỮA CÁC LOẠI THỜI GIAN

Trong hệ thống file thường có:

1) Creation time (thời điểm tạo)
2) Last modified time (sửa cuối)
3) Last access time (truy cập cuối)

File.lastModified() chỉ trả về:

    Last modified time

============================================================
IX. LƯU Ý QUAN TRỌNG

1) Giá trị phụ thuộc hệ điều hành.
2) Một số hệ thống file không lưu chính xác mili-giây.
3) Nếu file đang mở hoặc đang ghi,
   thời gian có thể thay đổi ngay sau đó.
4) Nếu file không tồn tại → trả 0.

============================================================
X. SO SÁNH VỚI NIO (CÁCH HIỆN ĐẠI)

Cách hiện đại hơn:

    Files.getLastModifiedTime(path);

Ưu điểm:
- Dùng NIO
- Linh hoạt hơn
- Hỗ trợ nhiều loại file attribute

============================================================
XI. TÓM TẮT NGẮN GỌN

File a = new File(aPath);

- Tạo object đại diện cho đường dẫn
- Không tạo file thật

a.lastModified();

- Trả về thời điểm sửa cuối của file
- Kiểu long
- Đơn vị mili-giây từ 01/01/1970
- Nếu file không tồn tại → trả 0

Đây là cách lấy timestamp chỉnh sửa cuối cùng của file trong Java.

--- driver.findElemnts(By.id("changePassword)).size()

GIẢI THÍCH CHI TIẾT:

driver.findElements(By.id("changePassword")).size()

(Lưu ý: phải là findElements và phải đóng ngoặc kép đúng:
By.id("changePassword"))

============================================================
I. TỔNG QUAN

Câu lệnh này dùng trong Selenium WebDriver để:

1) Tìm tất cả các phần tử có id = "changePassword"
2) Trả về danh sách (List<WebElement>)
3) Lấy số lượng phần tử tìm được bằng .size()

Nó thường dùng để:
- Kiểm tra phần tử có tồn tại hay không
- Kiểm tra số lượng phần tử

============================================================
II. PHÂN TÍCH TỪNG THÀNH PHẦN

------------------------------------------------------------
1) driver

driver là đối tượng WebDriver.

Ví dụ:

    WebDriver driver = new ChromeDriver();

Nó đại diện cho trình duyệt đang được điều khiển.

------------------------------------------------------------
2) findElements(...)

Cú pháp:

    List<WebElement> list = driver.findElements(locator);

Khác với findElement():

- findElement()
  → Trả về 1 WebElement
  → Nếu không tìm thấy → ném NoSuchElementException

- findElements()
  → Trả về List<WebElement>
  → Nếu không tìm thấy → trả về List rỗng
  → KHÔNG ném exception

Đây là điểm cực kỳ quan trọng.

------------------------------------------------------------
3) By.id("changePassword")

By.id là một cách định vị phần tử theo thuộc tính id.

Nó sẽ tìm phần tử có:

    id="changePassword"

Ví dụ HTML:

    <button id="changePassword">Change</button>

------------------------------------------------------------
4) .size()

size() là method của List.

Cú pháp:

    int size()

Nó trả về số lượng phần tử trong danh sách.

============================================================
III. TOÀN BỘ CÂU LỆNH HOẠT ĐỘNG NHƯ SAU

driver.findElements(By.id("changePassword"))

Bước 1:
- Selenium tìm tất cả phần tử có id="changePassword"

Bước 2:
- Trả về List<WebElement>

Bước 3:
- Gọi .size()
- Trả về số phần tử trong danh sách

============================================================
IV. TRƯỜNG HỢP CỤ THỂ

------------------------------------------------------------
Trường hợp 1: Có 1 phần tử

HTML:

    <button id="changePassword">Change</button>

Kết quả:

    size() = 1

------------------------------------------------------------
Trường hợp 2: Không có phần tử

HTML không chứa id="changePassword"

Kết quả:

    size() = 0

KHÔNG có exception.

------------------------------------------------------------
Trường hợp 3: (Không chuẩn HTML)

Nếu có nhiều phần tử trùng id:

    size() có thể > 1

Mặc dù HTML chuẩn không cho phép trùng id.

============================================================
V. ỨNG DỤNG THỰC TẾ

------------------------------------------------------------
1) Kiểm tra phần tử có tồn tại không

    if (driver.findElements(By.id("changePassword")).size() > 0) {
        System.out.println("Element exists");
    }

------------------------------------------------------------
2) Viết gọn hơn

    boolean exists =
        !driver.findElements(By.id("changePassword")).isEmpty();

============================================================
VI. TẠI SAO NÊN DÙNG findElements + size()?

Vì:

findElement() nếu không tìm thấy sẽ gây lỗi:

    NoSuchElementException

Nhưng findElements():

- An toàn hơn
- Không gây crash test
- Phù hợp để kiểm tra sự tồn tại

============================================================
VII. SO SÁNH HAI CÁCH

Cách 1 (có thể lỗi):

    driver.findElement(By.id("changePassword"));

Nếu không tồn tại → test fail ngay.

------------------------------------------------------------
Cách 2 (an toàn):

    driver.findElements(By.id("changePassword")).size();

Nếu không tồn tại → trả 0

============================================================
VIII. LƯU Ý QUAN TRỌNG

1) findElements luôn trả về List, không bao giờ null.
2) size() luôn trả int >= 0.
3) Không cần try-catch khi chỉ kiểm tra tồn tại.

============================================================
IX. TÓM TẮT NGẮN GỌN

driver.findElements(By.id("changePassword")).size()

Hoạt động theo thứ tự:

1) Tìm tất cả phần tử có id="changePassword"
2) Trả về danh sách WebElement
3) Lấy số lượng phần tử trong danh sách

Nếu không tìm thấy:
→ size() = 0
→ Không ném exception

Đây là cách an toàn và phổ biến để kiểm tra phần tử có tồn tại trên trang hay không trong Selenium.

--- LÀM CÁCH NÀO DEBUG ICON LOADING KHI NÓ BIẾN MẤT QUÁ NHANH?

GIẢI THÍCH CHI TIẾT:

LÀM CÁCH NÀO DEBUG ICON LOADING KHI NÓ BIẾN MẤT QUÁ NHANH?

============================================================
I. VẤN ĐỀ

Bạn có một icon loading (spinner).

Khi bấm Search:
- Icon xuất hiện
- Sau đó biến mất rất nhanh
- Bạn không kịp Inspect để xem id / class / attribute

Mục tiêu:
- Làm cho nó “đứng yên”
- Hoặc bắt được nó trong DevTools
- Hoặc xác định id của nó

============================================================
II. CÁC CÁCH DEBUG HIỆU QUẢ NHẤT

============================================================
CÁCH 1: DÙNG CHROME DEVTOOLS – PAUSE SCRIPT

Đây là cách hiệu quả nhất.

Bước 1:
Mở DevTools (F12)

Bước 2:
Vào tab:
    Sources

Bước 3:
Bấm nút:
    Pause script execution (biểu tượng ||)

Hoặc nhấn:
    F8

Bước 4:
Sau đó bấm nút Search

Khi loading xuất hiện:
- Script sẽ bị pause
- Trang bị "đóng băng"
- Loading đứng yên
- Bạn có thể Inspect nó

============================================================
CÁCH 2: DÙNG SLOW NETWORK (LÀM CHẬM REQUEST)

Nếu loading phụ thuộc vào API call.

Bước 1:
F12 → tab Network

Bước 2:
Chọn:
    Throttling → Slow 3G
    hoặc Custom → tốc độ rất chậm

Bước 3:
Bấm Search

Vì mạng chậm:
- Request mất lâu hơn
- Loading hiển thị lâu hơn
- Bạn có thời gian Inspect

============================================================
CÁCH 3: DÙNG BREAKPOINT THEO DOM

Bước 1:
F12 → tab Elements

Bước 2:
Chọn phần tử cha (ví dụ div chứa search result)

Bước 3:
Right click → Break on → Subtree modifications

Bước 4:
Bấm Search

Khi DOM thay đổi (loading được thêm vào):
- Trình duyệt tự động pause
- Bạn inspect được loading

============================================================
CÁCH 4: DÙNG CONSOLE ĐỂ GIỮ LẠI LOADING

Khi loading vừa xuất hiện,
nhanh tay chạy trong Console:

    debugger;

Hoặc trước khi search, bạn chèn breakpoint thủ công:

Trong Sources → tìm file JS xử lý search → đặt breakpoint tại đoạn:

    showLoading();

Khi chạy tới đó:
- Script dừng
- Loading không biến mất

============================================================
CÁCH 5: DISABLE JAVASCRIPT TẠM THỜI

Cách nâng cao:

Bước 1:
Mở DevTools
Bước 2:
Command Menu (Ctrl + Shift + P)
Bước 3:
Gõ:
    Disable JavaScript

Sau đó:
- Loading có thể không bị remove
- Hoặc DOM không cập nhật tiếp

============================================================
CÁCH 6: DÙNG NETWORK TAB ĐỂ XÁC ĐỊNH ELEMENT

Bước 1:
F12 → Network

Bước 2:
Bấm Search

Bước 3:
Chọn request tương ứng

Bước 4:
Right click → Replay XHR

Khi replay:
- Loading sẽ xuất hiện lại
- Bạn có thể Inspect

============================================================
III. SAU KHI BẮT ĐƯỢC LOADING

Khi Inspect được nó, bạn xem:

1) id
2) class
3) data-* attribute
4) aria-* attribute
5) style (display, visibility)
6) nó có bị remove khỏi DOM hay chỉ hidden

Ví dụ có thể là:

    <div id="loadingSpinner"></div>

Hoặc:

    <div class="spinner active"></div>

Hoặc:

    <div data-testid="loading-icon"></div>

============================================================
IV. KIỂM TRA BẰNG CONSOLE

Khi loading đang hiển thị, bạn có thể thử:

Tìm theo class:

    document.querySelectorAll(".spinner")

Tìm theo id:

    document.querySelectorAll("#loading")

Tìm tất cả element có chữ "load":

    document.querySelectorAll("[id*='load']")

============================================================
V. NẾU LOADING BỊ REMOVE KHỎI DOM

Có 2 kiểu loading phổ biến:

1) display: none;
   (vẫn còn trong DOM)

2) Bị remove hoàn toàn khỏi DOM

Nếu bị remove:
- Phải dùng breakpoint DOM modification
- Hoặc slow network

============================================================
VI. SAU KHI BIẾT ID → DÙNG TRONG SELENIUM

Ví dụ tìm được:

    id="loadingSpinner"

Bạn có thể chờ loading biến mất:

    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    wait.until(ExpectedConditions.invisibilityOfElementLocated(By.id("loadingSpinner")));

Hoặc:

    wait.until(ExpectedConditions.presenceOfElementLocated(By.id("loadingSpinner")));

============================================================
VII. TÓM TẮT CÁCH NHANH NHẤT

Nếu muốn làm nhanh và chắc chắn thành công:

1) F12
2) Tab Network
3) Chọn Slow 3G
4) Bấm Search
5) Inspect loading

Hoặc:

1) F12
2) Tab Sources
3) Nhấn F8 (Pause)
4) Bấm Search
5) Inspect

============================================================
VIII. KẾT LUẬN

Vấn đề loading biến mất quá nhanh có thể xử lý bằng:

- Pause script (F8)
- Throttling network
- Breakpoint DOM modification
- Breakpoint trong file JS
- Replay XHR

Cách hiệu quả và dễ nhất:
DÙNG Slow Network hoặc Pause Script trong DevTools.

Sau khi bắt được loading, bạn có thể xác định id/class để dùng trong Selenium.

--- CÁCH LẤY ĐƯỢC <app-query-root> TRONG JAVASCRIPT

GIẢI THÍCH CHI TIẾT:

CÁCH LẤY ĐƯỢC <app-query-root> TRONG JAVASCRIPT

============================================================
I. <app-query-root> LÀ GÌ?

<app-query-root> là một custom HTML tag.

Thông thường nó xuất hiện trong:
- Angular
- Web Components
- Single Page Application (SPA)

Ví dụ trong DOM:

    <app-query-root>
        ...
    </app-query-root>

Đây KHÔNG phải là thẻ HTML chuẩn như div, span, p...
Nó là custom element.

============================================================
II. CÁCH LẤY <app-query-root> BẰNG JAVASCRIPT

============================================================
CÁCH 1: DÙNG document.querySelector()

Đây là cách đơn giản nhất.

    var element = document.querySelector("app-query-root");

Giải thích:
- querySelector nhận CSS selector
- Vì đây là tag name → chỉ cần truyền tên thẻ

Nếu có nhiều thẻ:

    var elements = document.querySelectorAll("app-query-root");

============================================================
CÁCH 2: DÙNG getElementsByTagName()

    var elements = document.getElementsByTagName("app-query-root");

Giải thích:
- Trả về HTMLCollection
- Muốn lấy phần tử đầu tiên:

    var element = document.getElementsByTagName("app-query-root")[0];

============================================================
III. TRƯỜNG HỢP KHÔNG LẤY ĐƯỢC

============================================================
1) DOM CHƯA LOAD XONG

Nếu bạn chạy JS quá sớm:

    document.querySelector("app-query-root");

Có thể trả về null.

Giải pháp:

    document.addEventListener("DOMContentLoaded", function() {
        var element = document.querySelector("app-query-root");
        console.log(element);
    });

Hoặc:

    window.onload = function() {
        var element = document.querySelector("app-query-root");
    };

============================================================
2) ELEMENT NẰM TRONG SHADOW DOM

Nếu <app-query-root> là Web Component dùng Shadow DOM:

Ví dụ:

    <app-query-root>
        #shadow-root
            ...
    </app-query-root>

Bạn không thể query trực tiếp bên trong shadow.

Phải làm:

    var root = document.querySelector("app-query-root");
    var shadow = root.shadowRoot;

    var innerElement = shadow.querySelector("div");

Lưu ý:
- shadowRoot chỉ tồn tại nếu component dùng open shadow
- Nếu là closed shadow → không truy cập được

============================================================
3) ELEMENT ĐƯỢC RENDER SAU (SPA / Angular)

Trong Angular:
- app-query-root có thể được render sau khi app bootstrap
- Nếu query quá sớm → null

Giải pháp:
Dùng setTimeout để test nhanh:

    setTimeout(function() {
        var element = document.querySelector("app-query-root");
        console.log(element);
    }, 2000);

Hoặc dùng MutationObserver:

    var observer = new MutationObserver(function(mutations) {
        var element = document.querySelector("app-query-root");
        if (element) {
            console.log("Found:", element);
            observer.disconnect();
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true
    });

============================================================
IV. KIỂM TRA TRONG CONSOLE

Trong Chrome DevTools (F12):

Chạy:

    document.querySelector("app-query-root")

Nếu trả về:
- null → chưa có trong DOM
- object → đã tồn tại

============================================================
V. LẤY ATTRIBUTE CỦA <app-query-root>

Ví dụ:

    <app-query-root id="mainApp" class="root-class">

Lấy id:

    var element = document.querySelector("app-query-root");
    console.log(element.id);

Lấy class:

    console.log(element.clas

--- if (Files.notExists(fileMove.getParent())) Files.createDirectory(fileMove.getParent());

GIẢI THÍCH CHI TIẾT:

PHÂN TÍCH ĐOẠN CODE:

if (Files.notExists(fileMove.getParent()))
    Files.createDirectory(fileMove.getParent());

============================================================
I. BỐI CẢNH

Đây là code Java sử dụng:

    java.nio.file.Files
    java.nio.file.Path

Thường dùng khi:
- Move file
- Copy file
- Tạo file mới
- Ghi file ra thư mục chưa tồn tại

Mục đích chính của đoạn code:
KIỂM TRA THƯ MỤC CHA CÓ TỒN TẠI KHÔNG
NẾU CHƯA → TẠO THƯ MỤC

============================================================
II. PHÂN TÍCH TỪNG THÀNH PHẦN

------------------------------------------------------------
1) fileMove

fileMove thường là một đối tượng Path.

Ví dụ:

    Path fileMove = Paths.get("D:/backup/report/test.txt");

------------------------------------------------------------
2) fileMove.getParent()

Hàm này trả về thư mục cha của file.

Ví dụ:

    fileMove = D:/backup/report/test.txt

Thì:

    fileMove.getParent()

Sẽ trả về:

    D:/backup/report

Quan trọng:
getParent() KHÔNG trả về file
Mà trả về thư mục chứa file

------------------------------------------------------------
3) Files.notExists(path)

Hàm này kiểm tra:

Đường dẫn có KHÔNG tồn tại hay không?

Nếu:
- Chưa có thư mục
→ trả về true

Nếu:
- Đã tồn tại
→ trả về false

Lưu ý:
Tên đúng là:
    Files.notExists()
KHÔNG phải:
    notExist()

------------------------------------------------------------
4) Files.createDirectory(path)

Hàm này tạo MỘT thư mục.

Ví dụ:

    Files.createDirectory(Paths.get("D:/backup/report"));

Nó sẽ tạo thư mục report
Nhưng:

Nếu thư mục cha chưa tồn tại → sẽ lỗi

============================================================
III. Ý NGHĨA TOÀN BỘ ĐOẠN CODE

if (Files.notExists(fileMove.getParent()))
    Files.createDirectory(fileMove.getParent());

Diễn giải:

1) Lấy thư mục cha của file
2) Kiểm tra thư mục đó có tồn tại không
3) Nếu chưa tồn tại → tạo nó

Mục đích:
Đảm bảo thư mục tồn tại trước khi ghi/move file

============================================================
IV. TẠI SAO CẦN ĐOẠN CODE NÀY?

Ví dụ bạn muốn move file đến:

    D:/backup/report/test.txt

Nhưng:
- Thư mục backup chưa tồn tại
- Hoặc report chưa tồn tại

Nếu bạn move trực tiếp:

    Files.move(source, fileMove);

Sẽ bị lỗi:

    NoSuchFileException

Vì thư mục đích không tồn tại.

Do đó phải tạo thư mục trước.

============================================================
V. VẤN ĐỀ QUAN TRỌNG: createDirectory vs createDirectories

------------------------------------------------------------
Files.createDirectory()

Chỉ tạo 1 thư mục duy nhất.

Nếu cha của nó chưa tồn tại → lỗi.

Ví dụ:

    D:/backup/report

Nếu backup chưa tồn tại
→ createDirectory(report) sẽ lỗi.

------------------------------------------------------------
Files.createDirectories()

Khuyến nghị dùng:

    Files.createDirectories(fileMove.getParent());

Hàm này:
- Tạo toàn bộ thư mục cha nếu chưa tồn tại
- Không lỗi nếu thư mục đã tồn tại

An toàn hơn nhiều.

============================================================
VI. PHIÊN BẢN CHUẨN NÊN DÙNG

Thay vì:

if (Files.notExists(fileMove.getParent()))
    Files.createDirectory(fileMove.getParent());

Nên dùng:

Files.createDirectories(fileMove.getParent());

Vì:
- Không cần kiểm tra trước
- Không lỗi nếu thư mục đã tồn tại
- Tạo được nhiều cấp thư mục

============================================================
VII. TÓM TẮT LUỒNG HOẠT ĐỘNG

1) fileMove là đường dẫn file đích
2) getParent() lấy thư mục chứa file
3) notExists() kiểm tra thư mục có tồn tại không
4) Nếu chưa → createDirectory() tạo thư mục

============================================================
VIII. KẾT LUẬN

Đoạn code này dùng để:

ĐẢM BẢO THƯ MỤC CHA CỦA FILE TỒN TẠI TRƯỚC KHI THAO TÁC FILE.

Mục đích chính:
Tránh lỗi khi move/copy/ghi file vào thư mục chưa tồn tại.

Khuyến nghị thực tế:
Nên dùng Files.createDirectories() thay vì createDirectory().

--- SANDBOX LÀ GÌ?

GIẢI THÍCH CHI TIẾT: SANDBOX LÀ GÌ?

============================================================
I. SANDBOX LÀ GÌ?

Sandbox (nghĩa đen: "hộp cát") trong CNTT là:

MỘT MÔI TRƯỜNG CÔ LẬP, AN TOÀN
được dùng để:
- Chạy chương trình
- Thử nghiệm code
- Test phần mềm
- Phân tích file đáng ngờ

Mà KHÔNG làm ảnh hưởng đến hệ thống chính.

Hiểu đơn giản:

Sandbox = Khu vực cách ly để thử nghiệm.

============================================================
II. TẠI SAO CẦN SANDBOX?

Vì khi chạy:
- Code mới viết
- Phần mềm chưa rõ nguồn gốc
- File tải từ internet
- Virus / malware

Nếu chạy trực tiếp trên máy thật
→ có thể:
- Làm hỏng hệ điều hành
- Đánh cắp dữ liệu
- Gây lỗi hệ thống
- Lây nhiễm virus

Sandbox giúp:
CHẠY THỬ NHƯNG KHÔNG GÂY HẠI

============================================================
III. CƠ CHẾ HOẠT ĐỘNG CỦA SANDBOX

Sandbox thường:

1) Cô lập hệ thống file
2) Cô lập bộ nhớ
3) Cô lập network
4) Giới hạn quyền truy cập

Chương trình bên trong sandbox:
- Không thể truy cập file hệ thống
- Không thể truy cập registry (Windows)
- Không thể ảnh hưởng đến OS chính
- Không thể truy cập internet (nếu bị chặn)

============================================================
IV. CÁC LOẠI SANDBOX PHỔ BIẾN

------------------------------------------------------------
1) SANDBOX TRONG TRÌNH DUYỆT

Ví dụ:
- Chrome
- Edge

Mỗi tab chạy trong sandbox riêng.

Nếu 1 trang web có mã độc:
→ Nó không thể truy cập toàn bộ máy tính.

------------------------------------------------------------
2) SANDBOX TRONG JAVA

Java có cơ chế:

SecurityManager (cũ)
ClassLoader isolation

Applet trước đây chạy trong sandbox:
- Không được truy cập file hệ thống
- Không được ghi đĩa
- Không được mở socket

------------------------------------------------------------
3) SANDBOX DÙNG MÁY ẢO (Virtual Machine)

Ví dụ:
- VirtualBox
- VMware

Bạn tạo 1 máy ảo:
- Cài Windows/Linux riêng
- Chạy phần mềm trong đó
- Nếu bị virus → xóa máy ảo là xong

------------------------------------------------------------
4) SANDBOX DÙNG CONTAINER

Ví dụ:
- Docker

Container cô lập:
- File system
- Process
- Network

Dùng nhiều trong DevOps.

------------------------------------------------------------
5) SANDBOX PHÂN TÍCH MALWARE

Các công ty bảo mật dùng sandbox để:
- Chạy file nghi ngờ
- Quan sát hành vi
- Phân tích virus

============================================================
V. SANDBOX TRONG LẬP TRÌNH

Khi nói:

"Code chạy trong sandbox"

Nghĩa là:

- Code bị giới hạn quyền
- Không thể truy cập hệ thống thật
- Có môi trường riêng

Ví dụ:

Một nền tảng online cho phép bạn chạy code
→ Code của bạn chạy trong sandbox server
→ Không thể phá server.

============================================================
VI. SO SÁNH SANDBOX VÀ MÔI TRƯỜNG THẬT

Môi trường thật:
- Toàn quyền hệ thống
- Có thể làm hỏng OS

Sandbox:
- Bị giới hạn
- An toàn
- Có thể reset

============================================================
VII. ƯU ĐIỂM CỦA SANDBOX

- An toàn
- Ngăn virus
- Bảo vệ dữ liệu
- Test code không sợ hỏng máy
- Phân tích bảo mật

============================================================
VIII. NHƯỢC ĐIỂM

- Có thể chậm hơn
- Tốn tài nguyên
- Không phản ánh 100% môi trường thật
- Malware nâng cao có thể phát hiện đang chạy trong sandbox

============================================================
IX. VÍ DỤ DỄ HIỂU

Hãy tưởng tượng:

Bạn có một phòng thí nghiệm chống nổ.

Bạn đặt một vật thể nghi là bom vào trong phòng kín.

Nếu nó nổ:
→ Không ảnh hưởng bên ngoài.

Sandbox cũng vậy:
Chạy code nguy hiểm trong phòng kín.

============================================================
X. KHI NÀO NÊN DÙNG SANDBOX?

- Test phần mềm chưa ổn định
- Chạy file tải từ nguồn lạ
- Phân tích malware
- Học bảo mật
- Chạy script tự động
- Dev/test môi trường production

============================================================
XI. TÓM TẮT NGẮN GỌN

Sandbox là:

MỘT MÔI TRƯỜNG CÔ LẬP VÀ AN TOÀN
để chạy thử chương trình
mà không làm ảnh hưởng đến hệ thống chính.

============================================================
KẾT LUẬN

Nếu bạn thấy một hệ thống nói:

"Code của bạn chạy trong sandbox"

Điều đó có nghĩa:
- Bạn không có toàn quyền hệ thống
- Môi trường đã bị giới hạn
- Mọi thứ được kiểm soát để đảm bảo an toàn

--- UAT LÀ GÌ?

GIẢI THÍCH CHI TIẾT: UAT LÀ GÌ?

============================================================
I. UAT LÀ GÌ?

UAT là viết tắt của:

User Acceptance Testing

Dịch ra tiếng Việt là:

Kiểm thử chấp nhận người dùng

Đây là giai đoạn kiểm thử cuối cùng trước khi:
- Go-live
- Release production
- Bàn giao cho khách hàng

Mục tiêu của UAT:
XÁC NHẬN HỆ THỐNG CÓ ĐÁP ỨNG ĐÚNG YÊU CẦU NGHIỆP VỤ HAY KHÔNG.

============================================================
II. UAT KIỂM TRA CÁI GÌ?

Không giống test kỹ thuật.

UAT tập trung vào:

- Quy trình nghiệp vụ
- Logic business
- Trải nghiệm người dùng
- Đúng yêu cầu ban đầu

Ví dụ:

Yêu cầu:
"Khi khách hàng thanh toán thành công thì đơn hàng phải chuyển sang trạng thái PAID"

UAT sẽ kiểm tra:
- Thanh toán có thành công không?
- Trạng thái có đổi đúng không?
- Email có gửi không?
- Dữ liệu có lưu đúng không?

============================================================
III. AI THỰC HIỆN UAT?

Khác với các loại test khác:

Unit test → Developer
Integration test → Dev / QA
System test → QA

UAT thường do:
- Khách hàng
- Business Analyst
- End-user
- Product Owner

Thực hiện.

Vì họ hiểu nghiệp vụ nhất.

============================================================
IV. UAT DIỄN RA Ở ĐÂU?

Thường diễn ra trên môi trường riêng gọi là:

UAT Environment

Các môi trường phổ biến:

DEV  → Developer test
SIT  → System Integration Test
UAT  → User Acceptance Test
PROD → Production

============================================================
V. UAT KHÁC GÌ VỚI TEST THÔNG THƯỜNG?

1) Unit Test
- Test từng hàm
- Do developer viết
- Mang tính kỹ thuật

2) Integration Test
- Test các module kết nối với nhau

3) System Test
- Test toàn hệ thống

4) UAT
- Test theo góc nhìn người dùng
- Kiểm tra có đáp ứng đúng yêu cầu business không

UAT KHÔNG tập trung vào:
- Code
- Technical bug nhỏ
- Performance chi tiết

Mà tập trung vào:
"Có dùng được trong thực tế không?"

============================================================
VI. VÍ DỤ THỰC TẾ

Giả sử bạn làm hệ thống bán hàng.

Flow nghiệp vụ:

1) Tạo đơn hàng
2) Thanh toán
3) Giao hàng
4) Hoàn tiền

Trong UAT, người dùng sẽ:

- Tạo đơn hàng thật
- Thanh toán test
- Kiểm tra trạng thái
- Xem báo cáo doanh thu

Nếu đúng theo yêu cầu ban đầu
→ UAT pass

============================================================
VII. KẾT QUẢ CỦA UAT

Có 3 khả năng:

1) PASS
Hệ thống đạt yêu cầu
→ Chuẩn bị go-live

2) FAIL
Có lỗi nghiệp vụ
→ Dev sửa → Test lại

3) CONDITIONAL PASS
Có lỗi nhỏ nhưng chấp nhận được

============================================================
VIII. UAT VÀ SIGN-OFF

Khi UAT thành công:

Khách hàng sẽ ký:

UAT Sign-off

Điều này có nghĩa:

Họ chính thức chấp nhận hệ thống.

Sau đó:
- Release production
- Hoặc triển khai chính thức

============================================================
IX. TẠI SAO UAT QUAN TRỌNG?

Nếu bỏ qua UAT:

Có thể xảy ra:
- Hệ thống chạy đúng code nhưng sai nghiệp vụ
- User không dùng được
- Sai quy trình
- Sai tính toán tiền
- Ảnh hưởng kinh doanh

UAT giúp:
Đảm bảo hệ thống thật sự usable.

============================================================
X. UAT KHÔNG PHẢI LÀ GÌ?

UAT không phải:

- Load test
- Performance test
- Security test
- Unit test

Nó là:
Business validation test.

============================================================
XI. TÓM TẮT NGẮN GỌN

UAT (User Acceptance Testing) là:

GIAI ĐOẠN KIỂM THỬ DO NGƯỜI DÙNG/ KHÁCH HÀNG THỰC HIỆN
để xác nhận hệ thống đáp ứng đúng yêu cầu nghiệp vụ
trước khi đưa vào production.

============================================================
KẾT LUẬN

Nếu ai đó nói:

"Đợi UAT xong mới deploy"

Điều đó có nghĩa:

Hệ thống phải được người dùng xác nhận đạt yêu cầu
trước khi chính thức sử dụng.

--- ĐỌC FILE BẰNG BUFFEREDREADER CHO 1 FILE VÀ CÓ THỂ CHUYỂN THÀNH ĐỌC NHIỀU FILE TRONG 1 FOLDER KHÔNG?

GIẢI THÍCH CHI TIẾT:

ĐỌC FILE BẰNG BUFFEREDREADER CHO 1 FILE
VÀ CÓ THỂ CHUYỂN THÀNH ĐỌC NHIỀU FILE TRONG 1 FOLDER KHÔNG?

============================================================
I. ĐỌC 1 FILE BẰNG BUFFEREDREADER

Ví dụ bạn có:

D:/data/test.txt

Code đọc 1 file:

------------------------------------------------------------
FileReader fr = new FileReader("D:/data/test.txt");
BufferedReader br = new BufferedReader(fr);

String line;

while ((line = br.readLine()) != null) {
    System.out.println(line);
}

br.close();
------------------------------------------------------------

Giải thích:

FileReader:
- Mở file text

BufferedReader:
- Đọc file theo từng dòng
- Tăng tốc nhờ bộ đệm (buffer)

readLine():
- Đọc từng dòng cho đến khi null (hết file)

============================================================
II. VẤN ĐỀ: MUỐN ĐỌC NHIỀU FILE TRONG 1 FOLDER

Câu hỏi:
Có thể chuyển từ đọc 1 file → đọc nhiều file trong 1 folder không?

Câu trả lời:
CÓ.

Nhưng phải làm thêm bước:

1) Lấy danh sách file trong folder
2) Duyệt từng file
3) Mỗi file dùng BufferedReader đọc riêng

============================================================
III. CÁCH LẤY DANH SÁCH FILE TRONG 1 FOLDER

Cách 1: Dùng File.listFiles()

------------------------------------------------------------
File folder = new File("D:/data");
File[] listOfFiles = folder.listFiles();
------------------------------------------------------------

listFiles() sẽ trả về:
Mảng các file và folder bên trong thư mục đó.

============================================================
IV. ĐỌC NHIỀU FILE TRONG 1 FOLDER

Ví dụ hoàn chỉnh:

------------------------------------------------------------
File folder = new File("D:/data");
File[] files = folder.listFiles();

if (files != null) {
    for (File file : files) {

        if (file.isFile()) {   // chỉ đọc file, bỏ qua folder

            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);

            String line;

            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }

            br.close();
        }
    }
}
------------------------------------------------------------

============================================================
V. LUỒNG HOẠT ĐỘNG

1) Lấy folder
2) Lấy danh sách file
3) Duyệt từng file
4) Với mỗi file:
   - Tạo FileReader
   - Tạo BufferedReader
   - Đọc từng dòng
   - Đóng file

============================================================
VI. LƯU Ý QUAN TRỌNG

1) Phải kiểm tra file.isFile()
   Nếu không sẽ đọc cả folder → lỗi

2) Nên dùng try-with-resources để tránh leak

Ví dụ tốt hơn:

------------------------------------------------------------
for (File file : files) {
    if (file.isFile()) {

        try (BufferedReader br = new BufferedReader(new FileReader(file))) {

            String line;

            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
------------------------------------------------------------

============================================================
VII. CHỈ ĐỌC FILE .TXT THÔI?

Nếu bạn chỉ muốn đọc file .txt:

------------------------------------------------------------
if (file.isFile() && file.getName().endsWith(".txt"))
------------------------------------------------------------

============================================================
VIII. TỐI ƯU HƠN VỚI NIO (KHUYẾN NGHỊ)

Dùng java.nio.file:

------------------------------------------------------------
Path folderPath = Paths.get("D:/data");

Files.list(folderPath)
     .filter(Files::isRegularFile)
     .forEach(path -> {

         try (BufferedReader br = Files.newBufferedReader(path)) {

             String line;

             while ((line = br.readLine()) != null) {
                 System.out.println(line);
             }

         } catch (IOException e) {
             e.printStackTrace();
         }

     });
------------------------------------------------------------

Ưu điểm:
- Code gọn hơn
- Hiện đại hơn
- Dễ filter

============================================================
IX. CÓ THỂ GOM NỘI DUNG NHIỀU FILE LẠI KHÔNG?

Có.

Ví dụ bạn muốn:

- Đọc tất cả file
- Gộp nội dung vào 1 List

Bạn có thể thêm:

List<String> allLines = new ArrayList<>();

Rồi:

allLines.add(line);

============================================================
X. TÓM TẮT

Đọc 1 file:
- Dùng BufferedReader trực tiếp

Đọc nhiều file trong 1 folder:
- Lấy danh sách file
- Duyệt từng file
- Mỗi file tạo BufferedReader riêng

============================================================
XI. KẾT LUẬN

Bạn hoàn toàn có thể chuyển từ:

ĐỌC 1 FILE

Sang:

ĐỌC NHIỀU FILE TRONG 1 FOLDER

Bằng cách:
Duyệt danh sách file và áp dụng BufferedReader cho từng file.

--- File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".txt"));

GIẢI THÍCH CHI TIẾT:

PHÂN TÍCH ĐOẠN CODE:

File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".txt"));

(Lưu ý: trong câu hỏi có viết nhầm listFiels và endWith, 
đúng phải là listFiles và endsWith)

============================================================
I. MỤC ĐÍCH ĐOẠN CODE

Đoạn code này dùng để:

LẤY DANH SÁCH CÁC FILE .txt TRONG MỘT FOLDER

Tức là:
- Chỉ lấy file có đuôi .txt
- Bỏ qua các file khác (.doc, .pdf, .jpg, ...)
- Bỏ qua folder

============================================================
II. PHÂN TÍCH TỪNG THÀNH PHẦN

------------------------------------------------------------
1) folder

folder là một đối tượng File đại diện cho thư mục.

Ví dụ:

File folder = new File("D:/data");

------------------------------------------------------------
2) folder.listFiles()

Phương thức listFiles() có nhiều phiên bản (overload).

Phiên bản đang dùng ở đây là:

listFiles(FilenameFilter filter)

Nó sẽ:
- Lấy tất cả file trong folder
- Sau đó áp dụng filter
- Chỉ trả về những file thỏa điều kiện

------------------------------------------------------------
3) (dir, name) -> ...

Đây là biểu thức Lambda trong Java 8+.

Nó thay cho:

new FilenameFilter() {
    public boolean accept(File dir, String name) {
        ...
    }
}

Lambda tương đương với:

(dir, name) -> {
    return name.toLowerCase().endsWith(".txt");
}

Trong đó:

dir  = thư mục hiện tại
name = tên file (String)

------------------------------------------------------------
4) name.toLowerCase()

Chuyển tên file về chữ thường.

Ví dụ:
"TEST.TXT" → "test.txt"

Mục đích:
So sánh không phân biệt hoa thường.

------------------------------------------------------------
5) endsWith(".txt")

Kiểm tra tên file có kết thúc bằng ".txt" không.

Ví dụ:

"test.txt"      → true
"abc.TXT"       → true (vì đã toLowerCase)
"report.doc"    → false

============================================================
III. CÁCH HOẠT ĐỘNG TOÀN BỘ

Giả sử thư mục D:/data có:

report.txt
test.TXT
image.jpg
doc.pdf
subFolder/

Sau khi chạy:

File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".txt"));

Kết quả:

files sẽ chứa:

report.txt
test.TXT

Không chứa:
image.jpg
doc.pdf
subFolder

============================================================
IV. BẢN VIẾT ĐẦY ĐỦ KHÔNG DÙNG LAMBDA

Tương đương với:

File[] files = folder.listFiles(new FilenameFilter() {
    @Override
    public boolean accept(File dir, String name) {
        return name.toLowerCase().endsWith(".txt");
    }
});

Lambda chỉ là cách viết ngắn gọn hơn.

============================================================
V. CÁC LƯU Ý QUAN TRỌNG

1) listFiles() có thể trả về null

Nếu:
- folder không tồn tại
- Không phải là thư mục

Nên kiểm tra:

if (files != null) {
    for (File file : files) {
        System.out.println(file.getName());
    }
}

------------------------------------------------------------
2) Chỉ filter theo tên

Đoạn này chỉ kiểm tra tên.
Không kiểm tra file hay folder.

Nếu có folder tên:

abc.txt/

Nó vẫn có thể được trả về.

Muốn chắc chắn là file thật:

if (file.isFile())

============================================================
VI. SO SÁNH VỚI CÁCH DÙNG NIO (HIỆN ĐẠI HƠN)

Java NIO:

Files.list(Paths.get("D:/data"))
     .filter(path -> path.toString().toLowerCase().endsWith(".txt"))
     .forEach(System.out::println);

Cách này:
- Hiện đại hơn
- Linh hoạt hơn
- Dễ kết hợp stream

============================================================
VII. TÓM TẮT NGẮN GỌN

File[] files = folder.listFiles((dir, name) -> name.toLowerCase().endsWith(".txt"));

Có nghĩa là:

1) Lấy tất cả file trong folder
2) Chỉ giữ lại file có đuôi .txt
3) Không phân biệt hoa thường
4) Trả về mảng File[]

============================================================
VIII. KẾT LUẬN

Đây là cách dùng Lambda để:

LỌC FILE THEO ĐUÔI (.txt)
TRONG MỘT THƯ MỤC

Nó tương đương với việc dùng FilenameFilter,
nhưng ngắn gọn và hiện đại hơn.

--- TRONG inputStream.readLine(), MUỐN BỎ QUA NHỮNG DÒNG CÓ CHỨA "abc" THÌ LÀM THẾ NÀO?

GIẢI THÍCH CHI TIẾT:

TRONG inputStream.readLine(), MUỐN BỎ QUA NHỮNG DÒNG CÓ CHỨA "abc" THÌ LÀM THẾ NÀO?

============================================================
I. LÀM RÕ KHÁI NIỆM

Trước tiên:

InputStream KHÔNG có readLine().

readLine() thuộc về:

- BufferedReader
- DataInputStream (cũ, không khuyến khích)

Thông thường ta dùng:

BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));

Sau đó:

br.readLine();

============================================================
II. VẤN ĐỀ

Giả sử bạn đang đọc file theo từng dòng:

String line;

while ((line = br.readLine()) != null) {
    // xử lý line
}

Bây giờ yêu cầu:

BỎ QUA (skip) những dòng có chứa đoạn text "abc"

============================================================
III. CÁCH LÀM ĐƠN GIẢN NHẤT

Dùng điều kiện if + continue

Ví dụ:

------------------------------------------------------------
String line;

while ((line = br.readLine()) != null) {

    if (line.contains("abc")) {
        continue;   // bỏ qua dòng này
    }

    System.out.println(line);
}
------------------------------------------------------------

Giải thích:

- line.contains("abc")
  → kiểm tra dòng có chứa chuỗi "abc" không

- continue
  → bỏ qua phần còn lại của vòng lặp
  → chuyển sang đọc dòng tiếp theo

============================================================
IV. KHÔNG PHÂN BIỆT HOA THƯỜNG?

Nếu muốn bỏ qua cả:

ABC
Abc
aBc

Thì dùng:

------------------------------------------------------------
if (line.toLowerCase().contains("abc")) {
    continue;
}
------------------------------------------------------------

============================================================
V. MUỐN BỎ QUA CHÍNH XÁC DÒNG BẰNG "abc"?

Nếu yêu cầu là:

Chỉ bỏ qua dòng mà nội dung đúng bằng "abc"

Dùng:

------------------------------------------------------------
if (line.equals("abc")) {
    continue;
}
------------------------------------------------------------

Hoặc không phân biệt hoa thường:

------------------------------------------------------------
if (line.equalsIgnoreCase("abc")) {
    continue;
}
------------------------------------------------------------

============================================================
VI. MUỐN BỎ QUA DÒNG BẮT ĐẦU BẰNG "abc"?

------------------------------------------------------------
if (line.startsWith("abc")) {
    continue;
}
------------------------------------------------------------

============================================================
VII. MUỐN BỎ QUA DÒNG KẾT THÚC BẰNG "abc"?

------------------------------------------------------------
if (line.endsWith("abc")) {
    continue;
}
------------------------------------------------------------

============================================================
VIII. VÍ DỤ HOÀN CHỈNH

------------------------------------------------------------
InputStream inputStream = new FileInputStream("D:/data/test.txt");
BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));

String line;

while ((line = br.readLine()) != null) {

    if (line.toLowerCase().contains("abc")) {
        continue;
    }

    System.out.println(line);
}

br.close();
------------------------------------------------------------

============================================================
IX. GIẢI THÍCH LUỒNG HOẠT ĐỘNG

1) readLine() đọc từng dòng
2) Kiểm tra dòng có chứa "abc" không
3) Nếu có → bỏ qua
4) Nếu không → xử lý bình thường

============================================================
X. CÁCH DÙNG STREAM (JAVA 8+)

Có thể viết gọn hơn:

------------------------------------------------------------
br.lines()
  .filter(line -> !line.toLowerCase().contains("abc"))
  .forEach(System.out::println);
------------------------------------------------------------

Giải thích:

- filter giữ lại những dòng KHÔNG chứa "abc"
- forEach in ra

============================================================
XI. TÓM TẮT

Muốn bỏ qua dòng chứa "abc":

Cách chuẩn:

if (line.contains("abc")) {
    continue;
}

Hoặc không phân biệt hoa thường:

if (line.toLowerCase().contains("abc")) {
    continue;
}

============================================================
XII. KẾT LUẬN

Để bỏ qua dòng trong readLine():

Chỉ cần kiểm tra điều kiện và dùng continue.

Cơ chế rất đơn giản:
Đọc từng dòng → nếu không thỏa điều kiện → xử lý.
Nếu thỏa điều kiện bỏ qua → nhảy sang dòng tiếp theo.

--- removeIf() TRẢ VỀ GIÁ TRỊ GÌ?

GIẢI THÍCH CHI TIẾT:
removeIf() TRẢ VỀ GIÁ TRỊ GÌ?

========================================================
1. removeIf() LÀ GÌ?
========================================================

removeIf() là một method thuộc interface Collection trong Java 8.

Khai báo:

boolean removeIf(Predicate<? super E> filter)

Nghĩa là:

- Nhận vào một Predicate (điều kiện)
- Xóa tất cả phần tử thỏa điều kiện đó
- Trả về một giá trị boolean

========================================================
2. removeIf() TRẢ VỀ GÌ?
========================================================

removeIf() trả về:

TRUE  → nếu có ít nhất 1 phần tử bị xóa
FALSE → nếu KHÔNG có phần tử nào bị xóa

Nó KHÔNG trả về danh sách mới.
Nó KHÔNG trả về số phần tử bị xóa.
Nó chỉ trả về boolean.

========================================================
3. VÍ DỤ CỤ THỂ
========================================================

ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);

boolean result = list.removeIf(n -> n % 2 == 0);

Giải thích:

n % 2 == 0
→ xóa số chẵn

Danh sách sau khi xóa:
[1, 3]

result = true
vì có phần tử (2, 4) bị xóa

--------------------------------------------------------

Trường hợp khác:

ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(3);
list.add(5);

boolean result = list.removeIf(n -> n % 2 == 0);

Không có số chẵn.
Không phần tử nào bị xóa.

Danh sách vẫn là:
[1, 3, 5]

result = false

========================================================
4. TẠI SAO removeIf() CHỈ TRẢ VỀ BOOLEAN?
========================================================

Vì removeIf() hoạt động trực tiếp trên danh sách hiện tại (in-place).

Nó:

- Không tạo danh sách mới
- Không clone
- Không copy

Nó sửa đổi chính list đó.

Do đó chỉ cần trả về:
"Có thay đổi hay không?"

========================================================
5. CÁCH HOẠT ĐỘNG BÊN TRONG
========================================================

Về bản chất,
removeIf() sử dụng Iterator nội bộ.

Tương đương với:

Iterator<E> it = collection.iterator();

while (it.hasNext()) {
    if (filter.test(it.next())) {
        it.remove();
    }
}

Nếu có ít nhất một lần remove() xảy ra,
method sẽ trả về true.

========================================================
6. removeIf() KHÔNG TRẢ VỀ:
========================================================

✗ Không trả về số phần tử bị xóa
✗ Không trả về danh sách mới
✗ Không trả về phần tử bị xóa
✗ Không trả về index

Chỉ trả về boolean.

========================================================
7. CÁCH LẤY SỐ PHẦN TỬ BỊ XÓA (NẾU CẦN)
========================================================

Cách đơn giản:

int oldSize = list.size();

list.removeIf(condition);

int removedCount = oldSize - list.size();

========================================================
8. TỔNG KẾT
========================================================

removeIf() trả về:

TRUE  → nếu danh sách có thay đổi (có phần tử bị xóa)
FALSE → nếu danh sách không thay đổi

Nó sửa trực tiếp list hiện tại.

========================================================
TÓM LẠI 1 CÂU
========================================================

removeIf() trả về boolean:
"Có xóa được phần tử nào không?"

--- ĐOẠN CODE TRONG WHILE SẼ ĐỌC DÒNG THỨ 1 HAY THỨ 2?
line = inputStream.readLine();
while ( (a = inputStream.readLine()) != null ) {
    // xử lý
}

GIẢI THÍCH CHI TIẾT:
ĐOẠN CODE TRONG WHILE SẼ ĐỌC DÒNG THỨ 1 HAY THỨ 2?

--------------------------------------------------------
line = inputStream.readLine();
while ( (a = inputStream.readLine()) != null ) {
    // xử lý
}
--------------------------------------------------------

========================================================
1. CÂU TRẢ LỜI NGẮN GỌN
========================================================

ĐOẠN CODE TRONG while sẽ bắt đầu xử lý từ DÒNG THỨ 2.

Vì dòng thứ 1 đã bị đọc ở dòng lệnh phía trên.

========================================================
2. PHÂN TÍCH TỪNG BƯỚC
========================================================

Giả sử file có nội dung:

Line1
Line2
Line3

--------------------------------------------------------
BƯỚC 1:
--------------------------------------------------------

line = inputStream.readLine();

→ readLine() đọc dòng đầu tiên
→ line = "Line1"

Con trỏ file lúc này đã di chuyển xuống dòng 2.

--------------------------------------------------------
BƯỚC 2:
--------------------------------------------------------

while ( (a = inputStream.readLine()) != null )

Lần lặp đầu tiên:

readLine() đọc dòng kế tiếp
→ đọc "Line2"
→ a = "Line2"

Vì khác null → vào trong while.

=> LẦN LẶP ĐẦU TIÊN xử lý Line2.

--------------------------------------------------------
BƯỚC 3:
--------------------------------------------------------

Lần lặp thứ hai:

readLine() đọc "Line3"
→ a = "Line3"

=> xử lý Line3

--------------------------------------------------------
BƯỚC 4:
--------------------------------------------------------

Lần lặp tiếp:

readLine() trả về null (hết file)
→ thoát vòng lặp

========================================================
3. VÌ SAO DÒNG 1 BỊ BỎ QUA?
========================================================

Vì bạn đã đọc nó ở đây:

line = inputStream.readLine();

Nhưng bạn KHÔNG xử lý biến line trong while.

Do đó:

Line1 bị đọc
nhưng không được xử lý trong vòng lặp.

========================================================
4. SƠ ĐỒ DI CHUYỂN CON TRỎ FILE
========================================================

Ban đầu:
Con trỏ ở đầu file

Sau dòng 1:
line = readLine()
Con trỏ → xuống dòng 2

Trong while lần 1:
readLine()
Con trỏ → xuống dòng 3

Trong while lần 2:
readLine()
Con trỏ → EOF

========================================================
5. NẾU MUỐN ĐỌC TỪ DÒNG 1 THÌ SAO?
========================================================

Bạn phải viết như sau:

String line;

while ( (line = inputStream.readLine()) != null ) {
    // xử lý line
}

Khi đó:

Lần lặp 1 → đọc Line1
Lần lặp 2 → đọc Line2
Lần lặp 3 → đọc Line3

========================================================
6. KHI NÀO NGƯỜI TA CỐ TÌNH ĐỌC TRƯỚC 1 DÒNG?
========================================================

Trường hợp phổ biến:

- Bỏ qua header (dòng tiêu đề)

Ví dụ file CSV:

Name,Age,City
An,20,HCM
Binh,22,Hanoi

Người ta sẽ làm:

String header = reader.readLine(); // bỏ dòng tiêu đề

while ((line = reader.readLine()) != null) {
    // xử lý dữ liệu
}

Lúc này vòng while bắt đầu từ dòng 2 là đúng chủ ý.

========================================================
7. KẾT LUẬN
========================================================

Nếu bạn viết:

line = readLine();
while ( (a = readLine()) != null )

Thì:

✓ Dòng đầu tiên bị đọc trước
✓ Vòng while bắt đầu xử lý từ dòng thứ 2
✓ Không có dòng nào được đọc 2 lần
✓ Không có vòng lặp tự động thứ 2

========================================================
TÓM LẠI 1 CÂU
========================================================

Đoạn code trong while sẽ đọc và xử lý DÒNG THỨ 2,
vì dòng thứ 1 đã bị đọc trước đó.

--- reader.close() VÀ return CÓ TÁC DỤNG GÌ?

GIẢI THÍCH CHI TIẾT:
reader.close() VÀ return CÓ TÁC DỤNG GÌ?

========================================================
PHẦN 1: reader.close() LÀ GÌ?
========================================================

reader.close() là lệnh dùng để:

- Đóng luồng đọc (stream)
- Giải phóng tài nguyên hệ thống
- Ngắt kết nối tới file / socket / resource

Ví dụ:

BufferedReader reader = new BufferedReader(new FileReader("data.txt"));
reader.close();

========================================================
1.1. VÌ SAO PHẢI close()?
========================================================

Khi bạn mở file:

FileReader / BufferedReader
→ Hệ điều hành cấp tài nguyên (file handle)

Nếu bạn không close():

- File có thể bị khóa
- Rò rỉ bộ nhớ (resource leak)
- Không mở được file lần sau
- Ứng dụng có thể bị lỗi khi mở nhiều file

========================================================
1.2. SAU KHI close() XẢY RA ĐIỀU GÌ?
========================================================

Sau khi gọi:

reader.close();

- Không được phép đọc tiếp
- Gọi reader.readLine() sẽ gây IOException

========================================================
1.3. close() KHÔNG LÀM GÌ?
========================================================

reader.close() KHÔNG:

- Xóa file
- Xóa dữ liệu
- Reset file
- Xóa biến reader

Nó chỉ đóng luồng đọc.

========================================================
PHẦN 2: return LÀ GÌ?
========================================================

return là lệnh dùng để:

- Kết thúc method ngay lập tức
- Trả về giá trị (nếu method có kiểu trả về)

Ví dụ:

public int sum(int a, int b) {
    return a + b;
}

========================================================
2.1. return LÀM GÌ KHI ĐƯỢC GỌI?
========================================================

Khi gặp return:

- Method dừng ngay
- Không chạy các dòng phía sau
- Trả quyền điều khiển về nơi gọi method

========================================================
2.2. return KHÔNG LIÊN QUAN ĐẾN reader.close()
========================================================

return chỉ dừng method.
Nó KHÔNG tự động đóng file.

Ví dụ:

public void readFile() throws Exception {
    BufferedReader reader = new BufferedReader(new FileReader("data.txt"));
    return;
}

Ở đây:

- reader chưa được close
- File vẫn mở
- Có thể gây rò rỉ tài nguyên

========================================================
PHẦN 3: KẾT HỢP reader.close() VÀ return
========================================================

Ví dụ:

public String readFirstLine() throws Exception {
    BufferedReader reader = new BufferedReader(new FileReader("data.txt"));

    String line = reader.readLine();

    reader.close();
    return line;
}

Trình tự:

1. Mở file
2. Đọc 1 dòng
3. Đóng file
4. Trả kết quả

Đây là cách đúng.

========================================================
PHẦN 4: TRƯỜNG HỢP NGUY HIỂM
========================================================

public String readFirstLine() throws Exception {
    BufferedReader reader = new BufferedReader(new FileReader("data.txt"));

    String line = reader.readLine();

    if (line == null) {
        return null;   // CHƯA close()
    }

    reader.close();
    return line;
}

Nếu line == null:

- Method return ngay
- reader không được close
→ LỖI RÒ RỈ TÀI NGUYÊN

========================================================
PHẦN 5: CÁCH ĐÚNG NHẤT (TRY-WITH-RESOURCES)
========================================================

public String readFirstLine() throws Exception {

    try (BufferedReader reader =
             new BufferedReader(new FileReader("data.txt"))) {

        return reader.readLine();
    }

}

Ưu điểm:

- Tự động close()
- Không lo quên đóng file
- An toàn hơn

========================================================
PHẦN 6: SO SÁNH NHANH
========================================================

reader.close():
→ Đóng tài nguyên (file, stream, connection)

return:
→ Kết thúc method và trả về giá trị

Hai lệnh này hoàn toàn khác nhau về chức năng.

========================================================
PHẦN 7: TỔNG KẾT
========================================================

reader.close():
✓ Giải phóng tài nguyên
✓ Phải gọi khi dùng xong file
✓ Không tự động chạy khi return

return:
✓ Dừng method ngay lập tức
✓ Trả giá trị về nơi gọi
✓ Không đóng file

========================================================
TÓM LẠI 1 CÂU
========================================================

reader.close() = đóng file.
return = kết thúc method.
Chúng là hai cơ chế hoàn toàn khác nhau.

--- File a = new File(aPath); a.lastModified() CÓ HỢP LỆ NẾU a LÀ FOLDER KHÔNG?
VÀ KHI THÊM / SỬA FILE TRONG FOLDER THÌ lastModified() CÓ CẬP NHẬT KHÔNG?

GIẢI THÍCH CHI TIẾT:
File a = new File(aPath);
a.lastModified() CÓ HỢP LỆ NẾU a LÀ FOLDER KHÔNG?
VÀ KHI THÊM / SỬA FILE TRONG FOLDER THÌ lastModified() CÓ CẬP NHẬT KHÔNG?

========================================================
PHẦN 1: a.lastModified() CÓ HỢP LỆ NẾU a LÀ FOLDER KHÔNG?
========================================================

CÓ. HOÀN TOÀN HỢP LỆ.

Trong Java:

java.io.File đại diện cho:
- File thường
- Hoặc thư mục (folder)

Method:

long lastModified()

Áp dụng cho cả file và thư mục.

Nó trả về:
- Thời điểm chỉnh sửa cuối cùng (tính bằng milliseconds từ 01-01-1970 UTC)

Nếu file hoặc folder không tồn tại:
→ trả về 0

========================================================
PHẦN 2: lastModified() CỦA FOLDER NGHĨA LÀ GÌ?
========================================================

Đối với FOLDER:

lastModified() không có nghĩa là:
"bất kỳ file con nào thay đổi"

Nó chỉ có nghĩa là:
"metadata của folder bị thay đổi"

Metadata folder thay đổi khi:

- Thêm file mới vào folder
- Xóa file khỏi folder
- Đổi tên file trong folder

========================================================
PHẦN 3: TRƯỜNG HỢP 1
THÊM FILE MỚI VÀO FOLDER
========================================================

Ví dụ:

Folder A/
    file1.txt

Ta tạo thêm:

A/file2.txt

→ Folder A bị thay đổi nội dung
→ lastModified() của folder A THƯỜNG sẽ cập nhật

Lý do:
Hệ điều hành xem đây là thay đổi cấu trúc thư mục.

========================================================
PHẦN 4: TRƯỜNG HỢP 2
SỬA NỘI DUNG FILE BÊN TRONG FOLDER
========================================================

Ví dụ:

A/
   file1.txt

Ta sửa nội dung file1.txt

Điều xảy ra:

- lastModified() của file1.txt sẽ thay đổi
- lastModified() của folder A THƯỜNG KHÔNG thay đổi

Vì:

Folder không thay đổi cấu trúc.
Chỉ nội dung file bên trong thay đổi.

========================================================
PHẦN 5: TÓM TẮT HÀNH VI
========================================================

Hành động                          | lastModified(folder)
----------------------------------------------------------
Thêm file mới                      | Thường cập nhật
Xóa file                           | Thường cập nhật
Đổi tên file                       | Thường cập nhật
Sửa nội dung file bên trong        | Thường KHÔNG cập nhật

========================================================
PHẦN 6: TẠI SAO LẠI NHƯ VẬY?
========================================================

Vì hệ điều hành lưu:

Folder thực chất chỉ chứa:
- Danh sách tên file
- Metadata liên quan

Nó KHÔNG lưu nội dung file con.

Do đó:

Sửa nội dung file con
→ không làm thay đổi metadata folder.

========================================================
PHẦN 7: LƯU Ý QUAN TRỌNG
========================================================

Hành vi này phụ thuộc vào:

- Hệ điều hành (Windows, Linux, MacOS)
- Hệ thống file (NTFS, EXT4, APFS…)

Nhưng nguyên tắc chung:

Chỉnh sửa nội dung file con
→ không cập nhật timestamp của folder cha.

========================================================
PHẦN 8: NẾU MUỐN BIẾT FOLDER CÓ THAY ĐỔI BÊN TRONG KHÔNG?
========================================================

Bạn KHÔNG thể chỉ dựa vào:

a.lastModified()

Bạn phải:

- Duyệt tất cả file con
- So sánh lastModified của từng file

Ví dụ ý tưởng:

long newest = a.lastModified();

for (File child : a.listFiles()) {
    newest = Math.max(newest, child.lastModified());
}

========================================================
PHẦN 9: KẾT LUẬN
========================================================

1) a.lastModified() hoàn toàn hợp lệ nếu a là folder.

2) Khi thêm hoặc xóa file trong folder:
   → lastModified() của folder thường cập nhật.

3) Khi chỉ sửa nội dung file bên trong:
   → lastModified() của folder thường KHÔNG cập nhật.

========================================================
TÓM LẠI 1 CÂU
========================================================

Folder chỉ thay đổi timestamp khi cấu trúc của nó thay đổi,
không phải khi nội dung file bên trong thay đổi.

--- CODE ĐỂ UPLOAD FILE BẰNG JAVASCRIPT

GIẢI THÍCH CHI TIẾT:
CODE ĐỂ UPLOAD FILE BẰNG JAVASCRIPT

========================================================
PHẦN 1: NGUYÊN LÝ UPLOAD FILE TRONG WEB
========================================================

Khi upload file bằng JavaScript:

1) Người dùng chọn file từ input type="file"
2) JavaScript lấy file đó (đối tượng File)
3) Tạo FormData
4) Gửi lên server bằng:
   - fetch()
   - hoặc XMLHttpRequest

========================================================
PHẦN 2: HTML CƠ BẢN
========================================================

<input type="file" id="fileInput" />
<button onclick="uploadFile()">Upload</button>

========================================================
PHẦN 3: CODE JAVASCRIPT DÙNG FETCH (PHỔ BIẾN NHẤT)
========================================================

function uploadFile() {

    const input = document.getElementById("fileInput");

    // Kiểm tra có chọn file không
    if (input.files.length === 0) {
        alert("Vui lòng chọn file");
        return;
    }

    const file = input.files[0];

    const formData = new FormData();

    // "file" là tên field gửi lên server
    formData.append("file", file);

    fetch("http://localhost:8080/upload", {
        method: "POST",
        body: formData
    })
    .then(response => response.text())
    .then(data => {
        console.log("Upload thành công:", data);
    })
    .catch(error => {
        console.error("Lỗi upload:", error);
    });
}

========================================================
PHẦN 4: GIẢI THÍCH TỪNG BƯỚC
========================================================

1) input.files
   Là danh sách file người dùng chọn.

2) input.files[0]
   Lấy file đầu tiên.

3) FormData()
   Là đối tượng đặc biệt dùng để gửi dữ liệu dạng:
   multipart/form-data

4) formData.append("file", file)
   "file" là key gửi lên server.
   file là nội dung file.

5) fetch(...)
   Gửi HTTP POST request lên server.

========================================================
PHẦN 5: SERVER PHẢI HỖ TRỢ multipart/form-data
========================================================

Server (Java Spring Boot ví dụ):

@PostMapping("/upload")
public String upload(@RequestParam("file") MultipartFile file) {
    return "Upload OK: " + file.getOriginalFilename();
}

========================================================
PHẦN 6: UPLOAD NHIỀU FILE
========================================================

HTML:

<input type="file" id="fileInput" multiple />

JavaScript:

function uploadFile() {

    const input = document.getElementById("fileInput");
    const formData = new FormData();

    for (let i = 0; i < input.files.length; i++) {
        formData.append("files", input.files[i]);
    }

    fetch("http://localhost:8080/upload", {
        method: "POST",
        body: formData
    });
}

========================================================
PHẦN 7: CÁCH CŨ DÙNG XMLHttpRequest
========================================================

function uploadFile() {

    const input = document.getElementById("fileInput");
    const file = input.files[0];

    const formData = new FormData();
    formData.append("file", file);

    const xhr = new XMLHttpRequest();

    xhr.open("POST", "http://localhost:8080/upload", true);

    xhr.onload = function() {
        if (xhr.status === 200) {
            console.log("Upload thành công");
        } else {
            console.log("Upload lỗi");
        }
    };

    xhr.send(formData);
}

========================================================
PHẦN 8: LƯU Ý QUAN TRỌNG
========================================================

1) Không cần set Content-Type khi dùng FormData
   Trình duyệt tự set đúng boundary.

2) Nếu server khác domain
   → cần cấu hình CORS.

3) Nếu file lớn
   → nên xử lý progress bar.

========================================================
PHẦN 9: UPLOAD KHÔNG DÙNG NÚT (AUTO UPLOAD)
========================================================

<input type="file" id="fileInput" />

<script>
document.getElementById("fileInput")
    .addEventListener("change", uploadFile);
</script>

========================================================
PHẦN 10: TÓM LẠI QUY TRÌNH
========================================================

1) input type="file"
2) Lấy file từ input.files
3) Tạo FormData
4) append file vào FormData
5) fetch POST lên server

========================================================
TÓM LẠI 1 CÂU
========================================================

Upload file bằng JS = 
lấy file từ input → bỏ vào FormData → gửi POST bằng fetch().

--- PYC LÀ GÌ?

GIẢI THÍCH CHI TIẾT:
PYC LÀ GÌ?

========================================================
PHẦN 1: PYC TRONG PYTHON LÀ GÌ?
========================================================

PYC là viết tắt của:

Python Compiled File

Nó là file chứa BYTECODE được tạo ra sau khi Python biên dịch file .py.

Ví dụ:

main.py  →  main.cpython-311.pyc

========================================================
PHẦN 2: PYTHON CÓ BIÊN DỊCH KHÔNG?
========================================================

Có, nhưng không phải biên dịch ra file .exe như C/C++.

Quy trình Python:

1) Viết code .py
2) Python biên dịch sang BYTECODE
3) Lưu bytecode vào file .pyc
4) Python Virtual Machine (PVM) chạy bytecode đó

========================================================
PHẦN 3: BYTECODE LÀ GÌ?
========================================================

Bytecode là mã trung gian.

Nó không phải:
- Mã máy (machine code)
- Không chạy trực tiếp bởi CPU

Nó được chạy bởi:
Python Virtual Machine (PVM)

========================================================
PHẦN 4: KHI NÀO FILE .PYC ĐƯỢC TẠO?
========================================================

Khi bạn:

- Import một module
- Hoặc chạy chương trình Python

Python sẽ:

- Tạo thư mục __pycache__
- Tạo file .pyc bên trong đó

Ví dụ cấu trúc:

project/
    main.py
    __pycache__/
        main.cpython-311.pyc

========================================================
PHẦN 5: TẠI SAO CẦN FILE .PYC?
========================================================

Mục đích chính:

TĂNG TỐC ĐỘ CHẠY LẦN SAU

Lần đầu:
- Python phải compile .py → bytecode

Lần sau:
- Nếu .py không thay đổi
- Python dùng lại file .pyc
- Không cần compile lại

=> Chạy nhanh hơn

========================================================
PHẦN 6: CẤU TRÚC TÊN FILE .PYC
========================================================

Ví dụ:

main.cpython-311.pyc

Giải thích:

main           → tên file
cpython        → implementation Python
311            → phiên bản Python 3.11
pyc            → Python compiled

========================================================
PHẦN 7: CÓ NÊN COMMIT .PYC LÊN GIT KHÔNG?
========================================================

KHÔNG.

Lý do:

- .pyc được tạo tự động
- Phụ thuộc vào phiên bản Python
- Không cần thiết lưu vào repository

Thường thêm vào .gitignore:

__pycache__/
*.pyc

========================================================
PHẦN 8: CÓ THỂ CHẠY FILE .PYC KHÔNG?
========================================================

Có.

python file.pyc

Nhưng:

- Không khuyến khích
- Thường dùng file .py

========================================================
PHẦN 9: PYC KHÔNG PHẢI LÀ BẢO MẬT
========================================================

Nhiều người nghĩ:

"Đổi .py sang .pyc là che được source code"

SAI.

Có thể dùng tool decompile
để chuyển .pyc → gần giống source ban đầu.

========================================================
PHẦN 10: TÓM TẮT QUY TRÌNH THỰC TẾ
========================================================

Khi bạn chạy:

python main.py

Python sẽ:

1) Đọc main.py
2) Compile thành bytecode
3) Lưu vào __pycache__/main.cpython-xxx.pyc
4) PVM thực thi bytecode

========================================================
PHẦN 11: TÓM LẠI
========================================================

PYC là:

- File bytecode của Python
- Được tạo tự động
- Giúp tăng tốc độ thực thi
- Không phải file thực thi độc lập
- Không phải cơ chế bảo mật

========================================================
TÓM LẠI 1 CÂU
========================================================

PYC là file chứa bytecode được Python tạo ra sau khi biên dịch file .py để chạy nhanh hơn ở những lần sau.

--- QC LÀ GÌ? CÓ PHẢI LÀ TESTER KHÔNG?

GIẢI THÍCH CHI TIẾT:
QC LÀ GÌ? CÓ PHẢI LÀ TESTER KHÔNG?

========================================================
PHẦN 1: QC LÀ GÌ?
========================================================

QC là viết tắt của:

Quality Control (Kiểm soát chất lượng)

QC là hoạt động nhằm:

- Phát hiện lỗi
- Đảm bảo sản phẩm đạt tiêu chuẩn chất lượng
- Kiểm tra trước khi bàn giao cho khách hàng

QC xuất hiện trong:

- Phần mềm (Software)
- Sản xuất (Manufacturing)
- Dịch vụ
- Xây dựng
- Thực phẩm

========================================================
PHẦN 2: QC TRONG NGÀNH PHẦN MỀM
========================================================

Trong lĩnh vực phần mềm:

QC thường được hiểu gần giống với:

Tester (người kiểm thử)

Nhưng thực tế:

QC là khái niệm rộng hơn Tester.

========================================================
PHẦN 3: QC CÓ PHẢI LÀ TESTER KHÔNG?
========================================================

Câu trả lời:

GẦN ĐÚNG, nhưng không hoàn toàn giống nhau.

Tùy công ty:

- Có nơi gọi Tester là QC
- Có nơi tách riêng QC và Tester

========================================================
PHẦN 4: SO SÁNH QC VÀ TESTER
========================================================

1) Tester là gì?

Tester là người:

- Viết test case
- Thực hiện test
- Báo bug
- Xác nhận bug đã fix

Tester tập trung vào:

KIỂM THỬ PHẦN MỀM.

----------------------------------------

2) QC là gì?

QC có thể bao gồm:

- Kiểm thử
- Kiểm tra quy trình
- Kiểm tra tài liệu
- Kiểm tra chất lượng tổng thể sản phẩm

QC tập trung vào:

CHẤT LƯỢNG CUỐI CÙNG CỦA SẢN PHẨM.

========================================================
PHẦN 5: QC VÀ QA KHÁC NHAU NHƯ THẾ NÀO?
========================================================

QC (Quality Control)
→ Tìm lỗi sau khi sản phẩm được tạo ra.

QA (Quality Assurance)
→ Ngăn lỗi xảy ra bằng cách cải thiện quy trình.

Ví dụ:

QC:
- Test app
- Phát hiện bug

QA:
- Xây dựng quy trình coding chuẩn
- Đưa ra checklist review
- Cải thiện quy trình để ít bug hơn

========================================================
PHẦN 6: TẠI SAO NHIỀU CÔNG TY GỌI TESTER LÀ QC?
========================================================

Vì:

- Trong phần mềm, QC chủ yếu là test
- Nhiều công ty không phân biệt rõ QA, QC
- Dùng QC như một tên gọi khác của Tester

Do đó:

"QC Engineer"
thường chính là Tester.

========================================================
PHẦN 7: CÁC LOẠI QC TRONG PHẦN MỀM
========================================================

1) Manual QC
   - Test bằng tay
   - Click, nhập dữ liệu, kiểm tra giao diện

2) Automation QC
   - Viết script test tự động
   - Dùng Selenium, Playwright, v.v.

3) Performance QC
   - Test hiệu năng
   - Kiểm tra chịu tải

========================================================
PHẦN 8: NHIỆM VỤ THƯỜNG GẶP CỦA QC
========================================================

- Đọc requirement
- Viết test case
- Thực hiện test
- Tạo bug report
- Regression test
- Verify bug fix
- Báo cáo chất lượng

========================================================
PHẦN 9: KẾT LUẬN
========================================================

QC là:

Hoạt động kiểm soát chất lượng sản phẩm.

Trong ngành phần mềm:

QC thường được dùng như một tên gọi khác của Tester.

Tuy nhiên về mặt lý thuyết:

Tester chỉ là một phần trong hoạt động QC.

========================================================
TÓM LẠI 1 CÂU
========================================================

QC là kiểm soát chất lượng.
Trong ngành phần mềm, QC thường chính là Tester,
nhưng khái niệm QC rộng hơn Tester.

--- BA LÀ GÌ?

GIẢI THÍCH CHI TIẾT:
BA LÀ GÌ?

========================================================
PHẦN 1: BA LÀ GÌ?
========================================================

BA là viết tắt của:

Business Analyst (Chuyên viên phân tích nghiệp vụ)

BA là người:

- Phân tích yêu cầu từ khách hàng
- Làm rõ nghiệp vụ
- Viết tài liệu đặc tả hệ thống
- Là cầu nối giữa khách hàng và team kỹ thuật

========================================================
PHẦN 2: BA LÀM GÌ TRONG DỰ ÁN PHẦN MỀM?
========================================================

Trong dự án phần mềm, BA có vai trò cực kỳ quan trọng.

Họ đứng giữa:

Khách hàng  <---->  Dev / Tester / PM

BA giúp:

- Hiểu khách hàng muốn gì
- Chuyển yêu cầu đó thành tài liệu kỹ thuật
- Đảm bảo dev hiểu đúng yêu cầu

========================================================
PHẦN 3: CÔNG VIỆC CỤ THỂ CỦA BA
========================================================

1) Thu thập yêu cầu (Requirement Gathering)

- Họp với khách hàng
- Đặt câu hỏi
- Làm rõ mong muốn
- Ghi nhận yêu cầu

----------------------------------------

2) Phân tích yêu cầu

- Xác định nghiệp vụ chính
- Xác định các trường hợp đặc biệt
- Xác định luồng xử lý

----------------------------------------

3) Viết tài liệu

Các tài liệu BA thường viết:

- BRD (Business Requirement Document)
- SRS (Software Requirement Specification)
- User Story
- Use Case
- Flow Diagram

----------------------------------------

4) Giải thích yêu cầu cho team kỹ thuật

- Trình bày requirement cho Dev
- Trả lời câu hỏi của Dev
- Làm rõ khi có thắc mắc

----------------------------------------

5) Hỗ trợ kiểm thử

- Giải thích requirement cho Tester
- Xác nhận hệ thống làm đúng yêu cầu chưa

========================================================
PHẦN 4: BA KHÁC DEV VÀ TESTER NHƯ THẾ NÀO?
========================================================

DEV:
- Viết code
- Xây dựng hệ thống

TESTER:
- Kiểm tra lỗi
- Đảm bảo hệ thống chạy đúng

BA:
- Không code
- Không test chính
- Phân tích nghiệp vụ và làm rõ yêu cầu

========================================================
PHẦN 5: BA KHÔNG PHẢI LÀ SALES
========================================================

BA không phải là nhân viên bán hàng.

BA tập trung vào:

- Phân tích logic nghiệp vụ
- Hiểu quy trình kinh doanh
- Đảm bảo hệ thống hỗ trợ đúng quy trình đó

========================================================
PHẦN 6: BA CẦN KỸ NĂNG GÌ?
========================================================

1) Kỹ năng giao tiếp
   - Nói chuyện với khách hàng
   - Trình bày rõ ràng

2) Kỹ năng phân tích
   - Tư duy logic
   - Nhìn thấy vấn đề tiềm ẩn

3) Kỹ năng viết tài liệu
   - Viết rõ ràng
   - Tránh mơ hồ

4) Hiểu biết nghiệp vụ
   - Ví dụ: ngân hàng, bảo hiểm, thương mại điện tử…

========================================================
PHẦN 7: VÍ DỤ CỤ THỂ
========================================================

Khách hàng nói:

"Tôi muốn hệ thống quản lý đơn hàng."

BA sẽ hỏi:

- Ai tạo đơn hàng?
- Một đơn hàng có những thông tin gì?
- Có thể sửa đơn hàng không?
- Khi nào đơn hàng hoàn tất?
- Có trạng thái nào?
- Có thanh toán online không?

Sau đó BA viết tài liệu chi tiết để Dev code đúng.

========================================================
PHẦN 8: BA CÓ PHẢI LÀ PM KHÔNG?
========================================================

KHÔNG.

PM (Project Manager):
- Quản lý tiến độ
- Phân chia công việc
- Quản lý rủi ro

BA:
- Tập trung vào phân tích yêu cầu

========================================================
PHẦN 9: BA TRONG AGILE
========================================================

Trong Agile, BA thường:

- Viết User Story
- Làm việc cùng Product Owner
- Hỗ trợ team hiểu rõ yêu cầu

========================================================
PHẦN 10: KẾT LUẬN
========================================================

BA là người:

- Phân tích nghiệp vụ
- Là cầu nối giữa khách hàng và kỹ thuật
- Giúp hệ thống được xây dựng đúng với nhu cầu thực tế

========================================================
TÓM LẠI 1 CÂU
========================================================

BA là Business Analyst –
người phân tích yêu cầu và chuyển mong muốn của khách hàng
thành tài liệu rõ ràng để team kỹ thuật xây dựng hệ thống đúng mục tiêu.

--- CITAD CÓ NGHĨA LÀ GÌ TRONG NGÂN HÀNG?

CITAD CÓ NGHĨA LÀ GÌ TRONG NGÂN HÀNG?

1. CITAD LÀ VIẾT TẮT CỦA GÌ?

CITAD là viết tắt của:

Clearing and Interbank Transaction Accounting Department
(Tạm hiểu: Hệ thống thanh toán bù trừ và hạch toán giao dịch liên ngân hàng)

Tại Việt Nam, CITAD thường được hiểu là:

HỆ THỐNG THANH TOÁN ĐIỆN TỬ LIÊN NGÂN HÀNG
do Ngân hàng Nhà nước Việt Nam quản lý.

------------------------------------------------------------

2. BẢN CHẤT CỦA CITAD LÀ GÌ?

CITAD là hệ thống dùng để:

- Chuyển tiền giữa các ngân hàng khác nhau
- Thanh toán liên ngân hàng
- Hạch toán bù trừ tiền giữa các ngân hàng

Ví dụ:

Bạn chuyển tiền từ:
Ngân hàng A → sang → Ngân hàng B

Tiền không đi trực tiếp giữa 2 ngân hàng,
mà sẽ đi qua hệ thống CITAD của Ngân hàng Nhà nước.

------------------------------------------------------------

3. MÃ CITAD LÀ GÌ?

Mỗi chi nhánh ngân hàng sẽ có một MÃ CITAD riêng.

Mã CITAD dùng để:

- Xác định chính xác chi nhánh ngân hàng
- Định tuyến giao dịch chuyển tiền liên ngân hàng

Cấu trúc mã CITAD thường gồm:
- Mã tỉnh/thành
- Mã ngân hàng
- Mã chi nhánh

Ví dụ (minh họa):
01234567

Trong đó:
01  → mã tỉnh
234 → mã ngân hàng
567 → mã chi nhánh

(Lưu ý: cấu trúc cụ thể có thể thay đổi theo quy định từng thời kỳ)

------------------------------------------------------------

4. KHI NÀO DÙNG ĐẾN CITAD?

CITAD được sử dụng khi:

- Chuyển tiền khác ngân hàng
- Chuyển khoản liên tỉnh
- Giao dịch giá trị lớn qua hệ thống ngân hàng

Nếu bạn chuyển tiền cùng ngân hàng:
→ Không cần qua CITAD

Nếu bạn chuyển tiền khác ngân hàng:
→ Giao dịch sẽ đi qua hệ thống CITAD

------------------------------------------------------------

5. PHÂN BIỆT CITAD VÀ CHUYỂN TIỀN 24/7

CITAD:
- Thường xử lý theo phiên (giờ hành chính)
- Có thể mất vài giờ hoặc trong ngày

Chuyển tiền 24/7:
- Thực hiện qua hệ thống trung gian thanh toán
- Gần như ngay lập tức
- Hoạt động cả ngoài giờ hành chính

------------------------------------------------------------

6. TẠI SAO CẦN CITAD?

Vì:

- Mỗi ngân hàng có hệ thống riêng
- Cần một "trung tâm điều phối" để:
  + Đối chiếu
  + Bù trừ
  + Hạch toán
  + Đảm bảo an toàn hệ thống tài chính

CITAD đóng vai trò là:
Trung tâm thanh toán liên ngân hàng quốc gia.

------------------------------------------------------------

7. TÓM LẠI

CITAD trong ngân hàng là:

→ Hệ thống thanh toán điện tử liên ngân hàng
→ Do Ngân hàng Nhà nước quản lý
→ Dùng để chuyển tiền giữa các ngân hàng
→ Mỗi chi nhánh có một mã CITAD riêng để định danh

Nếu bạn muốn, tôi có thể giải thích thêm:

- Luồng tiền đi qua CITAD như thế nào từng bước
- So sánh CITAD với SWIFT
- Cách tra cứu mã CITAD
- Cơ chế bù trừ hoạt động ra sao

Chỉ cần nói bạn muốn đào sâu phần nào.

--- WEB THANH TOÁN TRONG JAVA SPRING – GIẢI THÍCH CHI TIẾT NHẤT

WEB THANH TOÁN TRONG JAVA SPRING – GIẢI THÍCH CHI TIẾT NHẤT

============================================================
I. WEB THANH TOÁN LÀ GÌ?
============================================================

Web thanh toán là hệ thống cho phép:

- Người dùng thực hiện thanh toán online
- Kết nối với cổng thanh toán (payment gateway)
- Xử lý giao dịch
- Nhận kết quả thành công / thất bại
- Cập nhật trạng thái đơn hàng

Trong Java Spring, web thanh toán thường được xây dựng bằng:

- Spring Boot
- Spring MVC
- Spring Security
- JPA / Hibernate
- REST API


============================================================
II. CÁC THÀNH PHẦN CHÍNH CỦA WEB THANH TOÁN
============================================================

1. FRONTEND (Giao diện người dùng)

Có thể là:
- Thymeleaf (server-side rendering)
- React / Angular / Vue (frontend riêng)

Chức năng:
- Hiển thị đơn hàng
- Nhập thông tin thanh toán
- Gửi request thanh toán


2. BACKEND (Spring Boot)

Gồm các tầng:

Controller → Service → Repository → Database

Nhiệm vụ:
- Tạo giao dịch
- Gọi API cổng thanh toán
- Nhận callback
- Cập nhật trạng thái


3. CỔNG THANH TOÁN (Payment Gateway)

Ví dụ:
- VNPay
- MoMo
- Stripe
- PayPal

Vai trò:
- Xử lý tiền thật
- Kiểm tra thẻ / ví
- Trả kết quả về hệ thống


============================================================
III. LUỒNG HOẠT ĐỘNG CỦA WEB THANH TOÁN
============================================================

BƯỚC 1: Người dùng đặt hàng
→ Hệ thống tạo Order với status = PENDING


BƯỚC 2: Tạo giao dịch thanh toán

Backend:
- Tạo mã transaction
- Lưu DB
- Gửi request đến cổng thanh toán


BƯỚC 3: Redirect sang cổng thanh toán

User được chuyển sang trang của VNPay / Stripe...


BƯỚC 4: Người dùng nhập thông tin thẻ


BƯỚC 5: Gateway xử lý


BƯỚC 6: Gateway gọi CALLBACK về server

Ví dụ:
POST /payment/callback

Server phải:
- Kiểm tra chữ ký (signature)
- Kiểm tra số tiền
- Kiểm tra transactionId


BƯỚC 7: Cập nhật trạng thái

Nếu thành công:
→ order.status = PAID

Nếu thất bại:
→ order.status = FAILED


============================================================
IV. CẤU TRÚC DATABASE CƠ BẢN
============================================================

TABLE: orders
- id
- user_id
- amount
- status (PENDING, PAID, FAILED)
- created_at

TABLE: payment_transactions
- id
- order_id
- transaction_code
- gateway
- status
- raw_response
- created_at


============================================================
V. CẤU TRÚC CODE TRONG SPRING
============================================================

1. Controller

@RestController
@RequestMapping("/payment")
public class PaymentController {

    @PostMapping("/create")
    public ResponseEntity<?> createPayment() {}

    @PostMapping("/callback")
    public ResponseEntity<?> callback() {}
}


2. Service

@Service
public class PaymentService {

    public String createPaymentUrl(Order order) {}

    public void handleCallback(Map<String, String> params) {}
}


3. Repository

public interface OrderRepository extends JpaRepository<Order, Long> {}

public interface PaymentRepository extends JpaRepository<PaymentTransaction, Long> {}


============================================================
VI. CÁC KIỂU TÍCH HỢP THANH TOÁN
============================================================

1. Redirect Integration

- User bị chuyển sang trang gateway
- An toàn vì không lưu thông tin thẻ
- Phổ biến nhất


2. API Direct Integration

- Backend gọi API thanh toán trực tiếp
- Phải tuân thủ chuẩn bảo mật PCI DSS
- Phức tạp hơn


3. Webhook Integration

- Gateway chủ động gọi lại server
- Phải xác thực chữ ký


============================================================
VII. BẢO MẬT TRONG WEB THANH TOÁN
============================================================

1. Xác thực chữ ký (Signature verification)

Rất quan trọng.
Phải kiểm tra:
- hash
- HMAC
- secret key


2. Không tin vào dữ liệu từ frontend

Không dùng:
amount từ client gửi lên

Phải:
- Lấy amount từ DB


3. Idempotency

Nếu gateway gửi callback nhiều lần:
→ Không được xử lý trùng


4. HTTPS bắt buộc


============================================================
VIII. CÁC VẤN ĐỀ THƯỜNG GẶP
============================================================

1. Double payment
2. Mất callback
3. Người dùng đóng tab giữa chừng
4. Giao dịch thành công nhưng chưa cập nhật DB
5. Race condition


============================================================
IX. MẪU LUỒNG XỬ LÝ CHUẨN TRONG THỰC TẾ
============================================================

1. Tạo order
2. Lưu DB
3. Tạo payment transaction
4. Redirect gateway
5. Nhận callback
6. Verify signature
7. So sánh amount
8. Update order
9. Ghi log đầy đủ


============================================================
X. KIẾN TRÚC TỐT CHO HỆ THỐNG LỚN
============================================================

- Tách Payment Service riêng (microservice)
- Dùng message queue (Kafka / RabbitMQ)
- Retry mechanism
- Circuit breaker
- Monitoring + logging


============================================================
XI. TÓM TẮT BẢN CHẤT

Web thanh toán trong Java Spring là:

- Một hệ thống trung gian giữa user và payment gateway
- Có trách nhiệm tạo giao dịch
- Xác thực kết quả
- Đảm bảo tiền và đơn hàng khớp nhau
- Phải cực kỳ chú trọng bảo mật và tính nhất quán dữ liệu


============================================================

Nếu bạn muốn, tôi có thể đào sâu thêm:

- Code ví dụ tích hợp VNPay cụ thể
- Code ví dụ Stripe
- Xử lý idempotency chi tiết
- Transaction management trong Spring khi thanh toán
- Thiết kế chuẩn cho hệ thống thương mại điện tử lớn

Chỉ cần nói bạn muốn đào sâu phần nào.

--- CÁCH THIẾT LẬP TÀI KHOẢN GIT VỚI GIT BASH

CÁCH THIẾT LẬP TÀI KHOẢN GIT VỚI GIT BASH – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. GIT BASH LÀ GÌ?
=====================================================================

Git Bash là công cụ dòng lệnh đi kèm khi cài Git trên Windows.
Nó cho phép bạn:

- Sử dụng các lệnh Git
- Dùng các lệnh Linux cơ bản
- Kết nối với GitHub / GitLab / Bitbucket


=====================================================================
II. CÁC BƯỚC THIẾT LẬP TÀI KHOẢN GIT
=====================================================================

BƯỚC 1: KIỂM TRA ĐÃ CÀI GIT CHƯA

Mở Git Bash và gõ:

git --version

Nếu hiển thị phiên bản → Đã cài thành công


---------------------------------------------------------------------
BƯỚC 2: CẤU HÌNH USER NAME VÀ EMAIL
---------------------------------------------------------------------

Git yêu cầu cấu hình:
- user.name
- user.email

Thiết lập toàn cục (áp dụng cho tất cả project):

git config --global user.name "Nguyen Van A"
git config --global user.email "email@gmail.com"


Giải thích:

--global nghĩa là áp dụng cho toàn bộ máy.
Thông tin này sẽ được ghi vào file:

~/.gitconfig


---------------------------------------------------------------------
BƯỚC 3: KIỂM TRA CẤU HÌNH
---------------------------------------------------------------------

Xem toàn bộ config:

git config --list

Hoặc:

git config user.name
git config user.email


=====================================================================
III. KẾT NỐI VỚI GITHUB BẰNG SSH (KHÁUYẾN NGHỊ)
=====================================================================

Cách chuyên nghiệp và an toàn nhất là dùng SSH Key.


---------------------------------------------------------------------
BƯỚC 1: TẠO SSH KEY
---------------------------------------------------------------------

Gõ:

ssh-keygen -t ed25519 -C "email@gmail.com"

Nếu máy cũ không hỗ trợ ed25519:

ssh-keygen -t rsa -b 4096 -C "email@gmail.com"

Sau đó nhấn Enter liên tục để tạo key mặc định.

SSH key sẽ được lưu ở:

~/.ssh/


---------------------------------------------------------------------
BƯỚC 2: MỞ FILE PUBLIC KEY
---------------------------------------------------------------------

Gõ:

cat ~/.ssh/id_ed25519.pub

Hoặc nếu dùng RSA:

cat ~/.ssh/id_rsa.pub

Copy toàn bộ nội dung hiển thị.


---------------------------------------------------------------------
BƯỚC 3: THÊM SSH KEY VÀO GITHUB
---------------------------------------------------------------------

1. Đăng nhập GitHub
2. Vào Settings
3. Chọn "SSH and GPG keys"
4. Chọn "New SSH key"
5. Dán key vào
6. Save


---------------------------------------------------------------------
BƯỚC 4: KIỂM TRA KẾT NỐI
---------------------------------------------------------------------

Gõ:

ssh -T git@github.com

Nếu thành công sẽ hiện thông báo chào mừng.


=====================================================================
IV. KẾT NỐI BẰNG HTTPS (CÁCH ĐƠN GIẢN HƠN)
=====================================================================

Nếu không dùng SSH, có thể dùng HTTPS:

Khi clone:

git clone https://github.com/username/repo.git

Lần đầu push sẽ yêu cầu:
- Username
- Personal Access Token (không dùng password thường)


=====================================================================
V. THIẾT LẬP CHO 1 PROJECT RIÊNG
=====================================================================

Nếu muốn cấu hình user khác cho một project:

cd vao_thu_muc_project

git config user.name "Ten Khac"
git config user.email "email_khac@gmail.com"

Lệnh này KHÔNG có --global
→ Chỉ áp dụng cho project hiện tại


=====================================================================
VI. TẠO REPOSITORY MỚI
=====================================================================

1. Tạo thư mục project
2. Vào thư mục đó
3. Gõ:

git init

Git sẽ tạo thư mục ẩn .git


=====================================================================
VII. QUY TRÌNH CƠ BẢN SAU KHI THIẾT LẬP
=====================================================================

1. git init
2. git add .
3. git commit -m "first commit"
4. git remote add origin <url>
5. git push -u origin main


=====================================================================
VIII. FILE CẤU HÌNH QUAN TRỌNG
=====================================================================

1. ~/.gitconfig        → config global
2. .git/config         → config riêng project
3. ~/.ssh/             → chứa SSH key


=====================================================================
IX. TÓM TẮT

Để thiết lập tài khoản Git với Git Bash cần:

1. Cài Git
2. Cấu hình user.name và user.email
3. Tạo SSH key
4. Thêm SSH key vào GitHub
5. Kiểm tra kết nối
6. Clone / push bình thường


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- Sự khác nhau giữa SSH và HTTPS
- Cơ chế hoạt động của SSH key
- Git config hoạt động bên trong như thế nào
- Quy trình chuẩn khi làm việc nhóm với Git
- Cách xử lý lỗi thường gặp khi push

Chỉ cần nói bạn muốn đào sâu phần nào.

--- CÁCH XEM THÔNG TIN ĐĂNG NHẬP Ở GIT

CÁCH XEM THÔNG TIN ĐĂNG NHẬP Ở GIT – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. LƯU Ý QUAN TRỌNG TRƯỚC KHI HIỂU
=====================================================================

Git KHÔNG có khái niệm “đăng nhập” như Facebook hay Gmail.

Git chỉ lưu:
- user.name
- user.email

Còn việc xác thực khi push/pull với GitHub/GitLab sẽ thông qua:
- SSH key
hoặc
- HTTPS + Token

Vì vậy cần phân biệt 3 loại thông tin:

1) Thông tin commit (user.name, user.email)
2) Thông tin remote repository
3) Thông tin xác thực (SSH hoặc Token)


=====================================================================
II. XEM USER.NAME VÀ USER.EMAIL (THÔNG TIN COMMIT)
=====================================================================

1) Xem user toàn cục (global)

git config --global user.name
git config --global user.email


2) Xem user của project hiện tại

git config user.name
git config user.email


3) Xem toàn bộ cấu hình

git config --list


4) Xem file cấu hình trực tiếp

Global config nằm tại:
~/.gitconfig

Project config nằm tại:
.git/config


=====================================================================
III. XEM REMOTE ĐANG KẾT NỐI TỚI ĐÂU
=====================================================================

Trong thư mục project, gõ:

git remote -v

Kết quả sẽ hiển thị:

origin  git@github.com:username/repo.git (fetch)
origin  git@github.com:username/repo.git (push)

Hoặc:

origin  https://github.com/username/repo.git

Từ đây bạn biết:
- Đang kết nối tài khoản GitHub nào
- Đang dùng SSH hay HTTPS


=====================================================================
IV. XEM SSH KEY ĐANG DÙNG
=====================================================================

1) Kiểm tra file SSH key

ls ~/.ssh/

Thông thường sẽ có:
- id_ed25519
- id_ed25519.pub
hoặc
- id_rsa
- id_rsa.pub


2) Xem nội dung public key

cat ~/.ssh/id_ed25519.pub


3) Kiểm tra kết nối SSH

ssh -T git@github.com

Nếu thành công sẽ hiện thông báo chào mừng.


=====================================================================
V. XEM CREDENTIAL (HTTPS TOKEN) ĐANG LƯU
=====================================================================

Nếu dùng HTTPS, Git có thể lưu credential trong:

Windows:
Control Panel → Credential Manager → Windows Credentials

Tìm mục liên quan đến:
git:https://github.com


Hoặc dùng lệnh:

git config --list | grep credential


=====================================================================
VI. XEM AI ĐÃ COMMIT GẦN NHẤT
=====================================================================

Trong project:

git log

Hoặc:

git log -1

Sẽ hiển thị:

Author: Nguyen Van A <email@gmail.com>

Đây là thông tin commit, không phải thông tin đăng nhập.


=====================================================================
VII. TÓM TẮT

Để xem "thông tin đăng nhập Git", bạn cần hiểu:

1) Git không lưu tài khoản đăng nhập như web
2) Git chỉ lưu:
   - user.name
   - user.email
3) Xác thực thực sự dựa vào:
   - SSH key
   - Token (HTTPS)

Các lệnh quan trọng:

git config --list
git remote -v
git log -1
ssh -T git@github.com


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- Git lưu credential bên trong như thế nào
- Sự khác nhau giữa user.email và tài khoản GitHub
- Cách đổi tài khoản Git trên cùng một máy
- Cách sử dụng nhiều tài khoản GitHub trên một máy

Chỉ cần nói bạn muốn đào sâu phần nào.

--- HƯỚNG DẪN ĐĂNG NHẬP TÀI KHOẢN GIT BẰNG GIT BASH

HƯỚNG DẪN ĐĂNG NHẬP TÀI KHOẢN GIT BẰNG GIT BASH – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. HIỂU ĐÚNG: GIT KHÔNG CÓ LỆNH "LOGIN"
=====================================================================

Git KHÔNG có lệnh:

git login

Git chỉ yêu cầu xác thực khi bạn thực hiện:
- git clone
- git pull
- git push

Việc "đăng nhập" xảy ra khi Git cần xác thực với GitHub/GitLab.

Hiện nay GitHub KHÔNG cho phép dùng password thường.
Bạn phải dùng:

- Personal Access Token (HTTPS)
hoặc
- SSH key (khuyến nghị)


=====================================================================
II. CÁCH 1 – ĐĂNG NHẬP BẰNG HTTPS (DÙNG TOKEN)
=====================================================================

BƯỚC 1: TẠO PERSONAL ACCESS TOKEN TRÊN GITHUB

1. Đăng nhập GitHub trên web
2. Vào Settings
3. Chọn Developer Settings
4. Chọn Personal Access Tokens
5. Generate new token (classic)
6. Chọn quyền repo
7. Generate
8. Copy token (CHỈ HIỂN THỊ 1 LẦN)


------------------------------------------------------------
BƯỚC 2: CLONE HOẶC PUSH BẰNG HTTPS
------------------------------------------------------------

Ví dụ clone:

git clone https://github.com/username/repo.git


Khi Git hỏi:

Username:

→ nhập username GitHub

Password:

→ DÁN TOKEN (không phải password thường)


------------------------------------------------------------
BƯỚC 3: LƯU CREDENTIAL
------------------------------------------------------------

Để Git lưu thông tin đăng nhập:

git config --global credential.helper manager

Lần sau sẽ không cần nhập lại.


=====================================================================
III. CÁCH 2 – ĐĂNG NHẬP BẰNG SSH (CHUYÊN NGHIỆP HƠN)
=====================================================================

Cách này KHÔNG cần nhập username/password mỗi lần.


------------------------------------------------------------
BƯỚC 1: TẠO SSH KEY
------------------------------------------------------------

ssh-keygen -t ed25519 -C "email@gmail.com"

Nhấn Enter liên tục.

SSH key sẽ được tạo tại:

~/.ssh/


------------------------------------------------------------
BƯỚC 2: COPY PUBLIC KEY
------------------------------------------------------------

cat ~/.ssh/id_ed25519.pub

Copy toàn bộ nội dung hiển thị.


------------------------------------------------------------
BƯỚC 3: THÊM VÀO GITHUB
------------------------------------------------------------

1. Vào GitHub
2. Settings
3. SSH and GPG keys
4. New SSH key
5. Dán key
6. Save


------------------------------------------------------------
BƯỚC 4: KIỂM TRA KẾT NỐI
------------------------------------------------------------

ssh -T git@github.com

Nếu thành công sẽ hiện thông báo chào mừng.


------------------------------------------------------------
BƯỚC 5: DÙNG SSH KHI CLONE
------------------------------------------------------------

git clone git@github.com:username/repo.git


=====================================================================
IV. CẤU HÌNH USER NAME VÀ EMAIL (KHÔNG PHẢI LOGIN)
=====================================================================

Cần thiết lập:

git config --global user.name "Ten cua ban"
git config --global user.email "email@gmail.com"

Đây chỉ là thông tin hiển thị khi commit,
không phải thông tin đăng nhập.


=====================================================================
V. TÓM TẮT QUAN TRỌNG

1) Git không có lệnh login
2) GitHub không cho dùng password thường
3) Phải dùng:
   - Token (HTTPS)
   hoặc
   - SSH key (khuyên dùng)

Cách đơn giản nhất:

git clone https://github.com/username/repo.git
→ nhập username
→ nhập TOKEN làm password


=====================================================================

Nếu bạn muốn, tôi có thể hướng dẫn:

- Cách đăng nhập 2 tài khoản GitHub trên cùng một máy
- Cách xóa tài khoản Git đã lưu
- Cách đổi tài khoản đang dùng
- Cách kiểm tra đang dùng SSH hay HTTPS

Chỉ cần nói bạn muốn đào sâu phần nào.

--- class A implements Controller

VÍ DỤ: class A implements Controller – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. HIỂU "implements" TRONG JAVA LÀ GÌ?
=====================================================================

Trong Java:

implements dùng để:
→ Một class thực thi (implement) một interface.

Khi một class implements một interface:
→ Class đó BẮT BUỘC phải override tất cả các method
   được khai báo trong interface.

Ví dụ cơ bản:

interface Animal {
    void sound();
}

class Dog implements Animal {
    @Override
    public void sound() {
        System.out.println("Gau gau");
    }
}

Ở đây:
- Animal là interface
- Dog implements Animal
- Dog phải viết lại method sound()


=====================================================================
II. CONTROLLER LÀ GÌ TRONG SPRING?
=====================================================================

Trong Spring MVC:

Controller là thành phần xử lý request HTTP.

Có 2 kiểu:

1) Dùng annotation:
   @Controller
   @RestController

2) Implement interface Controller (kiểu cũ của Spring)


=====================================================================
III. VÍ DỤ: class A implements Controller (SPRING MVC CỔ ĐIỂN)
=====================================================================

Interface Controller thuộc package:

org.springframework.web.servlet.mvc.Controller

Nó khai báo method:

ModelAndView handleRequest(
    HttpServletRequest request,
    HttpServletResponse response
)


------------------------------------------------------------
VÍ DỤ CODE
------------------------------------------------------------

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

public class A implements Controller {

    @Override
    public ModelAndView handleRequest(
            HttpServletRequest request,
            HttpServletResponse response) throws Exception {

        String name = request.getParameter("name");

        ModelAndView mv = new ModelAndView();
        mv.setViewName("hello");
        mv.addObject("username", name);

        return mv;
    }
}


=====================================================================
IV. GIẢI THÍCH TỪNG PHẦN
=====================================================================

1) class A implements Controller

Nghĩa là:
- A là một controller trong Spring MVC
- A phải override method handleRequest()


------------------------------------------------------------

2) handleRequest()

Đây là method bắt buộc của interface Controller.

Spring sẽ gọi method này khi có request HTTP gửi đến.


------------------------------------------------------------

3) HttpServletRequest request

Dùng để:
- Lấy parameter
- Lấy header
- Lấy body
- Lấy thông tin session


------------------------------------------------------------

4) HttpServletResponse response

Dùng để:
- Set status code
- Set header
- Ghi dữ liệu trả về


------------------------------------------------------------

5) ModelAndView

Dùng để:
- Chỉ định view (trang JSP/HTML)
- Truyền dữ liệu sang view

mv.setViewName("hello");

→ Spring sẽ render file hello.jsp hoặc hello.html

mv.addObject("username", name);

→ Truyền dữ liệu sang view


=====================================================================
V. LUỒNG HOẠT ĐỘNG
=====================================================================

1) User gửi request:
   http://localhost:8080/a?name=An

2) DispatcherServlet nhận request

3) Spring tìm controller phù hợp

4) Gọi:
   A.handleRequest()

5) Trả về ModelAndView

6) Spring render view hello


=====================================================================
VI. SO SÁNH VỚI CÁCH HIỆN ĐẠI (@RestController)
=====================================================================

Ngày nay thường viết:

@RestController
@RequestMapping("/a")
public class A {

    @GetMapping
    public String hello(@RequestParam String name) {
        return "Hello " + name;
    }
}

Ưu điểm:
- Ngắn gọn
- Dễ đọc
- Không cần implements Controller


=====================================================================
VII. KHI NÀO DÙNG implements Controller?
=====================================================================

Hiện nay:
- Rất hiếm khi dùng
- Chủ yếu trong project cũ (Spring 2.x, 3.x)

Spring hiện đại khuyến nghị dùng annotation-based controller.


=====================================================================
VIII. TÓM TẮT BẢN CHẤT

class A implements Controller nghĩa là:

- A là một class thực thi interface Controller
- Bắt buộc phải override handleRequest()
- Spring sẽ gọi method này khi có HTTP request
- Trả về ModelAndView để render view

Đây là cách viết controller kiểu cũ trong Spring MVC.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- DispatcherServlet hoạt động thế nào bên trong
- ModelAndView thực sự hoạt động ra sao
- Sự khác nhau giữa @Controller và @RestController
- Cơ chế mapping URL trong Spring MVC

Chỉ cần nói bạn muốn đào sâu phần nào.

--- CÁCH "class A implements Controller" CÓ DÙNG URL TRONG CONTROLLER KHÔNG?

CÁCH "class A implements Controller" CÓ DÙNG URL TRONG CONTROLLER KHÔNG?

=====================================================================
I. TRẢ LỜI NGẮN GỌN
=====================================================================

ĐÚNG.
Khi dùng:

class A implements Controller

→ Bạn KHÔNG khai báo URL trực tiếp trong class.

URL sẽ được cấu hình ở file cấu hình Spring (XML hoặc Java Config),
không nằm trong controller như @RequestMapping.


=====================================================================
II. TẠI SAO KHÔNG CÓ URL TRONG CLASS?
=====================================================================

Vì đây là cách viết Spring MVC kiểu cũ (trước annotation).

Controller chỉ xử lý logic.
Còn mapping URL → controller được cấu hình bên ngoài.


=====================================================================
III. URL ĐƯỢC KHAI BÁO Ở ĐÂU?
=====================================================================

1) Nếu dùng XML config

Ví dụ file: servlet-context.xml


<bean name="/hello" class="com.example.A"/>

Ở đây:

name="/hello"
→ chính là URL

class="com.example.A"
→ là controller sẽ xử lý URL đó


Khi user truy cập:

http://localhost:8080/hello

→ Spring gọi A.handleRequest()


------------------------------------------------------------
2) Nếu dùng SimpleUrlHandlerMapping
------------------------------------------------------------

<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
    <property name="mappings">
        <props>
            <prop key="/hello">aController</prop>
        </props>
    </property>
</bean>

<bean id="aController" class="com.example.A"/>

Ở đây:

/hello → ánh xạ đến bean aController


=====================================================================
IV. SO SÁNH VỚI CÁCH HIỆN ĐẠI
=====================================================================

Cách cũ:

URL được khai báo trong XML:

<bean name="/hello" class="A"/>


Cách mới:

@RestController
@RequestMapping("/hello")
public class A {

}

URL nằm trực tiếp trong class.


=====================================================================
V. LUỒNG HOẠT ĐỘNG KIỂU CŨ
=====================================================================

1) User gọi:
   /hello

2) DispatcherServlet nhận request

3) HandlerMapping tìm bean có name="/hello"

4) Tìm thấy class A

5) Gọi method:
   handleRequest()

6) Trả về ModelAndView


=====================================================================
VI. TẠI SAO CÁCH CŨ BỊ THAY THẾ?
=====================================================================

Vì:

- Phải cấu hình XML dài dòng
- Khó đọc
- Không trực quan
- Khó bảo trì

Annotation giúp:

- Nhìn vào class là biết URL
- Dễ hiểu hơn
- Code gọn hơn


=====================================================================
VII. KẾT LUẬN

Với:

class A implements Controller

→ KHÔNG có @RequestMapping
→ KHÔNG có URL trong class
→ URL được cấu hình bên ngoài (XML hoặc Java config)

Đây là cách làm cũ của Spring MVC.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- DispatcherServlet tìm controller như thế nào
- HandlerMapping hoạt động bên trong ra sao
- So sánh chi tiết giữa cách cũ và cách annotation
- Cơ chế mapping URL nội bộ của Spring

Chỉ cần nói bạn muốn đào sâu phần nào.

--- HƯỚNG DẪN START SOURCE CODE MVC TRÊN INTELLIJ VÀ ECLIPSE

HƯỚNG DẪN START SOURCE CODE MVC TRÊN INTELLIJ VÀ ECLIPSE – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. TRƯỚC KHI START – CẦN XÁC ĐỊNH LOẠI MVC
=====================================================================

Có 2 trường hợp phổ biến:

1) Spring Boot MVC (phổ biến nhất hiện nay)
2) Spring MVC truyền thống (chạy bằng Tomcat)

Bạn phải xác định project của bạn thuộc loại nào.


=====================================================================
II. TRƯỜNG HỢP 1: SPRING BOOT MVC
=====================================================================

Đặc điểm:
- Có file pom.xml hoặc build.gradle
- Có class main có @SpringBootApplication
- Có method main()

Ví dụ:

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}


------------------------------------------------------------
A. START TRÊN INTELLIJ
------------------------------------------------------------

BƯỚC 1: MỞ PROJECT

File → Open → Chọn thư mục project


BƯỚC 2: IMPORT MAVEN/GRADLE

Nếu có pom.xml:
→ IntelliJ sẽ hỏi Import Maven project → chọn Yes

Nếu không tự import:
→ Chuột phải pom.xml → Add as Maven Project


BƯỚC 3: CHẠY APPLICATION

Cách 1:
- Mở class có @SpringBootApplication
- Nhấn nút Run (biểu tượng tam giác)

Cách 2:
- Mở Maven tool window
- Vào lifecycle
- Double click spring-boot:run


BƯỚC 4: KIỂM TRA SERVER

Nếu chạy thành công sẽ thấy log:

Tomcat started on port 8080

Mở trình duyệt:
http://localhost:8080


------------------------------------------------------------
B. START TRÊN ECLIPSE
------------------------------------------------------------

BƯỚC 1: IMPORT PROJECT

File → Import → Maven → Existing Maven Project
→ Chọn thư mục chứa pom.xml


BƯỚC 2: CHẠY PROJECT

Cách 1:
- Chuột phải class có main()
- Run As → Java Application

Cách 2:
- Chuột phải project
- Run As → Maven Build
- Goals: spring-boot:run


BƯỚC 3: KIỂM TRA

Vào:
http://localhost:8080


=====================================================================
III. TRƯỜNG HỢP 2: SPRING MVC TRUYỀN THỐNG (WAR + TOMCAT)
=====================================================================

Đặc điểm:

- Có web.xml
- Có servlet-context.xml
- Đóng gói dạng WAR
- Không có @SpringBootApplication


------------------------------------------------------------
A. START TRÊN INTELLIJ
------------------------------------------------------------

BƯỚC 1: IMPORT PROJECT (Maven)

File → Open → chọn project


BƯỚC 2: CẤU HÌNH TOMCAT

File → Settings → Plugins
→ Cài Tomcat nếu chưa có

Sau đó:

Run → Edit Configurations
→ Add new configuration
→ Tomcat Server → Local


BƯỚC 3: CHỈ ĐỊNH WAR ARTIFACT

Trong tab Deployment:
→ Add artifact
→ Chọn war exploded


BƯỚC 4: CHẠY SERVER

Nhấn Run

Truy cập:
http://localhost:8080/project-name


------------------------------------------------------------
B. START TRÊN ECLIPSE
------------------------------------------------------------

BƯỚC 1: CÀI TOMCAT

Window → Preferences → Server → Runtime Environments
→ Add → Apache Tomcat


BƯỚC 2: ADD PROJECT VÀO SERVER

Window → Show View → Servers
→ Chuột phải → New Server
→ Chọn Tomcat
→ Add project vào


BƯỚC 3: START SERVER

Chuột phải server → Start

Truy cập:
http://localhost:8080/project-name


=====================================================================
IV. CÁC LỖI THƯỜNG GẶP
=====================================================================

1) Port 8080 bị chiếm

Giải pháp:
- Đổi port trong application.properties:

server.port=9090


2) Missing dependencies

Giải pháp:
- Maven → Reload project
- mvn clean install


3) Không load được view

Kiểm tra:
- prefix / suffix trong cấu hình view resolver


=====================================================================
V. CÁCH KIỂM TRA PROJECT LÀ BOOT HAY TRUYỀN THỐNG
=====================================================================

Nếu có:
@SpringBootApplication
→ Là Spring Boot

Nếu có:
web.xml
→ Là Spring MVC truyền thống


=====================================================================
VI. TÓM TẮT

Spring Boot:
→ Run class main()

Spring MVC truyền thống:
→ Deploy lên Tomcat

IntelliJ:
→ Run trực tiếp hoặc cấu hình Tomcat

Eclipse:
→ Run As Java Application hoặc Server


=====================================================================

Nếu bạn muốn, tôi có thể hướng dẫn thêm:

- Cấu trúc chuẩn của project MVC
- Cách debug từng bước trong IntelliJ
- Cách cấu hình database
- Cách build file WAR/JAR để deploy

Chỉ cần nói bạn muốn đào sâu phần nào.

--- web.xml TRONG ỨNG DỤNG JAVA WEB

GIẢI THÍCH CHI TIẾT VỀ FILE web.xml TRONG ỨNG DỤNG JAVA WEB

=====================================================================
I. web.xml LÀ GÌ?
=====================================================================

web.xml là file cấu hình của Java Web Application (Servlet-based).

Tên đầy đủ:
Deployment Descriptor

Nó dùng để:

- Cấu hình servlet
- Mapping URL
- Cấu hình filter
- Cấu hình listener
- Cấu hình session
- Cấu hình welcome file
- Cấu hình error page

File này nằm trong:

WEB-INF/web.xml


=====================================================================
II. web.xml HOẠT ĐỘNG NHƯ THẾ NÀO?
=====================================================================

Khi server (Tomcat, Jetty...) khởi động:

1) Đọc file web.xml
2) Khởi tạo các servlet
3) Tạo mapping URL
4) Khởi tạo filter
5) Chuẩn bị môi trường web

Tóm lại:
web.xml là bản đồ cấu hình của toàn bộ ứng dụng web.


=====================================================================
III. CẤU TRÚC CƠ BẢN CỦA web.xml
=====================================================================

Ví dụ đơn giản:

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         version="3.1">

    <display-name>MyApp</display-name>

    <servlet>
        <servlet-name>helloServlet</servlet-name>
        <servlet-class>com.example.HelloServlet</servlet-class>
    </servlet>

    <servlet-mapping>
        <servlet-name>helloServlet</servlet-name>
        <url-pattern>/hello</url-pattern>
    </servlet-mapping>

</web-app>


=====================================================================
IV. GIẢI THÍCH TỪNG THÀNH PHẦN
=====================================================================

1) <web-app>

Là thẻ gốc (root element) của web.xml.


------------------------------------------------------------
2) <servlet>
------------------------------------------------------------

Khai báo một servlet.

<servlet>
    <servlet-name>helloServlet</servlet-name>
    <servlet-class>com.example.HelloServlet</servlet-class>
</servlet>

Giải thích:

- servlet-name: tên định danh nội bộ
- servlet-class: class xử lý request


------------------------------------------------------------
3) <servlet-mapping>
------------------------------------------------------------

Mapping URL với servlet.

<servlet-mapping>
    <servlet-name>helloServlet</servlet-name>
    <url-pattern>/hello</url-pattern>
</servlet-mapping>

Khi user truy cập:

http://localhost:8080/hello

→ HelloServlet sẽ xử lý


=====================================================================
V. FILTER TRONG web.xml
=====================================================================

Filter dùng để:

- Kiểm tra login
- Logging
- Encoding
- Bảo mật

Ví dụ:

<filter>
    <filter-name>authFilter</filter-name>
    <filter-class>com.example.AuthFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>authFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

Nghĩa là:
Mọi request đều đi qua AuthFilter trước.


=====================================================================
VI. LISTENER TRONG web.xml
=====================================================================

Listener lắng nghe sự kiện:

- Application start
- Session create
- Session destroy

Ví dụ:

<listener>
    <listener-class>com.example.MyListener</listener-class>
</listener>


=====================================================================
VII. CẤU HÌNH SESSION
=====================================================================

<session-config>
    <session-timeout>30</session-timeout>
</session-config>

Nghĩa là:
Session hết hạn sau 30 phút không hoạt động.


=====================================================================
VIII. WELCOME FILE
=====================================================================

<welcome-file-list>
    <welcome-file>index.jsp</welcome-file>
</welcome-file-list>

Khi truy cập:

http://localhost:8080/

→ Tự động mở index.jsp


=====================================================================
IX. ERROR PAGE
=====================================================================

<error-page>
    <error-code>404</error-code>
    <location>/error404.jsp</location>
</error-page>

Khi xảy ra lỗi 404:
→ Chuyển đến error404.jsp


=====================================================================
X. web.xml TRONG SPRING MVC
=====================================================================

Ví dụ phổ biến:

<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>

DispatcherServlet là trung tâm của Spring MVC.


=====================================================================
XI. load-on-startup LÀ GÌ?
=====================================================================

<load-on-startup>1</load-on-startup>

Nghĩa là:
Servlet được khởi tạo ngay khi server start.

Nếu không có:
Servlet chỉ được tạo khi có request đầu tiên.


=====================================================================
XII. TỪ JAVA EE 6 TRỞ LÊN
=====================================================================

Có thể dùng annotation thay cho web.xml:

@WebServlet("/hello")

@WebFilter("/*")

@WebListener

Khi đó web.xml có thể bỏ trống hoặc không cần nữa.


=====================================================================
XIII. TẠI SAO web.xml ÍT DÙNG HIỆN NAY?
=====================================================================

Vì:

- Annotation dễ đọc hơn
- Spring Boot tự cấu hình
- Không cần XML dài dòng


=====================================================================
XIV. TÓM TẮT

web.xml là:

- File cấu hình chính của Java Web Application
- Định nghĩa servlet
- Mapping URL
- Cấu hình filter
- Cấu hình session
- Cấu hình error page

Trong Spring Boot hiện đại:
→ Gần như không còn dùng web.xml


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- DispatcherServlet hoạt động chi tiết thế nào
- Filter chain bên trong server
- So sánh web.xml và annotation
- Cơ chế khởi động Tomcat khi đọc web.xml

Chỉ cần nói bạn muốn đào sâu phần nào.

--- CHẠY TRÊN NGINX LÀ CHỈ CHO FRONTEND ĐÚNG KHÔNG?

"CHẠY TRÊN NGINX LÀ CHỈ CHO FRONTEND ĐÚNG KHÔNG?" – GIẢI THÍCH CHI TIẾT NHẤT

=====================================================================
I. TRẢ LỜI NGẮN GỌN
=====================================================================

KHÔNG.

Nginx KHÔNG chỉ dùng cho frontend.

Nginx có thể:

1) Phục vụ frontend (static file)
2) Làm reverse proxy cho backend
3) Load balancing nhiều server
4) Làm SSL termination
5) Làm gateway trung gian


=====================================================================
II. NGINX LÀ GÌ?
=====================================================================

Nginx là:

- Web server
- Reverse proxy server
- Load balancer
- HTTP server rất nhẹ và hiệu năng cao

Nó có thể:

- Trả file HTML, CSS, JS
- Chuyển tiếp request đến backend (Spring, Node, PHP...)


=====================================================================
III. TRƯỜNG HỢP 1: NGINX CHỈ CHẠY FRONTEND
=====================================================================

Ví dụ bạn có:

Frontend:
React build ra thư mục dist/

Khi đó Nginx cấu hình:

server {
    listen 80;
    server_name example.com;

    root /var/www/frontend/dist;
    index index.html;
}

Khi user truy cập:
example.com

→ Nginx trả file index.html
→ Trả CSS, JS

Trong trường hợp này:
ĐÚNG, Nginx chỉ phục vụ frontend.


=====================================================================
IV. TRƯỜNG HỢP 2: NGINX LÀM REVERSE PROXY CHO BACKEND
=====================================================================

Ví dụ backend Spring Boot chạy ở:

localhost:8080

Nginx cấu hình:

server {
    listen 80;

    location / {
        proxy_pass http://localhost:8080;
    }
}

Khi user gọi:
example.com/api/users

→ Nginx nhận request
→ Chuyển tiếp đến backend
→ Backend xử lý
→ Nginx trả lại kết quả

Ở đây:
Nginx KHÔNG phải frontend.
Nó chỉ là trung gian.


=====================================================================
V. TRƯỜNG HỢP 3: NGINX VỪA FRONTEND VỪA BACKEND
=====================================================================

Ví dụ cấu hình thực tế:

server {
    listen 80;

    # Frontend
    location / {
        root /var/www/frontend;
        try_files $uri /index.html;
    }

    # Backend API
    location /api/ {
        proxy_pass http://localhost:8080;
    }
}

Khi user truy cập:

/        → trả frontend
/api/... → chuyển về backend

Đây là mô hình rất phổ biến.


=====================================================================
VI. NGINX CÓ CHẠY ĐƯỢC CODE JAVA KHÔNG?
=====================================================================

KHÔNG.

Nginx không chạy được:

- Java
- Spring Boot
- NodeJS
- PHP (trực tiếp)

Nginx chỉ:

- Trả file
- Hoặc chuyển tiếp request

Java phải chạy bằng:

- Tomcat
- Jetty
- Embedded Tomcat (Spring Boot)


=====================================================================
VII. KIẾN TRÚC THỰC TẾ PHỔ BIẾN
=====================================================================

User → Nginx → Backend (Spring Boot)

Hoặc:

User → Nginx → Load Balancer → Nhiều Backend


=====================================================================
VIII. TẠI SAO CẦN NGINX TRƯỚC BACKEND?
=====================================================================

Vì Nginx:

- Nhẹ hơn
- Xử lý static file nhanh
- Bảo vệ backend
- Giảm tải backend
- Quản lý SSL (HTTPS)
- Hạn chế DDOS


=====================================================================
IX. SO SÁNH VAI TRÒ

Frontend:
- React, Angular
- HTML/CSS/JS

Backend:
- Spring Boot
- NodeJS
- PHP

Nginx:
- Không phải frontend
- Không phải backend
- Là server trung gian


=====================================================================
X. KẾT LUẬN

"Chạy trên Nginx có phải chỉ cho frontend?"

→ Không đúng hoàn toàn.

Nginx có thể:

1) Chỉ phục vụ frontend
2) Chỉ làm proxy cho backend
3) Vừa phục vụ frontend vừa proxy backend

Nginx là tầng trung gian trong kiến trúc web hiện đại.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- Kiến trúc triển khai Spring Boot + Nginx chi tiết
- SSL hoạt động qua Nginx thế nào
- Cấu hình Nginx thực tế cho production
- So sánh Nginx và Apache
- Cách deploy frontend React lên Nginx

Chỉ cần nói bạn muốn đào sâu phần nào.

--- .tomcatplugin

GIẢI THÍCH CHI TIẾT VỀ FILE .tomcatplugin

=====================================================================
I. .tomcatplugin LÀ GÌ?
=====================================================================

.tomcatplugin là một file cấu hình được tạo ra khi sử dụng
plugin Tomcat trong IDE (thường là Eclipse).

Nó KHÔNG phải file chuẩn của Java.
Nó KHÔNG thuộc Tomcat gốc.
Nó là file cấu hình nội bộ của plugin.

Mục đích:
→ Lưu thông tin cấu hình server Tomcat cho project trong IDE.


=====================================================================
II. FILE NÀY XUẤT HIỆN KHI NÀO?
=====================================================================

File .tomcatplugin thường xuất hiện khi:

- Bạn dùng Eclipse
- Bạn cài Tomcat Plugin
- Bạn cấu hình project để chạy trên Tomcat

Plugin sẽ tạo file này để lưu:

- Port
- Context path
- Cấu hình deploy
- Thông tin server


=====================================================================
III. VỊ TRÍ FILE .tomcatplugin
=====================================================================

Thông thường nằm trong thư mục project:

project-name/.tomcatplugin


=====================================================================
IV. NỘI DUNG FILE .tomcatplugin
=====================================================================

Nội dung thường là XML.

Ví dụ minh họa:

<?xml version="1.0" encoding="UTF-8"?>
<tomcatplugin>
    <tomcatDir>C:/apache-tomcat-9.0.80</tomcatDir>
    <contextPath>/myapp</contextPath>
    <serverPort>8080</serverPort>
    <adminPort>8005</adminPort>
    <deployDir>webapps</deployDir>
</tomcatplugin>


Giải thích:

tomcatDir     → đường dẫn đến Tomcat
contextPath   → đường dẫn truy cập app
serverPort    → port HTTP
adminPort     → port shutdown
deployDir     → thư mục deploy


=====================================================================
V. FILE NÀY CÓ BẮT BUỘC KHÔNG?
=====================================================================

KHÔNG.

Nếu bạn:

- Chạy project bằng IntelliJ
- Hoặc deploy WAR thủ công
- Hoặc dùng Spring Boot embedded Tomcat

→ Không cần file này.

Nó chỉ phục vụ IDE cụ thể.


=====================================================================
VI. KHÁC GÌ VỚI web.xml?
=====================================================================

web.xml:
- Là file chuẩn Java EE
- Server bắt buộc phải đọc

.tomcatplugin:
- Chỉ IDE dùng
- Tomcat thật không đọc file này


=====================================================================
VII. CÓ NÊN ĐƯA .tomcatplugin LÊN GIT KHÔNG?
=====================================================================

Thông thường: KHÔNG nên.

Vì:

- Chỉ liên quan môi trường cá nhân
- Mỗi người có đường dẫn Tomcat khác nhau
- Có thể gây xung đột

Thường thêm vào .gitignore


=====================================================================
VIII. KHI NÀO CÓ THỂ XÓA FILE NÀY?
=====================================================================

Bạn có thể xóa nếu:

- Không dùng plugin Tomcat nữa
- Chuyển sang Spring Boot
- Dùng server ngoài IDE

Xóa file này không ảnh hưởng logic ứng dụng.


=====================================================================
IX. TÓM TẮT

.tomcatplugin là:

- File cấu hình của plugin Tomcat trong IDE
- Không phải file chuẩn của Java
- Không bắt buộc
- Không được Tomcat server đọc
- Chỉ dùng để IDE biết cách start server

Nó chỉ là file hỗ trợ môi trường phát triển.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- Cách Eclipse quản lý server nội bộ
- Khác nhau giữa Tomcat plugin và Tomcat runtime
- Cách deploy WAR thủ công lên Tomcat
- Cách Spring Boot embedded Tomcat hoạt động

Chỉ cần nói bạn muốn đào sâu phần nào.

--- config.properties

GIẢI THÍCH CHI TIẾT VỀ FILE config.properties

=====================================================================
I. config.properties LÀ GÌ?
=====================================================================

config.properties là một file cấu hình dạng key = value.

Nó thường được dùng trong ứng dụng Java để:

- Lưu cấu hình hệ thống
- Lưu thông tin database
- Lưu thông tin API
- Lưu biến môi trường
- Lưu tham số tùy chỉnh

File này KHÔNG phải file bắt buộc của Java.
Nó chỉ là một file cấu hình do lập trình viên tạo ra.


=====================================================================
II. CẤU TRÚC CỦA FILE properties
=====================================================================

Cú pháp cơ bản:

key=value

Ví dụ:

server.port=8080
db.url=jdbc:mysql://localhost:3306/mydb
db.username=root
db.password=123456
app.name=MyApplication

Đặc điểm:

- Mỗi dòng là một cấu hình
- Không có thẻ XML
- Không có dấu ngoặc {}
- Đơn giản, dễ đọc


=====================================================================
III. VỊ TRÍ FILE config.properties
=====================================================================

Trong project Java thường nằm tại:

src/main/resources/config.properties

Khi build project, file này sẽ nằm trong classpath.


=====================================================================
IV. CÁCH ĐỌC FILE config.properties TRONG JAVA
=====================================================================

Cách phổ biến dùng class Properties.

Ví dụ:

import java.io.InputStream;
import java.util.Properties;

public class ConfigLoader {

    public static void main(String[] args) throws Exception {

        Properties prop = new Properties();

        InputStream input = 
            ConfigLoader.class.getClassLoader()
                .getResourceAsStream("config.properties");

        prop.load(input);

        String url = prop.getProperty("db.url");
        System.out.println(url);
    }
}

Giải thích:

1) Tạo đối tượng Properties
2) Load file từ classpath
3) Dùng getProperty("key") để lấy giá trị


=====================================================================
V. CÁCH DÙNG TRONG SPRING
=====================================================================

Nếu là Spring Boot, thường dùng:

application.properties

Nhưng nếu là config.properties riêng, có thể dùng:

@PropertySource("classpath:config.properties")

Ví dụ:

@Configuration
@PropertySource("classpath:config.properties")
public class AppConfig {

    @Value("${db.url}")
    private String dbUrl;

}

Spring sẽ tự inject giá trị.


=====================================================================
VI. PHÂN BIỆT config.properties VÀ application.properties
=====================================================================

config.properties:
- Tên tự đặt
- Không có ý nghĩa đặc biệt với Spring Boot

application.properties:
- Tên chuẩn của Spring Boot
- Được Spring Boot tự động load


=====================================================================
VII. KHI NÀO DÙNG config.properties?
=====================================================================

Thường dùng khi:

- Project Java thuần (không Spring Boot)
- Muốn tách config riêng
- Muốn có nhiều file cấu hình

Ví dụ:

config-dev.properties
config-prod.properties


=====================================================================
VIII. CÁCH GHI FILE properties
=====================================================================

Ví dụ ghi file:

import java.io.FileOutputStream;
import java.util.Properties;

public class WriteConfig {

    public static void main(String[] args) throws Exception {

        Properties prop = new Properties();
        prop.setProperty("name", "Tuan");
        prop.setProperty("env", "dev");

        prop.store(new FileOutputStream("config.properties"), null);
    }
}


=====================================================================
IX. LƯU Ý QUAN TRỌNG

1) Không nên lưu password thật trong git
2) Nên dùng biến môi trường cho production
3) Có thể dùng mã hóa nếu chứa dữ liệu nhạy cảm
4) Không để khoảng trắng sai cú pháp


=====================================================================
X. ƯU ĐIỂM CỦA FILE properties

- Nhẹ
- Dễ đọc
- Dễ sửa
- Không cần parser phức tạp
- Hỗ trợ sẵn trong Java


=====================================================================
XI. HẠN CHẾ

- Không hỗ trợ cấu trúc phức tạp như JSON/YAML
- Không hỗ trợ nested object tốt
- Không phù hợp cấu hình lớn


=====================================================================
XII. TÓM TẮT

config.properties là:

- File cấu hình dạng key=value
- Không bắt buộc của Java
- Dùng để lưu thông tin cấu hình hệ thống
- Có thể đọc bằng class Properties
- Có thể tích hợp với Spring

Nó giúp tách cấu hình khỏi code.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- So sánh properties và YAML
- Cách Spring Boot load nhiều profile
- Cách mã hóa password trong properties
- Cách đọc properties trong Servlet cũ
- Cơ chế classpath hoạt động ra sao

Chỉ cần nói bạn muốn đào sâu phần nào.

--- .JKS (JAVA KEYSTORE)

GIẢI THÍCH CHI TIẾT VỀ FILE .JKS (JAVA KEYSTORE)

=====================================================================
I. FILE .JKS LÀ GÌ?
=====================================================================

.jks là viết tắt của:

Java KeyStore

Đây là một file dùng để lưu:

- Private key (khóa riêng)
- Public key (khóa công khai)
- Certificate (chứng chỉ số)
- Certificate chain

File này được dùng trong Java để:

- Cấu hình HTTPS
- SSL/TLS
- Mã hóa
- Xác thực server hoặc client


=====================================================================
II. TẠI SAO CẦN FILE .JKS?
=====================================================================

Khi bạn chạy một server HTTPS (ví dụ Spring Boot, Tomcat),
server cần:

1) Private key
2) Certificate

Để:

- Mã hóa dữ liệu
- Chứng minh danh tính server
- Thiết lập kết nối SSL/TLS an toàn

.jks là nơi chứa các thông tin đó.


=====================================================================
III. BÊN TRONG FILE .JKS CÓ GÌ?
=====================================================================

Một keystore (.jks) có thể chứa nhiều entry.

Mỗi entry có:

- Alias (tên định danh)
- Private key
- Certificate
- Password bảo vệ

Ví dụ cấu trúc:

Keystore (file.jks)
  ├── alias: myserver
  │     ├── private key
  │     ├── certificate
  │     └── certificate chain


=====================================================================
IV. TẠO FILE .JKS BẰNG KEYTOOL
=====================================================================

Java cung cấp công cụ:

keytool

Ví dụ tạo keystore:

keytool -genkeypair \
  -alias myserver \
  -keyalg RSA \
  -keysize 2048 \
  -keystore mykeystore.jks \
  -validity 365

Sau đó nhập:
- Keystore password
- Tên tổ chức
- Domain
- Quốc gia

File mykeystore.jks sẽ được tạo ra.


=====================================================================
V. SỬ DỤNG .JKS TRONG SPRING BOOT
=====================================================================

Trong application.properties:

server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:mykeystore.jks
server.ssl.key-store-password=123456
server.ssl.key-store-type=JKS
server.ssl.key-alias=myserver

Khi chạy ứng dụng:

https://localhost:8443


=====================================================================
VI. SỬ DỤNG .JKS TRONG TOMCAT
=====================================================================

Trong file server.xml:

<Connector port="8443"
           protocol="org.apache.coyote.http11.Http11NioProtocol"
           SSLEnabled="true"
           keystoreFile="conf/mykeystore.jks"
           keystorePass="123456"
           scheme="https"
           secure="true"
           sslProtocol="TLS" />


=====================================================================
VII. JKS KHÁC GÌ VỚI PKCS12 (.p12)?
=====================================================================

JKS:
- Định dạng riêng của Java
- Truyền thống

PKCS12 (.p12 hoặc .pfx):
- Chuẩn quốc tế
- Tương thích nhiều hệ thống
- Hiện nay được khuyến nghị hơn

Java mới có thể dùng:

server.ssl.key-store-type=PKCS12


=====================================================================
VIII. TRUSTSTORE VÀ KEYSTORE
=====================================================================

Keystore:
- Chứa private key + certificate của bạn

Truststore:
- Chứa certificate của người khác mà bạn tin tưởng

Ví dụ:
- Server dùng keystore
- Client dùng truststore


=====================================================================
IX. PASSWORD TRONG .JKS
=====================================================================

Có 2 loại password:

1) Keystore password
   → bảo vệ toàn bộ file

2) Key password
   → bảo vệ từng private key


=====================================================================
X. XEM NỘI DUNG FILE .JKS
=====================================================================

Dùng lệnh:

keytool -list -v -keystore mykeystore.jks

Sẽ hiển thị:

- Alias
- Ngày tạo
- Certificate info
- Validity


=====================================================================
XI. LƯU Ý BẢO MẬT

1) Không commit file .jks lên Git public
2) Không để password trong source code
3) Không chia sẻ private key
4) Dùng certificate từ CA thật khi production


=====================================================================
XII. LUỒNG HTTPS HOẠT ĐỘNG

1) Client gửi request HTTPS
2) Server gửi certificate từ .jks
3) Client kiểm tra certificate
4) Hai bên tạo session key
5) Dữ liệu được mã hóa


=====================================================================
XIII. TÓM TẮT

File .jks là:

- Java KeyStore
- Chứa private key và certificate
- Dùng để cấu hình HTTPS/SSL
- Được tạo bằng keytool
- Có password bảo vệ
- Quan trọng cho bảo mật server

Nó là thành phần cốt lõi khi cấu hình HTTPS trong Java.


=====================================================================

Nếu bạn muốn, tôi có thể giải thích thêm:

- SSL handshake chi tiết từng bước
- Cách tạo certificate tự ký (self-signed)
- Cách chuyển đổi JKS sang PKCS12
- Sự khác nhau giữa HTTPS và TLS
- Cách cấu hình mutual SSL (2 chiều)

Chỉ cần nói bạn muốn đào sâu phần nào.

--- .ZUL

GIAI THICH CHI TIET VE FILE .ZUL

I. FILE .ZUL LA GI?

- File .zul la file giao dien (UI file) cua ZK Framework.
- ZUL viet tat cua: ZK User Interface Language.
- No la mot dang XML dac biet duoc ZK su dung de dinh nghia giao dien web.
- Thay vi viet HTML + JavaScript thu cong, ta viet file .zul de ZK tu dong sinh HTML va xu ly su kien.

=> Tom lai:
File .zul = file mo ta giao dien (View) trong mo hinh MVC cua ZK.


II. ZK FRAMEWORK LA GI?

ZK la:
- Mot Java Web Framework.
- Ho tro mo hinh MVC.
- Cho phep viet UI bang XML (.zul).
- Xu ly su kien bang Java thay vi JavaScript.

ZK giup:
- Lap trinh web theo huong server-side.
- Viet giao dien giong nhu lap trinh desktop (event-driven).
- Giam su dung JavaScript o frontend.


III. FILE .ZUL NAM O DAU?

Thuong nam trong:

/webapp
   /WEB-INF
   index.zul
   login.zul
   dashboard.zul

Hoac:

src/main/webapp/


IV. CAU TRUC CO BAN CUA FILE .ZUL

File .zul la XML nen phai dung dung cu phap XML.

Vi du:

<?xml version="1.0" encoding="UTF-8"?>
<zk>
    <window title="Demo" border="normal" width="300px">
        <label value="Xin chao ZK!" />
        <button label="Click me" />
    </window>
</zk>

Giai thich:

- <zk> la root element.
- <window> la container (giong div trong HTML).
- <label> la hien thi text.
- <button> la nut bam.

Tat ca cac the nay la component cua ZK.


V. CAC THANH PHAN PHO BIEN TRONG .ZUL

1. Container
- <window>
- <div>
- <vlayout>
- <hlayout>
- <grid>

2. Input
- <textbox>
- <intbox>
- <combobox>
- <datebox>

3. Hien thi
- <label>
- <image>
- <listbox>

4. Su kien
- onClick
- onChange
- onOK
- onSelect


VI. XU LY SU KIEN TRONG .ZUL

Co 2 cach xu ly:

1. Viet script truc tiep trong .zul

<button label="Click"
        onClick='alert("Hello");' />

2. Gan voi Controller Java

.zul:

<window apply="com.example.MyController">
    <button id="btn" label="Click" />
</window>

Controller Java:

public class MyController extends SelectorComposer<Component> {

    @Wire
    private Button btn;

    @Listen("onClick = #btn")
    public void click() {
        Messagebox.show("Hello");
    }
}

=> Khi bam nut, method click() trong Java duoc goi.


VII. FILE .ZUL TRONG MO HINH MVC

Trong ZK:

- Model  : du lieu (Java class, database)
- View   : file .zul
- Controller : Java Composer

Luong chay:

1. User mo trang login.zul
2. ZK render giao dien
3. User bam nut
4. Su kien gui ve server
5. Controller Java xu ly
6. Cap nhat UI


VIII. ZUL KHAC GI HTML?

HTML:
- Chay o client (browser).
- Can JavaScript de xu ly su kien.

ZUL:
- Duoc xu ly o server.
- Su kien xu ly bang Java.
- ZK tu dong tao HTML.

Ban viet:

<button label="OK"/>

ZK se tao HTML + JS phuc tap o ben duoi.


IX. FILE .ZUL CO THE:

1. Nhung EL Expression

<label value="${user.name}" />

2. Su dung Binding (MVVM)

<window viewModel="@id('vm') @init('com.example.MyVM')">
    <label value="@bind(vm.username)" />
</window>

3. Include file khac

<include src="header.zul"/>


X. LUONG CHAY KHI MO FILE .ZUL

1. Trinh duyet request: /login.zul
2. Server nhan request
3. ZK Engine phan tich XML
4. Tao component tree
5. Sinh HTML
6. Gui HTML ve browser
7. Tuong tac gui event AJAX ve server


XI. UU DIEM CUA .ZUL

- Khong can viet JavaScript nhieu
- Lap trinh theo su kien
- Code gon hon
- Tach ro View va Controller
- Phu hop cho he thong doanh nghiep


XII. NHUOC DIEM

- Phu thuoc ZK
- Render server-side nen ton tai round-trip
- Khong phu hop SPA frontend rieng biet


XIII. TOM TAT NGAN GON

File .zul la:

- File giao dien XML
- Thuoc ZK Framework
- Dung de dinh nghia UI
- Chay theo mo hinh MVC
- Su kien xu ly bang Java
- Duoc server render thanh HTML

Neu ban thay file .zul trong project:

=> Do la project dang dung ZK Framework.
=> .zul chinh la View layer.

KET LUAN:

.zul = giao dien XML cua ZK
Controller = Java class
Model = du lieu

Ba thanh phan nay tao thanh ung dung web theo mo hinh MVC trong ZK.

--- ByteArrayInputStream KHÁC GÌ FileInputStream

GIẢI THÍCH CHI TIẾT: ByteArrayInputStream KHÁC GÌ FileInputStream

I. TỔNG QUAN

1) ByteArrayInputStream là gì?
- Là một lớp trong java.io
- Dùng để đọc dữ liệu từ một mảng byte (byte[]) có sẵn trong RAM.
- Nguồn dữ liệu: BỘ NHỚ (memory).

2) FileInputStream là gì?
- Là một lớp trong java.io
- Dùng để đọc dữ liệu từ một file trên ổ đĩa.
- Nguồn dữ liệu: FILE TRÊN Ổ CỨNG (disk).

=> Khác biệt lớn nhất:
ByteArrayInputStream đọc từ RAM
FileInputStream đọc từ FILE ngoài hệ thống


==================================================================
II. SO SÁNH CHI TIẾT TỪNG KHÍA CẠNH
==================================================================

1) NGUỒN DỮ LIỆU (Source)

ByteArrayInputStream:
- Đọc từ byte[] đã tồn tại trong bộ nhớ.
- Không liên quan tới file thật.
- Không truy cập ổ cứng.

FileInputStream:
- Đọc trực tiếp từ file trên hệ điều hành.
- Phải chỉ định đường dẫn file.
- Có thao tác I/O với ổ đĩa.

Ví dụ:

ByteArrayInputStream:
byte[] data = "Hello".getBytes();
ByteArrayInputStream bis = new ByteArrayInputStream(data);

FileInputStream:
FileInputStream fis = new FileInputStream("data.txt");


==================================================================
2) TỐC ĐỘ
==================================================================

ByteArrayInputStream:
- Rất nhanh.
- Vì đọc trực tiếp từ RAM.
- Không có I/O hệ điều hành.

FileInputStream:
- Chậm hơn.
- Vì phải đọc từ ổ cứng.
- Có I/O hệ điều hành.


==================================================================
3) CÓ CẦN ĐÓNG (close) KHÔNG?
==================================================================

ByteArrayInputStream:
- Không bắt buộc phải close().
- Vì không chiếm tài nguyên hệ điều hành.
- close() gần như không làm gì.

FileInputStream:
- BẮT BUỘC phải close().
- Vì đang giữ file descriptor của hệ điều hành.
- Nếu không close() có thể gây rò rỉ tài nguyên.


==================================================================
4) DÙNG TRONG TRƯỜNG HỢP NÀO?
==================================================================

Dùng ByteArrayInputStream khi:
- Dữ liệu đã có sẵn trong byte[].
- Test code.
- Parse dữ liệu nhận từ mạng.
- Convert String sang InputStream.
- Không muốn thao tác file thật.

Ví dụ:
String json = "{\"name\":\"Tuan\"}";
InputStream is = new ByteArrayInputStream(json.getBytes());


Dùng FileInputStream khi:
- Cần đọc file thật trên máy.
- Đọc file ảnh, video, pdf, txt...
- Xử lý file upload.


==================================================================
5) PHỤ THUỘC VÀO HỆ ĐIỀU HÀNH
==================================================================

ByteArrayInputStream:
- Không phụ thuộc file system.
- Không bị lỗi FileNotFoundException.

FileInputStream:
- Phụ thuộc đường dẫn.
- Có thể bị:
  + FileNotFoundException
  + Permission denied
  + File bị khóa


==================================================================
6) KHẢ NĂNG RESET
==================================================================

ByteArrayInputStream:
- Hỗ trợ mark() và reset() rất tốt.
- Có thể reset về đầu dễ dàng.

FileInputStream:
- Không hỗ trợ mark/reset hiệu quả.
- Thường phải mở lại file nếu muốn đọc lại từ đầu.


==================================================================
III. SO SÁNH BẢNG TỔNG KẾT
==================================================================

Tiêu chí               | ByteArrayInputStream      | FileInputStream
---------------------------------------------------------------------------
Nguồn dữ liệu          | byte[] trong RAM          | File trên ổ đĩa
Tốc độ                 | Nhanh                     | Chậm hơn
Cần close()            | Không bắt buộc            | Bắt buộc
Có lỗi FileNotFound    | Không                     | Có
Tài nguyên OS          | Không chiếm               | Có chiếm
Phù hợp test           | Rất phù hợp               | Không tiện
Đọc file thật          | Không                     | Có
Phụ thuộc đường dẫn    | Không                     | Có


==================================================================
IV. VÍ DỤ SO SÁNH THỰC TẾ
==================================================================

1) ByteArrayInputStream

byte[] arr = {65, 66, 67};
ByteArrayInputStream bis = new ByteArrayInputStream(arr);

int data;
while ((data = bis.read()) != -1) {
    System.out.println((char) data);
}


2) FileInputStream

FileInputStream fis = new FileInputStream("abc.txt");

int data;
while ((data = fis.read()) != -1) {
    System.out.println((char) data);
}
fis.close();


==================================================================
V. HIỂU THEO CÁCH ĐƠN GIẢN
==================================================================

Hãy tưởng tượng:

ByteArrayInputStream:
= Bạn đọc dữ liệu từ tờ giấy đang cầm trên tay.

FileInputStream:
= Bạn đi ra kho lấy tài liệu rồi đọc.


==================================================================
VI. KẾT LUẬN NGẮN GỌN
==================================================================

- ByteArrayInputStream đọc từ bộ nhớ.
- FileInputStream đọc từ file thật.
- ByteArrayInputStream nhanh, dùng cho test, dữ liệu tạm.
- FileInputStream dùng khi xử lý file ngoài hệ thống.
- FileInputStream phải close(), ByteArrayInputStream thì không bắt buộc.

Nếu cần hiệu năng và dữ liệu đã ở RAM → dùng ByteArrayInputStream.
Nếu cần đọc file thật → dùng FileInputStream.

--- TA DÙNG close() TRONG BufferedReader KHI NÀO?

GIẢI THÍCH CHI TIẾT:
TA DÙNG close() TRONG BufferedReader KHI NÀO?
DÙNG SAU new HAY SAU readLine()?

==================================================================
I. CÂU TRẢ LỜI NGẮN GỌN
==================================================================

- Không gọi close() ngay sau khi new.
- Không gọi close() ngay sau mỗi lần readLine().
- Phải gọi close() KHI ĐÃ ĐỌC XONG TOÀN BỘ DỮ LIỆU.
- Tốt nhất: dùng try-with-resources để tự động close.

==================================================================
II. HIỂU ĐÚNG BẢN CHẤT
==================================================================

BufferedReader là lớp bọc ngoài một Reader khác.
Ví dụ:

BufferedReader br =
    new BufferedReader(new FileReader("data.txt"));

Chuỗi này gồm:

FileReader  → đọc file từ ổ đĩa
BufferedReader → bọc lại để đọc nhanh hơn (có buffer)

Khi bạn close BufferedReader:
- Nó sẽ đóng chính nó
- Và đóng luôn FileReader bên trong

Vì vậy:
Chỉ cần close BufferedReader là đủ.


==================================================================
III. KHÔNG ĐƯỢC close() NGAY SAU new
==================================================================

Sai:

BufferedReader br =
    new BufferedReader(new FileReader("data.txt"));
br.close();  // đóng ngay
String line = br.readLine(); // LỖI

Vì:
- Bạn đã đóng stream rồi
- Không thể đọc tiếp


==================================================================
IV. KHÔNG ĐƯỢC close() SAU MỖI readLine()
==================================================================

Sai:

String line = br.readLine();
br.close(); // đóng
line = br.readLine(); // LỖI

Vì:
- Sau khi close, stream không còn hoạt động


==================================================================
V. THỜI ĐIỂM ĐÚNG ĐỂ close()
==================================================================

Đúng:

BufferedReader br =
    new BufferedReader(new FileReader("data.txt"));

String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

br.close();  // đóng SAU KHI đọc xong

Nguyên tắc:
close() luôn đặt ở CUỐI quá trình sử dụng.


==================================================================
VI. TẠI SAO PHẢI close()?
==================================================================

Vì BufferedReader (khi đọc file) đang giữ:

- File descriptor của hệ điều hành
- Bộ nhớ buffer
- Tài nguyên hệ thống

Nếu không close:
- Có thể rò rỉ tài nguyên
- File có thể bị khóa
- Tốn bộ nhớ


==================================================================
VII. CÁCH TỐT NHẤT: TRY-WITH-RESOURCES
==================================================================

Đây là cách chuẩn hiện đại:

try (BufferedReader br =
         new BufferedReader(new FileReader("data.txt"))) {

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

} // tự động close ở đây

Ưu điểm:
- Không cần gọi close()
- Không sợ quên
- An toàn nếu có exception


==================================================================
VIII. TRƯỜNG HỢP KHÔNG CẦN QUÁ LO VỀ close
==================================================================

Nếu BufferedReader đọc từ:

new BufferedReader(
    new StringReader("abc")
);

Hoặc đọc từ:

ByteArrayInputStream

Thì:
- Không giữ tài nguyên hệ điều hành
- close() không quá quan trọng
- Nhưng vẫn nên gọi để đúng nguyên tắc


==================================================================
IX. TÓM LẠI RÕ RÀNG
==================================================================

1) Không close sau new.
2) Không close sau mỗi readLine().
3) Close sau khi đọc xong toàn bộ dữ liệu.
4) Tốt nhất dùng try-with-resources.
5) Close BufferedReader sẽ đóng luôn stream bên trong.

Nguyên tắc vàng:
MỞ ở đầu → DÙNG ở giữa → ĐÓNG ở cuối.

--- Ý NGHĨA CỦA HÀM main TRONG JAVA

GIẢI THÍCH CHI TIẾT NHẤT:
Ý NGHĨA CỦA HÀM main TRONG JAVA

==================================================================
I. HÀM main LÀ GÌ?
==================================================================

Hàm main là điểm bắt đầu (entry point) của một chương trình Java.

Khi bạn chạy một file .class hoặc một chương trình Java,
JVM (Java Virtual Machine) sẽ tìm và gọi hàm main trước tiên.

Nếu không có hàm main đúng chuẩn,
chương trình sẽ không chạy được.

==================================================================
II. CÚ PHÁP CHUẨN CỦA main
==================================================================

public static void main(String[] args)

Phải đúng chính xác như vậy.

Nếu sai dù chỉ một phần, JVM sẽ không nhận diện được.

==================================================================
III. PHÂN TÍCH TỪNG THÀNH PHẦN
==================================================================

1) public

- Cho phép JVM truy cập được hàm này.
- Nếu để private hoặc không có public → JVM không gọi được.

Ví dụ sai:

static void main(String[] args)   // thiếu public → lỗi khi chạy


---------------------------------------------------------------

2) static

- JVM gọi main mà không cần tạo object.
- Vì khi chương trình bắt đầu, chưa có object nào tồn tại.
- Do đó main phải là static.

Nếu không static:

public void main(String[] args)

→ JVM không thể gọi vì cần tạo object trước.


---------------------------------------------------------------

3) void

- main không trả về giá trị.
- Khi chương trình kết thúc, nó chỉ dừng lại.

Khác với C/C++ (main trả về int),
Java không yêu cầu trả về.


---------------------------------------------------------------

4) main

- Là tên bắt buộc.
- JVM tìm đúng tên này.
- Viết sai thành Main hoặc MAIN → không chạy.


---------------------------------------------------------------

5) String[] args

- Là mảng String.
- Dùng để nhận tham số dòng lệnh khi chạy chương trình.

Ví dụ chạy:

java MyProgram hello 123

Thì:

args[0] = "hello"
args[1] = "123"


==================================================================
IV. LUỒNG HOẠT ĐỘNG KHI CHẠY CHƯƠNG TRÌNH
==================================================================

1) Bạn gõ:

java MyProgram

2) JVM:
   - Tìm class MyProgram
   - Tìm hàm:
     public static void main(String[] args)

3) Nếu tìm thấy → gọi main()
4) Bắt đầu thực thi code bên trong main.


==================================================================
V. main CHỈ LÀ ĐIỂM BẮT ĐẦU
==================================================================

main không phải nơi chứa toàn bộ chương trình.

Nó chỉ là điểm khởi động.

Ví dụ:

public class App {

    public static void main(String[] args) {
        sayHello();
    }

    static void sayHello() {
        System.out.println("Hello");
    }
}

Ở đây:
- JVM gọi main()
- main() gọi sayHello()
- sayHello() thực thi


==================================================================
VI. CÓ THỂ OVERLOAD main KHÔNG?
==================================================================

Có thể viết nhiều main:

public static void main() { }
public static void main(String arg) { }

Nhưng:
JVM chỉ nhận dạng duy nhất:

public static void main(String[] args)

Các main khác chỉ là method bình thường.


==================================================================
VII. main CÓ THỂ VIẾT THEO CÁCH KHÁC KHÔNG?
==================================================================

Có thể viết:

public static void main(String args[])

Hoặc:

public static void main(String... args)

Vì:
- String... là varargs
- JVM vẫn hiểu là mảng String


==================================================================
VIII. ĐIỀU GÌ XẢY RA NẾU KHÔNG CÓ main?
==================================================================

Nếu bạn chạy class không có main:

Lỗi sẽ xuất hiện:

Error: Main method not found in class ...

Vì:
JVM không biết bắt đầu từ đâu.


==================================================================
IX. TRONG ỨNG DỤNG LỚN (SPRING, SERVLET...)
==================================================================

Trong ứng dụng framework:

- main có thể nằm trong class cấu hình
- Hoặc framework sẽ tự quản lý

Ví dụ Spring Boot:

public static void main(String[] args) {
    SpringApplication.run(App.class, args);
}

Ở đây:
- main chỉ dùng để khởi động framework.


==================================================================
X. HIỂU THEO CÁCH ĐƠN GIẢN
==================================================================

Hãy tưởng tượng:

- Chương trình = một tòa nhà.
- main = cửa chính.
- JVM = người bước vào.

Nếu không có cửa chính,
không thể vào tòa nhà.


==================================================================
XI. TÓM LẠI NGẮN GỌN
==================================================================

- main là điểm bắt đầu của chương trình Java.
- JVM luôn tìm:
  public static void main(String[] args)
- public: để JVM truy cập.
- static: để gọi mà không cần object.
- void: không trả về giá trị.
- String[] args: nhận tham số dòng lệnh.
- Không có main → chương trình không chạy được.

Kết luận:

main = ENTRY POINT của chương trình Java.

--- CONTROLLER TRONG org.springframework.web.servlet.mvc.controller

GIẢI THÍCH CHI TIẾT NHẤT:
CONTROLLER TRONG org.springframework.web.servlet.mvc.controller

==================================================================
I. VỊ TRÍ CỦA Controller TRONG SPRING MVC
==================================================================

Package:
org.springframework.web.servlet.mvc.controller

Đây là package thuộc Spring MVC truyền thống (kiểu cũ),
dựa trên interface Controller trước khi có @Controller annotation hiện đại.

Nó thuộc module:
spring-webmvc

==================================================================
II. CONTROLLER LÀ GÌ TRONG SPRING MVC?
==================================================================

Controller là thành phần xử lý request từ client.

Trong mô hình MVC:

Client → DispatcherServlet → Controller → Model → View → Response

Controller:
- Nhận HttpServletRequest
- Xử lý logic
- Trả về ModelAndView


==================================================================
III. INTERFACE GỐC: Controller
==================================================================

Interface cốt lõi:

public interface Controller {
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response
    ) throws Exception;
}

Ý nghĩa:
- Mỗi Controller phải implement phương thức handleRequest.
- Đây là điểm xử lý request.


==================================================================
IV. LUỒNG HOẠT ĐỘNG CHI TIẾT
==================================================================

1) Client gửi HTTP request
2) DispatcherServlet nhận request
3) HandlerMapping tìm Controller phù hợp
4) DispatcherServlet gọi handleRequest()
5) Controller xử lý
6) Trả về ModelAndView
7) ViewResolver chọn View
8) Render HTML trả về client


==================================================================
V. CÁC CLASS QUAN TRỌNG TRONG PACKAGE NÀY
==================================================================

1) AbstractController

Là lớp abstract cung cấp logic sẵn.

Bạn chỉ cần override:

protected ModelAndView handleRequestInternal(
    HttpServletRequest request,
    HttpServletResponse response
)

Thay vì phải implement toàn bộ interface.


---------------------------------------------------------------

2) AbstractCommandController

Dùng để bind dữ liệu form vào object (command object).

Hỗ trợ:
- Data binding
- Validation


---------------------------------------------------------------

3) SimpleFormController (đã deprecated)

Hỗ trợ xử lý form:
- Hiển thị form
- Submit form
- Validate
- Chuyển view

Trước khi có @ModelAttribute và @PostMapping.


---------------------------------------------------------------

4) ParameterizableViewController

Controller đơn giản:
- Không xử lý logic
- Chỉ trả về một view cố định

Ví dụ:
Chỉ cần trả về trang home.jsp


==================================================================
VI. VÍ DỤ CONTROLLER CỔ ĐIỂN
==================================================================

public class HelloController implements Controller {

    public ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response
    ) {

        ModelAndView mav = new ModelAndView("hello");
        mav.addObject("message", "Hello Spring MVC");

        return mav;
    }
}

Ý nghĩa:
- View name: "hello"
- Model: message = "Hello Spring MVC"


==================================================================
VII. CẤU HÌNH XML KIỂU CŨ
==================================================================

Trong XML:

<bean name="/hello.htm"
      class="com.example.HelloController"/>

HandlerMapping sẽ map URL tới bean này.

Đây là cách cấu hình trước thời annotation.


==================================================================
VIII. HẠN CHẾ CỦA Controller KIỂU CŨ
==================================================================

1) Phải implement interface
2) Không linh hoạt
3) Không hỗ trợ annotation mapping
4) Code dài và cứng nhắc
5) Cấu hình XML phức tạp


==================================================================
IX. SO SÁNH VỚI @Controller HIỆN ĐẠI
==================================================================

Controller kiểu cũ:
- Implement Controller interface
- Trả về ModelAndView
- Mapping bằng XML

Controller hiện đại:
- Dùng @Controller
- Dùng @RequestMapping
- Trả về String hoặc object
- Tự động binding
- Tích hợp REST dễ dàng


Ví dụ hiện đại:

@Controller
public class HelloController {

    @GetMapping("/hello")
    public String hello(Model model) {
        model.addAttribute("message", "Hello");
        return "hello";
    }
}

Ngắn gọn và dễ đọc hơn nhiều.


==================================================================
X. TẠI SAO PACKAGE NÀY VẪN TỒN TẠI?
==================================================================

Vì:
- Đảm bảo backward compatibility
- Hỗ trợ ứng dụng legacy
- Một số hệ thống cũ vẫn dùng


==================================================================
XI. BẢN CHẤT THỰC SỰ
==================================================================

org.springframework.web.servlet.mvc.controller

Là tập hợp các Controller theo phong cách:

- Interface-based
- Class inheritance-based
- XML configuration-based

Trước khi Spring chuyển sang annotation-driven model.


==================================================================
XII. TÓM LẠI NGẮN GỌN
==================================================================

- Đây là Controller kiểu cũ của Spring MVC.
- Phải implement interface Controller.
- Phải override handleRequest().
- Trả về ModelAndView.
- Cấu hình bằng XML.
- Hiện nay ít dùng, thay bằng @Controller.

Hiểu đơn giản:

Controller trong package này là phiên bản "đời đầu"
của Spring MVC trước khi có annotation hiện đại.

--- NẾU CẤU HÌNH CONTROLLER TRONG FILE dispatch-servlet.xml THÌ SAO?

GIẢI THÍCH CHI TIẾT NHẤT:
NẾU CẤU HÌNH CONTROLLER TRONG FILE dispatch-servlet.xml THÌ SAO?
(ÁP DỤNG CHO Controller KIỂU CŨ: org.springframework.web.servlet.mvc.controller)

==================================================================
I. dispatch-servlet.xml LÀ GÌ?
==================================================================

Khi dùng Spring MVC kiểu XML truyền thống,
mỗi DispatcherServlet sẽ có một file cấu hình riêng:

Ví dụ:

<servlet>
    <servlet-name>dispatch</servlet-name>
    <servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
</servlet>

=> Spring sẽ tự động tìm file:

dispatch-servlet.xml

File này chứa:
- Bean Controller
- HandlerMapping
- ViewResolver
- Các cấu hình MVC khác


==================================================================
II. LUỒNG HOẠT ĐỘNG KHI CẤU HÌNH TRONG dispatch-servlet.xml
==================================================================

1) Client gửi request: /hello.htm
2) DispatcherServlet nhận
3) DispatcherServlet dùng HandlerMapping để tìm Controller
4) Controller xử lý và trả ModelAndView
5) ViewResolver tìm JSP tương ứng
6) Trả HTML về client


==================================================================
III. VÍ DỤ CẤU HÌNH ĐẦY ĐỦ (KIỂU CŨ)
==================================================================

1) Controller Java

public class HelloController
        implements Controller {

    public ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response
    ) {

        ModelAndView mav =
            new ModelAndView("hello");

        mav.addObject("message",
            "Hello from XML config");

        return mav;
    }
}


---------------------------------------------------------------
2) dispatch-servlet.xml
---------------------------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    -----------------------------------------------------------
    ĐĂNG KÝ CONTROLLER
    -----------------------------------------------------------

    <bean name="/hello.htm"
          class="com.example.HelloController"/>

    -----------------------------------------------------------
    VIEW RESOLVER
    -----------------------------------------------------------

    <bean
      class="org.springframework.web.servlet.view.InternalResourceViewResolver">

        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>

    </bean>

</beans>


==================================================================
IV. GIẢI THÍCH TỪNG PHẦN
==================================================================

1) <bean name="/hello.htm"...>

- name = URL mapping
- Khi user truy cập:
  http://localhost:8080/app/hello.htm

Spring sẽ map tới HelloController.


2) ViewResolver

prefix = "/WEB-INF/jsp/"
suffix = ".jsp"

Nếu controller trả:

new ModelAndView("hello")

Spring sẽ render:

/WEB-INF/jsp/hello.jsp


==================================================================
V. TRƯỜNG HỢP DÙNG AbstractController
==================================================================

Controller:

public class HelloController
        extends AbstractController {

    protected ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response
    ) {

        return new ModelAndView("hello");
    }
}

XML vẫn giống như trên.


==================================================================
VI. NẾU DÙNG SimpleUrlHandlerMapping
==================================================================

Bạn có thể cấu hình rõ ràng mapping:

<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
    <property name="mappings">
        <props>
            <prop key="/hello.htm">helloController</prop>
        </props>
    </property>
</bean>

<bean id="helloController"
      class="com.example.HelloController"/>

Cách này tách:
- URL mapping
- Bean definition


==================================================================
VII. SO SÁNH 2 CÁCH MAP
==================================================================

Cách 1:
<bean name="/hello.htm" class="..."/>

→ Đơn giản, tự động mapping

Cách 2:
SimpleUrlHandlerMapping

→ Linh hoạt hơn
→ Phù hợp hệ thống lớn


==================================================================
VIII. ƯU ĐIỂM CỦA dispatch-servlet.xml
==================================================================

- Tách cấu hình khỏi code
- Không phụ thuộc annotation
- Phù hợp hệ thống legacy
- Dễ chỉnh sửa mà không cần sửa Java


==================================================================
IX. NHƯỢC ĐIỂM
==================================================================

- XML dài và khó đọc
- Mapping không trực quan
- Không linh hoạt bằng annotation
- Khó maintain khi project lớn


==================================================================
X. SO SÁNH VỚI ANNOTATION HIỆN ĐẠI
==================================================================

XML cũ:

<bean name="/hello.htm" class="..."/>

Annotation mới:

@Controller
@RequestMapping("/hello")

→ Không cần XML mapping


==================================================================
XI. TÓM LẠI NGẮN GỌN
==================================================================

Nếu cấu hình trong dispatch-servlet.xml:

1) Bạn phải khai báo bean Controller.
2) Mapping URL bằng name hoặc HandlerMapping.
3) Cấu hình ViewResolver.
4) DispatcherServlet sẽ đọc file XML này khi khởi động.

Cách này là Spring MVC đời cũ,
dựa hoàn toàn vào XML configuration.

--- ModelAndView mav = new ModelAndView("hello");

GIẢI THÍCH CHI TIẾT NHẤT:
ModelAndView mav = new ModelAndView("hello");

==================================================================
I. CÂU LỆNH NÀY NẰM Ở ĐÂU?
==================================================================

Câu lệnh này thường nằm trong Controller của Spring MVC.

Ví dụ:

public ModelAndView handleRequest(...) {
    ModelAndView mav = new ModelAndView("hello");
    return mav;
}

Hoặc:

@GetMapping("/hello")
public ModelAndView hello() {
    ModelAndView mav = new ModelAndView("hello");
    return mav;
}

==================================================================
II. ModelAndView LÀ GÌ?
==================================================================

ModelAndView là một class trong Spring MVC.

Chức năng:
- Chứa MODEL (dữ liệu)
- Chứa VIEW (tên trang hiển thị)

Nó là gói kết quả trả về cho DispatcherServlet.

==================================================================
III. PHÂN TÍCH TỪNG PHẦN CỦA CÂU LỆNH
==================================================================

ModelAndView mav = new ModelAndView("hello");

1) ModelAndView
   Là kiểu dữ liệu.
   Đây là đối tượng chứa:
   - viewName
   - model (Map<String, Object>)

2) mav
   Là biến tham chiếu.
   Bạn có thể đặt tên khác như:
   result, modelView, responseView...

3) new ModelAndView("hello")
   Gọi constructor với tham số là tên view.

==================================================================
IV. "hello" NGHĨA LÀ GÌ?
==================================================================

"hello" là view name (tên view logic).

Nó KHÔNG phải file đầy đủ.
Nó chỉ là tên logic.

Spring sẽ dùng ViewResolver để biến nó thành file thật.

Ví dụ:

ViewResolver cấu hình:

prefix = "/WEB-INF/jsp/"
suffix = ".jsp"

Khi bạn trả:

new ModelAndView("hello")

Spring sẽ render:

/WEB-INF/jsp/hello.jsp


==================================================================
V. BÊN TRONG ModelAndView CHỨA GÌ?
==================================================================

ModelAndView có 2 phần chính:

1) viewName
2) model (Map dữ liệu)

Khi tạo:

new ModelAndView("hello");

Thì bên trong:

viewName = "hello"
model = rỗng (chưa có dữ liệu)


==================================================================
VI. THÊM DỮ LIỆU VÀO ModelAndView
==================================================================

Ví dụ:

ModelAndView mav = new ModelAndView("hello");
mav.addObject("name", "Tuan");

Bây giờ:

viewName = "hello"
model:
    key = "name"
    value = "Tuan"

Trong JSP có thể dùng:

${name}

==================================================================
VII. LUỒNG HOẠT ĐỘNG KHI RETURN ModelAndView
==================================================================

1) Controller trả về ModelAndView.
2) DispatcherServlet nhận.
3) Lấy viewName = "hello".
4) Gửi viewName cho ViewResolver.
5) ViewResolver tìm file tương ứng.
6) Gắn model vào request scope.
7) Render view.
8) Trả HTML cho client.


==================================================================
VIII. CÁC CONSTRUCTOR KHÁC CỦA ModelAndView
==================================================================

1) Chỉ view:

new ModelAndView("hello")

2) View + 1 object:

new ModelAndView("hello", "name", "Tuan")

3) View + Map:

Map<String, Object> map = new HashMap<>();
map.put("age", 25);

new ModelAndView("hello", map)


==================================================================
IX. HIỂU THEO CÁCH ĐƠN GIẢN
==================================================================

ModelAndView giống như một chiếc hộp:

- Nắp hộp = View
- Bên trong hộp = Dữ liệu

Bạn đưa hộp này cho Spring.
Spring sẽ mở hộp,
lấy view,
đổ dữ liệu vào trang,
và hiển thị.


==================================================================
X. SO SÁNH VỚI CÁCH HIỆN ĐẠI
==================================================================

Cách cũ:

return new ModelAndView("hello");

Cách mới:

@GetMapping("/hello")
public String hello(Model model) {
    model.addAttribute("name", "Tuan");
    return "hello";
}

Hiện đại:
- Tách view và model rõ ràng hơn
- Không bắt buộc dùng ModelAndView


==================================================================
XI. KẾT LUẬN NGẮN GỌN
==================================================================

ModelAndView mav = new ModelAndView("hello");

Có nghĩa là:

1) Tạo một đối tượng chứa:
   - Tên view là "hello"
   - Model rỗng

2) Sau đó có thể thêm dữ liệu bằng addObject()

3) Khi return, Spring sẽ:
   - Dùng ViewResolver tìm file thật
   - Gắn model vào request
   - Render trang

Nói ngắn gọn:

Dòng này tạo kết quả trả về cho Spring MVC,
bao gồm:
- Trang sẽ hiển thị
- Dữ liệu gửi sang trang đó.

--- TRUYỀN BIẾN TỪ CONTROLLER SANG JSP TRONG SPRING MVC

GIẢI THÍCH CHI TIẾT NHẤT:
VÍ DỤ TRUYỀN BIẾN TỪ CONTROLLER SANG JSP TRONG SPRING MVC

==================================================================
I. MỤC TIÊU
==================================================================

Chúng ta sẽ làm ví dụ:

1) Controller gửi biến:
   - name
   - age

2) JSP nhận và hiển thị:
   ${name}
   ${age}

==================================================================
II. CẤU TRÚC ĐƠN GIẢN
==================================================================

Controller  →  ModelAndView  →  DispatcherServlet
            →  ViewResolver  →  JSP
            →  JSP dùng EL để hiển thị

==================================================================
III. VÍ DỤ 1: DÙNG ModelAndView (KIỂU CŨ)
==================================================================

1) Controller

public class UserController implements Controller {

    public ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response
    ) {

        ModelAndView mav =
            new ModelAndView("user");

        mav.addObject("name", "Tuan");
        mav.addObject("age", 25);

        return mav;
    }
}

Giải thích:
- "user" là tên view
- "name" và "age" là key
- "Tuan" và 25 là value


---------------------------------------------------------------
2) dispatch-servlet.xml
---------------------------------------------------------------

<bean name="/user.htm"
      class="com.example.UserController"/>

<bean
  class="org.springframework.web.servlet.view.InternalResourceViewResolver">

    <property name="prefix" value="/WEB-INF/jsp/"/>
    <property name="suffix" value=".jsp"/>

</bean>


---------------------------------------------------------------
3) File JSP: /WEB-INF/jsp/user.jsp
---------------------------------------------------------------

<%@ page contentType="text/html;charset=UTF-8" %>

<html>
<body>

<h2>Thông tin người dùng</h2>

Tên: ${name} <br/>
Tuổi: ${age}

</body>
</html>


==================================================================
IV. LUỒNG HOẠT ĐỘNG
==================================================================

1) Truy cập:
   http://localhost:8080/app/user.htm

2) DispatcherServlet gọi Controller

3) Controller trả:
   viewName = "user"
   model:
       name = "Tuan"
       age = 25

4) ViewResolver chuyển:
   "user"
   → /WEB-INF/jsp/user.jsp

5) Spring đưa model vào request scope

6) JSP hiển thị:
   ${name} → Tuan
   ${age} → 25


==================================================================
V. VÍ DỤ 2: DÙNG @Controller (CÁCH HIỆN ĐẠI)
==================================================================

1) Controller

@Controller
public class UserController {

    @GetMapping("/user")
    public String showUser(Model model) {

        model.addAttribute("name", "Tuan");
        model.addAttribute("age", 25);

        return "user";
    }
}

Giải thích:
- model.addAttribute tương đương mav.addObject
- return "user" là view name


---------------------------------------------------------------
2) JSP (giống như trên)
---------------------------------------------------------------

Tên: ${name}
Tuổi: ${age}


==================================================================
VI. TRUYỀN OBJECT SANG JSP
==================================================================

Controller:

public String showUser(Model model) {

    User user = new User();
    user.setName("Tuan");
    user.setAge(25);

    model.addAttribute("user", user);

    return "user";
}

JSP:

Tên: ${user.name}
Tuổi: ${user.age}

Giải thích:
- JSP dùng EL để truy cập getter:
  getName() → ${user.name}
  getAge() → ${user.age}


==================================================================
VII. PHẠM VI (SCOPE) CỦA BIẾN
==================================================================

Biến được thêm vào model sẽ nằm trong:

request scope

Tương đương:

request.setAttribute("name", "Tuan");

Vì vậy chỉ tồn tại trong 1 request.


==================================================================
VIII. NHỮNG LỖI THƯỜNG GẶP
==================================================================

1) Sai view name
   → Không tìm thấy JSP

2) Sai prefix/suffix
   → 404 hoặc lỗi render

3) Không dùng ${}
   → JSP không hiển thị biến

4) Viết sai key
   model.addAttribute("username", "Tuan");
   JSP dùng ${name}
   → null


==================================================================
IX. TÓM TẮT NGẮN GỌN
==================================================================

Cách truyền biến từ Controller sang JSP:

1) Thêm dữ liệu vào Model hoặc ModelAndView
2) Return tên view
3) ViewResolver tìm JSP
4) JSP dùng EL (${ }) để hiển thị

Ví dụ đơn giản nhất:

Controller:
model.addAttribute("name", "Tuan");
return "user";

JSP:
${name}

Đó là cách Spring MVC truyền dữ liệu
từ Controller sang View (JSP).

--- FILE .ZUL KHÁC GÌ FILE .JSP ?

GIẢI THÍCH CHI TIẾT NHẤT:
FILE .ZUL KHÁC GÌ FILE .JSP ?

==================================================================
I. TỔNG QUAN
==================================================================

.jsp
- Là JavaServer Pages.
- Công nghệ chuẩn của Java EE / Jakarta EE.
- Dùng để tạo HTML động phía server.

.zul
- Là file giao diện của framework ZK.
- Viết bằng XML.
- Dùng để xây dựng UI theo kiểu component-based.

Tóm lại:
JSP = công nghệ chuẩn Servlet/JSP
ZUL = công nghệ thuộc framework ZK


==================================================================
II. BẢN CHẤT KỸ THUẬT
==================================================================

1) JSP

- Khi server chạy:
  JSP → được compile thành Servlet.
- Chạy trên Servlet container (Tomcat, Jetty…).
- Kết quả trả về là HTML.

Luồng:

JSP → Servlet → HTML → Browser


---------------------------------------------------------------

2) ZUL

- ZUL là file XML định nghĩa component UI.
- Được ZK engine xử lý.
- ZK sinh HTML + JavaScript tương ứng.
- Có cơ chế binding trực tiếp với Java class.

Luồng:

ZUL → ZK Engine → HTML + JS → Browser


==================================================================
III. CÚ PHÁP KHÁC NHAU
==================================================================

1) JSP (viết lẫn Java và HTML)

Ví dụ:

<html>
<body>
Tên: ${name}
</body>
</html>

Có thể chèn:

<%
   int a = 5;
%>


---------------------------------------------------------------

2) ZUL (XML thuần component)

Ví dụ:

<window title="User Info" border="normal">
    <label value="Tên:"/>
    <label value="${name}"/>
</window>

Không viết Java trực tiếp trong file.
Logic đặt ở Java class riêng (ViewModel / Composer).


==================================================================
IV. MÔ HÌNH LẬP TRÌNH
==================================================================

JSP:
- Template-based.
- HTML là trung tâm.
- Java chỉ hỗ trợ phía sau.

ZUL:
- Component-based.
- UI được xây dựng từ component:
  window, button, textbox, grid...
- Giống như lập trình Swing nhưng chạy trên web.


==================================================================
V. CÁCH XỬ LÝ SỰ KIỆN
==================================================================

JSP:
- Sự kiện xử lý qua:
  Form submit
  Ajax
  JavaScript
  Controller

ZUL:
- Có event server-side trực tiếp.

Ví dụ:

<button label="Click"
        onClick="@command('save')" />

ZK tự động gọi method trong ViewModel.


==================================================================
VI. DATA BINDING
==================================================================

JSP:
- Dùng EL:
  ${user.name}

- Không có binding 2 chiều mặc định.

ZUL:
- Có MVVM binding mạnh.

Ví dụ:

<textbox value="@bind(vm.name)" />

Nếu user nhập:
→ Tự động cập nhật vào Java object.


==================================================================
VII. MỨC ĐỘ TƯƠNG TÁC
==================================================================

JSP:
- Chủ yếu render HTML.
- Muốn dynamic mạnh phải dùng JS/Ajax.

ZUL:
- Framework tự sinh Ajax.
- Giao diện dynamic như desktop app.
- Không cần viết JS nhiều.


==================================================================
VIII. PHỤ THUỘC FRAMEWORK
==================================================================

JSP:
- Chuẩn Java EE.
- Không phụ thuộc framework cụ thể.

ZUL:
- Phụ thuộc framework ZK.
- Không có ZK → không chạy được.


==================================================================
IX. VÍ DỤ SO SÁNH CỤ THỂ
==================================================================

Yêu cầu:
Hiển thị textbox và nút, khi bấm nút hiển thị nội dung.


---------------------------------------------------------------
1) JSP
---------------------------------------------------------------

HTML + Form:

<form action="/save" method="post">
    <input type="text" name="name"/>
    <input type="submit" value="Save"/>
</form>

Controller xử lý riêng.


---------------------------------------------------------------
2) ZUL
---------------------------------------------------------------

<window apply="com.example.MyComposer">
    <textbox id="nameBox"/>
    <button label="Save" onClick="save()"/>
</window>

Trong Composer Java:
public void save() {
    String name = nameBox.getValue();
}

→ Event chạy trực tiếp server-side.


==================================================================
X. SO SÁNH TỔNG KẾT
==================================================================

Tiêu chí             | JSP                      | ZUL
----------------------------------------------------------------
Loại file            | Template HTML            | XML UI component
Chuẩn                | Java EE chuẩn            | Framework ZK
Compile              | Thành Servlet            | ZK xử lý
Event                | Form/Ajax/JS             | Server-side event
Data Binding         | EL 1 chiều               | 2 chiều (MVVM)
Dynamic UI           | Phụ thuộc JS             | Tự động Ajax
Phù hợp              | Web truyền thống         | Web giống desktop


==================================================================
XI. HIỂU THEO CÁCH ĐƠN GIẢN
==================================================================

JSP:
= Bạn viết HTML có thêm chút Java.

ZUL:
= Bạn xây dựng giao diện bằng component
  giống như lập trình Swing,
  nhưng chạy trên web.


==================================================================
XII. KẾT LUẬN NGẮN GỌN
==================================================================

- JSP là công nghệ web truyền thống.
- ZUL là file giao diện của framework ZK.
- JSP thiên về HTML template.
- ZUL thiên về component + data binding.
- ZUL mạnh về UI tương tác, giống desktop app.
- JSP phổ biến hơn và là chuẩn Java EE.

Nếu làm web MVC truyền thống → JSP.
Nếu dùng ZK framework → ZUL.

--- HttpServletRequest request; request.getRequestDispatcher là gì?

GIẢI THÍCH CHI TIẾT: HttpServletRequest request; request.getRequestDispatcher(...) LÀ GÌ?

I. HttpServletRequest request LÀ GÌ?

1. HttpServletRequest là gì?

HttpServletRequest là một interface trong Java Servlet API (thuộc package: javax.servlet.http hoặc jakarta.servlet.http tùy phiên bản).

Đây là đối tượng đại diện cho HTTP Request mà client (trình duyệt) gửi lên server.

Khi người dùng gửi:
- Submit form
- Gõ URL
- Gửi AJAX
- Gửi REST API request

=> Server (Tomcat, Jetty...) sẽ tạo ra một đối tượng HttpServletRequest chứa toàn bộ thông tin của request đó và truyền vào phương thức doGet() hoặc doPost().

Ví dụ:

protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

}

Trong đó:
- request: chứa dữ liệu client gửi lên
- response: dùng để trả dữ liệu về client


2. request chứa những gì?

request chứa:
- URL người dùng gọi
- HTTP method (GET, POST, PUT...)
- Parameter (form data)
- Header
- Cookie
- Session
- Body
- Attribute nội bộ giữa các servlet

Ví dụ:
request.getParameter("username")
request.getHeader("User-Agent")
request.getSession()


------------------------------------------------------------

II. request.getRequestDispatcher(...) LÀ GÌ?

1. Định nghĩa

getRequestDispatcher(String path) là một phương thức của HttpServletRequest.

Nó dùng để lấy ra một đối tượng RequestDispatcher.

RequestDispatcher cho phép:
- Forward request sang tài nguyên khác (JSP/Servlet)
- Hoặc include nội dung của tài nguyên khác vào response hiện tại

Cú pháp:

RequestDispatcher rd = request.getRequestDispatcher("duongDan");
rd.forward(request, response);

Hoặc:

request.getRequestDispatcher("duongDan").forward(request, response);


------------------------------------------------------------

III. RequestDispatcher LÀ GÌ?

RequestDispatcher là một interface trong Servlet API.

Nó cho phép:
1) forward()
2) include()

Nó hoạt động nội bộ bên trong server (server-side), không phải redirect ra ngoài trình duyệt.


------------------------------------------------------------

IV. forward() HOẠT ĐỘNG NHƯ THẾ NÀO?

Cú pháp:

request.getRequestDispatcher("/home.jsp").forward(request, response);

Giải thích từng bước:

1. User gửi request tới Servlet A
2. Servlet A xử lý logic
3. Servlet A gọi forward sang JSP hoặc Servlet B
4. JSP hoặc Servlet B tiếp tục xử lý
5. Kết quả trả về client

QUAN TRỌNG:

- URL trên trình duyệt KHÔNG thay đổi
- Chỉ có 1 request duy nhất
- request object vẫn được giữ nguyên
- Attribute trong request vẫn còn


------------------------------------------------------------

V. include() HOẠT ĐỘNG NHƯ THẾ NÀO?

Cú pháp:

request.getRequestDispatcher("/header.jsp").include(request, response);

include() sẽ:

- Chạy tài nguyên kia
- Lấy output của nó
- Chèn vào response hiện tại

Nó giống như:
- include file
- tái sử dụng header/footer


------------------------------------------------------------

VI. SO SÁNH forward() VÀ sendRedirect()

forward()                                sendRedirect()

- Server nội bộ chuyển tiếp               - Trình duyệt gửi request mới
- 1 request                               - 2 request
- Không đổi URL                           - Đổi URL
- Giữ được request attribute              - Mất request attribute
- Nhanh hơn                               - Chậm hơn chút

Ví dụ:

response.sendRedirect("home.jsp");

Khi dùng sendRedirect:
- Browser nhận 302
- Browser tự gửi request mới tới home.jsp


------------------------------------------------------------

VII. VÌ SAO PHẢI DÙNG getRequestDispatcher?

Trong mô hình MVC (Model-View-Controller):

Servlet = Controller
JSP = View

Luồng chuẩn:

1. User gửi request
2. Servlet xử lý business logic
3. Lưu dữ liệu vào request.setAttribute()
4. Forward sang JSP
5. JSP hiển thị dữ liệu

Ví dụ đầy đủ:

Servlet:

protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    String name = "Tuan";

    request.setAttribute("name", name);

    request.getRequestDispatcher("/home.jsp").forward(request, response);
}

JSP:

Hello ${name}

Vì forward giữ nguyên request nên JSP nhận được attribute.


------------------------------------------------------------

VIII. LƯU Ý QUAN TRỌNG

1) Path truyền vào getRequestDispatcher là đường dẫn tương đối so với context root nếu bắt đầu bằng "/"

"/home.jsp" => tính từ root của web app

2) Nếu không có "/" ở đầu:
"home.jsp" => tính tương đối so với servlet hiện tại

3) forward() phải được gọi trước khi response commit (trước khi in ra output)

Nếu đã ghi ra response rồi mà forward sẽ lỗi:
IllegalStateException


------------------------------------------------------------

IX. TÓM TẮT NGẮN GỌN

HttpServletRequest request:
→ Là đối tượng chứa toàn bộ thông tin request từ client.

request.getRequestDispatcher(path):
→ Lấy ra RequestDispatcher để chuyển tiếp (forward) hoặc include sang tài nguyên khác trong server.

forward():
→ Chuyển xử lý nội bộ, không đổi URL, giữ nguyên request.

include():
→ Chèn nội dung của tài nguyên khác vào response hiện tại.

Đây là cơ chế cốt lõi trong mô hình MVC khi làm web bằng Servlet + JSP.

--- request.getRequestDispatcher("/path-to-resource").include(request, response)

GIẢI THÍCH CHI TIẾT:

request.getRequestDispatcher("/path-to-resource").include(request, response)

====================================================================

I. TỔNG QUAN

Dòng lệnh:

request.getRequestDispatcher("/path-to-resource").include(request, response);

có nghĩa là:

→ Lấy nội dung của một tài nguyên khác (JSP, Servlet, HTML...)
→ Thực thi nó ở phía server
→ Chèn (include) kết quả của nó vào response hiện tại
→ Sau đó tiếp tục chạy code phía dưới

Đây là cơ chế include phía server (server-side include).

====================================================================

II. PHÂN TÍCH TỪNG PHẦN

1) request

Là đối tượng HttpServletRequest đại diện cho HTTP request hiện tại.

Nó chứa:
- parameter
- header
- session
- attribute
- body

2) getRequestDispatcher("/path-to-resource")

Phương thức này:
- Nhận vào đường dẫn của tài nguyên
- Trả về một đối tượng RequestDispatcher

Lưu ý về đường dẫn:

"/path-to-resource"

Nếu bắt đầu bằng "/":
→ Được tính từ context root của ứng dụng web.

Ví dụ:
Nếu web app có context root là /myapp
Thì:

"/header.jsp"
= http://localhost:8080/myapp/header.jsp


3) include(request, response)

Đây là phương thức của RequestDispatcher.

Nó sẽ:
- Gọi tài nguyên kia
- Chạy code của tài nguyên đó
- Lấy nội dung output của nó
- Ghi thêm (append) vào response hiện tại
- Sau đó quay lại servlet ban đầu để tiếp tục xử lý

====================================================================

III. LUỒNG HOẠT ĐỘNG CHI TIẾT

Giả sử:

User → gửi request → Servlet A

Trong Servlet A có:

request.getRequestDispatcher("/header.jsp").include(request, response);

Luồng chạy:

1) User gọi Servlet A
2) Servlet A bắt đầu xử lý
3) Gặp lệnh include
4) Server tạm dừng Servlet A
5) Server chuyển sang chạy header.jsp
6) header.jsp sinh ra HTML
7) HTML đó được ghi vào response hiện tại
8) Sau khi header.jsp chạy xong
9) Server quay lại Servlet A
10) Servlet A tiếp tục chạy các dòng phía dưới

Quan trọng:

Servlet A KHÔNG bị kết thúc.
Nó chỉ tạm dừng để include tài nguyên khác.

====================================================================

IV. ĐIỂM QUAN TRỌNG NHẤT

include() KHÔNG thay đổi URL trên trình duyệt.

Browser vẫn thấy URL ban đầu.

Chỉ có 1 request duy nhất.

====================================================================

V. SO SÁNH include() VỚI forward()

include()

- Chèn nội dung tài nguyên khác vào response hiện tại
- Sau khi include xong, servlet tiếp tục chạy
- Có thể include nhiều lần
- Thường dùng để chèn header, footer, menu

forward()

- Chuyển hẳn quyền xử lý sang tài nguyên khác
- Servlet hiện tại bị kết thúc
- Không chạy tiếp phía dưới
- Thường dùng để chuyển sang JSP hiển thị kết quả

Ví dụ minh họa:

----------------------
DÙNG include()
----------------------

response.getWriter().println("Start");

request.getRequestDispatcher("/header.jsp").include(request, response);

response.getWriter().println("End");

Kết quả HTML:

Start
(nội dung header.jsp)
End


----------------------
DÙNG forward()
----------------------

response.getWriter().println("Start");

request.getRequestDispatcher("/header.jsp").forward(request, response);

response.getWriter().println("End");

Kết quả:

Chỉ có nội dung header.jsp
"End" sẽ không bao giờ chạy.

====================================================================

VI. include() CÓ GIỮ REQUEST KHÔNG?

Có.

Vì chỉ có 1 request duy nhất nên:

- request parameter vẫn còn
- request attribute vẫn còn
- session vẫn còn

Ví dụ:

request.setAttribute("name", "Tuan");

request.getRequestDispatcher("/show.jsp").include(request, response);

show.jsp có thể đọc:

${name}

====================================================================

VII. include() THƯỜNG DÙNG TRONG TRƯỜNG HỢP NÀO?

1) Chèn header chung
2) Chèn footer chung
3) Chèn menu chung
4) Layout chia nhỏ thành nhiều phần

Ví dụ cấu trúc web:

header.jsp
menu.jsp
content.jsp
footer.jsp

Trong Servlet hoặc JSP:

include header
include menu
include content
include footer

Giúp tái sử dụng code.

====================================================================

VIII. KHÁC GÌ VỚI <%@ include %> TRONG JSP?

Có 2 loại include trong JSP:

1) Directive include:
   <%@ include file="header.jsp" %>

→ Include lúc compile
→ Giống copy-paste code

2) RequestDispatcher include:
   request.getRequestDispatcher("header.jsp").include()

→ Include lúc runtime
→ Linh hoạt hơn
→ Có thể dựa vào điều kiện

====================================================================

IX. CÁC LƯU Ý QUAN TRỌNG

1) include() không được reset response
Tài nguyên được include không được gọi:
response.reset()

2) include() không nên set header hoặc status code
Vì response đã bắt đầu xử lý.

3) Có thể include nhiều lần trong cùng 1 request

4) Nếu include Servlet khác:
Servlet kia sẽ chạy doGet/doPost bình thường.

====================================================================

X. TÓM TẮT BẢN CHẤT

request.getRequestDispatcher("/path").include(request, response)

= Thực thi tài nguyên khác trên server
= Lấy output của nó
= Chèn vào response hiện tại
= Sau đó quay lại servlet ban đầu tiếp tục chạy

Không đổi URL
Không tạo request mới
Không mất request attribute
Dùng chủ yếu để tái sử dụng giao diện (header/footer/layout)

====================================================================

XI. HÌNH DUNG DỄ HIỂU

include() giống như:

Bạn đang viết một tài liệu Word.
Đến đoạn cần chèn nội dung từ file khác.
Bạn copy nội dung file kia dán vào giữa tài liệu.
Sau đó tiếp tục viết tiếp.

forward() thì giống như:
Bạn ngừng viết tài liệu hiện tại và chuyển sang viết tài liệu khác hoàn toàn.

====================================================================

KẾT LUẬN NGẮN GỌN

include() là cơ chế chèn nội dung tài nguyên khác vào response hiện tại trong cùng một request, thường dùng để tái sử dụng giao diện và layout trong ứng dụng Servlet/JSP.

--- Object obj = request.getParameter("abc"); HttpSession session = request.getSession(); Object id = session.getAttribute(obj.toString());

GIẢI THÍCH CHI TIẾT ĐOẠN CODE:

Object obj = request.getParameter("abc");
HttpSession session = request.getSession();
Object id = session.getAttribute(obj.toString());

====================================================================

I. TỔNG QUAN Ý NGHĨA

Đoạn code này thực hiện các bước:

1) Lấy một parameter tên "abc" từ HTTP request.
2) Lấy HttpSession hiện tại.
3) Dùng giá trị của parameter đó làm key để lấy dữ liệu từ session.

Hiểu đơn giản:

Client gửi lên một giá trị.
Server dùng giá trị đó để tìm một object tương ứng đã lưu trong session.

====================================================================

II. PHÂN TÍCH TỪNG DÒNG

--------------------------------------------------------------------
1) Object obj = request.getParameter("abc");
--------------------------------------------------------------------

A. request.getParameter("abc") là gì?

- Đây là phương thức của HttpServletRequest.
- Dùng để lấy dữ liệu người dùng gửi lên qua:
  + Form HTML (method GET hoặc POST)
  + Query string
  + application/x-www-form-urlencoded

Ví dụ:

URL:
http://localhost:8080/app/test?abc=123

Hoặc form:

<input name="abc" value="123" />

Khi đó:

request.getParameter("abc") → trả về "123"

B. Kiểu dữ liệu thực tế trả về là gì?

getParameter() luôn trả về String.

Nó KHÔNG bao giờ trả về Object.

Vậy dòng:

Object obj = request.getParameter("abc");

Thực tế là:

- request.getParameter("abc") trả về String
- String được gán vào Object (vì String là con của Object)

Nên:

obj thực chất là một String.

Ví dụ:
obj = "123"

C. Nếu không tồn tại parameter?

Nếu không có "abc":

request.getParameter("abc") → trả về null

=> obj sẽ là null.

--------------------------------------------------------------------
2) HttpSession session = request.getSession();
--------------------------------------------------------------------

A. getSession() là gì?

- Lấy session hiện tại.
- Nếu chưa có session → tạo mới.
- Nếu đã có session → trả về session đó.

Session dùng để:
- Lưu dữ liệu giữa nhiều request.
- Lưu thông tin người dùng (login, cart, id, role...)

B. Session tồn tại bao lâu?

- Cho đến khi:
  + Hết timeout
  + Gọi session.invalidate()
  + Người dùng đóng browser (tuỳ cấu hình)

--------------------------------------------------------------------
3) Object id = session.getAttribute(obj.toString());
--------------------------------------------------------------------

A. session.getAttribute(String name) là gì?

- Lấy một object đã lưu trong session.
- name là key.

Ví dụ:

session.setAttribute("123", userObject);

Sau đó:

session.getAttribute("123") → trả về userObject

B. obj.toString() có nghĩa gì?

Như phân tích ở trên:
obj thực chất là String (ví dụ "123")

Nên:

obj.toString() → vẫn là "123"

C. Toàn bộ dòng lệnh có nghĩa gì?

Giả sử:

Client gửi:
abc=123

Thì:

obj = "123"

Sau đó:

session.getAttribute("123");

=> Lấy object trong session có key là "123"

====================================================================

III. LUỒNG HOẠT ĐỘNG TOÀN BỘ

Giả sử trước đó:

session.setAttribute("1001", someUserObject);

Sau đó client gửi request:

?abc=1001

Luồng xử lý:

1) request.getParameter("abc") → "1001"
2) obj = "1001"
3) session.getAttribute("1001")
4) id = someUserObject

====================================================================

IV. RỦI RO NGUY HIỂM TRONG ĐOẠN CODE

1) RỦI RO NULL

Nếu:

request.getParameter("abc") trả về null

Thì:

obj = null

Sau đó:

obj.toString()

→ NullPointerException

Vì bạn đang gọi method trên null.

Cách an toàn:

String obj = request.getParameter("abc");
if (obj != null) {
    Object id = session.getAttribute(obj);
}

Hoặc:

Object id = null;
if (obj != null) {
    id = session.getAttribute(obj.toString());
}

--------------------------------------------------------------------

2) VẤN ĐỀ BẢO MẬT

Đây là điểm rất quan trọng.

Bạn đang dùng dữ liệu từ client làm key để truy xuất session.

Điều này có thể nguy hiểm nếu:

- Client đoán được key
- Client cố tình gửi giá trị khác để lấy object khác

Ví dụ:

?abc=admin
?abc=superuser
?abc=1002

Nếu session chứa nhiều object nhạy cảm thì có thể bị truy cập trái phép.

Nên:
Không nên dùng trực tiếp parameter làm key session mà không validate.

====================================================================

V. VÌ SAO DÙNG Object?

Đoạn code dùng:

Object obj
Object id

Thực tế nên dùng:

String obj = request.getParameter("abc");

Vì getParameter trả về String.

Dùng Object ở đây không sai nhưng không rõ ràng.

====================================================================

VI. TÓM TẮT Ý NGHĨA

Dòng 1:
Lấy parameter "abc" từ request.

Dòng 2:
Lấy session hiện tại.

Dòng 3:
Dùng giá trị của parameter làm key để lấy object tương ứng từ session.

Nói đơn giản:

Client gửi lên một key.
Server dùng key đó tìm dữ liệu đã lưu trong session.

====================================================================

VII. PHIÊN BẢN AN TOÀN HƠN

String key = request.getParameter("abc");

HttpSession session = request.getSession(false); // không tạo mới nếu chưa có

Object id = null;

if (key != null && session != null) {
    id = session.getAttribute(key);
}

====================================================================

KẾT LUẬN NGẮN GỌN

- request.getParameter("abc") lấy dữ liệu client gửi lên (String).
- request.getSession() lấy hoặc tạo HttpSession.
- session.getAttribute(obj.toString()) dùng giá trị parameter làm key để lấy object đã lưu trong session.
- Cần kiểm tra null để tránh lỗi NullPointerException.
- Cần validate dữ liệu để tránh rủi ro bảo mật.

-- @ModelAttribute TRONG SPRING MVC

GIẢI THÍCH CHI TIẾT VỀ @ModelAttribute TRONG SPRING MVC
(NHẤN MẠNH TRƯỜNG HỢP SỬ DỤNG LÀM THAM SỐ PHƯƠNG THỨC)

====================================================================
I. @ModelAttribute LÀ GÌ?
====================================================================

@ModelAttribute là annotation trong Spring MVC dùng để:

1) Bind (ánh xạ) dữ liệu từ HTTP request vào một object Java.
2) Đưa object đó vào Model để truyền sang View (JSP, Thymeleaf...).
3) Hoặc khởi tạo sẵn dữ liệu trước khi controller xử lý.

Nó thường dùng trong mô hình MVC:

Client → Controller → Model → View

====================================================================
II. TRƯỜNG HỢP QUAN TRỌNG NHẤT:
@ModelAttribute LÀM THAM SỐ PHƯƠNG THỨC
====================================================================

Cú pháp cơ bản:

@PostMapping("/save")
public String save(@ModelAttribute User user) {
    ...
}

Đây là cách dùng phổ biến nhất.

--------------------------------------------------------------------
1) Điều gì xảy ra phía sau?
--------------------------------------------------------------------

Giả sử có form HTML:

<form action="/save" method="post">
    <input name="name" />
    <input name="age" />
</form>

Và class:

public class User {
    private String name;
    private int age;

    // getter setter
}

Khi submit form:

Spring sẽ tự động:

Bước 1: Tạo một object User mới.
Bước 2: Lấy dữ liệu từ request.
Bước 3: Dựa vào tên field để set giá trị.

Ví dụ:

name=John
age=25

Spring sẽ gọi:

user.setName("John");
user.setAge(25);

Toàn bộ việc này diễn ra tự động.

--------------------------------------------------------------------
2) Vì sao phải dùng @ModelAttribute?
--------------------------------------------------------------------

Thực tế:

Nếu tham số là object phức tạp (POJO), Spring mặc định đã coi nó là @ModelAttribute.

Tức là:

public String save(User user)

vẫn hoạt động.

Tuy nhiên:

Việc ghi rõ @ModelAttribute giúp:
- Code rõ ràng
- Tránh nhầm với @RequestBody
- Dễ đọc
- Kiểm soát tốt hơn

====================================================================
III. @ModelAttribute KHÁC GÌ @RequestBody?
====================================================================

@ModelAttribute:

- Lấy dữ liệu từ form (application/x-www-form-urlencoded)
- Lấy từ query string
- Lấy từ multipart form
- Bind từng field

@RequestBody:

- Dùng cho JSON
- Dùng khi client gửi raw body
- Parse bằng Jackson

Ví dụ:

POST JSON:

{
  "name": "John",
  "age": 25
}

=> phải dùng @RequestBody

====================================================================
IV. @ModelAttribute CÓ ĐƯA OBJECT VÀO MODEL KHÔNG?
====================================================================

CÓ.

Khi dùng:

public String save(@ModelAttribute User user)

Spring sẽ:

1) Bind dữ liệu
2) Tự động add user vào Model
   với key = "user"

=> View có thể truy cập:

${user.name}

====================================================================
V. TRƯỜNG HỢP CÓ TÊN TÙY CHỈNH
====================================================================

public String save(@ModelAttribute("myUser") User user)

Lúc này:

Object được đưa vào model với key là "myUser".

View truy cập:

${myUser.name}

====================================================================
VI. TRƯỜNG HỢP GET FORM + POST SUBMIT
====================================================================

1) Hiển thị form:

@GetMapping("/form")
public String showForm(Model model) {
    model.addAttribute("user", new User());
    return "form";
}

2) Submit form:

@PostMapping("/form")
public String submit(@ModelAttribute User user) {
    ...
}

Spring sẽ bind dữ liệu submit vào object user.

====================================================================
VII. @ModelAttribute DÙNG Ở CẤP METHOD (KHÁC VỚI THAM SỐ)
====================================================================

Ngoài việc dùng làm tham số, @ModelAttribute còn có thể đặt trên method:

@ModelAttribute
public User initUser() {
    return new User();
}

Method này sẽ chạy trước mọi handler method trong controller.

Nó dùng để:
- Chuẩn bị dữ liệu chung
- Tạo dropdown list
- Load dữ liệu mặc định

====================================================================
VIII. CÁCH SPRING BIND DỮ LIỆU
====================================================================

Spring dùng:

WebDataBinder

Nguyên tắc:

Tên field trong form
= Tên property trong object
= Có setter tương ứng

Ví dụ:

<input name="address.street">

Spring sẽ tự động bind nested object.

====================================================================
IX. LỖI THƯỜNG GẶP
====================================================================

1) Không có setter
→ Không bind được.

2) Sai tên field
→ Giá trị không được set.

3) Kiểu dữ liệu sai
→ Lỗi convert type.

Ví dụ:
age = "abc" → int

====================================================================
X. TÌNH HUỐNG THỰC TẾ

Khi nào dùng @ModelAttribute làm tham số?

1) Submit form HTML.
2) Upload file (kết hợp MultipartFile).
3) Search form.
4) Filter dữ liệu.
5) CRUD truyền object nhiều field.

Không dùng khi:
- API REST nhận JSON.
- Client gửi raw JSON.

====================================================================
XI. TÓM TẮT CỐT LÕI

@ModelAttribute khi dùng làm tham số:

1) Spring tự tạo object.
2) Bind dữ liệu request vào object.
3) Tự động add object vào Model.
4) Trả về View có thể sử dụng object đó.

Nó là cơ chế tự động mapping dữ liệu form vào POJO trong Spring MVC.

====================================================================
KẾT LUẬN NGẮN GỌN

@ModelAttribute là cơ chế bind dữ liệu từ HTTP request (form/query) vào object Java và đưa object đó vào Model. Khi dùng làm tham số phương thức, Spring sẽ tự động tạo object, gán giá trị cho các field tương ứng và truyền object đó vào controller.

--- LÀM SAO ĐỂ BIẾT @ModelAttribute User user LẤY DỮ LIỆU TỪ FILE NÀO?

GIẢI THÍCH CHI TIẾT:

LÀM SAO ĐỂ BIẾT @ModelAttribute User user LẤY DỮ LIỆU TỪ FILE NÀO?

====================================================================
I. CÂU HỎI CỐT LÕI
====================================================================

Khi viết:

@PostMapping("/save")
public String save(@ModelAttribute User user) {
    ...
}

Bạn thắc mắc:

Spring lấy dữ liệu từ file nào?
Từ JSP nào?
Từ form nào?

Câu trả lời quan trọng:

@ModelAttribute KHÔNG lấy dữ liệu từ "file".
Nó lấy dữ liệu từ HTTP REQUEST mà client gửi lên.

====================================================================
II. NGUỒN DỮ LIỆU THỰC SỰ LÀ GÌ?
====================================================================

Nguồn dữ liệu đến từ:

1) Form HTML (JSP, Thymeleaf, HTML...)
2) Query string trên URL
3) Dữ liệu multipart/form-data
4) Request parameter

Spring KHÔNG quan tâm file vật lý nào.
Spring chỉ quan tâm:

Request hiện tại chứa những parameter gì.

====================================================================
III. VÍ DỤ THỰC TẾ

Giả sử bạn có file:

form.jsp

Nội dung:

<form action="/save" method="post">
    <input name="name" />
    <input name="age" />
    <button type="submit">Submit</button>
</form>

Khi user nhấn submit:

Trình duyệt gửi HTTP request:

POST /save
Body:
name=John&age=25

====================================================================
IV. LÚC NÀY @ModelAttribute LÀM GÌ?
====================================================================

Spring nhận request:

@PostMapping("/save")
public String save(@ModelAttribute User user)

Spring sẽ:

Bước 1:
Tạo new User()

Bước 2:
Đọc request parameter:
name = "John"
age = "25"

Bước 3:
So khớp tên field trong class User:

public class User {
    private String name;
    private int age;
}

Bước 4:
Gọi setter:

user.setName("John");
user.setAge(25);

Hoàn toàn KHÔNG đọc file JSP.
Nó chỉ đọc dữ liệu từ request.

====================================================================
V. LÀM SAO BIẾT NÓ LẤY TỪ FORM NÀO?
====================================================================

Nó phụ thuộc vào:

Mapping URL.

Ví dụ:

<form action="/save">

Sẽ gọi controller:

@PostMapping("/save")

Vậy:
Form nào submit tới URL đó
→ Controller đó nhận dữ liệu.

Nghĩa là:

URL quyết định controller.
Request parameter quyết định dữ liệu.
Không phải file.

====================================================================
VI. NẾU CÓ NHIỀU FILE JSP THÌ SAO?
====================================================================

Ví dụ:

create.jsp:
<form action="/save" method="post">

edit.jsp:
<form action="/save" method="post">

Cả hai đều submit tới /save.

Spring không phân biệt file nào.
Nó chỉ biết:

Request gửi tới /save
và chứa parameter gì.

====================================================================
VII. NẾU LÀ GET REQUEST THÌ SAO?
====================================================================

Ví dụ:

http://localhost:8080/save?name=John&age=25

Controller:

@GetMapping("/save")
public String save(@ModelAttribute User user)

Spring vẫn bind bình thường.

Vì dữ liệu nằm trong query string.

====================================================================
VIII. KẾT LUẬN QUAN TRỌNG

@ModelAttribute không đọc file.
Nó không biết JSP nào.
Nó không đọc database.
Nó không đọc JSON.

Nó chỉ làm việc với:

HTTP REQUEST hiện tại.

====================================================================
IX. CÁCH TỰ KIỂM TRA NÓ LẤY TỪ ĐÂU
====================================================================

Bạn có thể in ra:

Enumeration<String> names = request.getParameterNames();

Hoặc debug:

System.out.println(user.getName());

Bạn sẽ thấy:
Giá trị đến từ form hoặc URL.

====================================================================
X. VÌ SAO NHIỀU NGƯỜI HIỂU NHẦM?
====================================================================

Vì:

Form nằm trong file JSP.
Nên tưởng Spring đọc file JSP.

Thực tế:

JSP chỉ tạo HTML.
Browser gửi HTTP request.
Spring chỉ xử lý request đó.

====================================================================
XI. TÓM TẮT NGẮN GỌN

@ModelAttribute User user:

1) Spring tạo object User.
2) Lấy dữ liệu từ HTTP request.
3) Dựa vào tên field để bind.
4) Không phụ thuộc file JSP nào.
5) Phụ thuộc URL mapping và parameter gửi lên.

====================================================================
CÂU KẾT LUẬN QUAN TRỌNG NHẤT

Spring không lấy dữ liệu từ file.
Spring lấy dữ liệu từ HTTP request được gửi tới đúng URL mapping của controller.

--- SERIALIZABLE TRONG JAVA

GIẢI THÍCH CHI TIẾT VỀ SERIALIZABLE TRONG JAVA
====================================================================

I. SERIALIZABLE LÀ GÌ?
====================================================================

Serializable là một interface marker trong Java (không có method).

Khai báo:

public class User implements Serializable {
}

Nó dùng để đánh dấu (mark) rằng:
Object của class này có thể được chuyển thành chuỗi byte (byte stream)
để:
- Ghi xuống file
- Gửi qua mạng
- Lưu vào session
- Cache
- Hoặc truyền giữa các JVM

Quá trình đó gọi là: Serialization (Tuần tự hóa).

Quá trình ngược lại gọi là: Deserialization.

====================================================================
II. SERIALIZATION LÀ GÌ?
====================================================================

Serialization là quá trình:

Chuyển object trong bộ nhớ
→ thành dãy byte
→ để lưu trữ hoặc truyền đi.

Ví dụ:

User user = new User("Tuan", 25);

Sau khi serialize:
→ user được chuyển thành một dãy byte.

====================================================================
III. DESERIALIZATION LÀ GÌ?
====================================================================

Deserialization là quá trình:

Chuyển dãy byte
→ thành object lại trong bộ nhớ.

Tức là khôi phục lại trạng thái object ban đầu.

====================================================================
IV. VÌ SAO CẦN SERIALIZABLE?
====================================================================

1) Lưu object xuống file
2) Gửi object qua mạng (RMI, socket)
3) Lưu object vào HttpSession
4) Distributed cache
5) Cluster server (replicate session)

Ví dụ:

Trong web app:

HttpSession session = request.getSession();
session.setAttribute("user", user);

Nếu server dùng session replication:
→ object User phải implements Serializable.

====================================================================
V. CÁCH HOẠT ĐỘNG BÊN TRONG
====================================================================

Java sử dụng:

ObjectOutputStream
ObjectInputStream

Ví dụ serialize:

ObjectOutputStream oos =
    new ObjectOutputStream(new FileOutputStream("user.dat"));

oos.writeObject(user);

Ví dụ deserialize:

ObjectInputStream ois =
    new ObjectInputStream(new FileInputStream("user.dat"));

User user = (User) ois.readObject();

====================================================================
VI. TẠI SAO PHẢI IMPLEMENT SERIALIZABLE?
====================================================================

Nếu class không implements Serializable:

Khi gọi writeObject()
→ Sẽ bị lỗi:

java.io.NotSerializableException

Vì Java yêu cầu class phải được đánh dấu cho phép serialize.

====================================================================
VII. SERIALIZABLE LÀ MARKER INTERFACE
====================================================================

Serializable không có method.

Nó chỉ là một "dấu hiệu" để JVM biết:
Class này cho phép serialize.

====================================================================
VIII. serialVersionUID LÀ GÌ?
====================================================================

Ví dụ:

private static final long serialVersionUID = 1L;

Đây là mã phiên bản của class.

Mục đích:

Khi deserialize,
Java kiểm tra:

serialVersionUID của class hiện tại
có trùng với serialVersionUID lúc serialize không.

Nếu không trùng:
→ InvalidClassException.

====================================================================
IX. VÌ SAO CẦN serialVersionUID?
====================================================================

Nếu bạn thay đổi cấu trúc class:

- Thêm field
- Xóa field
- Đổi kiểu dữ liệu

Thì khi deserialize file cũ
→ Có thể lỗi.

Khai báo serialVersionUID giúp:
- Kiểm soát version
- Tránh lỗi không mong muốn

====================================================================
X. FIELD NÀO ĐƯỢC SERIALIZE?
====================================================================

Mặc định:
- Tất cả field non-static
- Và không có từ khóa transient

Sẽ được serialize.

====================================================================
XI. transient LÀ GÌ?
====================================================================

Nếu bạn không muốn một field được serialize:

private transient String password;

Field password sẽ:
- Không được ghi vào byte stream
- Sau khi deserialize sẽ = null

Dùng khi:
- Dữ liệu nhạy cảm
- Hoặc có thể tính lại

====================================================================
XII. static CÓ ĐƯỢC SERIALIZE KHÔNG?
====================================================================

KHÔNG.

Vì static thuộc về class,
không thuộc object.

====================================================================
XIII. LƯU Ý QUAN TRỌNG
====================================================================

1) Nếu object chứa object khác:
→ Object con cũng phải Serializable.

Ví dụ:

class User implements Serializable {
    private Address address;
}

→ Address cũng phải implements Serializable.

2) Constructor KHÔNG được gọi khi deserialize.
Java khôi phục object trực tiếp từ byte stream.

====================================================================
XIV. HẠN CHẾ CỦA SERIALIZABLE
====================================================================

1) Không an toàn nếu deserialize dữ liệu không tin cậy.
2) Không tương thích tốt khi thay đổi cấu trúc class.
3) Performance không cao.
4) Dễ lỗi version mismatch.

====================================================================
XV. SO SÁNH VỚI JSON SERIALIZATION
====================================================================

Serializable (Java built-in):
- Chuyển thành byte nhị phân
- Dùng trong nội bộ Java
- Không đọc được bằng mắt thường

JSON (Jackson, Gson):
- Chuyển thành text JSON
- Dễ đọc
- Dùng cho REST API

====================================================================
XVI. KHI NÀO NÊN DÙNG?
====================================================================

Nên dùng khi:
- Lưu object xuống file
- Lưu vào session
- Gửi object giữa JVM

Không nên dùng khi:
- Cần tương thích đa nền tảng
- Làm REST API (nên dùng JSON)

====================================================================
XVII. TÓM TẮT NGẮN GỌN
====================================================================

Serializable trong Java là cơ chế cho phép:

Object
→ chuyển thành dãy byte (Serialization)
→ và khôi phục lại (Deserialization).

Phải implements Serializable để Java cho phép quá trình này.
Dùng serialVersionUID để kiểm soát version.
Field static không được serialize.
Field transient sẽ bị bỏ qua.

Đây là cơ chế tuần tự hóa mặc định của Java.

--- .HBM.XML TRONG HIBERNATE

GIẢI THÍCH CHI TIẾT VỀ FILE .HBM.XML TRONG HIBERNATE
====================================================================

I. FILE .HBM.XML LÀ GÌ?
====================================================================

.hbm.xml là file cấu hình mapping trong Hibernate.

HBM = Hibernate Mapping.

File này dùng để:

Mapping giữa:
- Class Java (Entity)
và
- Bảng trong Database

Nói đơn giản:

Nó định nghĩa:
Class nào tương ứng với table nào
Field nào tương ứng với column nào
Quan hệ giữa các bảng ra sao

====================================================================
II. VÌ SAO CẦN .hbm.xml?
====================================================================

Hibernate là ORM (Object Relational Mapping).

ORM nghĩa là:

Object (Java)
↔
Table (Database)

Để Hibernate biết cách chuyển đổi:
- Object → Record
- Record → Object

Nó cần file mapping.

Có 2 cách mapping:

1) Dùng annotation (@Entity, @Table, @Column...)
2) Dùng file .hbm.xml (XML mapping)

.hbm.xml là cách cũ nhưng rất rõ ràng và mạnh mẽ.

====================================================================
III. CẤU TRÚC CƠ BẢN CỦA FILE .HBM.XML
====================================================================

Ví dụ:

User.hbm.xml

<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC
 "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
 "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="com.example.User" table="users">

        <id name="id" column="id">
            <generator class="identity"/>
        </id>

        <property name="name" column="name"/>
        <property name="age" column="age"/>

    </class>
</hibernate-mapping>

====================================================================
IV. GIẢI THÍCH TỪNG PHẦN
====================================================================

1) <hibernate-mapping>

Là thẻ gốc.
Bao toàn bộ cấu hình mapping.

--------------------------------------------------------------------

2) <class>

<class name="com.example.User" table="users">

name:
- Tên class đầy đủ (package + class)

table:
- Tên bảng trong database

Nghĩa là:
Class User ↔ table users

--------------------------------------------------------------------

3) <id>

<id name="id" column="id">

id:
- Khai báo khóa chính (primary key)

name:
- Tên field trong class

column:
- Tên cột trong database

--------------------------------------------------------------------

4) <generator>

<generator class="identity"/>

Xác định cách sinh id.

Một số loại phổ biến:

identity  → auto increment
sequence  → dùng sequence
uuid      → sinh UUID
assigned  → tự set thủ công

--------------------------------------------------------------------

5) <property>

<property name="name" column="name"/>

property:
- Mapping field thường (không phải khóa chính)

name:
- Tên field trong class

column:
- Tên cột trong bảng

====================================================================
V. MAPPING QUAN HỆ (RELATIONSHIP)
====================================================================

1) one-to-many

<set name="orders" table="orders">
    <key column="user_id"/>
    <one-to-many class="com.example.Order"/>
</set>

Nghĩa là:
User có nhiều Order.

--------------------------------------------------------------------

2) many-to-one

<many-to-one name="user"
             class="com.example.User"
             column="user_id"/>

Order thuộc về một User.

--------------------------------------------------------------------

3) many-to-many

<set name="roles" table="user_role">
    <key column="user_id"/>
    <many-to-many class="com.example.Role"
                  column="role_id"/>
</set>

====================================================================
VI. CÁC THUỘC TÍNH QUAN TRỌNG
====================================================================

1) lazy="true"

Tải dữ liệu lười (lazy loading).

2) cascade="all"

Tự động lưu/xóa theo quan hệ.

3) fetch="join"

Join khi truy vấn.

====================================================================
VII. CÁCH KHAI BÁO FILE .HBM.XML
====================================================================

Phải khai báo trong:

hibernate.cfg.xml

<mapping resource="com/example/User.hbm.xml"/>

Nếu không khai báo:
Hibernate sẽ không biết file mapping.

====================================================================
VIII. SO SÁNH .HBM.XML VỚI ANNOTATION
====================================================================

.hbm.xml:

Ưu điểm:
- Tách cấu hình khỏi code
- Dễ chỉnh sửa mà không cần compile lại
- Phù hợp hệ thống lớn

Nhược điểm:
- Dài dòng
- Khó quản lý nhiều file

Annotation:

Ưu điểm:
- Gọn
- Dễ đọc
- Phổ biến hiện nay

Nhược điểm:
- Trộn config vào code

====================================================================
IX. LUỒNG HOẠT ĐỘNG
====================================================================

Khi Hibernate chạy:

1) Đọc hibernate.cfg.xml
2) Load các file .hbm.xml
3) Tạo metadata mapping
4) Khi truy vấn:
   - SQL được sinh dựa trên mapping
5) Kết quả SQL
   → Chuyển thành object Java

====================================================================
X. TÓM TẮT NGẮN GỌN
====================================================================

.hbm.xml là file mapping XML trong Hibernate dùng để:

- Ánh xạ class Java với bảng database
- Định nghĩa khóa chính
- Định nghĩa column
- Định nghĩa quan hệ giữa các bảng
- Cấu hình lazy loading, cascade...

Nó là cơ chế ORM dựa trên XML của Hibernate.

Hiện nay phần lớn dự án dùng annotation thay vì .hbm.xml, nhưng nguyên lý mapping vẫn giống nhau.

--- VÌ SAO TRONG SOURCE CODE CÓ SỰ KẾT HỢP GIỮA .HBM.XML VÀ hibernate.cfg.xml

GIẢI THÍCH CHI TIẾT:
VÌ SAO TRONG SOURCE CODE CÓ SỰ KẾT HỢP GIỮA .HBM.XML VÀ hibernate.cfg.xml

====================================================================
I. CÂU HỎI CỐT LÕI
====================================================================

Bạn thấy trong project có:

- File: hibernate.cfg.xml
- Và nhiều file: *.hbm.xml

Vậy:

Chúng liên quan gì với nhau?
Tại sao phải dùng cả hai?
Chúng phối hợp với nhau như thế nào?

Câu trả lời ngắn gọn:

hibernate.cfg.xml là file cấu hình tổng.
.hbm.xml là file mapping chi tiết từng entity.

hibernate.cfg.xml sẽ LOAD các file .hbm.xml.

====================================================================
II. VAI TRÒ CỦA hibernate.cfg.xml
====================================================================

hibernate.cfg.xml là file cấu hình chính của Hibernate.

Nó dùng để:

1) Cấu hình kết nối database
2) Cấu hình dialect
3) Cấu hình driver
4) Username / password
5) Show SQL
6) Mapping resource (chính là .hbm.xml)

Ví dụ:

<hibernate-configuration>
    <session-factory>

        <property name="hibernate.connection.driver_class">
            com.mysql.cj.jdbc.Driver
        </property>

        <property name="hibernate.connection.url">
            jdbc:mysql://localhost:3306/test
        </property>

        <property name="hibernate.connection.username">
            root
        </property>

        <property name="hibernate.connection.password">
            123456
        </property>

        <property name="hibernate.dialect">
            org.hibernate.dialect.MySQLDialect
        </property>

        <property name="hibernate.show_sql">
            true
        </property>

        <mapping resource="com/example/User.hbm.xml"/>
        <mapping resource="com/example/Order.hbm.xml"/>

    </session-factory>
</hibernate-configuration>

====================================================================
III. VAI TRÒ CỦA FILE .HBM.XML
====================================================================

.hbm.xml là file mapping.

Nó chỉ làm nhiệm vụ:

Mapping class Java ↔ table database.

Ví dụ:

User.hbm.xml

<class name="com.example.User" table="users">
    <id name="id" column="id">
        <generator class="identity"/>
    </id>

    <property name="name" column="name"/>
</class>

Nó KHÔNG chứa:
- Thông tin kết nối database
- Driver
- Password
- Dialect

====================================================================
IV. MỐI QUAN HỆ GIỮA HAI FILE
====================================================================

Quan hệ như sau:

hibernate.cfg.xml
        ↓
Load các file .hbm.xml
        ↓
Tạo metadata mapping
        ↓
Tạo SessionFactory
        ↓
Sinh SQL dựa vào mapping

Nói đơn giản:

hibernate.cfg.xml là trung tâm.
.hbm.xml là thành phần phụ thuộc.

====================================================================
V. LUỒNG HOẠT ĐỘNG KHI CHẠY CHƯƠNG TRÌNH
====================================================================

Khi ứng dụng khởi động:

1) Hibernate đọc hibernate.cfg.xml
2) Thiết lập kết nối DB
3) Đọc các thẻ <mapping resource="...">
4) Load từng file .hbm.xml
5) Phân tích mapping
6) Tạo SessionFactory
7) Sẵn sàng thao tác DB

Nếu không khai báo .hbm.xml trong hibernate.cfg.xml
→ Hibernate sẽ không biết mapping đó tồn tại.

====================================================================
VI. VÌ SAO PHẢI TÁCH RA 2 FILE?
====================================================================

Lý do thiết kế:

1) Phân tách trách nhiệm (Separation of concerns)

hibernate.cfg.xml:
→ Cấu hình hệ thống

.hbm.xml:
→ Cấu hình mapping entity

2) Dễ mở rộng

Có thể thêm entity mới
Chỉ cần thêm file .hbm.xml
Và thêm dòng mapping vào cfg

3) Dễ bảo trì

Thay đổi mapping
Không cần sửa file cấu hình DB

====================================================================
VII. NẾU KHÔNG DÙNG .HBM.XML THÌ SAO?
====================================================================

Nếu dùng annotation:

@Entity
@Table(name="users")

Thì trong hibernate.cfg.xml
có thể dùng:

<mapping class="com.example.User"/>

Lúc này:
Không cần file .hbm.xml nữa.

====================================================================
VIII. TẠI SAO NHIỀU PROJECT CŨ DÙNG CẢ HAI?
====================================================================

Vì:

1) Hibernate ban đầu thiết kế dựa trên XML.
2) Annotation xuất hiện sau (JPA).
3) Nhiều hệ thống enterprise cũ vẫn dùng XML mapping.

====================================================================
IX. HÌNH DUNG DỄ HIỂU
====================================================================

Hãy tưởng tượng:

hibernate.cfg.xml
= bộ điều khiển trung tâm.

.hbm.xml
= bản vẽ chi tiết từng bảng.

Không có cfg:
→ Không biết kết nối DB.

Không có hbm:
→ Không biết mapping object nào.

Cần cả hai để Hibernate hoạt động đầy đủ.

====================================================================
X. TÓM TẮT NGẮN GỌN
====================================================================

hibernate.cfg.xml:
- Cấu hình tổng thể Hibernate.
- Kết nối database.
- Load mapping.

.hbm.xml:
- Mapping class Java ↔ table database.
- Định nghĩa id, property, quan hệ.

Quan hệ giữa chúng:

hibernate.cfg.xml khai báo và load các file .hbm.xml.
Hibernate đọc cfg trước, sau đó đọc hbm để biết cách mapping dữ liệu.

Đây là cách cấu hình truyền thống của Hibernate dựa trên XML.

--- applicationContext-business.xml TRONG SPRING

GIẢI THÍCH CHI TIẾT VỀ applicationContext-business.xml TRONG SPRING
====================================================================

I. applicationContext-business.xml LÀ GÌ?
====================================================================

applicationContext-business.xml là một file cấu hình của Spring Framework
dùng để khai báo các bean thuộc tầng Business (Service layer).

Tên file có thể khác nhau tùy project, ví dụ:
- applicationContext.xml
- applicationContext-service.xml
- applicationContext-dao.xml
- applicationContext-web.xml

Nhưng “business” thường ám chỉ:
→ Chứa các bean xử lý nghiệp vụ (Service).

====================================================================
II. VAI TRÒ CỦA FILE NÀY
====================================================================

Trong kiến trúc nhiều tầng (layered architecture):

Controller
↓
Service (Business logic)
↓
DAO / Repository
↓
Database

applicationContext-business.xml thường chứa:
- Các bean Service
- Cấu hình transaction
- Inject DAO vào Service

====================================================================
III. CẤU TRÚC CƠ BẢN
====================================================================

Ví dụ:

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop">

    <!-- Khai báo Service -->
    <bean id="userService"
          class="com.example.service.UserServiceImpl">

        <property name="userDao" ref="userDao"/>

    </bean>

    <!-- Cấu hình transaction -->
    <tx:annotation-driven transaction-manager="transactionManager"/>

</beans>

====================================================================
IV. GIẢI THÍCH TỪNG PHẦN
====================================================================

1) <beans>

Là thẻ gốc.
Bao toàn bộ cấu hình bean.

--------------------------------------------------------------------

2) <bean>

Dùng để khai báo một object do Spring quản lý (Spring Bean).

Ví dụ:

<bean id="userService"
      class="com.example.service.UserServiceImpl">

id:
- Tên bean trong container.

class:
- Class cụ thể được tạo object.

--------------------------------------------------------------------

3) <property>

<property name="userDao" ref="userDao"/>

Dùng để inject dependency.

Nghĩa là:

Spring sẽ:
- Tạo userService
- Gán userDao vào field userDao

Tương đương với:

@Autowired
private UserDao userDao;

====================================================================
V. VÌ SAO PHẢI TÁCH FILE BUSINESS?
====================================================================

Trong hệ thống lớn, cấu hình có thể chia thành:

applicationContext-dao.xml
applicationContext-business.xml
applicationContext-web.xml

Lý do:

1) Phân chia rõ ràng từng layer
2) Dễ bảo trì
3) Dễ quản lý
4) Tránh file quá lớn

====================================================================
VI. TRANSACTION THƯỜNG NẰM TRONG FILE BUSINESS
====================================================================

Vì:

Transaction thường áp dụng ở tầng Service.

Ví dụ:

@Transactional
public void createUser(User user) {
    ...
}

Trong XML:

<tx:annotation-driven transaction-manager="transactionManager"/>

Hoặc cấu hình transaction bằng AOP.

====================================================================
VII. QUAN HỆ VỚI CÁC FILE KHÁC
====================================================================

Thông thường:

web.xml
↓
Load applicationContext.xml
↓
applicationContext.xml import các file khác

Ví dụ:

<import resource="applicationContext-dao.xml"/>
<import resource="applicationContext-business.xml"/>

Như vậy:

Spring container sẽ load tất cả bean từ nhiều file.

====================================================================
VIII. LUỒNG HOẠT ĐỘNG
====================================================================

Khi ứng dụng khởi động:

1) Spring đọc applicationContext-business.xml
2) Tạo các bean Service
3) Inject DAO
4) Cấu hình transaction
5) Lưu tất cả vào IoC container

Khi Controller gọi:

userService.createUser()

Spring trả về bean đã được inject đầy đủ.

====================================================================
IX. SO SÁNH VỚI CẤU HÌNH BẰNG ANNOTATION
====================================================================

Ngày nay nhiều project không dùng XML nữa,
mà dùng annotation:

@Service
public class UserServiceImpl implements UserService {
}

Và bật component scan:

<context:component-scan base-package="com.example"/>

Khi đó:
Không cần khai báo bean trong XML.

====================================================================
X. TÓM TẮT NGẮN GỌN
====================================================================

applicationContext-business.xml là:

File cấu hình Spring dùng để:
- Khai báo các bean thuộc tầng Business (Service).
- Inject DAO vào Service.
- Cấu hình transaction.
- Tổ chức cấu hình theo từng layer.

Nó là một phần của Spring IoC container
giúp quản lý và kết nối các thành phần trong ứng dụng.

--- HIBERNATE SESSION VÀ HIBERNATE QUERY

GIẢI THÍCH CHI TIẾT VỀ HIBERNATE SESSION VÀ HIBERNATE QUERY
====================================================================

I. HIBERNATE SESSION LÀ GÌ?
====================================================================

Hibernate Session là một interface trung tâm của Hibernate.

Nó đại diện cho:
- Một phiên làm việc (working unit)
- Một kết nối logic giữa ứng dụng và database
- Một vùng quản lý vòng đời của object (Persistence Context)

Nói đơn giản:

Session là nơi bạn:
- Lưu object
- Sửa object
- Xóa object
- Truy vấn object

Mọi thao tác với database trong Hibernate đều thông qua Session.

====================================================================
II. SESSION ĐƯỢC TẠO NHƯ THẾ NÀO?
====================================================================

SessionFactory sessionFactory = ...;

Session session = sessionFactory.openSession();

Hoặc:

Session session = sessionFactory.getCurrentSession();

Sự khác nhau:

openSession():
- Luôn tạo session mới.

getCurrentSession():
- Lấy session gắn với transaction hiện tại.

====================================================================
III. SESSION QUẢN LÝ GÌ?
====================================================================

1) Persistence Context (First Level Cache)
2) Transaction
3) Mapping object ↔ database
4) Dirty checking
5) Lazy loading

====================================================================
IV. PERSISTENCE CONTEXT (FIRST LEVEL CACHE)
====================================================================

Mỗi Session có một bộ nhớ cache riêng.

Ví dụ:

User user1 = session.get(User.class, 1);
User user2 = session.get(User.class, 1);

Chỉ query database 1 lần.
Lần sau lấy từ cache.

Khi session đóng:
→ cache bị xóa.

====================================================================
V. CÁC THAO TÁC CƠ BẢN VỚI SESSION
====================================================================

1) Lưu object

session.save(user);

2) Cập nhật

session.update(user);

3) Xóa

session.delete(user);

4) Lấy theo id

User user = session.get(User.class, 1);

====================================================================
VI. VÒNG ĐỜI OBJECT TRONG SESSION
====================================================================

1) Transient
   - Mới tạo bằng new
   - Chưa gắn với session

2) Persistent
   - Đang được quản lý bởi session

3) Detached
   - Đã từng persistent
   - Nhưng session đã đóng

====================================================================
VII. TRANSACTION VỚI SESSION
====================================================================

Transaction tx = session.beginTransaction();

session.save(user);

tx.commit();

Nếu không commit:
→ dữ liệu không được ghi xuống DB.

====================================================================
VIII. HIBERNATE QUERY LÀ GÌ?
====================================================================

Hibernate Query là cách bạn truy vấn dữ liệu.

Có 3 loại chính:

1) HQL (Hibernate Query Language)
2) Criteria API
3) Native SQL

====================================================================
IX. HQL LÀ GÌ?
====================================================================

HQL giống SQL nhưng:

- Query trên class
- Không query trực tiếp trên table

Ví dụ:

String hql = "FROM User WHERE age > :age";

Query query = session.createQuery(hql);

query.setParameter("age", 18);

List<User> list = query.list();

Lưu ý:

FROM User
KHÔNG phải FROM users
(User là tên class)

====================================================================
X. CÁCH DÙNG QUERY
====================================================================

1) createQuery() → HQL

Query<User> query = session.createQuery("FROM User", User.class);

2) createSQLQuery() → Native SQL

Query query = session.createSQLQuery("SELECT * FROM users");

3) getSingleResult()

User user = query.uniqueResult();

====================================================================
XI. PARAMETER TRONG QUERY
====================================================================

Named parameter:

:age

query.setParameter("age", 20);

Positional parameter:

?1

query.setParameter(1, 20);

====================================================================
XII. LAZY LOADING VỚI SESSION
====================================================================

Nếu một field được cấu hình lazy:

@ManyToOne(fetch = FetchType.LAZY)

Hibernate chỉ load khi gọi getter.

Nếu session đã đóng:
→ LazyInitializationException

====================================================================
XIII. SESSION KHÔNG THREAD-SAFE
====================================================================

Session không dùng chung giữa nhiều thread.

Mỗi request web nên có một session riêng.

====================================================================
XIV. SESSION FACTORY
====================================================================

SessionFactory:
- Tạo một lần khi ứng dụng khởi động
- Thread-safe
- Tạo Session

Session:
- Tạo nhiều lần
- Không thread-safe

====================================================================
XV. SO SÁNH SESSION VÀ JDBC CONNECTION
====================================================================

JDBC Connection:
- Gửi SQL trực tiếp

Hibernate Session:
- Làm việc với object
- Tự sinh SQL
- Quản lý cache
- Quản lý trạng thái object

====================================================================
XVI. TÓM TẮT NGẮN GỌN
====================================================================

Hibernate Session:
- Là trung tâm thao tác với database.
- Quản lý vòng đời object.
- Có first-level cache.
- Gắn với transaction.

Hibernate Query:
- Là cách truy vấn dữ liệu qua HQL, Criteria hoặc SQL.
- Query trên class thay vì table.
- Hỗ trợ parameter an toàn.

Session là môi trường làm việc.
Query là công cụ truy vấn trong môi trường đó.

--- org.hibernate.SessionFactory

GIẢI THÍCH CHI TIẾT VỀ org.hibernate.SessionFactory
====================================================================

I. SessionFactory LÀ GÌ?
====================================================================

org.hibernate.SessionFactory là một interface quan trọng nhất trong Hibernate.

Nó là:
- Nhà máy (factory) tạo ra các Session.
- Đối tượng trung tâm quản lý toàn bộ cấu hình Hibernate.
- Thành phần đại diện cho một database.

Hiểu đơn giản:

SessionFactory = "Nhà máy tạo Session"
Session = "Phiên làm việc với database"

====================================================================
II. VỊ TRÍ CỦA SessionFactory TRONG KIẾN TRÚC HIBERNATE
====================================================================

Luồng hoạt động cơ bản:

Configuration
     ↓
SessionFactory
     ↓
Session
     ↓
Transaction
     ↓
Database

Giải thích:

1) Configuration đọc:
   - hibernate.cfg.xml
   - file .hbm.xml hoặc entity annotation

2) Từ Configuration build ra SessionFactory.

3) SessionFactory tạo ra Session.

4) Session thực hiện:
   - save()
   - update()
   - delete()
   - query()

====================================================================
III. VAI TRÒ CHÍNH CỦA SessionFactory
====================================================================

1) Tạo Session

Session session = sessionFactory.openSession();

Hoặc:

Session session = sessionFactory.getCurrentSession();

--------------------------------------------------------------------

2) Lưu trữ metadata

SessionFactory chứa:
- Thông tin mapping entity
- Thông tin cấu hình database
- Dialect
- Cache configuration

--------------------------------------------------------------------

3) Quản lý cache cấp 2 (Second Level Cache)

SessionFactory quản lý:
- Second-level cache
- Query cache

--------------------------------------------------------------------

4) Thread-safe

SessionFactory:
- Thread-safe
- Có thể dùng chung toàn bộ ứng dụng

====================================================================
IV. TẠI SAO CHỈ TẠO 1 SessionFactory?
====================================================================

SessionFactory rất:

- Nặng (heavy-weight object)
- Tốn tài nguyên
- Mất thời gian khởi tạo

Khi khởi tạo SessionFactory, Hibernate sẽ:

- Đọc tất cả file mapping
- Phân tích entity
- Tạo metadata
- Chuẩn bị SQL generator
- Tạo cache

Vì vậy:

Nguyên tắc chuẩn:
Chỉ tạo 1 SessionFactory cho mỗi database.

====================================================================
V. VÒNG ĐỜI CỦA SessionFactory
====================================================================

1) Tạo khi ứng dụng khởi động
2) Dùng suốt vòng đời ứng dụng
3) Đóng khi ứng dụng shutdown

Ví dụ:

SessionFactory sessionFactory = 
    new Configuration()
        .configure()
        .buildSessionFactory();

Khi shutdown:

sessionFactory.close();

====================================================================
VI. PHÂN BIỆT SessionFactory VÀ Session
====================================================================

SessionFactory:
- Tạo 1 lần
- Dùng chung
- Thread-safe
- Nặng

Session:
- Tạo nhiều lần
- Không thread-safe
- Nhẹ
- Đại diện 1 đơn vị làm việc (unit of work)

Ví dụ:

SessionFactory → như nhà máy
Session → như công nhân làm việc

====================================================================
VII. openSession() VS getCurrentSession()
====================================================================

1) openSession()

- Luôn tạo session mới
- Phải tự close()
- Không tự quản lý transaction

2) getCurrentSession()

- Gắn với context hiện tại
- Thường dùng với Spring
- Tự động đóng khi transaction kết thúc

====================================================================
VIII. SESSIONFACTORY TRONG SPRING
====================================================================

Trong Spring (không dùng JPA):

Spring sẽ:

- Tạo SessionFactory như một Bean
- Inject vào DAO

Ví dụ:

@Autowired
private SessionFactory sessionFactory;

Sau đó:

Session session = sessionFactory.getCurrentSession();

====================================================================
IX. SESSIONFACTORY VÀ CONNECTION POOL
====================================================================

SessionFactory thường tích hợp với:

- C3P0
- HikariCP
- DBCP

Nó không tự quản lý connection đơn lẻ,
mà sử dụng connection pool.

====================================================================
X. INTERNAL BÊN TRONG SessionFactory
====================================================================

Bên trong SessionFactory chứa:

1) Metadata về entity
2) Mapping table
3) SQL generator
4) Cache manager
5) Transaction factory
6) Service registry

Nó là trung tâm của toàn bộ Hibernate runtime.

====================================================================
XI. LỖI THƯỜNG GẶP
====================================================================

1) Tạo SessionFactory trong mỗi request
→ Sai hoàn toàn
→ Làm hệ thống cực chậm

2) Không đóng SessionFactory khi shutdown
→ Memory leak

3) Tạo nhiều SessionFactory cho cùng 1 database
→ Tốn tài nguyên

====================================================================
XII. SƠ ĐỒ TƯ DUY
====================================================================

Application start
      ↓
Build SessionFactory (1 lần)
      ↓
Mỗi request:
    open Session
    begin Transaction
    CRUD
    commit
    close Session
      ↓
Application shutdown
      ↓
Close SessionFactory

====================================================================
XIII. TÓM TẮT CỰC NGẮN
====================================================================

org.hibernate.SessionFactory là:

- Nhà máy tạo Session
- Được tạo một lần
- Thread-safe
- Chứa toàn bộ cấu hình Hibernate
- Trung tâm quản lý cache và metadata
- Đại diện cho một database trong ứng dụng

Nếu Hibernate là một nhà máy sản xuất,
thì SessionFactory chính là toàn bộ nhà máy,
còn Session chỉ là một ca làm việc trong nhà máy đó.

--- org.hibernate.SessionFactory session; session.openSession() và session.close() là gì?

GIẢI THÍCH CHI TIẾT:

org.hibernate.SessionFactory session
session.openSession() và session.close() là gì?

====================================================================
I. PHÂN TÍCH DÒNG KHAI BÁO:
====================================================================

org.hibernate.SessionFactory session;

Dòng này có nghĩa:

- org.hibernate.SessionFactory: là kiểu dữ liệu (interface của Hibernate).
- session: là tên biến.

LƯU Ý:
Đặt tên biến là "session" cho SessionFactory là không chuẩn,
vì dễ nhầm với org.hibernate.Session.

Nên đặt:

SessionFactory sessionFactory;

====================================================================
II. SessionFactory LÀ GÌ?
====================================================================

SessionFactory là:

- Nhà máy tạo ra Session.
- Đại diện cho một database.
- Được tạo một lần khi ứng dụng khởi động.
- Thread-safe (có thể dùng chung).

Ví dụ tạo SessionFactory:

SessionFactory sessionFactory =
    new Configuration()
        .configure("hibernate.cfg.xml")
        .buildSessionFactory();

====================================================================
III. sessionFactory.openSession() LÀ GÌ?
====================================================================

openSession() là phương thức của SessionFactory.

Nó có nhiệm vụ:

- Tạo ra một Session mới.
- Mở một phiên làm việc với database.

Ví dụ:

Session session = sessionFactory.openSession();

Giải thích:

Session = một phiên làm việc với database.
Nó giống như bạn mở một kết nối làm việc tạm thời.

====================================================================
IV. Session LÀ GÌ?
====================================================================

Session đại diện cho:

- Một kết nối tới database.
- Một đơn vị làm việc (unit of work).
- Nơi thực hiện CRUD.

CRUD bao gồm:

- save()
- update()
- delete()
- get()
- createQuery()

====================================================================
V. session.close() LÀ GÌ?
====================================================================

session.close() có nhiệm vụ:

- Đóng Session.
- Giải phóng kết nối database.
- Trả connection về connection pool.

Ví dụ đầy đủ:

Session session = sessionFactory.openSession();

Transaction tx = session.beginTransaction();

session.save(user);

tx.commit();

session.close();

====================================================================
VI. VÒNG ĐỜI HOẠT ĐỘNG
====================================================================

1) SessionFactory tạo 1 lần
2) Mỗi request:
    - openSession()
    - beginTransaction()
    - xử lý
    - commit()
    - close()

====================================================================
VII. TẠI SAO PHẢI close()?
====================================================================

Nếu không gọi session.close():

- Connection không được trả về pool.
- Có thể gây memory leak.
- Hết connection.
- Ứng dụng bị treo.

Session KHÔNG tự đóng nếu bạn dùng openSession().

====================================================================
VIII. openSession() HOẠT ĐỘNG NHƯ THẾ NÀO?
====================================================================

Khi gọi:

sessionFactory.openSession();

Hibernate sẽ:

1) Lấy connection từ connection pool.
2) Tạo một đối tượng Session.
3) Gắn connection vào Session.
4) Sẵn sàng thao tác database.

====================================================================
IX. PHÂN BIỆT openSession() VÀ getCurrentSession()
====================================================================

openSession():
- Luôn tạo session mới.
- Phải tự close().
- Không tự quản lý transaction.

getCurrentSession():
- Gắn với context hiện tại.
- Thường dùng trong Spring.
- Tự động đóng khi transaction kết thúc.

====================================================================
X. SƠ ĐỒ HOẠT ĐỘNG
====================================================================

SessionFactory
      ↓
openSession()
      ↓
Session
      ↓
beginTransaction()
      ↓
Thực hiện CRUD
      ↓
commit()
      ↓
close()

====================================================================
XI. LỖI THƯỜNG GẶP
====================================================================

1) Quên close()

Sai:

Session session = sessionFactory.openSession();
session.save(user);

Đúng:

Session session = sessionFactory.openSession();
try {
    session.save(user);
} finally {
    session.close();
}

2) Tạo SessionFactory trong mỗi request
→ Sai nghiêm trọng

====================================================================
XII. TÓM TẮT CỰC NGẮN
====================================================================

org.hibernate.SessionFactory:
- Nhà máy tạo Session.
- Tạo 1 lần duy nhất.

openSession():
- Mở một phiên làm việc mới với database.
- Trả về đối tượng Session.

session.close():
- Đóng phiên làm việc.
- Giải phóng tài nguyên.

Hiểu đơn giản:

SessionFactory = nhà máy
openSession() = mở ca làm việc
Session = ca làm việc
close() = kết thúc ca làm việc

--- session.beginTransaction()

GIẢI THÍCH CHI TIẾT VỀ session.beginTransaction()

====================================================================
I. session.beginTransaction() LÀ GÌ?
====================================================================

session.beginTransaction() là phương thức của org.hibernate.Session.

Nó có nhiệm vụ:

- Bắt đầu một Transaction (giao dịch).
- Tạo một đơn vị xử lý dữ liệu có tính toàn vẹn (atomic).
- Chuẩn bị để commit hoặc rollback.

Nó trả về một đối tượng:

org.hibernate.Transaction

Ví dụ:

Transaction tx = session.beginTransaction();

====================================================================
II. TRANSACTION LÀ GÌ?
====================================================================

Transaction (giao dịch) là một nhóm thao tác database được thực hiện như một khối thống nhất.

Đặc điểm của Transaction theo nguyên tắc ACID:

1) Atomicity (Tính nguyên tử)
   - Hoặc thành công toàn bộ
   - Hoặc thất bại toàn bộ

2) Consistency (Tính nhất quán)
   - Database luôn hợp lệ trước và sau giao dịch

3) Isolation (Tính cô lập)
   - Giao dịch này không ảnh hưởng giao dịch khác

4) Durability (Tính bền vững)
   - Sau commit, dữ liệu được lưu vĩnh viễn

====================================================================
III. TẠI SAO PHẢI beginTransaction()?
====================================================================

Database hiện đại (Oracle, PostgreSQL, MySQL…) yêu cầu:

- Mọi thao tác INSERT, UPDATE, DELETE nên nằm trong transaction.
- Nếu không commit → dữ liệu không được lưu.

Nếu không dùng transaction:

- Có thể gây lỗi.
- Có thể dữ liệu không được ghi xuống database.
- Không rollback được khi có lỗi.

====================================================================
IV. LUỒNG HOẠT ĐỘNG CHUẨN
====================================================================

Session session = sessionFactory.openSession();

Transaction tx = null;

try {
    tx = session.beginTransaction();

    session.save(user);

    tx.commit();

} catch (Exception e) {

    if (tx != null) {
        tx.rollback();
    }

} finally {
    session.close();
}

====================================================================
V. session.beginTransaction() LÀM GÌ BÊN TRONG?
====================================================================

Khi gọi:

session.beginTransaction();

Hibernate sẽ:

1) Tạo đối tượng Transaction.
2) Bắt đầu giao dịch ở mức JDBC.
3) Set autoCommit = false.
4) Chuẩn bị theo dõi các thay đổi trong Session.

====================================================================
VI. COMMIT() VÀ ROLLBACK()
====================================================================

1) commit()

tx.commit();

- Gửi tất cả SQL xuống database.
- Lưu dữ liệu vĩnh viễn.
- Kết thúc transaction.

2) rollback()

tx.rollback();

- Hủy toàn bộ thay đổi.
- Trả database về trạng thái trước khi beginTransaction().
- Dùng khi có lỗi.

====================================================================
VII. ĐIỀU GÌ XẢY RA NẾU KHÔNG COMMIT?
====================================================================

Nếu bạn:

- beginTransaction()
- save()
- nhưng không commit()

Thì:

- SQL có thể chưa được gửi xuống database.
- Khi session đóng → dữ liệu mất.
- Transaction bị rollback tự động.

====================================================================
VIII. CÁC LOẠI THAO TÁC CẦN TRANSACTION
====================================================================

CẦN transaction:

- save()
- update()
- delete()
- merge()
- bulk query

KHÔNG bắt buộc (nhưng vẫn nên dùng):

- select (read-only)

====================================================================
IX. TRONG SPRING THÌ SAO?
====================================================================

Nếu dùng Spring + @Transactional:

Bạn KHÔNG cần gọi:

session.beginTransaction();

Spring sẽ tự:

- begin
- commit
- rollback

Ví dụ:

@Transactional
public void saveUser(User user) {
    session.save(user);
}

====================================================================
X. MỘT SỐ LỖI THƯỜNG GẶP
====================================================================

1) Không rollback khi có exception
→ Dẫn tới transaction bị treo.

2) Gọi commit nhiều lần
→ Lỗi trạng thái transaction.

3) Quên beginTransaction()
→ Lỗi khi thực hiện update/delete.

====================================================================
XI. SƠ ĐỒ TƯ DUY
====================================================================

openSession()
     ↓
beginTransaction()
     ↓
Thực hiện CRUD
     ↓
commit() hoặc rollback()
     ↓
close()

====================================================================
XII. TÓM TẮT CỰC NGẮN
====================================================================

session.beginTransaction() là:

- Lệnh bắt đầu một giao dịch.
- Chuẩn bị cho commit hoặc rollback.
- Đảm bảo tính toàn vẹn dữ liệu.
- Bắt buộc khi ghi dữ liệu xuống database.

Nếu không có transaction:
- Không đảm bảo an toàn dữ liệu.
- Không rollback được khi lỗi.

Hiểu đơn giản:

beginTransaction() = bắt đầu một "hợp đồng".
commit() = ký xác nhận.
rollback() = hủy hợp đồng.

--- session.saveOrUpdate(value)

GIẢI THÍCH CHI TIẾT VỀ session.saveOrUpdate(value)

====================================================================
I. session.saveOrUpdate(value) LÀ GÌ?
====================================================================

session.saveOrUpdate(value) là một phương thức của org.hibernate.Session.

Nó có nhiệm vụ:

- Nếu object CHƯA tồn tại trong database → INSERT
- Nếu object ĐÃ tồn tại trong database → UPDATE

Nói đơn giản:

saveOrUpdate() = "Nếu chưa có thì lưu mới, nếu có rồi thì cập nhật"

====================================================================
II. CÚ PHÁP
====================================================================

session.saveOrUpdate(object);

Ví dụ:

User user = new User();
user.setId(1);
user.setName("Nguyen Van A");

session.saveOrUpdate(user);

====================================================================
III. HIBERNATE QUYẾT ĐỊNH INSERT HAY UPDATE NHƯ THẾ NÀO?
====================================================================

Hibernate dựa vào:

1) Giá trị của ID (primary key)
2) Trạng thái của object trong Session

--------------------------------------------------------------------
TRƯỜNG HỢP 1: ID = null hoặc chưa có trong DB
--------------------------------------------------------------------

→ Hibernate hiểu là object mới
→ Thực hiện INSERT

--------------------------------------------------------------------
TRƯỜNG HỢP 2: ID đã tồn tại trong DB
--------------------------------------------------------------------

→ Hibernate hiểu là object đã tồn tại
→ Thực hiện UPDATE

====================================================================
IV. CÁC TRẠNG THÁI CỦA OBJECT TRONG HIBERNATE
====================================================================

Hibernate có 3 trạng thái chính:

1) Transient
   - Object mới tạo
   - Chưa liên kết với Session
   - Chưa có trong database

2) Persistent
   - Đang được quản lý bởi Session
   - Đã có trong database

3) Detached
   - Đã từng persistent
   - Nhưng Session đã đóng

saveOrUpdate() xử lý tốt cả Transient và Detached.

====================================================================
V. VÍ DỤ CỤ THỂ
====================================================================

Trường hợp 1: INSERT

User user = new User();
user.setName("A");

session.saveOrUpdate(user);

→ Hibernate sinh SQL:

INSERT INTO user ...

--------------------------------------------------------------------

Trường hợp 2: UPDATE

User user = session.get(User.class, 1);
user.setName("B");

session.saveOrUpdate(user);

→ Hibernate sinh SQL:

UPDATE user SET name='B' WHERE id=1

====================================================================
VI. KHÁC NHAU GIỮA save() VÀ saveOrUpdate()
====================================================================

save():
- Chỉ dùng để INSERT.
- Nếu ID đã tồn tại → lỗi.

saveOrUpdate():
- Tự động quyết định INSERT hoặc UPDATE.
- Linh hoạt hơn.

====================================================================
VII. SO SÁNH saveOrUpdate() VÀ merge()
====================================================================

saveOrUpdate():
- Gắn object vào Session hiện tại.
- Nếu đã có object cùng ID trong Session → lỗi.

merge():
- Không gắn trực tiếp object truyền vào.
- Tạo bản sao được quản lý.
- An toàn hơn trong nhiều trường hợp.

====================================================================
VIII. LƯU Ý QUAN TRỌNG
====================================================================

1) Phải nằm trong Transaction

Transaction tx = session.beginTransaction();
session.saveOrUpdate(user);
tx.commit();

2) Nếu không commit:
→ Dữ liệu không được lưu.

3) Nếu ID được sinh tự động (AUTO, IDENTITY):
→ Hibernate tự xử lý INSERT.

====================================================================
IX. LỖI THƯỜNG GẶP
====================================================================

1) NonUniqueObjectException

Xảy ra khi:
- Trong Session đã có object với ID = 1
- Bạn gọi saveOrUpdate() với object khác cũng ID = 1

2) Không có transaction
→ Lỗi khi update.

====================================================================
X. LUỒNG HOẠT ĐỘNG BÊN TRONG
====================================================================

Khi gọi saveOrUpdate():

1) Hibernate kiểm tra ID.
2) Kiểm tra object có đang trong Session không.
3) Nếu chưa có:
     - INSERT hoặc UPDATE tương ứng.
4) Đưa object vào trạng thái Persistent.
5) Chờ commit() để thực thi SQL.

====================================================================
XI. SƠ ĐỒ TƯ DUY
====================================================================

Object truyền vào
      ↓
Kiểm tra ID
      ↓
Nếu ID null → INSERT
Nếu ID tồn tại → UPDATE
      ↓
Đưa vào Persistence Context
      ↓
commit() → gửi SQL xuống database

====================================================================
XII. TÓM TẮT CỰC NGẮN
====================================================================

session.saveOrUpdate(value) là:

- Phương thức lưu hoặc cập nhật object.
- Nếu object mới → INSERT.
- Nếu object đã tồn tại → UPDATE.
- Phải dùng trong transaction.
- Hibernate quyết định dựa vào ID.

Hiểu đơn giản:

saveOrUpdate() = "Thông minh tự biết khi nào thêm mới, khi nào cập nhật".

--- session.flush()

GIẢI THÍCH CHI TIẾT VỀ session.flush()

====================================================================
I. session.flush() LÀ GÌ?
====================================================================

session.flush() là phương thức của org.hibernate.Session.

Nó có nhiệm vụ:

- Đồng bộ (synchronize) dữ liệu trong bộ nhớ (Persistence Context)
  xuống database.
- Gửi các câu SQL (INSERT, UPDATE, DELETE) đang chờ xuống DB.
- NHƯNG KHÔNG commit transaction.

Quan trọng:
flush() ≠ commit()

====================================================================
II. HIBERNATE LÀM VIỆC NHƯ THẾ NÀO?
====================================================================

Hibernate không gửi SQL xuống database ngay khi bạn gọi:

session.save()
session.update()
session.delete()

Thay vào đó:

- Hibernate lưu thay đổi trong bộ nhớ (Persistence Context).
- Chỉ khi flush() hoặc commit() thì SQL mới được gửi đi.

====================================================================
III. FLUSH LÀ GÌ VỀ BẢN CHẤT?
====================================================================

Flush = đồng bộ bộ nhớ với database.

Tức là:

Bộ nhớ (Session cache)
      ↓
Đẩy SQL xuống database
      ↓
Nhưng transaction vẫn chưa kết thúc

====================================================================
IV. VÍ DỤ CỤ THỂ
====================================================================

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

User user = new User();
user.setName("A");

session.save(user);

session.flush();   // SQL INSERT được gửi xuống DB tại đây

tx.commit();       // Transaction kết thúc tại đây

session.close();

====================================================================
V. FLUSH KHÁC COMMIT NHƯ THẾ NÀO?
====================================================================

flush():
- Gửi SQL xuống DB.
- Không kết thúc transaction.
- Có thể rollback được.

commit():
- Gửi SQL (nếu chưa flush).
- Kết thúc transaction.
- Không rollback được sau commit.

====================================================================
VI. KHI NÀO HIBERNATE TỰ FLUSH?
====================================================================

Hibernate tự flush khi:

1) Trước khi commit()
2) Trước khi thực hiện một query SELECT
   (để đảm bảo dữ liệu nhất quán)

Ví dụ:

session.save(user);
session.createQuery("from User").list();

→ Hibernate tự flush trước khi query.

====================================================================
VII. FLUSH MODE
====================================================================

Hibernate có các chế độ flush:

1) AUTO (mặc định)
   - Tự flush khi cần thiết.

2) COMMIT
   - Chỉ flush khi commit.

3) MANUAL
   - Chỉ flush khi gọi flush() thủ công.

Ví dụ:

session.setFlushMode(FlushMode.MANUAL);

====================================================================
VIII. TẠI SAO CẦN session.flush() THỦ CÔNG?
====================================================================

1) Khi muốn chắc chắn SQL đã được gửi.
2) Khi xử lý batch lớn để tránh tốn bộ nhớ.
3) Khi cần lấy ID sinh tự động ngay lập tức.

Ví dụ batch:

for (int i = 0; i < 1000; i++) {
    session.save(userList.get(i));

    if (i % 50 == 0) {
        session.flush();
        session.clear();
    }
}

====================================================================
IX. FLUSH KHÔNG LÀM GÌ?
====================================================================

flush() KHÔNG:

- Kết thúc transaction
- Đóng session
- Giải phóng connection

====================================================================
X. FLUSH VÀ ROLLBACK
====================================================================

Nếu bạn:

session.save(user);
session.flush();
tx.rollback();

→ Dữ liệu vẫn bị hủy.
Vì flush chỉ gửi SQL, chưa commit.

====================================================================
XI. SƠ ĐỒ HOẠT ĐỘNG
====================================================================

save()
   ↓
Thay đổi lưu trong Session
   ↓
flush()
   ↓
SQL gửi xuống DB
   ↓
commit()
   ↓
Dữ liệu lưu vĩnh viễn

====================================================================
XII. LỖI THƯỜNG GẶP
====================================================================

1) Tưởng flush là commit
→ Sai.

2) Gọi flush quá nhiều
→ Giảm hiệu năng.

3) Không clear() khi batch lớn
→ OutOfMemoryError.

====================================================================
XIII. TÓM TẮT CỰC NGẮN
====================================================================

session.flush() là:

- Đồng bộ dữ liệu từ Session xuống database.
- Gửi SQL nhưng không commit.
- Có thể rollback sau flush.
- Hibernate thường tự flush trước commit hoặc query.

Hiểu đơn giản:

flush() = "Gửi SQL xuống database"
commit() = "Chốt giao dịch"

--- transaction.commit()

GIẢI THÍCH CHI TIẾT VỀ transaction.commit()

====================================================================
I. transaction.commit() LÀ GÌ?
====================================================================

transaction.commit() là phương thức của org.hibernate.Transaction.

Nó có nhiệm vụ:

- Kết thúc transaction hiện tại.
- Xác nhận (commit) tất cả thay đổi.
- Ghi dữ liệu vĩnh viễn xuống database.
- Không thể rollback sau khi commit thành công.

====================================================================
II. TRANSACTION LÀ GÌ (NHẮC LẠI NGẮN GỌN)?
====================================================================

Transaction là một khối thao tác database:

- Hoặc thành công toàn bộ.
- Hoặc thất bại toàn bộ.

Nó đảm bảo tính ACID:
- Atomicity
- Consistency
- Isolation
- Durability

====================================================================
III. LUỒNG HOẠT ĐỘNG CHUẨN
====================================================================

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

session.save(user);

tx.commit();

session.close();

====================================================================
IV. transaction.commit() LÀM GÌ BÊN TRONG?
====================================================================

Khi gọi:

tx.commit();

Hibernate sẽ:

1) Gọi session.flush() (nếu chưa flush).
2) Gửi tất cả SQL xuống database.
3) Gọi commit ở mức JDBC.
4) Database ghi dữ liệu vĩnh viễn.
5) Kết thúc transaction.

====================================================================
V. COMMIT KHÁC FLUSH NHƯ THẾ NÀO?
====================================================================

flush():
- Chỉ gửi SQL xuống DB.
- Chưa kết thúc transaction.
- Có thể rollback.

commit():
- Gửi SQL (nếu cần).
- Kết thúc transaction.
- Không thể rollback sau đó.

====================================================================
VI. VÍ DỤ RÕ SỰ KHÁC BIỆT
====================================================================

session.save(user);
session.flush();
tx.rollback();

→ Dữ liệu bị hủy.

--------------------------------------------

session.save(user);
tx.commit();
tx.rollback();  // Không còn tác dụng

→ Dữ liệu đã được lưu vĩnh viễn.

====================================================================
VII. NẾU KHÔNG GỌI commit() THÌ SAO?
====================================================================

Nếu bạn:

- beginTransaction()
- save()
- nhưng không commit()

Thì:

- Dữ liệu không được lưu.
- Khi session đóng → transaction bị rollback.
- Mọi thay đổi mất hết.

====================================================================
VIII. LỖI THƯỜNG GẶP
====================================================================

1) Quên commit()
→ Không thấy dữ liệu trong database.

2) Gọi commit() nhiều lần
→ Lỗi IllegalStateException.

3) Commit sau khi rollback()
→ Lỗi trạng thái transaction.

====================================================================
IX. CẤU TRÚC AN TOÀN CHUẨN
====================================================================

Transaction tx = null;

try {
    tx = session.beginTransaction();

    session.save(user);

    tx.commit();

} catch (Exception e) {

    if (tx != null) {
        tx.rollback();
    }

} finally {
    session.close();
}

====================================================================
X. SAU KHI commit(), ĐIỀU GÌ XẢY RA?
====================================================================

1) Transaction kết thúc.
2) Session vẫn còn mở.
3) Có thể mở transaction mới nếu cần.
4) Connection vẫn được giữ cho đến khi session.close().

====================================================================
XI. TRONG SPRING @Transactional
====================================================================

Nếu dùng Spring:

@Transactional
public void saveUser(User user) {
    session.save(user);
}

→ Spring tự động:

- begin
- commit nếu không có lỗi
- rollback nếu có exception

Bạn không cần gọi commit() thủ công.

====================================================================
XII. SƠ ĐỒ TỔNG QUÁT
====================================================================

openSession()
      ↓
beginTransaction()
      ↓
Thực hiện CRUD
      ↓
commit()
      ↓
Dữ liệu lưu vĩnh viễn
      ↓
close()

====================================================================
XIII. TÓM TẮT CỰC NGẮN
====================================================================

transaction.commit() là:

- Lệnh kết thúc giao dịch.
- Ghi dữ liệu vĩnh viễn xuống database.
- Không thể rollback sau commit.
- Tự động flush nếu cần.

Hiểu đơn giản:

flush() = gửi SQL
commit() = chốt và xác nhận giao dịch
rollback() = hủy giao dịch

--- Query query; query.setMaxResults(pageSize); query.setFirstResult(pageSize * pageIndex)

GIẢI THÍCH CHI TIẾT VỀ:

Query query
query.setMaxResults(pageSize)
query.setFirstResult(pageSize * pageIndex)

====================================================================
I. NGỮ CẢNH SỬ DỤNG
====================================================================

Đây là các lệnh dùng trong Hibernate để PHÂN TRANG (Pagination).

Phân trang có nghĩa là:

- Không lấy toàn bộ dữ liệu trong database.
- Chỉ lấy một phần dữ liệu theo từng trang.
- Ví dụ: mỗi trang 10 bản ghi.

====================================================================
II. Query query LÀ GÌ?
====================================================================

Query là đối tượng đại diện cho một câu truy vấn HQL hoặc SQL.

Ví dụ:

Query query = session.createQuery("from User order by id");

Query này sẽ trả về danh sách User.

====================================================================
III. query.setMaxResults(pageSize) LÀ GÌ?
====================================================================

setMaxResults(pageSize) có nghĩa là:

- Giới hạn số bản ghi tối đa được trả về.
- Tương đương với LIMIT trong SQL.

Ví dụ:

pageSize = 10

query.setMaxResults(10);

→ Chỉ lấy tối đa 10 dòng.

====================================================================
IV. query.setFirstResult(pageSize * pageIndex) LÀ GÌ?
====================================================================

setFirstResult() xác định:

- Bắt đầu lấy dữ liệu từ vị trí nào (offset).

Công thức:

offset = pageSize * pageIndex

Ví dụ:

pageSize = 10
pageIndex = 0

offset = 10 * 0 = 0
→ Lấy từ dòng đầu tiên

--------------------------------------------

pageIndex = 1

offset = 10 * 1 = 10
→ Bỏ qua 10 dòng đầu
→ Lấy từ dòng thứ 11

--------------------------------------------

pageIndex = 2

offset = 10 * 2 = 20
→ Bỏ qua 20 dòng đầu
→ Lấy từ dòng thứ 21

====================================================================
V. VÍ DỤ ĐẦY ĐỦ
====================================================================

int pageSize = 10;
int pageIndex = 2;

Query query = session.createQuery("from User order by id");

query.setFirstResult(pageSize * pageIndex);
query.setMaxResults(pageSize);

List<User> users = query.list();

====================================================================
VI. SQL TƯƠNG ĐƯƠNG
====================================================================

Nếu dùng MySQL:

SELECT * FROM user
ORDER BY id
LIMIT 10 OFFSET 20;

Nếu dùng Oracle:

SELECT * FROM (
   SELECT a.*, ROWNUM rnum FROM (
      SELECT * FROM user ORDER BY id
   ) a WHERE ROWNUM <= 30
) WHERE rnum > 20;

Hibernate tự động chuyển đổi theo database.

====================================================================
VII. LƯU Ý QUAN TRỌNG
====================================================================

1) pageIndex thường bắt đầu từ 0.

Nếu muốn pageIndex bắt đầu từ 1:

offset = pageSize * (pageIndex - 1)

2) Phải có ORDER BY
Nếu không:
- Dữ liệu có thể không ổn định giữa các trang.

====================================================================
VIII. VÍ DỤ MINH HỌA PHÂN TRANG
====================================================================

Giả sử có 35 bản ghi.
pageSize = 10

Trang 0:
- Lấy 0 -> 9

Trang 1:
- Lấy 10 -> 19

Trang 2:
- Lấy 20 -> 29

Trang 3:
- Lấy 30 -> 34

====================================================================
IX. LỖI THƯỜNG GẶP
====================================================================

1) Nhầm pageIndex với pageNumber

Nếu người dùng nhập trang 1, 2, 3...

Bạn phải trừ 1:

offset = pageSize * (pageNumber - 1)

2) Không dùng ORDER BY
→ Dữ liệu mỗi trang có thể bị lặp hoặc thiếu.

====================================================================
X. SƠ ĐỒ HOẠT ĐỘNG
====================================================================

Query gốc (1000 bản ghi)
        ↓
setFirstResult(offset)
        ↓
Bỏ qua offset dòng đầu
        ↓
setMaxResults(pageSize)
        ↓
Chỉ lấy pageSize dòng tiếp theo

====================================================================
XI. TÓM TẮT CỰC NGẮN
====================================================================

query.setMaxResults(pageSize)
→ Giới hạn số dòng trả về (LIMIT).

query.setFirstResult(offset)
→ Bỏ qua offset dòng đầu (OFFSET).

offset = pageSize * pageIndex

Hiểu đơn giản:

setFirstResult = bắt đầu từ đâu
setMaxResults = lấy bao nhiêu dòng

--- java.util.Properties

GIẢI THÍCH CHI TIẾT VỀ java.util.Properties

====================================================================
I. java.util.Properties LÀ GÌ?
====================================================================

java.util.Properties là một class trong Java dùng để:

- Lưu trữ dữ liệu dạng key-value (chuỗi - chuỗi).
- Đọc và ghi file cấu hình (.properties).
- Quản lý cấu hình ứng dụng.

Properties kế thừa từ Hashtable<Object, Object>.

Tuy nhiên:
Trong thực tế ta chỉ dùng kiểu String cho key và value.

====================================================================
II. CẤU TRÚC CỦA FILE .properties
====================================================================

Ví dụ file config.properties:

db.url=jdbc:mysql://localhost:3306/test
db.username=root
db.password=123456
app.name=MyApp

Định dạng:

key=value

Hoặc:

key : value

====================================================================
III. TẠO ĐỐI TƯỢNG Properties
====================================================================

Properties properties = new Properties();

====================================================================
IV. THÊM DỮ LIỆU VÀO Properties
====================================================================

properties.setProperty("username", "admin");
properties.setProperty("password", "123");

Hoặc:

properties.put("key", "value");

Khuyến nghị:
Nên dùng setProperty() vì nó đảm bảo key và value là String.

====================================================================
V. LẤY GIÁ TRỊ
====================================================================

String username = properties.getProperty("username");

Nếu key không tồn tại:

String value = properties.getProperty("abc", "defaultValue");

====================================================================
VI. ĐỌC FILE .properties
====================================================================

Properties properties = new Properties();

FileInputStream fis = new FileInputStream("config.properties");

properties.load(fis);

fis.close();

Sau đó:

String url = properties.getProperty("db.url");

====================================================================
VII. GHI FILE .properties
====================================================================

Properties properties = new Properties();

properties.setProperty("app.name", "TestApp");

FileOutputStream fos = new FileOutputStream("config.properties");

properties.store(fos, "Application Config");

fos.close();

====================================================================
VIII. LOAD TỪ CLASSPATH
====================================================================

InputStream input =
    getClass().getClassLoader().getResourceAsStream("config.properties");

Properties properties = new Properties();
properties.load(input);

====================================================================
IX. ỨNG DỤNG THỰC TẾ
====================================================================

1) Lưu cấu hình database.
2) Lưu cấu hình môi trường (dev, test, prod).
3) Lưu thông số hệ thống.
4) Cấu hình Hibernate, Spring, logging.

====================================================================
X. ĐẶC ĐIỂM QUAN TRỌNG
====================================================================

1) Chỉ hỗ trợ String key và String value khi dùng setProperty().
2) Hỗ trợ comment bằng dấu # hoặc !.
3) Tự động bỏ qua dòng trống.
4) Không hỗ trợ cấu trúc phức tạp (chỉ key-value).

====================================================================
XI. PHÂN BIỆT VỚI HashMap
====================================================================

Properties:
- Chuyên dùng cho cấu hình.
- Có thể load/store từ file.
- Tự hỗ trợ định dạng .properties.

HashMap:
- Chỉ là cấu trúc dữ liệu.
- Không hỗ trợ load/store file.

====================================================================
XII. VÍ DỤ TỔNG HỢP
====================================================================

Properties prop = new Properties();

FileInputStream fis = new FileInputStream("db.properties");

prop.load(fis);

String url = prop.getProperty("db.url");
String user = prop.getProperty("db.username");

System.out.println(url);

fis.close();

====================================================================
XIII. LỖI THƯỜNG GẶP
====================================================================

1) File không tồn tại → FileNotFoundException.
2) Không đóng stream → rò rỉ tài nguyên.
3) Encoding tiếng Việt → cần xử lý UTF-8.

====================================================================
XIV. VẤN ĐỀ ENCODING
====================================================================

Theo mặc định:

Properties.load(InputStream)
→ dùng ISO-8859-1.

Nếu file UTF-8:

Nên dùng:

InputStreamReader reader =
    new InputStreamReader(new FileInputStream("config.properties"), "UTF-8");

properties.load(reader);

====================================================================
XV. TÓM TẮT CỰC NGẮN
====================================================================

java.util.Properties là:

- Class quản lý cấu hình dạng key=value.
- Có thể đọc và ghi file .properties.
- Dùng nhiều cho cấu hình hệ thống.
- Chỉ lưu trữ chuỗi.

Hiểu đơn giản:

Properties = công cụ đọc và quản lý file cấu hình key-value trong Java.

--- FileInputStream KHÁC GÌ VỚI InputStream

GIẢI THÍCH CHI TIẾT:
FileInputStream KHÁC GÌ VỚI InputStream

====================================================================
I. TỔNG QUAN
====================================================================

InputStream là một class trừu tượng (abstract class).

FileInputStream là một class cụ thể (concrete class)
kế thừa từ InputStream.

Quan hệ:

InputStream (cha)
        ↑
FileInputStream (con)

====================================================================
II. InputStream LÀ GÌ?
====================================================================

InputStream thuộc package java.io.

Nó là lớp cha đại diện cho:

- Luồng đọc dữ liệu dạng byte.
- Có thể đọc từ nhiều nguồn khác nhau.

Ví dụ nguồn dữ liệu:
- File
- Mạng (socket)
- Bộ nhớ (byte array)
- Resource trong classpath

InputStream là ABSTRACT → không thể new trực tiếp.

Sai:

InputStream in = new InputStream();   // lỗi

====================================================================
III. FileInputStream LÀ GÌ?
====================================================================

FileInputStream là class cụ thể dùng để:

- Đọc dữ liệu từ file trên ổ đĩa.

Ví dụ:

FileInputStream fis = new FileInputStream("data.txt");

Nó đọc dữ liệu dạng byte từ file.

====================================================================
IV. SO SÁNH CHI TIẾT
====================================================================

1) Bản chất

InputStream:
- Là abstract class.
- Là khái niệm chung.

FileInputStream:
- Là implementation cụ thể.
- Chuyên đọc file.

----------------------------------------------------

2) Có thể new trực tiếp?

InputStream:
- Không.

FileInputStream:
- Có.

----------------------------------------------------

3) Phạm vi sử dụng

InputStream:
- Tổng quát.
- Có thể trỏ tới nhiều loại stream khác nhau.

FileInputStream:
- Chỉ đọc từ file.

----------------------------------------------------

4) Ví dụ đa hình

InputStream in = new FileInputStream("a.txt");

Ở đây:
- Kiểu tham chiếu: InputStream
- Đối tượng thật: FileInputStream

Đây gọi là POLYMORPHISM (đa hình).

====================================================================
V. VÍ DỤ THỰC TẾ
====================================================================

Ví dụ 1: Dùng FileInputStream trực tiếp

FileInputStream fis = new FileInputStream("a.txt");
int data = fis.read();
fis.close();

----------------------------------------------------

Ví dụ 2: Dùng kiểu InputStream

InputStream in = new FileInputStream("a.txt");
int data = in.read();
in.close();

Hai cách đều hoạt động như nhau.

====================================================================
VI. TẠI SAO NÊN DÙNG InputStream LÀM KIỂU?
====================================================================

Lý do:

- Linh hoạt.
- Dễ thay đổi implementation.

Ví dụ:

InputStream in;

if (fromFile) {
    in = new FileInputStream("a.txt");
} else {
    in = new ByteArrayInputStream(data);
}

Code phía dưới không cần biết nguồn là gì.

====================================================================
VII. CÁC CLASS KHÁC KẾ THỪA InputStream
====================================================================

Ngoài FileInputStream còn có:

- ByteArrayInputStream
- BufferedInputStream
- ObjectInputStream
- DataInputStream
- PipedInputStream

Tất cả đều là InputStream.

====================================================================
VIII. SƠ ĐỒ KẾ THỪA
====================================================================

java.lang.Object
        ↓
java.io.InputStream
        ↓
FileInputStream

====================================================================
IX. KHI NÀO DÙNG CÁI NÀO?
====================================================================

Dùng FileInputStream khi:
- Biết chắc đang đọc từ file.

Dùng InputStream khi:
- Viết code tổng quát.
- Muốn linh hoạt nguồn dữ liệu.
- Viết thư viện.

====================================================================
X. TÓM TẮT CỰC NGẮN
====================================================================

InputStream:
- Lớp cha trừu tượng.
- Đại diện cho luồng đọc byte.

FileInputStream:
- Lớp con cụ thể.
- Dùng để đọc byte từ file.

Hiểu đơn giản:

InputStream = khái niệm chung về luồng đọc.
FileInputStream = luồng đọc từ file.

--- KeyStore TRONG JAVA

GIẢI THÍCH CHI TIẾT VỀ KeyStore TRONG JAVA

====================================================================
I. KeyStore LÀ GÌ?
====================================================================

KeyStore là một cơ chế trong Java dùng để:

- Lưu trữ khóa bảo mật (cryptographic keys).
- Lưu trữ chứng chỉ số (digital certificates).
- Bảo vệ khóa bằng mật khẩu.

Hiểu đơn giản:

KeyStore = "két sắt" lưu khóa và chứng chỉ.

====================================================================
II. KeyStore LƯU NHỮNG GÌ?
====================================================================

KeyStore có thể chứa:

1) Private Key (khóa bí mật)
2) Public Key (khóa công khai)
3) Certificate (chứng chỉ số)
4) Secret Key (khóa đối xứng)

Mỗi mục trong KeyStore được gọi là một Entry.

====================================================================
III. CÁC LOẠI ENTRY TRONG KEYSTORE
====================================================================

1) PrivateKeyEntry
   - Private key
   - Certificate chain

2) SecretKeyEntry
   - Khóa đối xứng (AES…)

3) TrustedCertificateEntry
   - Chỉ chứa certificate
   - Không có private key

====================================================================
IV. VỊ TRÍ CỦA KeyStore
====================================================================

KeyStore thường được lưu dưới dạng file.

Ví dụ:

- keystore.jks
- keystore.p12

====================================================================
V. CÁC ĐỊNH DẠNG PHỔ BIẾN
====================================================================

1) JKS (Java KeyStore)
   - Định dạng cũ mặc định của Java.

2) PKCS12 (.p12, .pfx)
   - Chuẩn quốc tế.
   - Từ Java 9 trở đi là mặc định.

====================================================================
VI. CÁCH TẠO KeyStore BẰNG keytool
====================================================================

Tạo keystore:

keytool -genkeypair \
  -alias mykey \
  -keyalg RSA \
  -keystore keystore.jks

====================================================================
VII. CÁCH LOAD KEYSTORE TRONG JAVA
====================================================================

KeyStore keyStore = KeyStore.getInstance("JKS");

FileInputStream fis = new FileInputStream("keystore.jks");

keyStore.load(fis, "password".toCharArray());

fis.close();

====================================================================
VIII. LẤY PRIVATE KEY TỪ KEYSTORE
====================================================================

Key key = keyStore.getKey("aliasName", "keyPassword".toCharArray());

Nếu là PrivateKey:

PrivateKey privateKey = (PrivateKey) key;

====================================================================
IX. LẤY CERTIFICATE
====================================================================

Certificate cert = keyStore.getCertificate("aliasName");

PublicKey publicKey = cert.getPublicKey();

====================================================================
X. ỨNG DỤNG THỰC TẾ
====================================================================

1) HTTPS (SSL/TLS)
   - Server lưu private key trong keystore.
   - Trình duyệt dùng certificate để xác thực.

2) Ký số (Digital Signature)

3) Mã hóa / giải mã dữ liệu

4) Ứng dụng ngân hàng, bảo mật cao

====================================================================
XI. MẬT KHẨU TRONG KEYSTORE
====================================================================

KeyStore có 2 loại mật khẩu:

1) Store password
   - Bảo vệ toàn bộ file keystore.

2) Key password
   - Bảo vệ từng private key.

====================================================================
XII. TẠI SAO PHẢI DÙNG KeyStore?
====================================================================

Nếu bạn lưu private key trong file text:

→ Rất nguy hiểm.

KeyStore:

- Mã hóa khóa.
- Bảo vệ bằng password.
- Chuẩn bảo mật.

====================================================================
XIII. SƠ ĐỒ HOẠT ĐỘNG
====================================================================

Ứng dụng
    ↓
Load KeyStore
    ↓
Lấy private key
    ↓
Dùng để ký / giải mã

====================================================================
XIV. SỰ KHÁC NHAU GIỮA KeyStore VÀ TrustStore
====================================================================

KeyStore:
- Lưu private key + certificate của chính mình.

TrustStore:
- Lưu certificate của bên thứ ba tin cậy.
- Dùng để xác thực server.

====================================================================
XV. TÓM TẮT CỰC NGẮN
====================================================================

KeyStore là:

- Kho lưu trữ khóa bảo mật và certificate.
- Được bảo vệ bằng mật khẩu.
- Dùng trong SSL, ký số, mã hóa.

Hiểu đơn giản:

KeyStore = két sắt lưu chìa khóa bảo mật trong Java.

--- javax.servlet.http.HttpServlet

GIẢI THÍCH CHI TIẾT VỀ javax.servlet.http.HttpServlet

====================================================================
I. HttpServlet LÀ GÌ?
====================================================================

javax.servlet.http.HttpServlet là một class trong Servlet API.

Nó dùng để:

- Xử lý request HTTP từ client (trình duyệt).
- Tạo response trả về client.
- Là nền tảng của ứng dụng web Java truyền thống.

Hiểu đơn giản:

HttpServlet = lớp xử lý request HTTP trong Java Web.

====================================================================
II. VỊ TRÍ TRONG HỆ THỐNG
====================================================================

Trình duyệt
    ↓ (HTTP Request)
Web Server (Tomcat)
    ↓
Servlet Container
    ↓
HttpServlet
    ↓ (HTTP Response)
Trình duyệt

====================================================================
III. KẾ THỪA CỦA HttpServlet
====================================================================

Object
   ↓
GenericServlet
   ↓
HttpServlet

GenericServlet:
- Lớp cơ bản cho mọi loại giao thức.

HttpServlet:
- Chuyên xử lý giao thức HTTP.

====================================================================
IV. CÁC PHƯƠNG THỨC QUAN TRỌNG
====================================================================

1) doGet()
   - Xử lý HTTP GET.

2) doPost()
   - Xử lý HTTP POST.

3) doPut()
4) doDelete()
5) doHead()

====================================================================
V. VÍ DỤ ĐƠN GIẢN
====================================================================

public class HelloServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request,
                         HttpServletResponse response)
            throws ServletException, IOException {

        response.setContentType("text/html");

        PrintWriter out = response.getWriter();

        out.println("<h1>Hello World</h1>");
    }
}

====================================================================
VI. VÒNG ĐỜI CỦA HttpServlet
====================================================================

1) init()
   - Gọi một lần khi servlet được khởi tạo.

2) service()
   - Gọi mỗi khi có request.
   - Tự động phân phối sang doGet/doPost.

3) destroy()
   - Gọi khi servlet bị hủy.

====================================================================
VII. CƠ CHẾ service()
====================================================================

Khi có request đến:

service(request, response)

Bên trong service:

Nếu method = GET → gọi doGet()
Nếu method = POST → gọi doPost()

Bạn không cần override service() trong hầu hết trường hợp.

====================================================================
VIII. HttpServletRequest LÀ GÌ?
====================================================================

Đại diện cho HTTP request.

Cho phép:

- Lấy parameter
- Lấy header
- Lấy session
- Lấy body

Ví dụ:

String name = request.getParameter("name");

====================================================================
IX. HttpServletResponse LÀ GÌ?
====================================================================

Đại diện cho HTTP response.

Cho phép:

- Trả dữ liệu về client
- Set header
- Redirect
- Forward

Ví dụ:

response.sendRedirect("home.jsp");

====================================================================
X. CÁCH ĐĂNG KÝ SERVLET
====================================================================

1) Cách cũ (web.xml)

<servlet>
    <servlet-name>HelloServlet</servlet-name>
    <servlet-class>com.example.HelloServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>HelloServlet</servlet-name>
    <url-pattern>/hello</url-pattern>
</servlet-mapping>

--------------------------------------------

2) Cách mới (Annotation)

@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
}

====================================================================
XI. THREAD-SAFE VÀ ĐA LUỒNG
====================================================================

Servlet chỉ được tạo 1 instance.

Mỗi request:
- Chạy trên 1 thread khác nhau.
- Dùng cùng một object servlet.

Do đó:

KHÔNG nên dùng biến instance để lưu dữ liệu request.

Sai:

private String name;

Đúng:

String name = request.getParameter("name");

====================================================================
XII. MỐI QUAN HỆ VỚI JSP VÀ FRAMEWORK
====================================================================

JSP thực chất cũng được compile thành servlet.

Các framework như:
- Spring MVC
- Struts

Đều chạy trên nền tảng Servlet.

====================================================================
XIII. SERVER CHẠY HttpServlet
====================================================================

Cần Servlet Container:

Ví dụ:
- Apache Tomcat
- Jetty
- WildFly

====================================================================
XIV. SƠ ĐỒ TỔNG QUÁT
====================================================================

Client gửi HTTP request
        ↓
Tomcat nhận
        ↓
Gọi service()
        ↓
Gọi doGet()/doPost()
        ↓
Sinh response
        ↓
Trả về client

====================================================================
XV. TÓM TẮT CỰC NGẮN
====================================================================

HttpServlet là:

- Lớp xử lý HTTP trong Java Web.
- Chạy trong Servlet Container.
- Override doGet(), doPost() để xử lý request.
- Là nền tảng của mọi framework web Java truyền thống.

Hiểu đơn giản:

HttpServlet = bộ xử lý request HTTP của Java Web.

--- javax.servlet.Filter

GIẢI THÍCH CHI TIẾT VỀ javax.servlet.Filter

====================================================================
I. Filter LÀ GÌ?
====================================================================

javax.servlet.Filter là một interface trong Servlet API.

Filter dùng để:

- Chặn (intercept) request trước khi vào Servlet.
- Chặn response trước khi trả về client.
- Thực hiện xử lý trung gian.

Hiểu đơn giản:

Filter = lớp trung gian đứng giữa Client và Servlet.

====================================================================
II. VỊ TRÍ CỦA FILTER TRONG LUỒNG REQUEST
====================================================================

Client
   ↓
Filter
   ↓
Servlet
   ↓
Filter (trả ngược)
   ↓
Client

Filter có thể:
- Xử lý trước khi vào Servlet.
- Xử lý sau khi Servlet trả response.

====================================================================
III. MỤC ĐÍCH SỬ DỤNG FILTER
====================================================================

1) Kiểm tra đăng nhập (Authentication)
2) Phân quyền (Authorization)
3) Logging
4) Mã hóa dữ liệu
5) Xử lý encoding
6) Chống XSS
7) Nén dữ liệu (GZIP)

====================================================================
IV. CẤU TRÚC CỦA Filter
====================================================================

Filter có 3 phương thức chính:

1) init()
2) doFilter()
3) destroy()

====================================================================
V. doFilter() LÀ PHƯƠNG THỨC QUAN TRỌNG NHẤT
====================================================================

public void doFilter(ServletRequest request,
                     ServletResponse response,
                     FilterChain chain)

Trong đó:

request = request từ client
response = response trả về
chain = chuỗi Filter + Servlet

====================================================================
VI. VÍ DỤ CƠ BẢN
====================================================================

public class LoggingFilter implements Filter {

    public void init(FilterConfig filterConfig) {
        System.out.println("Filter init");
    }

    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain)
            throws IOException, ServletException {

        System.out.println("Before request");

        chain.doFilter(request, response);

        System.out.println("After response");
    }

    public void destroy() {
        System.out.println("Filter destroy");
    }
}

====================================================================
VII. Ý NGHĨA CỦA chain.doFilter()
====================================================================

chain.doFilter(request, response);

Có nghĩa là:

- Cho phép request tiếp tục đi tiếp.
- Nếu không gọi dòng này → request bị chặn lại.

Nếu bạn không gọi chain.doFilter():
→ Servlet sẽ không được thực thi.

====================================================================
VIII. ĐĂNG KÝ FILTER
====================================================================

1) Cách cũ (web.xml)

<filter>
    <filter-name>LoggingFilter</filter-name>
    <filter-class>com.example.LoggingFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>LoggingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

--------------------------------------------------

2) Cách mới (Annotation)

@WebFilter("/*")
public class LoggingFilter implements Filter {
}

====================================================================
IX. FILTER CHẠY TRƯỚC HAY SAU SERVLET?
====================================================================

Trong doFilter():

Trước chain.doFilter() → chạy trước Servlet
Sau chain.doFilter() → chạy sau Servlet

Ví dụ:

Before request
→ Servlet xử lý
After response

====================================================================
X. FILTER CÓ THỂ CÓ NHIỀU CÁI KHÔNG?
====================================================================

Có.

Filter1 → Filter2 → Servlet

Thứ tự phụ thuộc vào cấu hình.

====================================================================
XI. FILTER VÀ THREAD
====================================================================

Filter:

- Chỉ có 1 instance.
- Mỗi request chạy trên thread khác nhau.
- Không nên dùng biến instance để lưu dữ liệu request.

====================================================================
XII. SO SÁNH FILTER VÀ SERVLET
====================================================================

Filter:
- Xử lý trung gian.
- Không trực tiếp sinh nội dung chính.
- Dùng cho xử lý chung.

Servlet:
- Xử lý nghiệp vụ chính.
- Sinh response.

====================================================================
XIII. VÍ DỤ THỰC TẾ: KIỂM TRA LOGIN
====================================================================

public void doFilter(...) {

    HttpServletRequest req = (HttpServletRequest) request;

    HttpSession session = req.getSession(false);

    if (session == null) {
        response.sendRedirect("login.jsp");
        return;
    }

    chain.doFilter(request, response);
}

====================================================================
XIV. SƠ ĐỒ HOẠT ĐỘNG
====================================================================

Request đến
    ↓
Filter1
    ↓
Filter2
    ↓
Servlet
    ↓
Filter2 (ngược lại)
    ↓
Filter1 (ngược lại)
    ↓
Response về client

====================================================================
XV. TÓM TẮT CỰC NGẮN
====================================================================

javax.servlet.Filter là:

- Interface chặn request/response.
- Chạy trước và sau Servlet.
- Dùng cho bảo mật, logging, encoding, kiểm tra login.
- Phải gọi chain.doFilter() để request tiếp tục.

Hiểu đơn giản:

Filter = lớp bảo vệ và xử lý trung gian của ứng dụng web Java.

--- java.security.PrivateKey

GIẢI THÍCH CHI TIẾT VỀ java.security.PrivateKey
(Lưu ý: Tên đúng là java.security.PrivateKey, không phải security.ProvateKey)

====================================================================
I. PrivateKey LÀ GÌ?
====================================================================

java.security.PrivateKey là một interface trong Java Security API.

PrivateKey đại diện cho:

- Khóa bí mật (khóa riêng)
- Dùng trong hệ mật mã bất đối xứng (Asymmetric Cryptography)

Trong hệ mật mã bất đối xứng luôn có 2 khóa:

1) Public Key  (khóa công khai)
2) Private Key (khóa bí mật)

PrivateKey phải được giữ bí mật tuyệt đối.

====================================================================
II. MẬT MÃ BẤT ĐỐI XỨNG LÀ GÌ?
====================================================================

Mã hóa bất đối xứng sử dụng 2 khóa khác nhau:

- PublicKey để mã hóa
- PrivateKey để giải mã

Hoặc:

- PrivateKey để ký (digital signature)
- PublicKey để xác minh chữ ký

Ví dụ thuật toán:
- RSA
- DSA
- EC (Elliptic Curve)

====================================================================
III. PrivateKey THUỘC PACKAGE NÀO?
====================================================================

java.security.PrivateKey

Nó kế thừa từ:

java.security.Key
java.security.Serializable

Sơ đồ:

Object
  ↓
Key (interface)
  ↓
PrivateKey (interface)

====================================================================
IV. PrivateKey DÙNG ĐỂ LÀM GÌ?
====================================================================

1) Giải mã dữ liệu đã được mã hóa bằng PublicKey
2) Tạo chữ ký số (Digital Signature)
3) Xác thực danh tính
4) Thiết lập kết nối bảo mật SSL/TLS
5) Xác thực JWT
6) Xử lý certificate

====================================================================
V. VÍ DỤ LUỒNG MÃ HÓA RSA
====================================================================

Bên A:
- Tạo cặp khóa (PublicKey + PrivateKey)
- Gửi PublicKey cho B

Bên B:
- Mã hóa dữ liệu bằng PublicKey
- Gửi dữ liệu mã hóa cho A

Bên A:
- Dùng PrivateKey để giải mã

Chỉ PrivateKey mới giải mã được.

====================================================================
VI. VÍ DỤ LUỒNG CHỮ KÝ SỐ
====================================================================

A:
- Dùng PrivateKey ký dữ liệu

B:
- Dùng PublicKey để kiểm tra chữ ký

Nếu chữ ký hợp lệ:
→ Dữ liệu không bị thay đổi
→ Đúng người gửi

====================================================================
VII. TẠO PrivateKey TRONG JAVA
====================================================================

Ví dụ tạo cặp khóa RSA:

KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);

KeyPair pair = keyGen.generateKeyPair();

PrivateKey privateKey = pair.getPrivate();
PublicKey publicKey = pair.getPublic();

====================================================================
VIII. DÙNG PrivateKey ĐỂ GIẢI MÃ
====================================================================

Cipher cipher = Cipher.getInstance("RSA");

cipher.init(Cipher.DECRYPT_MODE, privateKey);

byte[] decrypted = cipher.doFinal(encryptedData);

====================================================================
IX. DÙNG PrivateKey ĐỂ KÝ DỮ LIỆU
====================================================================

Signature signature = Signature.getInstance("SHA256withRSA");

signature.initSign(privateKey);

signature.update(data);

byte[] digitalSignature = signature.sign();

====================================================================
X. LƯU TRỮ PrivateKey Ở ĐÂU?
====================================================================

PrivateKey thường được lưu trong:

1) File .keystore
2) File .p12
3) File .jks
4) HSM (Hardware Security Module)
5) Database (đã mã hóa)

PrivateKey thường nằm trong:

KeyStore

====================================================================
XI. LẤY PrivateKey TỪ KeyStore
====================================================================

KeyStore keyStore = KeyStore.getInstance("JKS");

FileInputStream fis = new FileInputStream("keystore.jks");
keyStore.load(fis, password);

PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, password);

====================================================================
XII. PrivateKey KHÔNG BAO GIỜ ĐƯỢC LÀM GÌ?
====================================================================

Không được:

- Public lên GitHub
- Gửi qua email
- Hard-code trong source
- Lưu dạng plain text
- Chia sẻ cho người khác

Vì:

Ai có PrivateKey = có toàn quyền giả mạo bạn.

====================================================================
XIII. PrivateKey KHÁC SecretKey NHƯ THẾ NÀO?
====================================================================

PrivateKey:
- Dùng cho mã hóa bất đối xứng
- Có cặp với PublicKey

SecretKey:
- Dùng cho mã hóa đối xứng
- Chỉ có 1 khóa

====================================================================
XIV. CÁC THUẬT TOÁN PHỔ BIẾN DÙNG PrivateKey
====================================================================

1) RSA
2) DSA
3) EC (Elliptic Curve)
4) Ed25519

====================================================================
XV. PrivateKey CÓ PHẢI LÀ OBJECT KHÔNG?
====================================================================

Có.

PrivateKey là interface.
Các class thực thi ví dụ:

- RSAPrivateKey
- DSAPrivateKey
- ECPrivateKey

====================================================================
XVI. THUỘC TÍNH QUAN TRỌNG
====================================================================

privateKey.getAlgorithm()
privateKey.getFormat()
privateKey.getEncoded()

Ví dụ:

privateKey.getAlgorithm() → "RSA"
privateKey.getFormat() → "PKCS#8"

====================================================================
XVII. ĐỊNH DẠNG PrivateKey
====================================================================

Thường là:

PKCS#8

Khi export ra file .pem:

-----BEGIN PRIVATE KEY-----
(base64 data)
-----END PRIVATE KEY-----

====================================================================
XVIII. TÓM TẮT CỰC NGẮN
====================================================================

java.security.PrivateKey là:

- Interface đại diện cho khóa bí mật.
- Dùng trong mã hóa bất đối xứng.
- Dùng để giải mã hoặc ký số.
- Phải bảo mật tuyệt đối.
- Thường lưu trong KeyStore.

Hiểu đơn giản:

PrivateKey = chìa khóa bí mật mạnh nhất trong hệ thống bảo mật Java.

--- saml2.core.LogoutResponse

GIẢI THÍCH CHI TIẾT VỀ saml2.core.LogoutResponse

====================================================================
I. LogoutResponse LÀ GÌ?
====================================================================

saml2.core.LogoutResponse là một thành phần trong chuẩn SAML 2.0
(SAML = Security Assertion Markup Language).

LogoutResponse đại diện cho:

- Thông điệp phản hồi (response)
- Sau khi thực hiện yêu cầu đăng xuất (LogoutRequest)

Hiểu đơn giản:

LogoutResponse = thông báo xác nhận đã logout thành công hoặc thất bại.

====================================================================
II. SAML 2.0 LÀ GÌ?
====================================================================

SAML 2.0 là chuẩn xác thực Single Sign-On (SSO).

Nó cho phép:
- Người dùng đăng nhập 1 lần
- Sử dụng nhiều hệ thống khác nhau

Thành phần chính:

1) Service Provider (SP)
2) Identity Provider (IdP)

====================================================================
III. LOGOUT TRONG SAML 2.0 HOẠT ĐỘNG NHƯ THẾ NÀO?
====================================================================

1) User đăng nhập qua SSO.
2) User bấm logout tại SP.
3) SP gửi LogoutRequest đến IdP.
4) IdP xử lý logout.
5) IdP gửi LogoutResponse về SP.
6) SP kết thúc session.

====================================================================
IV. LogoutResponse ĐƯỢC GỬI KHI NÀO?
====================================================================

Sau khi IdP:

- Xác nhận logout thành công
- Hoặc gặp lỗi khi logout

====================================================================
V. LogoutResponse CHỨA NHỮNG GÌ?
====================================================================

Một LogoutResponse XML thường có:

1) ID
2) Version
3) IssueInstant
4) Destination
5) Issuer
6) InResponseTo
7) Status

====================================================================
VI. CẤU TRÚC XML MẪU
====================================================================

<samlp:LogoutResponse
    ID="_abc123"
    Version="2.0"
    IssueInstant="2024-01-01T10:00:00Z"
    Destination="https://sp.example.com/logout">

    <saml:Issuer>
        https://idp.example.com
    </saml:Issuer>

    <samlp:Status>
        <samlp:StatusCode
            Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    </samlp:Status>

</samlp:LogoutResponse>

====================================================================
VII. CÁC TRẠNG THÁI (StatusCode)
====================================================================

Một số giá trị phổ biến:

- Success
- RequestDenied
- PartialLogout
- UnknownPrincipal

Success = logout thành công.

====================================================================
VIII. Ý NGHĨA CỦA InResponseTo
====================================================================

InResponseTo = ID của LogoutRequest trước đó.

Giúp:

- Xác nhận response khớp với request
- Tránh tấn công replay

====================================================================
IX. LogoutResponse TRONG JAVA
====================================================================

Trong các thư viện SAML (ví dụ OpenSAML):

org.opensaml.saml.saml2.core.LogoutResponse

Đây là interface đại diện cho XML LogoutResponse.

====================================================================
X. CÁC PHƯƠNG THỨC THƯỜNG DÙNG
====================================================================

logoutResponse.getID()
logoutResponse.getIssuer()
logoutResponse.getIssueInstant()
logoutResponse.getDestination()
logoutResponse.getStatus()

====================================================================
XI. XỬ LÝ LogoutResponse TRONG SP
====================================================================

SP sẽ:

1) Kiểm tra chữ ký (Signature)
2) Kiểm tra InResponseTo
3) Kiểm tra Destination
4) Kiểm tra StatusCode
5) Nếu Success → xóa session

====================================================================
XII. BẢO MẬT LogoutResponse
====================================================================

LogoutResponse thường:

- Được ký số bởi IdP
- Có thể được mã hóa
- Truyền qua HTTP Redirect hoặc POST

SP phải xác thực chữ ký trước khi tin tưởng response.

====================================================================
XIII. SINGLE LOGOUT (SLO)
====================================================================

LogoutResponse thường liên quan đến:

Single Logout (SLO)

SLO cho phép:

- Logout khỏi tất cả hệ thống cùng lúc.

====================================================================
XIV. VÍ DỤ LUỒNG ĐẦY ĐỦ
====================================================================

User → SP → IdP → SP

1) User click logout.
2) SP gửi LogoutRequest.
3) IdP xóa session.
4) IdP gửi LogoutResponse (Success).
5) SP xóa session local.
6) User bị logout hoàn toàn.

====================================================================
XV. SỰ KHÁC BIỆT GIỮA LogoutRequest VÀ LogoutResponse
====================================================================

LogoutRequest:
- Yêu cầu logout

LogoutResponse:
- Phản hồi kết quả logout

====================================================================
XVI. CÁC LỖI CÓ THỂ XẢY RA
====================================================================

1) Session không tồn tại
2) User không hợp lệ
3) Signature không hợp lệ
4) Destination sai
5) Replay attack

====================================================================
XVII. TÓM TẮT CỰC NGẮN
====================================================================

saml2.core.LogoutResponse là:

- Thông điệp phản hồi logout trong SAML 2.0.
- Được gửi từ IdP về SP.
- Chứa trạng thái logout.
- Phải được kiểm tra chữ ký và tính hợp lệ.
- Dùng trong cơ chế Single Logout (SLO).

Hiểu đơn giản:

LogoutResponse = xác nhận cuối cùng rằng người dùng đã logout khỏi hệ thống SSO.

--- GWServicesSoapBindingStub

GIẢI THÍCH CHI TIẾT VỀ GWServicesSoapBindingStub

====================================================================
I. GWServicesSoapBindingStub LÀ GÌ?
====================================================================

GWServicesSoapBindingStub là một class được sinh ra tự động
(auto-generated) từ file WSDL khi sử dụng SOAP Web Service.

Nó thường được tạo bởi:

- Apache Axis (Axis 1.x)
- Hoặc các tool generate client SOAP tương tự

Hiểu đơn giản:

GWServicesSoapBindingStub = lớp đại diện client dùng để gọi
SOAP Web Service từ Java.

====================================================================
II. TẠI SAO CÓ "Stub"?
====================================================================

Trong mô hình RPC / SOAP:

- Stub là lớp trung gian phía client
- Nó đóng vai trò như proxy

Khi bạn gọi:

stub.someMethod()

Thực chất:

→ Nó tạo SOAP request
→ Gửi HTTP request đến server
→ Nhận SOAP response
→ Parse XML
→ Trả kết quả về Java object

Bạn không cần tự viết XML.

====================================================================
III. TẠO RA GWServicesSoapBindingStub NHƯ THẾ NÀO?
====================================================================

Khi có file WSDL:

Bạn dùng lệnh ví dụ:

wsdl2java (Apache Axis)

Tool sẽ generate:

- Interface service
- Locator
- Stub class (GWServicesSoapBindingStub)

====================================================================
IV. VỊ TRÍ CỦA Stub TRONG KIẾN TRÚC
====================================================================

Client Java
   ↓
GWServicesSoapBindingStub
   ↓
HTTP
   ↓
SOAP Web Service Server

====================================================================
V. CẤU TRÚC CƠ BẢN CỦA Stub
====================================================================

public class GWServicesSoapBindingStub
    extends org.apache.axis.client.Stub
    implements GWServices {

Nghĩa là:

- Kế thừa từ org.apache.axis.client.Stub
- Implement interface service

====================================================================
VI. Stub LÀM NHỮNG GÌ?
====================================================================

1) Serialize object Java → XML
2) Tạo SOAP Envelope
3) Gửi request qua HTTP
4) Nhận response XML
5) Deserialize XML → object Java
6) Ném exception nếu có lỗi

====================================================================
VII. CÁCH SỬ DỤNG
====================================================================

Ví dụ:

GWServicesSoapBindingStub stub =
    new GWServicesSoapBindingStub(
        new URL("http://example.com/service"),
        new ServiceLocator()
    );

String result = stub.someMethod(param1, param2);

====================================================================
VIII. CÁC CHỨC NĂNG QUAN TRỌNG
====================================================================

1) setTimeout()
2) setUsername()
3) setPassword()
4) _setProperty()
5) setHeader()

Ví dụ:

stub.setTimeout(30000);

====================================================================
IX. CƠ CHẾ HOẠT ĐỘNG BÊN TRONG
====================================================================

Khi gọi:

stub.someMethod()

Bên trong sẽ:

1) Tạo org.apache.axis.client.Call
2) Cấu hình endpoint URL
3) Cấu hình SOAPAction
4) Gửi request qua HTTP
5) Parse SOAP Body
6) Trả kết quả

====================================================================
X. GWServicesSoapBindingStub KHÁC GÌ VỚI REST CLIENT?
====================================================================

SOAP Stub:

- Tự động generate từ WSDL
- Giao tiếp XML
- Chuẩn SOAP
- Thường dùng trong hệ thống enterprise cũ

REST Client:

- Giao tiếp JSON
- Dùng HTTP đơn giản
- Thường viết thủ công hoặc dùng thư viện như RestTemplate

====================================================================
XI. LỖI THƯỜNG GẶP
====================================================================

1) Connection timeout
2) SSL handshake error
3) Endpoint sai URL
4) SOAP Fault
5) Serialization error

====================================================================
XII. SOAP FAULT LÀ GÌ?
====================================================================

Nếu server trả lỗi:

Stub sẽ ném:

org.apache.axis.AxisFault

Bạn phải bắt exception:

try {
    stub.someMethod();
} catch (AxisFault e) {
    e.printStackTrace();
}

====================================================================
XIII. BẢO MẬT
====================================================================

Stub có thể cấu hình:

1) Basic Authentication
2) SSL
3) WS-Security header
4) Certificate

Ví dụ:

stub._setProperty(
    Stub.USERNAME_PROPERTY,
    "username"
);

====================================================================
XIV. TẠI SAO TÊN DÀI NHƯ VẬY?
====================================================================

GWServices = tên service
SoapBinding = kiểu binding SOAP
Stub = client proxy

Tên này được generate tự động từ WSDL.

====================================================================
XV. VẤN ĐỀ CỦA AXIS 1.x STUB
====================================================================

1) Thư viện cũ
2) Không thread-safe
3) Cần tạo mới mỗi lần dùng
4) Không tối ưu performance

====================================================================
XVI. THREAD-SAFETY
====================================================================

Không nên dùng chung một instance Stub cho nhiều thread.

Mỗi request nên tạo Stub mới.

====================================================================
XVII. TÓM TẮT CỰC NGẮN
====================================================================

GWServicesSoapBindingStub là:

- Lớp client proxy cho SOAP Web Service.
- Được generate từ WSDL.
- Dùng để gọi web service như gọi method Java.
- Bên trong xử lý SOAP XML và HTTP.
- Thường thuộc Apache Axis.

Hiểu đơn giản:

GWServicesSoapBindingStub = cầu nối giữa Java client và SOAP Web Service.

--- java.text.DecimalFormat

GIẢI THÍCH CHI TIẾT VỀ java.text.DecimalFormat

====================================================================
I. DecimalFormat LÀ GÌ?
====================================================================

java.text.DecimalFormat là một class trong Java dùng để:

- Định dạng số (number formatting)
- Chuyển số thành chuỗi theo mẫu (pattern)
- Làm tròn số
- Thêm dấu phân cách hàng nghìn
- Hiển thị phần thập phân theo ý muốn

Nó thuộc package:

java.text

====================================================================
II. DecimalFormat DÙNG ĐỂ LÀM GÌ?
====================================================================

1) Hiển thị tiền tệ
2) Hiển thị số phần trăm
3) Làm tròn số
4) Chuẩn hóa số thập phân
5) Format số theo yêu cầu nghiệp vụ

====================================================================
III. CÁCH TẠO DecimalFormat
====================================================================

DecimalFormat df = new DecimalFormat("pattern");

Ví dụ:

DecimalFormat df = new DecimalFormat("#,###.00");

====================================================================
IV. CÁC KÝ TỰ TRONG PATTERN
====================================================================

1) 0  → Bắt buộc phải có số
2) #  → Có thể có hoặc không
3) .  → Dấu thập phân
4) ,  → Dấu phân cách hàng nghìn
5) %  → Nhân 100 và thêm %
6) E  → Dạng số mũ (scientific notation)

====================================================================
V. SỰ KHÁC NHAU GIỮA 0 VÀ #
====================================================================

0 = luôn hiển thị số 0 nếu thiếu

# = nếu không có thì bỏ qua

Ví dụ:

Pattern: "0000"
Số: 25
Kết quả: 0025

Pattern: "####"
Số: 25
Kết quả: 25

====================================================================
VI. VÍ DỤ CƠ BẢN
====================================================================

double number = 12345.6789;

DecimalFormat df = new DecimalFormat("#,###.00");

String result = df.format(number);

Kết quả:
"12,345.68"

====================================================================
VII. LÀM TRÒN SỐ
====================================================================

DecimalFormat mặc định làm tròn theo:

RoundingMode.HALF_EVEN

Có thể chỉnh:

df.setRoundingMode(RoundingMode.HALF_UP);

====================================================================
VIII. FORMAT SỐ PHẦN TRĂM
====================================================================

DecimalFormat df = new DecimalFormat("0.00%");

double value = 0.256;

df.format(value);

Kết quả:
"25.60%"

====================================================================
IX. ĐỊNH DẠNG TIỀN TỆ
====================================================================

DecimalFormat df = new DecimalFormat("#,###.00");

df.format(1000000);

Kết quả:
"1,000,000.00"

====================================================================
X. FORMAT THEO KHOA HỌC
====================================================================

DecimalFormat df = new DecimalFormat("0.###E0");

df.format(123456);

Kết quả:
"1.235E5"

====================================================================
XI. PARSE NGƯỢC LẠI SỐ
====================================================================

String text = "12,345.67";

Number number = df.parse(text);

====================================================================
XII. DecimalFormatSymbols
====================================================================

Dùng để đổi:

- Dấu thập phân
- Dấu phân cách
- Ký hiệu tiền tệ

Ví dụ:

DecimalFormatSymbols symbols =
    new DecimalFormatSymbols();

symbols.setDecimalSeparator(',');
symbols.setGroupingSeparator('.');

DecimalFormat df =
    new DecimalFormat("#,###.00", symbols);

====================================================================
XIII. ẢNH HƯỞNG CỦA LOCALE
====================================================================

Ở Việt Nam:

- 1.000.000,50

Ở Mỹ:

- 1,000,000.50

Có thể tạo theo locale:

NumberFormat.getInstance(Locale.US);

====================================================================
XIV. CÁC METHOD QUAN TRỌNG
====================================================================

df.format(number)
df.parse(string)
df.setMaximumFractionDigits()
df.setMinimumFractionDigits()
df.setGroupingUsed()
df.setRoundingMode()

====================================================================
XV. setMaximumFractionDigits
====================================================================

df.setMaximumFractionDigits(2);

Giới hạn tối đa 2 số thập phân.

====================================================================
XVI. setMinimumFractionDigits
====================================================================

df.setMinimumFractionDigits(2);

Luôn hiển thị ít nhất 2 số thập phân.

====================================================================
XVII. TẮT DẤU PHÂN CÁCH
====================================================================

df.setGroupingUsed(false);

====================================================================
XVIII. LƯU Ý VỀ THREAD-SAFETY
====================================================================

DecimalFormat KHÔNG thread-safe.

Không dùng chung instance cho nhiều thread.

Nên:

- Tạo mới mỗi lần
Hoặc
- Dùng ThreadLocal

====================================================================
XIX. SỰ KHÁC NHAU GIỮA DecimalFormat VÀ String.format
====================================================================

DecimalFormat:
- Chuyên format số
- Linh hoạt hơn
- Hỗ trợ parse

String.format:
- Format chuỗi tổng quát
- Ít chuyên sâu cho số

====================================================================
XX. TÓM TẮT CỰC NGẮN
====================================================================

java.text.DecimalFormat là:

- Class dùng để định dạng số.
- Có thể làm tròn, thêm dấu phẩy, định dạng phần trăm.
- Dựa trên pattern như "#,###.00".
- Không thread-safe.
- Hữu ích trong tài chính, báo cáo, hiển thị số.

Hiểu đơn giản:

DecimalFormat = công cụ định dạng số chuyên nghiệp trong Java.

--- com.linuxense.javabf.DBField

GIẢI THÍCH CHI TIẾT VỀ com.linuxense.javabf.DBField

====================================================================
I. DBField LÀ GÌ?
====================================================================

com.linuxense.javabf.DBField là một class thuộc thư viện:

javabf (Java DBF Library)

Thư viện này dùng để:

- Đọc file DBF
- Ghi file DBF

DBF là định dạng database cũ của:

- dBase
- FoxPro
- Visual FoxPro

Hiểu đơn giản:

DBField đại diện cho 1 cột (column) trong file DBF.

====================================================================
II. FILE DBF LÀ GÌ?
====================================================================

DBF là file database dạng bảng.

Mỗi file DBF có:

- Header (mô tả cấu trúc)
- Nhiều record (dòng dữ liệu)

Mỗi record gồm nhiều field (cột).

DBField mô tả cấu trúc của 1 field.

====================================================================
III. DBField ĐẠI DIỆN CHO GÌ?
====================================================================

DBField chứa thông tin:

1) Tên cột
2) Kiểu dữ liệu
3) Độ dài
4) Số chữ số thập phân (nếu là số)

====================================================================
IV. CÁC KIỂU DỮ LIỆU TRONG DBF
====================================================================

Một số kiểu phổ biến:

'C' = Character (Chuỗi)
'N' = Numeric (Số)
'D' = Date (Ngày)
'L' = Logical (Boolean)
'F' = Float

====================================================================
V. CONSTRUCTOR THƯỜNG GẶP
====================================================================

DBField(String name,
        char type,
        int length,
        int decimalCount)

Ví dụ:

DBField field =
    new DBField("AMOUNT", 'N', 10, 2);

Nghĩa là:

Tên cột: AMOUNT
Kiểu: Numeric
Độ dài: 10
Thập phân: 2

====================================================================
VI. Ý NGHĨA CÁC THAM SỐ
====================================================================

1) name
   - Tên cột
   - Tối đa 10 ký tự (theo chuẩn DBF)

2) type
   - Ký tự đại diện kiểu dữ liệu

3) length
   - Tổng độ dài field

4) decimalCount
   - Số chữ số sau dấu thập phân

====================================================================
VII. VÍ DỤ TẠO FILE DBF
====================================================================

DBField[] fields = new DBField[3];

fields[0] = new DBField("ID", 'N', 5, 0);
fields[1] = new DBField("NAME", 'C', 20, 0);
fields[2] = new DBField("SALARY", 'N', 10, 2);

DBFWriter writer =
    new DBFWriter(new FileOutputStream("test.dbf"));

writer.setFields(fields);

====================================================================
VIII. SỬ DỤNG KHI ĐỌC FILE
====================================================================

DBFReader reader =
    new DBFReader(new FileInputStream("test.dbf"));

DBField[] fields = reader.getFields();

Có thể duyệt:

for (DBField field : fields) {
    System.out.println(field.getName());
}

====================================================================
IX. CÁC METHOD THƯỜNG DÙNG
====================================================================

field.getName()
field.getType()
field.getLength()
field.getDecimalCount()

====================================================================
X. getType() TRẢ VỀ GÌ?
====================================================================

Trả về kiểu dữ liệu dạng char.

Ví dụ:

'C'
'N'
'D'
'L'

====================================================================
XI. LƯU Ý QUAN TRỌNG
====================================================================

1) Tên field không quá 10 ký tự.
2) Numeric phải đảm bảo length đủ chứa số.
3) decimalCount <= length.
4) Nếu sai → lỗi khi ghi file.

====================================================================
XII. ỨNG DỤNG THỰC TẾ
====================================================================

Thường dùng khi:

- Xuất dữ liệu cho hệ thống cũ
- Tích hợp phần mềm kế toán
- Làm việc với FoxPro
- Hệ thống ngân hàng cũ

====================================================================
XIII. DBField KHÔNG LÀM GÌ?
====================================================================

DBField:

- Không chứa dữ liệu record
- Không lưu giá trị từng dòng
- Chỉ mô tả cấu trúc cột

====================================================================
XIV. SO SÁNH VỚI SQL COLUMN
====================================================================

DBField giống như:

CREATE TABLE users (
   id NUMBER(5),
   name VARCHAR(20),
   salary NUMBER(10,2)
);

DBField tương đương 1 cột trong bảng.

====================================================================
XV. VẤN ĐỀ THƯỜNG GẶP
====================================================================

1) Sai độ dài → dữ liệu bị cắt
2) Sai decimalCount → format lỗi
3) Encoding không đúng
4) Field name quá dài

====================================================================
XVI. TÓM TẮT CỰC NGẮN
====================================================================

com.linuxense.javabf.DBField là:

- Class mô tả một cột trong file DBF.
- Chứa tên, kiểu, độ dài, số thập phân.
- Dùng khi tạo hoặc đọc file DBF.
- Thuộc thư viện javabf.

Hiểu đơn giản:

DBField = định nghĩa cấu trúc của một cột trong file DBF.

--- JXL TRONG EXCEL

GIẢI THÍCH CHI TIẾT VỀ JXL TRONG EXCEL

====================================================================
I. JXL LÀ GÌ?
====================================================================

JXL (Java Excel API) là một thư viện Java dùng để:

- Đọc file Excel (.xls)
- Ghi file Excel (.xls)
- Tạo file Excel
- Chỉnh sửa nội dung Excel

Tên đầy đủ:

Java Excel API

Package chính:

jxl.*

====================================================================
II. JXL HỖ TRỢ ĐỊNH DẠNG FILE NÀO?
====================================================================

JXL chỉ hỗ trợ:

- .xls (Excel 97-2003)

KHÔNG hỗ trợ:

- .xlsx (Excel 2007+)

Nếu cần .xlsx → nên dùng Apache POI.

====================================================================
III. CÁC CHỨC NĂNG CHÍNH
====================================================================

1) Đọc dữ liệu từ Excel
2) Ghi dữ liệu vào Excel
3) Format ô (màu, font, border)
4) Merge cell
5) Tạo sheet
6) Xóa sheet

====================================================================
IV. CẤU TRÚC CƠ BẢN
====================================================================

Các class quan trọng:

1) Workbook
2) Sheet
3) WritableWorkbook
4) WritableSheet
5) Cell
6) Label
7) Number

====================================================================
V. ĐỌC FILE EXCEL
====================================================================

File file = new File("test.xls");

Workbook workbook = Workbook.getWorkbook(file);

Sheet sheet = workbook.getSheet(0);

Cell cell = sheet.getCell(0, 0);

String content = cell.getContents();

workbook.close();

====================================================================
VI. GIẢI THÍCH
====================================================================

Workbook = đại diện file Excel
Sheet = một trang trong Excel
Cell = một ô trong sheet
getContents() = lấy nội dung ô

====================================================================
VII. GHI FILE EXCEL
====================================================================

WritableWorkbook workbook =
    Workbook.createWorkbook(new File("output.xls"));

WritableSheet sheet =
    workbook.createSheet("Sheet1", 0);

Label label = new Label(0, 0, "Hello");

sheet.addCell(label);

workbook.write();
workbook.close();

====================================================================
VIII. CÁC KIỂU DỮ LIỆU KHI GHI
====================================================================

1) Label  → Chuỗi
2) Number → Số
3) DateTime → Ngày
4) Boolean → True/False

Ví dụ:

Number number = new Number(1, 0, 123.45);
sheet.addCell(number);

====================================================================
IX. ĐỊNH DẠNG Ô (FORMAT)
====================================================================

WritableFont font =
    new WritableFont(WritableFont.ARIAL, 12);

WritableCellFormat format =
    new WritableCellFormat(font);

format.setBackground(Colour.YELLOW);

Label label =
    new Label(0, 0, "Text", format);

sheet.addCell(label);

====================================================================
X. LẤY SỐ DÒNG VÀ CỘT
====================================================================

int rows = sheet.getRows();
int cols = sheet.getColumns();

====================================================================
XI. DUYỆT TOÀN BỘ FILE
====================================================================

for (int i = 0; i < sheet.getRows(); i++) {
    for (int j = 0; j < sheet.getColumns(); j++) {

        Cell cell = sheet.getCell(j, i);
        System.out.println(cell.getContents());
    }
}

====================================================================
XII. ƯU ĐIỂM CỦA JXL
====================================================================

1) Nhẹ
2) Dễ sử dụng
3) API đơn giản
4) Phù hợp hệ thống cũ

====================================================================
XIII. NHƯỢC ĐIỂM
====================================================================

1) Không hỗ trợ .xlsx
2) Dự án đã cũ, không còn cập nhật mạnh
3) Không hỗ trợ Excel hiện đại
4) Không hỗ trợ tốt file lớn

====================================================================
XIV. SO SÁNH JXL VÀ APACHE POI
====================================================================

JXL:
- Chỉ .xls
- Nhẹ
- Dễ dùng
- Cũ

Apache POI:
- .xls và .xlsx
- Mạnh hơn
- Phổ biến hiện nay

====================================================================
XV. KHI NÀO NÊN DÙNG JXL?
====================================================================

1) Hệ thống legacy
2) Chỉ cần .xls
3) File nhỏ
4) Dự án cũ đã dùng sẵn

====================================================================
XVI. CÀI ĐẶT
====================================================================

Thêm file:

jxl.jar

Vào project:

- Build path (Eclipse)
- Hoặc dependency

====================================================================
XVII. LUỒNG HOẠT ĐỘNG KHI GHI FILE
====================================================================

1) Tạo WritableWorkbook
2) Tạo WritableSheet
3) Tạo Cell (Label/Number)
4) addCell()
5) write()
6) close()

====================================================================
XVIII. LUỒNG HOẠT ĐỘNG KHI ĐỌC FILE
====================================================================

1) Workbook.getWorkbook()
2) getSheet()
3) getCell()
4) getContents()
5) close()

====================================================================
XIX. TÓM TẮT CỰC NGẮN
====================================================================

JXL (Java Excel API) là:

- Thư viện Java thao tác Excel.
- Chỉ hỗ trợ file .xls.
- Dễ dùng, nhẹ.
- Phù hợp hệ thống cũ.
- Hiện nay thường được thay bằng Apache POI.

Hiểu đơn giản:

JXL = thư viện Java để đọc/ghi file Excel .xls đời cũ.

--- SAXReader

GIẢI THÍCH CHI TIẾT VỀ SAXReader

====================================================================
I. SAXReader LÀ GÌ?
====================================================================

SAXReader là một class dùng để đọc và phân tích (parse) file XML.

Nó thường thuộc thư viện:

dom4j

Package:

org.dom4j.io.SAXReader

Hiểu đơn giản:

SAXReader = công cụ đọc file XML và chuyển thành Document để xử lý.

====================================================================
II. SAXReader THUỘC THƯ VIỆN NÀO?
====================================================================

Không phải Java core.

Nó thuộc:

dom4j (Document Object Model for Java)

Thường dùng trong:

- Hibernate cũ
- Struts
- Spring XML config cũ
- Hệ thống legacy

====================================================================
III. SAX LÀ GÌ?
====================================================================

SAX = Simple API for XML

Là cơ chế đọc XML theo kiểu:

Event-based parsing

Khác với DOM:

- SAX đọc tuần tự
- Không load toàn bộ file vào memory

Tuy nhiên:

SAXReader trong dom4j
→ dùng SAX bên dưới
→ nhưng trả về Document kiểu DOM

====================================================================
IV. CÁCH SỬ DỤNG CƠ BẢN
====================================================================

SAXReader reader = new SAXReader();

Document document = reader.read(new File("test.xml"));

Element root = document.getRootElement();

====================================================================
V. LUỒNG HOẠT ĐỘNG
====================================================================

1) Tạo SAXReader
2) Gọi read()
3) XML được parse
4) Trả về Document
5) Lấy root element
6) Duyệt các node

====================================================================
VI. VÍ DỤ XML
====================================================================

<users>
    <user>
        <name>John</name>
        <age>30</age>
    </user>
</users>

====================================================================
VII. ĐỌC XML VÀ LẤY DỮ LIỆU
====================================================================

SAXReader reader = new SAXReader();
Document document = reader.read(new File("users.xml"));

Element root = document.getRootElement();

List<Element> users = root.elements("user");

for (Element user : users) {

    String name = user.elementText("name");
    String age = user.elementText("age");

    System.out.println(name + " - " + age);
}

====================================================================
VIII. CÁC METHOD QUAN TRỌNG
====================================================================

reader.read(File file)
reader.read(InputStream in)
reader.read(String url)

Document.getRootElement()
Element.elements()
Element.elementText()
Element.attributeValue()

====================================================================
IX. ĐỌC ATTRIBUTE
====================================================================

Ví dụ XML:

<user id="1001">

Lấy attribute:

String id = user.attributeValue("id");

====================================================================
X. XỬ LÝ LỖI
====================================================================

read() có thể ném:

DocumentException

Phải bắt exception:

try {
    reader.read(file);
} catch (DocumentException e) {
    e.printStackTrace();
}

====================================================================
XI. BẬT/TẮT VALIDATION
====================================================================

reader.setValidation(true);

Dùng khi cần validate XML theo DTD.

====================================================================
XII. HỖ TRỢ NAMESPACE
====================================================================

SAXReader hỗ trợ:

- XML namespace
- XPath

Ví dụ XPath:

List nodes =
    document.selectNodes("//user/name");

====================================================================
XIII. SO SÁNH SAXReader VÀ DOM PARSER
====================================================================

SAXReader (dom4j):
- API dễ dùng
- Hỗ trợ XPath
- Linh hoạt

DOM Parser (javax.xml):
- Chuẩn Java
- API phức tạp hơn

====================================================================
XIV. SO SÁNH SAX VÀ DOM
====================================================================

SAX:
- Đọc tuần tự
- Nhẹ
- Không lưu toàn bộ tree

DOM:
- Load toàn bộ XML vào memory
- Dễ thao tác

SAXReader:
- Dùng SAX để parse
- Nhưng trả về Document (giống DOM)

====================================================================
XV. BẢO MẬT (XXE)
====================================================================

Khi đọc XML từ nguồn không tin cậy:

Phải tắt external entity:

reader.setFeature(
  "http://apache.org/xml/features/disallow-doctype-decl",
  true
);

Tránh tấn công XXE.

====================================================================
XVI. ỨNG DỤNG THỰC TẾ
====================================================================

1) Đọc file config XML
2) Đọc SOAP response
3) Xử lý SAML XML
4) Phân tích dữ liệu XML

====================================================================
XVII. NHƯỢC ĐIỂM
====================================================================

1) dom4j là thư viện cũ
2) Không còn phổ biến như trước
3) Có thể gây vấn đề bảo mật nếu cấu hình sai

====================================================================
XVIII. TÓM TẮT CỰC NGẮN
====================================================================

SAXReader là:

- Class của dom4j.
- Dùng để đọc và parse XML.
- Trả về Document để thao tác.
- Dùng SAX bên dưới.
- Phải xử lý DocumentException.
- Cần cấu hình bảo mật nếu đọc XML từ bên ngoài.

Hiểu đơn giản:

SAXReader = công cụ đọc file XML thành cấu trúc tree để xử lý trong Java.

--- SERVER SFTP

GIẢI THÍCH CHI TIẾT VỀ SERVER SFTP

====================================================================
I. SFTP LÀ GÌ?
====================================================================

SFTP = SSH File Transfer Protocol

Là giao thức truyền file bảo mật
chạy trên nền SSH (Secure Shell).

Hiểu đơn giản:

SFTP = cách truyền file an toàn qua mạng.

====================================================================
II. SERVER SFTP LÀ GÌ?
====================================================================

Server SFTP là:

- Máy chủ cung cấp dịch vụ SFTP
- Cho phép client kết nối
- Upload / Download file an toàn

Nó thường chạy trên:

- Linux
- Unix
- Windows Server

====================================================================
III. SFTP KHÁC FTP NHƯ THẾ NÀO?
====================================================================

FTP:
- Không mã hóa
- Dễ bị nghe lén
- Cổng 21

SFTP:
- Mã hóa toàn bộ dữ liệu
- Chạy trên SSH
- Cổng mặc định 22

====================================================================
IV. CƠ CHẾ HOẠT ĐỘNG
====================================================================

Client
   ↓
Kết nối SSH (port 22)
   ↓
Xác thực (password / key)
   ↓
Thiết lập phiên SFTP
   ↓
Upload / Download file

====================================================================
V. XÁC THỰC TRONG SFTP
====================================================================

Có 2 cách chính:

1) Username + Password
2) SSH Key (Public/Private key)

Cách 2 bảo mật hơn.

====================================================================
VI. CÁC CHỨC NĂNG CỦA SERVER SFTP
====================================================================

1) Upload file
2) Download file
3) Rename file
4) Delete file
5) Tạo thư mục
6) Phân quyền thư mục

====================================================================
VII. CẤU HÌNH TRÊN LINUX (OpenSSH)
====================================================================

SFTP thường dùng OpenSSH.

File cấu hình:

/etc/ssh/sshd_config

Bật SFTP subsystem:

Subsystem sftp /usr/lib/openssh/sftp-server

Khởi động lại:

systemctl restart sshd

====================================================================
VIII. CHROOT (GIỚI HẠN THƯ MỤC)
====================================================================

Có thể cấu hình:

Chỉ cho user truy cập một thư mục nhất định.

Ví dụ:

ChrootDirectory /home/sftpuser

Giúp tăng bảo mật.

====================================================================
IX. PHÂN QUYỀN
====================================================================

Dựa trên:

- Quyền file Linux (rwx)
- Ownership
- Group

Nếu sai permission → không upload được.

====================================================================
X. CLIENT KẾT NỐI SFTP
====================================================================

1) WinSCP
2) FileZilla
3) lệnh sftp trong Linux
4) Java (JSch, Apache Mina)

Ví dụ lệnh:

sftp user@server-ip

====================================================================
XI. SỬ DỤNG SFTP TRONG JAVA
====================================================================

Thường dùng thư viện:

JSch

Ví dụ:

JSch jsch = new JSch();
Session session = jsch.getSession("user", "host", 22);
session.setPassword("password");
session.connect();

Channel channel = session.openChannel("sftp");
channel.connect();

ChannelSftp sftp = (ChannelSftp) channel;
sftp.put("local.txt", "remote.txt");

====================================================================
XII. BẢO MẬT
====================================================================

Ưu điểm:

- Mã hóa toàn bộ dữ liệu
- Chống sniffing
- Hỗ trợ SSH key
- Có thể chặn IP

====================================================================
XIII. PORT MẶC ĐỊNH
====================================================================

22

Có thể đổi để tăng bảo mật.

====================================================================
XIV. KHÁC NHAU GIỮA SFTP VÀ FTPS
====================================================================

SFTP:
- Dựa trên SSH
- 1 kết nối duy nhất

FTPS:
- Dựa trên SSL/TLS
- Mở nhiều cổng
- Phức tạp hơn

====================================================================
XV. LỖI THƯỜNG GẶP
====================================================================

1) Connection refused
2) Permission denied
3) Host key verification failed
4) Authentication failed
5) Timeout

====================================================================
XVI. ỨNG DỤNG THỰC TẾ
====================================================================

1) Tích hợp ngân hàng
2) Truyền file báo cáo
3) Backup dữ liệu
4) Trao đổi dữ liệu giữa hệ thống

====================================================================
XVII. ƯU ĐIỂM
====================================================================

1) Bảo mật cao
2) Dễ cấu hình
3) Phổ biến
4) Ổn định

====================================================================
XVIII. NHƯỢC ĐIỂM
====================================================================

1) Cần quản lý key
2) Phải cấu hình permission đúng
3) Tốc độ phụ thuộc SSH

====================================================================
XIX. TÓM TẮT CỰC NGẮN
====================================================================

Server SFTP là:

- Máy chủ truyền file bảo mật qua SSH.
- Dùng port 22.
- Hỗ trợ password và SSH key.
- Phù hợp tích hợp hệ thống doanh nghiệp.
- An toàn hơn FTP.

Hiểu đơn giản:

SFTP server = nơi lưu trữ và trao đổi file an toàn qua mạng.

--- INTERCEPTOR TRONG LẬP TRÌNH WEB

GIẢI THÍCH CHI TIẾT: INTERCEPTOR TRONG LẬP TRÌNH WEB

1. INTERCEPTOR LÀ GÌ?

Interceptor (bộ chặn) là một cơ chế cho phép "chặn" và "can thiệp" vào request hoặc response trong
quá trình xử lý giữa client và server.

Hiểu đơn giản:
Interceptor giống như một lớp trung gian đứng giữa:
- Client gửi request lên server
- Server xử lý và trả response về client

Interceptor có thể:
- Chạy trước khi request tới controller
- Chạy sau khi controller xử lý xong
- Chạy sau khi response được render xong

Nó cho phép bạn can thiệp vào vòng đời xử lý request mà không cần sửa code business chính.


2. INTERCEPTOR HOẠT ĐỘNG Ở ĐÂU TRONG LUỒNG XỬ LÝ?

Luồng xử lý cơ bản trong web server:

Client
   ↓
Filter (nếu có)
   ↓
Interceptor (preHandle)
   ↓
Controller
   ↓
Interceptor (postHandle)
   ↓
View Render
   ↓
Interceptor (afterCompletion)
   ↓
Response trả về client

Tùy framework mà thứ tự có thể khác chút, nhưng về bản chất interceptor nằm giữa request và controller.


3. MỤC ĐÍCH CỦA INTERCEPTOR

Interceptor thường dùng cho các tác vụ:

- Kiểm tra đăng nhập (Authentication)
- Phân quyền (Authorization)
- Ghi log request/response
- Đo thời gian xử lý request
- Kiểm tra token (JWT)
- Thêm header vào response
- Kiểm tra dữ liệu đầu vào
- Thực hiện logic chung cho nhiều API

Quan trọng:
Interceptor không nên chứa business logic chính của hệ thống.


4. INTERCEPTOR KHÁC GÌ VỚI FILTER?

So sánh nhanh:

FILTER:
- Thuộc tầng Servlet
- Chạy trước DispatcherServlet
- Có thể chặn mọi request (kể cả static resource)

INTERCEPTOR:
- Thuộc tầng framework (ví dụ Spring MVC)
- Chạy sau khi request vào DispatcherServlet
- Chỉ áp dụng cho request mapping tới controller

Hiểu đơn giản:
Filter = tầng thấp hơn
Interceptor = tầng cao hơn, gần controller hơn


5. VÍ DỤ TRONG SPRING MVC

Trong Spring, interceptor thường implement interface:

HandlerInterceptor

Nó có 3 phương thức chính:

1) preHandle()
Chạy trước khi controller được gọi.
Trả về:
- true  → tiếp tục xử lý
- false → dừng request

2) postHandle()
Chạy sau khi controller xử lý xong, nhưng trước khi render view.

3) afterCompletion()
Chạy sau khi response hoàn tất.


6. GIẢI THÍCH TỪNG GIAI ĐOẠN

A. preHandle()

Dùng để:
- Kiểm tra login
- Kiểm tra token
- Chặn request không hợp lệ

Ví dụ logic:
Nếu chưa đăng nhập → redirect về login
Nếu token sai → trả 401


B. postHandle()

Dùng để:
- Thêm dữ liệu vào model
- Sửa dữ liệu trước khi render view


C. afterCompletion()

Dùng để:
- Ghi log kết thúc
- Giải phóng tài nguyên
- Đo thời gian thực thi


7. INTERCEPTOR TRONG FRONTEND (VÍ DỤ AXIOS)

Interceptor không chỉ có ở backend.

Ví dụ trong JavaScript (Axios):

- Request interceptor → chỉnh sửa request trước khi gửi
- Response interceptor → xử lý response trước khi trả về code gọi API

Thường dùng để:
- Tự động thêm Authorization header
- Bắt lỗi 401 → redirect login
- Log API


8. VÌ SAO NÊN DÙNG INTERCEPTOR?

Nếu không có interceptor:
Bạn phải lặp lại code kiểm tra login ở mọi controller.

Có interceptor:
Viết 1 lần → áp dụng cho toàn bộ hệ thống.

Đây là cách áp dụng nguyên tắc:
- DRY (Don't Repeat Yourself)
- Separation of Concerns


9. INTERCEPTOR KHÔNG PHẢI LÀ AOP?

Nhiều người nhầm lẫn.

Interceptor:
- Chỉ áp dụng cho HTTP request
- Hoạt động trong vòng đời web request

AOP:
- Áp dụng cho method (ở mọi tầng)
- Không chỉ giới hạn trong web

Interceptor = chuyên cho request web
AOP = can thiệp vào method ở bất kỳ đâu


10. TỔNG KẾT NGẮN GỌN

Interceptor trong lập trình web là:
Một cơ chế trung gian cho phép chặn và xử lý request/response trước hoặc sau khi controller thực thi.

Nó thường dùng để:
- Authentication
- Authorization
- Logging
- Thêm header
- Kiểm soát chung cho nhiều API

Interceptor giúp:
- Tách logic chung khỏi business logic
- Tránh lặp code
- Quản lý request tập trung
- Tăng tính bảo trì của hệ thống


11. HÌNH DUNG DỄ HIỂU

Bạn có thể tưởng tượng:

Client → Bảo vệ (Interceptor) → Controller → Bảo vệ → Client

Bảo vệ có quyền:
- Không cho vào
- Ghi lại thông tin
- Thêm thắt gì đó trước khi cho vào


KẾT LUẬN CUỐI CÙNG:

Interceptor là một thành phần trung gian trong web framework dùng để chặn và xử lý request/response
trước và sau khi controller thực thi, thường phục vụ cho các chức năng như kiểm tra đăng nhập, phân
quyền, logging và các xử lý dùng chung toàn hệ thống.

--- jxl.DateCell

GIẢI THÍCH CHI TIẾT: jxl.DateCell LÀ GÌ?

1. jxl LÀ GÌ?

jxl (JExcelAPI) là một thư viện Java dùng để:
- Đọc file Excel định dạng .xls (Excel 97–2003)
- Ghi file Excel .xls

Lưu ý:
jxl KHÔNG hỗ trợ file .xlsx (Excel 2007 trở lên).


2. DateCell LÀ GÌ?

jxl.DateCell là một interface trong thư viện jxl.

Nó đại diện cho một ô (cell) trong file Excel có kiểu dữ liệu là ngày tháng (Date).

Nói cách khác:
Nếu một ô trong Excel có định dạng kiểu Date,
khi đọc bằng jxl, ta có thể ép kiểu nó thành DateCell để lấy giá trị ngày tháng.


3. VỊ TRÍ CỦA DateCell TRONG HỆ THỐNG jxl

Trong jxl:

Cell (interface chung cho mọi loại ô)
   |
   |-- NumberCell
   |-- LabelCell
   |-- BooleanCell
   |-- DateCell
   |-- FormulaCell
   |-- ...

DateCell là một loại Cell chuyên dùng cho dữ liệu ngày tháng.


4. DATECELL DÙNG ĐỂ LÀM GÌ?

Khi bạn đọc một file Excel và gặp một ô có nội dung là ngày,
bạn cần:

1) Kiểm tra type của cell
2) Ép kiểu về DateCell
3) Lấy giá trị Date từ đó

Ví dụ tình huống:
Excel có ô A1 = 15/02/2026
Khi đọc bằng jxl:
Bạn sẽ dùng DateCell để lấy ra java.util.Date tương ứng.


5. CÁCH SỬ DỤNG DateCell

Bước 1: Lấy Cell từ sheet

Cell cell = sheet.getCell(col, row);

Bước 2: Kiểm tra loại cell

if (cell.getType() == CellType.DATE) {
    DateCell dateCell = (DateCell) cell;
    Date date = dateCell.getDate();
}

Quan trọng:
Nếu không kiểm tra type trước mà ép kiểu trực tiếp,
có thể bị ClassCastException.


6. PHƯƠNG THỨC QUAN TRỌNG CỦA DateCell

Phương thức chính:

Date getDate()

Ý nghĩa:
Trả về đối tượng java.util.Date tương ứng với giá trị trong ô Excel.


7. BẢN CHẤT CỦA DATE TRONG EXCEL

Excel lưu ngày tháng dưới dạng số (serial number).

Ví dụ:
1 = 01/01/1900
2 = 02/01/1900
...
45000 = một ngày nào đó

DateCell giúp:
- Tự động chuyển số serial đó thành java.util.Date
- Bạn không cần tự tính toán


8. SỰ KHÁC BIỆT GIỮA LabelCell VÀ DateCell

LabelCell:
- Lấy dữ liệu dạng String
- Ví dụ: "15/02/2026"

DateCell:
- Lấy dữ liệu dạng Date object
- Có thể xử lý tiếp bằng SimpleDateFormat

Nếu bạn dùng cell.getContents():
→ Bạn chỉ nhận được String.

Nếu bạn dùng DateCell.getDate():
→ Bạn nhận được đối tượng Date chuẩn của Java.


9. VÍ DỤ HOÀN CHỈNH

Giả sử đọc file Excel:

Workbook workbook = Workbook.getWorkbook(new File("test.xls"));
Sheet sheet = workbook.getSheet(0);

Cell cell = sheet.getCell(0, 0);

if (cell.getType() == CellType.DATE) {
    DateCell dateCell = (DateCell) cell;
    Date date = dateCell.getDate();

    System.out.println(date);
}

Kết quả:
In ra đối tượng Date tương ứng.


10. LỖI THƯỜNG GẶP

1) Ô Excel nhìn giống ngày nhưng thực tế là String.
Ví dụ:
"15/02/2026" nhưng format là Text.

Lúc này:
cell.getType() sẽ là LABEL
KHÔNG phải DATE

Giải pháp:
Kiểm tra kỹ định dạng trong Excel.


2) File là .xlsx
jxl sẽ không đọc được.


11. KHI NÀO NÊN DÙNG DateCell?

Khi:
- Đọc file .xls
- Cần xử lý ngày tháng dưới dạng Date object
- Cần tính toán thời gian (so sánh, cộng trừ ngày)

Không nên dùng khi:
- File là .xlsx
- Chỉ cần đọc chuỗi đơn giản


12. TỔNG KẾT NGẮN GỌN

jxl.DateCell là interface đại diện cho một ô Excel có kiểu ngày tháng trong thư viện JExcelAPI.

Nó cho phép:
- Ép kiểu từ Cell sang DateCell
- Lấy giá trị dưới dạng java.util.Date bằng phương thức getDate()

Nó giúp:
- Chuyển đổi giá trị ngày từ Excel sang đối tượng Date của Java
- Xử lý ngày tháng chính xác thay vì làm việc với String


13. KẾT LUẬN CUỐI CÙNG

DateCell là một loại Cell chuyên dùng cho dữ liệu Date trong thư viện jxl, cho phép bạn
lấy giá trị ngày tháng từ file Excel .xls dưới dạng java.util.Date để xử lý trong Java.

--- SO SÁNH SFTP VÀ FTP

GIẢI THÍCH CHI TIẾT: SO SÁNH SFTP VÀ FTP

1. FTP LÀ GÌ?

FTP (File Transfer Protocol) là giao thức truyền file giữa client và server qua mạng.

Đặc điểm:
- Ra đời từ rất sớm (1971)
- Hoạt động trên nền TCP
- Mặc định dùng port 21
- Không mã hóa dữ liệu

Mục đích chính:
- Upload file lên server
- Download file từ server
- Quản lý file từ xa


2. SFTP LÀ GÌ?

SFTP (SSH File Transfer Protocol) là giao thức truyền file an toàn dựa trên SSH.

Đặc điểm:
- Hoạt động trên nền SSH
- Mặc định dùng port 22
- Mã hóa toàn bộ dữ liệu
- Bảo mật cao

Quan trọng:
SFTP KHÔNG phải là FTP + SSL.
Nó là một giao thức hoàn toàn khác, chạy qua SSH.


3. SO SÁNH CHI TIẾT FTP VÀ SFTP

------------------------------------------------------------
I. BẢO MẬT
------------------------------------------------------------

FTP:
- Không mã hóa dữ liệu
- Username và password gửi dạng plain text
- Dễ bị sniffing (nghe lén)

SFTP:
- Mã hóa toàn bộ kết nối
- Bảo vệ username/password
- Bảo vệ dữ liệu file truyền đi

Kết luận:
SFTP an toàn hơn rất nhiều.


------------------------------------------------------------
II. CỔNG (PORT)
------------------------------------------------------------

FTP:
- Port 21 (control)
- Dùng thêm port khác cho data channel

SFTP:
- Port 22 (giống SSH)
- Chỉ cần 1 kết nối duy nhất

Kết luận:
SFTP đơn giản hơn về firewall configuration.


------------------------------------------------------------
III. KIẾN TRÚC KẾT NỐI
------------------------------------------------------------

FTP:
- Dùng 2 kênh:
  1) Control channel
  2) Data channel
- Có chế độ Active và Passive

SFTP:
- Chỉ dùng 1 kênh duy nhất qua SSH
- Không có Active/Passive

Kết luận:
SFTP đơn giản hơn trong cấu hình mạng.


------------------------------------------------------------
IV. MỨC ĐỘ PHỔ BIẾN HIỆN NAY
------------------------------------------------------------

FTP:
- Gần như không còn được khuyến nghị sử dụng trên Internet công cộng

SFTP:
- Được sử dụng rộng rãi trong hệ thống doanh nghiệp
- Thường dùng trong ngân hàng, hệ thống tài chính


------------------------------------------------------------
V. HIỆU NĂNG
------------------------------------------------------------

FTP:
- Nhanh hơn một chút vì không mã hóa

SFTP:
- Chậm hơn một chút vì có mã hóa
- Nhưng chênh lệch không đáng kể với máy hiện đại

Trong thực tế:
Sự khác biệt hiệu năng không phải vấn đề lớn.


------------------------------------------------------------
VI. XÁC THỰC (AUTHENTICATION)
------------------------------------------------------------

FTP:
- Username/password
- Có thể dùng anonymous login

SFTP:
- Username/password
- SSH key authentication (an toàn hơn)

SFTP có thể cấu hình:
- Chỉ cho phép login bằng private key


------------------------------------------------------------
VII. TRIỂN KHAI THỰC TẾ
------------------------------------------------------------

FTP thường dùng cho:
- Mạng nội bộ
- Hệ thống cũ (legacy system)

SFTP thường dùng cho:
- Truyền file giữa server production
- Tích hợp hệ thống
- Truyền dữ liệu nhạy cảm
- Gửi file báo cáo ngân hàng


4. BẢNG SO SÁNH TÓM TẮT

------------------------------------------------------------
TIÊU CHÍ        | FTP                     | SFTP
------------------------------------------------------------
Bảo mật         | Không mã hóa            | Mã hóa toàn bộ
Port            | 21                      | 22
Kết nối         | 2 kênh                  | 1 kênh
An toàn         | Thấp                    | Cao
Firewall        | Khó cấu hình            | Dễ hơn
Khuyến nghị     | Không nên dùng Internet | Nên dùng
------------------------------------------------------------


5. SỰ NHẦM LẪN PHỔ BIẾN

Nhiều người nhầm:

FTPS ≠ SFTP

FTPS:
- FTP + SSL/TLS

SFTP:
- Chạy trên SSH

Hai cái hoàn toàn khác nhau.


6. VÍ DỤ THỰC TẾ

Giả sử bạn gửi file giao dịch ngân hàng:

Nếu dùng FTP:
- Hacker có thể đọc được dữ liệu nếu sniff mạng.

Nếu dùng SFTP:
- Dữ liệu bị mã hóa.
- Hacker chỉ thấy dữ liệu đã mã hóa.


7. KHI NÀO NÊN DÙNG FTP?

Chỉ nên dùng khi:
- Hệ thống cũ bắt buộc
- Mạng nội bộ an toàn
- Không có yêu cầu bảo mật

Trong môi trường Internet công cộng:
Không nên dùng FTP.


8. KHI NÀO NÊN DÙNG SFTP?

Nên dùng khi:
- Truyền dữ liệu qua Internet
- Có dữ liệu nhạy cảm
- Hệ thống production
- Tích hợp giữa các công ty


9. TỔNG KẾT NGẮN GỌN

FTP:
- Giao thức truyền file cũ
- Không mã hóa
- Không an toàn trên Internet

SFTP:
- Giao thức truyền file an toàn qua SSH
- Mã hóa toàn bộ dữ liệu
- Được khuyến nghị sử dụng hiện nay


10. KẾT LUẬN CUỐI CÙNG

SFTP an toàn và hiện đại hơn FTP rất nhiều. 
Trong hầu hết các hệ thống hiện nay, nếu không bị ràng buộc bởi hệ thống cũ, bạn nên sử dụng
SFTP thay vì FTP để đảm bảo bảo mật dữ liệu.

--- getResourceAsStream LÀ GÌ TRONG JAVA

GIẢI THÍCH CHI TIẾT: getResourceAsStream LÀ GÌ TRONG JAVA

1. getResourceAsStream LÀ GÌ?

getResourceAsStream là một phương thức dùng để đọc file (resource) nằm trong classpath của ứng dụng
Java dưới dạng InputStream.

Nói đơn giản:
Nó giúp bạn đọc file nằm bên trong project (ví dụ trong thư mục resources hoặc trong file .jar) mà
không cần biết chính xác đường dẫn hệ điều hành.

Phương thức này thường dùng trong:
- Đọc file cấu hình (config.properties)
- Đọc file text
- Đọc file JSON
- Đọc file XML
- Đọc file nằm trong thư mục resources


2. getResourceAsStream NẰM Ở ĐÂU?

Có 2 cách phổ biến:

1) Class.getResourceAsStream(String name)
2) ClassLoader.getResourceAsStream(String name)

Hai cách này gần giống nhau nhưng có khác biệt về cách xử lý đường dẫn.


3. TẠI SAO KHÔNG DÙNG FileInputStream?

FileInputStream yêu cầu đường dẫn vật lý trên máy:

Ví dụ:
C:\project\config.properties

Nhưng khi build thành file .jar:
File đó nằm bên trong .jar → không còn là file vật lý nữa.

getResourceAsStream giải quyết vấn đề này vì:
Nó đọc resource từ classpath, kể cả khi ứng dụng chạy từ .jar.


4. CLASS PATH LÀ GÌ?

Classpath là nơi JVM tìm:
- Class (.class)
- Resource (file config, image, ...)

Thông thường trong project Maven/Gradle:

src/main/resources
→ sẽ được đưa vào classpath khi build.


5. CÁCH DÙNG CƠ BẢN

Giả sử có file:

src/main/resources/config.properties

Cách đọc:

InputStream is = MyClass.class.getResourceAsStream("/config.properties");

Sau đó có thể đọc bằng:

Properties prop = new Properties();
prop.load(is);


6. SỰ KHÁC BIỆT GIỮA CLASS VÀ CLASSLOADER

A. Class.getResourceAsStream()

Nếu đường dẫn bắt đầu bằng "/":
→ Tìm từ root của classpath

Nếu không có "/":
→ Tìm tương đối theo package của class

Ví dụ:

MyClass nằm trong package:
com.example.app

getResourceAsStream("config.properties")
→ Tìm trong:
com/example/app/

getResourceAsStream("/config.properties")
→ Tìm ở root classpath


B. ClassLoader.getResourceAsStream()

Luôn tìm từ root classpath.
KHÔNG dùng dấu "/" ở đầu.

Ví dụ:

ClassLoader cl = MyClass.class.getClassLoader();
InputStream is = cl.getResourceAsStream("config.properties");


7. SO SÁNH 2 CÁCH

----------------------------------------------------
CÁCH GỌI                         | BẮT ĐẦU TỪ ĐÂU
----------------------------------------------------
Class.getResourceAsStream("/a")   | Root classpath
Class.getResourceAsStream("a")    | Package hiện tại
ClassLoader.getResourceAsStream   | Root classpath
----------------------------------------------------


8. VÍ DỤ THỰC TẾ

Cấu trúc project:

src/main/java/com/example/Main.java
src/main/resources/data.txt

Đọc file data.txt:

InputStream is = Main.class.getResourceAsStream("/data.txt");

Hoặc:

InputStream is = Main.class
                     .getClassLoader()
                     .getResourceAsStream("data.txt");


9. KHI NÀO getResourceAsStream TRẢ VỀ NULL?

Nó trả về null khi:

- Sai tên file
- Sai đường dẫn
- File không nằm trong classpath
- Viết sai hoa thường (Linux phân biệt)


10. LỖI PHỔ BIẾN

1) Quên thêm file vào resources
2) Viết sai dấu "/" đầu đường dẫn
3) Dùng đường dẫn hệ điều hành thay vì classpath


11. KHÁC BIỆT VỚI getResource()

getResource()
→ Trả về URL

getResourceAsStream()
→ Trả về InputStream

Nếu bạn chỉ cần đọc nội dung file:
→ Nên dùng getResourceAsStream()


12. TẠI SAO PHẢI DÙNG TRONG ỨNG DỤNG WEB?

Trong ứng dụng web (Spring Boot, Servlet):

File config thường nằm trong:
- resources
- hoặc trong jar

getResourceAsStream đảm bảo:
- Chạy được khi deploy lên server
- Không phụ thuộc đường dẫn tuyệt đối


13. TÓM TẮT NGẮN GỌN

getResourceAsStream là phương thức dùng để đọc file nằm trong classpath dưới dạng InputStream.

Ưu điểm:
- Không phụ thuộc đường dẫn hệ điều hành
- Hoạt động cả khi chạy file .jar
- Phù hợp cho file cấu hình và resource nội bộ

Khác với FileInputStream:
FileInputStream đọc file vật lý.
getResourceAsStream đọc file trong classpath.


14. KẾT LUẬN CUỐI CÙNG

getResourceAsStream là cách chuẩn và an toàn trong Java để đọc các resource nội bộ của ứng
dụng (như file config, JSON, XML...) từ classpath, đặc biệt khi ứng dụng được đóng gói thành
file .jar hoặc deploy lên server.

--- SFTP TRONG JAVA CÓ CHỨC NĂNG LIÊN QUAN ĐẾN GÌ?

GIẢI THÍCH CHI TIẾT: SFTP TRONG JAVA CÓ CHỨC NĂNG LIÊN QUAN ĐẾN GÌ?

1. SFTP LÀ GÌ?

SFTP (SSH File Transfer Protocol) là giao thức truyền file an toàn thông qua SSH.

Trong Java, SFTP dùng để:
- Upload file lên server
- Download file từ server
- Xóa file trên server
- Tạo thư mục từ xa
- Liệt kê danh sách file
- Đổi tên file
- Kiểm tra tồn tại file
- Tự động hóa trao đổi dữ liệu giữa hệ thống


2. SFTP TRONG JAVA KHÔNG CÓ SẴN TRONG JDK

Quan trọng:
Java chuẩn (JDK) KHÔNG có sẵn thư viện SFTP.

Muốn dùng SFTP trong Java, bạn phải dùng thư viện bên ngoài như:

- JSch
- Apache Mina SSHD
- SSHJ
- Spring Integration SFTP


3. SFTP TRONG JAVA LIÊN QUAN ĐẾN NHỮNG CHỨC NĂNG GÌ?

------------------------------------------------------------
I. TRUYỀN FILE GIỮA HAI HỆ THỐNG
------------------------------------------------------------

Ví dụ thực tế:

- Hệ thống A tạo file báo cáo mỗi ngày
- Hệ thống B cần nhận file đó

Java sẽ:
- Kết nối SFTP
- Upload file lên server
- Hoặc download file từ server

Ứng dụng phổ biến:
- Hệ thống ngân hàng
- Hệ thống kế toán
- Tích hợp ERP
- Hệ thống thanh toán


------------------------------------------------------------
II. TỰ ĐỘNG HÓA (BATCH JOB)
------------------------------------------------------------

Trong Java thường có:

- Job chạy mỗi ngày
- Job chạy mỗi giờ
- Job chạy theo lịch (Scheduled)

Job này có thể:
- Kết nối SFTP
- Lấy file về xử lý
- Sau khi xử lý xong → chuyển file sang thư mục backup

SFTP thường kết hợp với:
- Timer
- ScheduledExecutorService
- Spring Scheduler


------------------------------------------------------------
III. TÍCH HỢP HỆ THỐNG (SYSTEM INTEGRATION)
------------------------------------------------------------

SFTP thường dùng để tích hợp giữa:

- Hệ thống nội bộ
- Hệ thống đối tác
- Hệ thống ngân hàng
- Hệ thống chính phủ

Thay vì gọi API trực tiếp, nhiều hệ thống cũ dùng cơ chế:
- Gửi file qua SFTP
- Hệ thống bên kia đọc file và xử lý


------------------------------------------------------------
IV. BẢO MẬT DỮ LIỆU
------------------------------------------------------------

SFTP trong Java liên quan đến:

- SSH
- Mã hóa dữ liệu
- Private key authentication
- Password authentication

Java cần cấu hình:
- Host
- Port (thường là 22)
- Username
- Password hoặc Private Key

SFTP đảm bảo:
- Dữ liệu được mã hóa
- Không bị sniff khi truyền qua Internet


------------------------------------------------------------
V. QUẢN LÝ FILE TỪ XA
------------------------------------------------------------

Java có thể dùng SFTP để:

- Kiểm tra file tồn tại
- Xóa file
- Tạo thư mục
- Di chuyển file
- Đổi tên file

Ví dụ:
Sau khi xử lý xong file → move sang thư mục "processed"


4. CÁC THƯ VIỆN PHỔ BIẾN TRONG JAVA

1) JSch
   - Nhẹ
   - Phổ biến
   - Dùng nhiều trong project cũ

2) SSHJ
   - Hiện đại hơn JSch
   - API rõ ràng hơn

3) Apache Mina SSHD
   - Mạnh hơn
   - Có thể làm SSH server

4) Spring Integration SFTP
   - Dùng trong hệ sinh thái Spring
   - Hỗ trợ polling tự động


5. QUY TRÌNH KẾT NỐI SFTP TRONG JAVA

Bước 1: Tạo SSH session
Bước 2: Xác thực (password hoặc private key)
Bước 3: Mở SFTP channel
Bước 4: Thực hiện upload/download
Bước 5: Đóng channel và session


6. SFTP TRONG JAVA THƯỜNG XUẤT HIỆN Ở ĐÂU?

- Ứng dụng backend
- Hệ thống batch xử lý file
- Hệ thống tài chính
- Hệ thống xuất nhập dữ liệu
- Microservice tích hợp file


7. SFTP KHÔNG LIÊN QUAN ĐẾN NHỮNG GÌ?

SFTP KHÔNG phải là:

- Giao thức API REST
- HTTP
- Web service
- Database

Nó chỉ chuyên về:
Truyền file an toàn qua SSH.


8. SO SÁNH NHANH VỚI FTP TRONG JAVA

FTP:
- Không mã hóa
- Không an toàn

SFTP:
- Mã hóa toàn bộ dữ liệu
- An toàn hơn
- Được khuyến nghị dùng trong production


9. TỔNG KẾT NGẮN GỌN

SFTP trong Java liên quan đến:

- Truyền file an toàn qua SSH
- Tích hợp hệ thống bằng file
- Batch processing
- Tự động hóa trao đổi dữ liệu
- Quản lý file từ xa
- Bảo mật dữ liệu khi truyền qua Internet


10. KẾT LUẬN CUỐI CÙNG

Trong Java, SFTP là cơ chế dùng để truyền và quản lý file từ xa một cách an toàn thông
qua SSH. Nó thường được sử dụng trong các hệ thống backend, hệ thống tích hợp, hệ
thống ngân hàng và các job tự động xử lý file định kỳ.

--- KHI ĐỊNH NGHĨA HÀM DOWNLOAD EXCEL TRONG JAVA, SFTP CÓ PHẢI LÀ TRUNG GIAN HAY KHÔNG?

GIẢI THÍCH CHI TIẾT: KHI ĐỊNH NGHĨA HÀM DOWNLOAD EXCEL TRONG JAVA, SFTP CÓ PHẢI LÀ TRUNG GIAN HAY KHÔNG?

1. CẦN HIỂU RÕ 2 KHÁI NIỆM "DOWNLOAD"

Có 2 kiểu download hoàn toàn khác nhau:

(1) Client (trình duyệt) download file từ server của bạn
(2) Server của bạn download file từ một server khác

Hai trường hợp này khác nhau hoàn toàn.

------------------------------------------------------------
2. TRƯỜNG HỢP 1: USER DOWNLOAD EXCEL TỪ WEBSITE CỦA BẠN
------------------------------------------------------------

Luồng xử lý:

Browser → HTTP request → Server Java → trả file Excel → Browser

Trong trường hợp này:

- Không có SFTP
- Không cần SFTP
- Chỉ dùng HTTP response

Bạn chỉ cần:

- Tạo file Excel (hoặc đọc từ disk)
- Ghi vào HttpServletResponse OutputStream
- Set header:
  Content-Type
  Content-Disposition

Ví dụ bản chất:

response.setContentType("application/vnd.ms-excel");
response.setHeader("Content-Disposition", "attachment; filename=report.xls");

Sau đó ghi file vào output stream.

KẾT LUẬN:
Nếu user download file từ server của bạn → SFTP KHÔNG liên quan.


------------------------------------------------------------
3. TRƯỜNG HỢP 2: SERVER CỦA BẠN DOWNLOAD EXCEL TỪ SERVER KHÁC
------------------------------------------------------------

Luồng xử lý:

Server A (đối tác)
        ↓
     SFTP
        ↓
Server của bạn (Java)
        ↓
User download qua HTTP

Trong trường hợp này:

SFTP chính là trung gian giữa 2 server.

Java của bạn sẽ:

1) Kết nối SFTP đến server đối tác
2) Download file Excel về local (hoặc memory)
3) Sau đó trả file đó cho user qua HTTP

Lúc này SFTP đóng vai trò:
→ Cầu nối truyền file giữa hai server.


------------------------------------------------------------
4. TÓM TẮT SO SÁNH 2 TÌNH HUỐNG

------------------------------------------------------------
TÌNH HUỐNG                    | SFTP CÓ LIÊN QUAN?
------------------------------------------------------------
User download từ website      | KHÔNG
Server lấy file từ server khác| CÓ
------------------------------------------------------------


------------------------------------------------------------
5. HIỂU ĐÚNG BẢN CHẤT SFTP
------------------------------------------------------------

SFTP không phải là giao thức download cho browser.

SFTP là giao thức:
- Truyền file giữa server và server
- Hoặc giữa máy client kỹ thuật và server

Browser không download bằng SFTP.
Browser download bằng HTTP/HTTPS.


------------------------------------------------------------
6. VÍ DỤ THỰC TẾ TRONG DOANH NGHIỆP

Ví dụ:

Ngân hàng A mỗi ngày đặt file report.xls lên SFTP server.

Hệ thống của bạn:

- Dùng Java job chạy 2h sáng
- Kết nối SFTP
- Lấy file report.xls về
- Lưu database
- Hoặc cho user tải lại qua website

Ở đây:

SFTP = trung gian giữa hệ thống bạn và ngân hàng.


------------------------------------------------------------
7. CÁC MÔ HÌNH PHỔ BIẾN

MÔ HÌNH 1 (Không dùng SFTP):

User → HTTP → Server Java → Trả file Excel

MÔ HÌNH 2 (Có SFTP):

User → HTTP → Server Java → SFTP → Server đối tác


------------------------------------------------------------
8. TRƯỜNG HỢP BẠN ĐANG HỎI CÓ THỂ LÀ GÌ?

Nếu bạn chỉ viết:

public void downloadExcel(...) 

và mục tiêu là cho user tải file →
KHÔNG CẦN SFTP.

Nếu file Excel nằm ở server khác và bạn phải lấy về trước →
SFTP chính là trung gian giữa 2 server.


------------------------------------------------------------
9. KẾT LUẬN CUỐI CÙNG

SFTP không phải là trung gian cho việc user download file từ website.

SFTP chỉ là trung gian truyền file giữa các server.

Nếu bạn viết hàm download Excel cho user tải từ web → bạn chỉ cần HTTP response.

Nếu file Excel nằm trên server khác → SFTP sẽ là cầu nối để server của bạn lấy file đó về trước khi trả cho user.

--- ĐỐI VỚI UPLOAD FILE THÌ SFTP CÓ VAI TRÒ GÌ?

GIẢI THÍCH CHI TIẾT: ĐỐI VỚI UPLOAD FILE THÌ SFTP CÓ VAI TRÒ GÌ?

1. TRƯỚC TIÊN CẦN PHÂN BIỆT 2 KIỂU UPLOAD

Giống như download, upload cũng có 2 trường hợp hoàn toàn khác nhau:

(1) User upload file lên website của bạn
(2) Server của bạn upload file lên server khác

Hai trường hợp này khác nhau về bản chất.

------------------------------------------------------------
2. TRƯỜNG HỢP 1: USER UPLOAD FILE LÊN WEBSITE CỦA BẠN
------------------------------------------------------------

Luồng xử lý:

Browser → HTTP request (multipart/form-data) → Server Java

Trong trường hợp này:

- Không có SFTP
- Không cần SFTP
- Chỉ dùng HTTP

Ví dụ thực tế:

<form enctype="multipart/form-data">
    <input type="file" name="file">
</form>

Server Java sẽ:

- Nhận file qua request
- Lưu vào:
    + Ổ đĩa
    + Database
    + Cloud storage (S3...)
    + Hoặc xử lý ngay

KẾT LUẬN:
User upload file lên web → SFTP KHÔNG liên quan.


------------------------------------------------------------
3. TRƯỜNG HỢP 2: SERVER CỦA BẠN UPLOAD FILE LÊN SERVER KHÁC
------------------------------------------------------------

Luồng xử lý:

User → HTTP → Server Java → SFTP → Server đối tác

Ví dụ thực tế:

User upload file report.xlsx lên hệ thống của bạn.
Sau đó hệ thống của bạn phải gửi file đó cho ngân hàng qua SFTP.

Lúc này:

SFTP chính là trung gian giữa hai server.

Quy trình:

1) User upload file qua HTTP
2) Server Java nhận file
3) Server Java dùng SFTP upload file đó lên server đối tác


------------------------------------------------------------
4. SO SÁNH 2 TÌNH HUỐNG UPLOAD

------------------------------------------------------------
TÌNH HUỐNG                         | SFTP CÓ LIÊN QUAN?
------------------------------------------------------------
User upload lên website            | KHÔNG
Server upload lên server khác      | CÓ
------------------------------------------------------------


------------------------------------------------------------
5. BẢN CHẤT SFTP TRONG UPLOAD
------------------------------------------------------------

SFTP dùng để:

- Truyền file từ server của bạn → server khác
- Không liên quan đến browser

Browser upload bằng HTTP.
Server upload giữa nhau có thể dùng SFTP.


------------------------------------------------------------
6. CÁC MÔ HÌNH PHỔ BIẾN

MÔ HÌNH 1 (KHÔNG SFTP):

User → HTTP → Server Java → Lưu local / database

MÔ HÌNH 2 (CÓ SFTP):

User → HTTP → Server Java → SFTP → Server đối tác

MÔ HÌNH 3 (JOB TỰ ĐỘNG):

Server Java tạo file batch → SFTP → Server đối tác


------------------------------------------------------------
7. VÍ DỤ DOANH NGHIỆP

Ví dụ 1:
Công ty bạn phải gửi file thanh toán cuối ngày cho ngân hàng.

Hệ thống của bạn:

- Tạo file payment.txt
- Dùng SFTP upload file lên server ngân hàng

Ví dụ 2:
Hệ thống của bạn là trung gian:

User upload file → hệ thống kiểm tra → SFTP gửi cho hệ thống khác


------------------------------------------------------------
8. KHI NÀO KHÔNG NÊN DÙNG SFTP?

Không cần SFTP khi:

- Upload chỉ diễn ra giữa browser và server của bạn
- Lưu file nội bộ
- Không cần truyền sang server khác

SFTP chỉ cần khi có:
- Hai hệ thống khác nhau
- Truyền file qua mạng
- Yêu cầu bảo mật cao


------------------------------------------------------------
9. TỔNG KẾT NGẮN GỌN

Upload file có 2 kiểu:

1) Browser → Server Java
   → Dùng HTTP
   → Không cần SFTP

2) Server Java → Server khác
   → Dùng SFTP
   → SFTP là trung gian truyền file


------------------------------------------------------------
10. KẾT LUẬN CUỐI CÙNG

Trong upload file:

- Nếu user upload file lên web → chỉ dùng HTTP.
- Nếu server của bạn phải gửi file đó sang server khác → SFTP sẽ là trung gian truyền file giữa hai hệ thống.

SFTP không thay thế HTTP upload của browser. 
Nó chỉ dùng cho truyền file giữa các server với nhau một cách an toàn.

--- HIỂU ĐÚNG BẢN CHẤT SFTP KẾT NỐI GIỮA CÁC MÁY NHƯ THẾ NÀO

GIẢI THÍCH CHI TIẾT: HIỂU ĐÚNG BẢN CHẤT SFTP KẾT NỐI GIỮA CÁC MÁY NHƯ THẾ NÀO

CÂU HỎI:
“SFTP nghĩa là nó sẽ kết nối máy tính đang chạy code backend đến một máy tính server để truyền nhận dữ liệu giữa hai máy đúng không?”

TRẢ LỜI NGẮN GỌN:
ĐÚNG — nhưng cần hiểu rõ bản chất kỹ thuật phía sau.


============================================================
1. SFTP THỰC SỰ KẾT NỐI CÁI GÌ?
============================================================

SFTP không kết nối “máy tính” theo nghĩa vật lý.
Nó kết nối:

Ứng dụng (program) đang chạy
        ↓
đến
SFTP Server (dịch vụ SSH đang chạy trên một máy khác)

Nghĩa là:

Không phải máy tính tự kết nối với nhau,
mà là chương trình Java của bạn mở một kết nối mạng TCP tới server SFTP.


============================================================
2. MÔ HÌNH ĐÚNG CỦA SFTP
============================================================

Giả sử:

- Máy A: chạy backend Java của bạn
- Máy B: chạy SFTP server

Luồng thực tế:

Backend Java (Máy A)
        ↓ TCP port 22
SSH Service (Máy B)
        ↓
SFTP subsystem
        ↓
Hệ thống file của Máy B


============================================================
3. CHI TIẾT CÁCH NÓ HOẠT ĐỘNG
============================================================

Bước 1:
Java của bạn mở socket TCP tới:
- IP server
- Port 22

Bước 2:
Thiết lập kết nối SSH (bắt tay, mã hóa)

Bước 3:
Xác thực:
- Username/password
HOẶC
- Private key

Bước 4:
Mở SFTP channel bên trong SSH

Bước 5:
Thực hiện thao tác file:
- Upload
- Download
- Xóa
- Đổi tên
- Tạo thư mục


============================================================
4. VẬY CÓ PHẢI KẾT NỐI 2 MÁY KHÔNG?
============================================================

Về mặt logic:
Đúng — backend của bạn đang giao tiếp với một máy khác.

Về mặt kỹ thuật:
Là một kết nối TCP giữa hai tiến trình qua mạng.


============================================================
5. SFTP CÓ LUÔN LÀ MÁY KHÁC KHÔNG?
============================================================

Không bắt buộc.

Có thể:

1) Kết nối đến máy khác (phổ biến nhất)
2) Kết nối đến server nội bộ trong cùng mạng LAN
3) Thậm chí kết nối đến localhost (cùng một máy)

Ví dụ:
Backend chạy trên server Linux.
SFTP server cũng chạy trên cùng server đó.
Bạn vẫn có thể kết nối tới 127.0.0.1 qua SFTP.


============================================================
6. SFTP CÓ PHẢI CHỈ TRUYỀN FILE KHÔNG?
============================================================

Đúng.

SFTP chỉ làm việc với file system.

Nó không:
- Gọi API
- Truy vấn database
- Gửi HTTP request

Nó chỉ thao tác file từ xa.


============================================================
7. PHÂN BIỆT RÕ VỚI HTTP
============================================================

HTTP:
Browser ↔ Web Server

SFTP:
Program ↔ SSH Server ↔ File System

SFTP không liên quan đến trình duyệt.


============================================================
8. VÍ DỤ THỰC TẾ
============================================================

Ví dụ 1:

Hệ thống của bạn phải gửi file thanh toán cho ngân hàng.

Backend Java:
- Tạo file payment.txt
- Kết nối SFTP tới server ngân hàng
- Upload file lên thư mục /incoming

Ví dụ 2:

Hệ thống của bạn cần lấy file từ đối tác.

Backend Java:
- Kết nối SFTP
- Download file report.xlsx
- Xử lý file


============================================================
9. TÓM TẮT CHÍNH XÁC NHẤT
============================================================

SFTP nghĩa là:

Chương trình backend của bạn sẽ mở một kết nối mạng (qua SSH) đến một SFTP server đang chạy trên một máy khác (hoặc cùng máy)
để truyền và quản lý file giữa hai hệ thống một cách an toàn.


============================================================
10. KẾT LUẬN CUỐI CÙNG
============================================================

Đúng — SFTP là cơ chế để backend của bạn kết nối tới một server khác thông qua SSH nhằm truyền nhận file giữa hai hệ thống.

Nhưng bản chất kỹ thuật là:
- Kết nối TCP
- Thiết lập SSH
- Mở SFTP channel
- Thao tác file từ xa

Nó không phải kết nối “máy với máy” theo nghĩa vật lý, mà là kết nối giữa các dịch vụ chạy trên hai máy thông qua mạng.

--- CÓ CẦN CLOSE BufferedReader KHI DÙNG readLine() KHÔNG?

GIẢI THÍCH CHI TIẾT: CÓ CẦN CLOSE BufferedReader KHI DÙNG readLine() KHÔNG?

============================================================
1. CÂU TRẢ LỜI NGẮN GỌN
============================================================

Có.

Khi dùng BufferedReader với readLine(), bạn PHẢI đóng (close) nó sau khi dùng xong.

Không chỉ BufferedReader — hầu hết các tài nguyên I/O trong Java đều cần được close.


============================================================
2. TẠI SAO PHẢI CLOSE?
============================================================

BufferedReader làm việc với:

- File
- Socket
- InputStream
- Resource hệ điều hành

Khi bạn mở nó, Java sẽ:

- Mở file descriptor
- Chiếm bộ nhớ buffer
- Giữ tài nguyên hệ điều hành

Nếu không close:

- Rò rỉ tài nguyên (resource leak)
- Hết file descriptor
- Không xóa được file
- Không ghi hết dữ liệu xuống disk
- Lỗi "Too many open files"

Vì vậy close là bắt buộc.


============================================================
3. readLine() KHÔNG TỰ CLOSE
============================================================

Nhiều người hiểu nhầm:

Gọi readLine() xong là xong.

Sai.

readLine() chỉ đọc 1 dòng.
Nó KHÔNG đóng stream.

Bạn phải tự close.


============================================================
4. VÍ DỤ SAI (DỄ GÂY LỖI)
============================================================

BufferedReader br = new BufferedReader(new FileReader("data.txt"));
String line = br.readLine();

// không close → sai

Nếu lặp lại nhiều lần → rò rỉ tài nguyên.


============================================================
5. CÁCH ĐÚNG: DÙNG TRY-WITH-RESOURCES
============================================================

Từ Java 7 trở lên, nên dùng:

try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

} catch (IOException e) {
    e.printStackTrace();
}

Lợi ích:

- Tự động close
- An toàn khi có exception
- Không cần finally


============================================================
6. NẾU KHÔNG DÙNG TRY-WITH-RESOURCES
============================================================

Bạn phải đóng trong finally:

BufferedReader br = null;

try {
    br = new BufferedReader(new FileReader("data.txt"));
    String line = br.readLine();

} finally {
    if (br != null) {
        br.close();
    }
}

Cách này dài và dễ quên.


============================================================
7. CÓ PHẢI TẤT CẢ ĐỀU PHẢI CLOSE KHÔNG?
============================================================

Gần như tất cả class liên quan đến I/O đều cần close.

Ví dụ:

- FileInputStream
- FileOutputStream
- BufferedReader
- BufferedWriter
- InputStream
- OutputStream
- Socket
- Scanner (đọc file)
- ResultSet (JDBC)
- Connection (JDBC)

Vì chúng đều giữ tài nguyên hệ điều hành.


============================================================
8. NGOẠI LỆ QUAN TRỌNG
============================================================

1) System.in
Không nên close nếu chương trình còn chạy.

2) InputStream từ getResourceAsStream
Nên close sau khi dùng xong.

3) ByteArrayInputStream
Không bắt buộc close vì nó chỉ dùng bộ nhớ.
Nhưng vẫn nên theo thói quen chuẩn.


============================================================
9. LUẬT CHUNG TRONG JAVA
============================================================

Nếu một class implement AutoCloseable hoặc Closeable:

→ Bạn nên đóng nó.

BufferedReader implements Closeable.
Vì vậy phải close.


============================================================
10. ĐÓNG BufferedReader CÓ ĐÓNG FileReader KHÔNG?
============================================================

Có.

Khi bạn gọi:

br.close();

Nó sẽ đóng luôn stream bên trong (ví dụ FileReader).

Vì BufferedReader là wrapper.


============================================================
11. TÓM TẮT NGẮN GỌN
============================================================

- readLine() không tự đóng stream.
- BufferedReader cần được close.
- Hầu hết các class I/O trong Java đều cần close.
- Nên dùng try-with-resources để tự động đóng.
- Nếu không close → dễ gây rò rỉ tài nguyên.


============================================================
12. KẾT LUẬN CUỐI CÙNG
============================================================

Có — khi dùng BufferedReader với readLine(), bạn bắt buộc phải đóng nó sau khi dùng
xong. Điều này đúng với hầu hết các tài nguyên I/O trong Java. Cách an toàn và chuẩn
nhất là sử dụng try-with-resources để Java tự động đóng tài nguyên ngay cả khi có
exception xảy ra.

--- MD5 LÀ GÌ?

GIẢI THÍCH CHI TIẾT: MD5 LÀ GÌ?

============================================================
1. MD5 LÀ GÌ?
============================================================

MD5 (Message Digest Algorithm 5) là một thuật toán băm (hashing algorithm) dùng để tạo ra một giá trị băm (hash value) có độ dài cố định 128 bit (16 byte).

Giá trị này thường được biểu diễn dưới dạng chuỗi hex 32 ký tự.

Ví dụ:

Chuỗi: "hello"

MD5 → 5d41402abc4b2a76b9719d911017c592

Quan trọng:
MD5 là thuật toán băm một chiều (one-way hash).
Không thể giải ngược lại dữ liệu ban đầu một cách trực tiếp.


============================================================
2. HASHING LÀ GÌ?
============================================================

Hashing (băm) là quá trình:

Input (bất kỳ độ dài nào)
        ↓
Thuật toán băm
        ↓
Output (độ dài cố định)

Đặc điểm:

- Không thể đảo ngược (về lý thuyết)
- Cùng input → luôn ra cùng output
- Input khác → hash gần như khác hoàn toàn


============================================================
3. MD5 HOẠT ĐỘNG NHƯ THẾ NÀO? (MỨC Ý TƯỞNG)
============================================================

MD5:

- Chia dữ liệu thành các block 512 bit
- Thực hiện nhiều vòng xử lý toán học
- Sử dụng các phép toán bit, XOR, AND, OR, dịch bit
- Cuối cùng tạo ra giá trị 128 bit

Chi tiết thuật toán phức tạp và hiếm khi cần biết sâu khi lập trình ứng dụng.


============================================================
4. ĐẶC ĐIỂM CỦA MD5
============================================================

- Đầu ra luôn 128 bit
- Biểu diễn dạng hex là 32 ký tự
- Nhanh
- Từng rất phổ biến

Ví dụ:

MD5("abc") 
→ 900150983cd24fb0d6963f7d28e17f72


============================================================
5. MD5 DÙNG ĐỂ LÀM GÌ?
============================================================

Trước đây MD5 được dùng để:

- Mã hóa mật khẩu
- Kiểm tra tính toàn vẹn file
- Tạo checksum
- Tạo chữ ký số (cũ)

Hiện nay:

- Không còn an toàn để bảo mật mật khẩu
- Vẫn có thể dùng để kiểm tra file đơn giản


============================================================
6. MD5 CÓ PHẢI LÀ MÃ HÓA (ENCRYPTION) KHÔNG?
============================================================

KHÔNG.

MD5 là HASH, không phải ENCRYPTION.

Khác biệt:

HASH:
- Một chiều
- Không giải mã lại được

ENCRYPTION:
- Có khóa
- Có thể giải mã lại

MD5 không có khóa.


============================================================
7. TẠI SAO MD5 KHÔNG CÒN AN TOÀN?
============================================================

MD5 có 2 vấn đề lớn:

------------------------------------------------------------
A. COLLISION (ĐỤNG ĐỘ HASH)
------------------------------------------------------------

Có thể tạo ra 2 dữ liệu khác nhau nhưng cùng MD5.

Điều này phá vỡ tính bảo mật.

------------------------------------------------------------
B. DỄ BỊ TẤN CÔNG BRUTE FORCE
------------------------------------------------------------

Vì:

- MD5 rất nhanh
- Không có salt mặc định

Hacker có thể dùng:

- Rainbow table
- Dictionary attack

Để dò mật khẩu.


============================================================
8. MD5 CÓ CÒN NÊN DÙNG KHÔNG?
============================================================

KHÔNG dùng cho:

- Lưu mật khẩu
- Hệ thống bảo mật
- Chữ ký số
- Hệ thống production yêu cầu bảo mật cao

CÓ THỂ dùng cho:

- Kiểm tra file download có bị lỗi không
- So sánh dữ liệu đơn giản


============================================================
9. THAY THẾ MD5 BẰNG GÌ?
============================================================

Đối với mật khẩu:

- BCrypt
- Argon2
- PBKDF2

Đối với hashing chung:

- SHA-256
- SHA-512


============================================================
10. MD5 TRONG JAVA
============================================================

Java hỗ trợ MD5 thông qua:

MessageDigest

Ví dụ:

MessageDigest md = MessageDigest.getInstance("MD5");
byte[] hash = md.digest(input.getBytes());

Sau đó chuyển sang hex string.


============================================================
11. SỰ KHÁC BIỆT GIỮA MD5 VÀ SHA-256
============================================================

MD5:
- 128 bit
- Không an toàn
- Nhanh

SHA-256:
- 256 bit
- An toàn hơn nhiều
- Chậm hơn một chút


============================================================
12. TÍNH CHẤT QUAN TRỌNG CỦA HASH
============================================================

Một thuật toán hash tốt cần:

- Deterministic (cùng input → cùng output)
- Fixed length
- Avalanche effect (thay đổi 1 ký tự → hash thay đổi mạnh)
- Khó tìm collision


============================================================
13. TÓM TẮT NGẮN GỌN
============================================================

MD5 là thuật toán băm 128 bit dùng để tạo checksum từ dữ liệu bất kỳ.

Nó:
- Không phải mã hóa
- Là một chiều
- Từng rất phổ biến
- Hiện nay không còn an toàn cho mục đích bảo mật

Chỉ nên dùng MD5 cho mục đích kiểm tra dữ liệu đơn giản, không nên dùng cho bảo mật mật khẩu
hoặc hệ thống nhạy cảm.


============================================================
14. KẾT LUẬN CUỐI CÙNG
============================================================

MD5 là một thuật toán hashing một chiều tạo ra chuỗi 128 bit từ dữ liệu đầu vào. Nó từng
được sử dụng rộng rãi cho bảo mật và kiểm tra dữ liệu, nhưng hiện nay đã bị xem là không
an toàn do có thể xảy ra collision và bị tấn công brute force. Trong hệ thống hiện đại,
nên sử dụng các thuật toán mạnh hơn như SHA-256 hoặc các cơ chế chuyên dụng như BCrypt
cho mật khẩu.

--- MessageDigest TRONG JAVA

GIẢI THÍCH CHI TIẾT: MessageDigest TRONG JAVA

============================================================
1. MessageDigest LÀ GÌ?
============================================================

MessageDigest là một class trong Java dùng để tạo giá trị băm (hash value) từ dữ liệu đầu vào.

Nó thuộc package:

java.security.MessageDigest

Mục đích của MessageDigest:
- Tính hash của dữ liệu (String, file, byte[])
- Kiểm tra tính toàn vẹn dữ liệu
- Hỗ trợ các thuật toán băm như:
  + MD5
  + SHA-1
  + SHA-256
  + SHA-512

Quan trọng:
MessageDigest KHÔNG phải là mã hóa (encryption).
Nó dùng cho hashing (băm một chiều).


============================================================
2. HASHING LÀ GÌ?
============================================================

Hashing là quá trình:

Input (bất kỳ độ dài nào)
        ↓
Thuật toán hash
        ↓
Output có độ dài cố định

Ví dụ:

"hello"
→ SHA-256
→ 64 ký tự hex


============================================================
3. CÁCH TẠO MessageDigest
============================================================

Bạn không tạo bằng new.
Bạn phải dùng factory method:

MessageDigest md = MessageDigest.getInstance("SHA-256");

Hoặc:

MessageDigest md = MessageDigest.getInstance("MD5");

Tên thuật toán truyền vào là String.


============================================================
4. CÁCH SỬ DỤNG MessageDigest
============================================================

Có 3 bước chính:

Bước 1: Tạo MessageDigest
Bước 2: Cung cấp dữ liệu (update hoặc digest trực tiếp)
Bước 3: Nhận kết quả byte[]

Ví dụ cơ bản:

MessageDigest md = MessageDigest.getInstance("SHA-256");
byte[] hash = md.digest("hello".getBytes());

Kết quả trả về là byte[].


============================================================
5. update() VÀ digest() KHÁC GÌ NHAU?
============================================================

update(byte[] input)
→ Thêm dữ liệu vào bộ nhớ tạm.

digest()
→ Tính hash và reset lại đối tượng.

Ví dụ:

md.update(dataPart1);
md.update(dataPart2);
byte[] hash = md.digest();

Thích hợp khi xử lý file lớn hoặc stream.


============================================================
6. TẠI SAO KẾT QUẢ LÀ byte[]?
============================================================

Vì hash thực chất là dữ liệu nhị phân.

Muốn in ra màn hình thường phải chuyển sang dạng hex:

Ví dụ:

for (byte b : hash) {
    sb.append(String.format("%02x", b));
}


============================================================
7. MessageDigest HOẠT ĐỘNG NHƯ THẾ NÀO?
============================================================

Bên trong:

- Áp dụng thuật toán hash (MD5, SHA-256, ...)
- Thực hiện nhiều vòng tính toán toán học
- Tạo ra giá trị cố định

Chi tiết thuật toán phụ thuộc vào loại bạn chọn.


============================================================
8. CÁC THUẬT TOÁN PHỔ BIẾN
============================================================

MD5
- 128 bit
- Không an toàn

SHA-1
- 160 bit
- Không còn an toàn

SHA-256
- 256 bit
- An toàn

SHA-512
- 512 bit
- Mạnh hơn


============================================================
9. DÙNG MessageDigest ĐỂ LÀM GÌ?
============================================================

- Kiểm tra file có bị thay đổi không
- So sánh dữ liệu
- Tạo checksum
- Tạo chữ ký số (kết hợp với private key)
- Hash mật khẩu (không khuyến nghị dùng trực tiếp)


============================================================
10. MessageDigest CÓ PHẢI THREAD-SAFE KHÔNG?
============================================================

Không.

MessageDigest KHÔNG thread-safe.

Nếu dùng trong multi-thread:

- Mỗi thread nên tạo riêng một instance.
- Không dùng chung một đối tượng.


============================================================
11. CÓ RESET ĐƯỢC KHÔNG?
============================================================

Có.

md.reset();

Dùng để xóa dữ liệu cũ trước khi tính hash mới.


============================================================
12. XỬ LÝ FILE LỚN
============================================================

Khi hash file lớn:

Không nên đọc toàn bộ vào memory.

Nên dùng:

while ((bytesRead = input.read(buffer)) != -1) {
    md.update(buffer, 0, bytesRead);
}

Sau đó:

byte[] hash = md.digest();


============================================================
13. MessageDigest KHÔNG LÀM GÌ?
============================================================

Nó không:

- Mã hóa có thể giải mã
- Lưu trữ mật khẩu an toàn hoàn chỉnh
- Tự động thêm salt

Nếu hash mật khẩu, nên dùng:

- BCrypt
- Argon2
- PBKDF2


============================================================
14. TÓM TẮT NGẮN GỌN
============================================================

MessageDigest là class trong Java dùng để tính hash (băm) của dữ liệu bằng các thuật toán như MD5, SHA-256, SHA-512.

Nó:
- Nhận dữ liệu dạng byte[]
- Trả về hash dạng byte[]
- Không phải encryption
- Không thread-safe
- Dùng cho kiểm tra toàn vẹn dữ liệu


============================================================
15. KẾT LUẬN CUỐI CÙNG
============================================================

MessageDigest là lớp chuẩn trong Java dùng để tạo giá trị băm từ dữ liệu đầu vào bằng các thuật toán
hash. Nó thường được dùng để kiểm tra tính toàn vẹn dữ liệu hoặc tạo checksum, và không phải là cơ
chế mã hóa hai chiều. Khi sử dụng trong môi trường đa luồng hoặc hệ thống bảo mật, cần hiểu rõ đặc
điểm không thread-safe và hạn chế của từng thuật toán hash.

--- ChannelSftp

GIẢI THÍCH CHI TIẾT: ChannelSftp TRONG JAVA

============================================================
1. ChannelSftp LÀ GÌ?
============================================================

ChannelSftp là một class dùng để thực hiện các thao tác SFTP 
(Secure File Transfer Protocol) trong Java.

Nó thuộc thư viện:

com.jcraft.jsch.ChannelSftp

Thư viện này nằm trong JSch (Java Secure Channel).

ChannelSftp cho phép bạn:

- Upload file lên server
- Download file từ server
- Xóa file
- Đổi tên file
- Tạo thư mục
- Liệt kê danh sách file
- Di chuyển giữa các thư mục trên server

Nó hoạt động dựa trên SSH.


============================================================
2. ChannelSftp NẰM Ở ĐÂU TRONG CẤU TRÚC SSH?
============================================================

Khi dùng JSch:

Bước 1: Tạo JSch object
Bước 2: Tạo Session (kết nối SSH)
Bước 3: Mở Channel
Bước 4: Cast sang ChannelSftp

Luồng hoạt động:

Máy backend của bạn
        ↓ SSH
Session
        ↓
Channel
        ↓
ChannelSftp
        ↓
Server SFTP

ChannelSftp chính là kênh chuyên dùng để truyền file.


============================================================
3. QUY TRÌNH TẠO ChannelSftp
============================================================

Các bước chuẩn:

1) Tạo JSch
2) Tạo Session
3) Connect session
4) Mở channel kiểu "sftp"
5) Connect channel
6) Ép kiểu sang ChannelSftp

Ví dụ logic:

JSch jsch = new JSch();

Session session = jsch.getSession(username, host, port);
session.setPassword(password);
session.setConfig("StrictHostKeyChecking", "no");
session.connect();

Channel channel = session.openChannel("sftp");
channel.connect();

ChannelSftp sftp = (ChannelSftp) channel;

Sau đó mới thao tác file.


============================================================
4. CÁC HÀM QUAN TRỌNG TRONG ChannelSftp
============================================================

4.1 Upload file

put(localPath, remotePath)

→ Upload file từ máy backend lên server SFTP


4.2 Download file

get(remotePath, localPath)

→ Download file từ server SFTP về máy backend


4.3 Xóa file

rm(remotePath)


4.4 Tạo thư mục

mkdir(path)


4.5 Đổi tên file

rename(oldPath, newPath)


4.6 Di chuyển thư mục

cd(path)


4.7 Lấy danh sách file

ls(path)


============================================================
5. Upload hoạt động như thế nào?
============================================================

Khi gọi:

sftp.put("C:/file.txt", "/home/file.txt");

Quá trình diễn ra:

1) Java đọc file từ máy backend
2) Truyền dữ liệu qua kết nối SSH
3) Server nhận và ghi file vào ổ đĩa của server

Tức là:
File đi từ máy chạy backend → qua SSH → sang server


============================================================
6. Download hoạt động như thế nào?
============================================================

Khi gọi:

sftp.get("/home/file.txt", "C:/file.txt");

Quá trình:

1) Server đọc file
2) Truyền dữ liệu qua SSH
3) Java ghi file vào máy backend


============================================================
7. ChannelSftp CÓ PHẢI LÀ SERVER KHÔNG?
============================================================

Không.

ChannelSftp là client.

Nó là công cụ để backend của bạn kết nối đến server SFTP.

Server SFTP có thể là:

- Linux server
- Cloud server
- FTP server có bật SSH


============================================================
8. KHÁC GÌ FTP?
============================================================

FTP:
- Không mã hóa
- Không an toàn

SFTP:
- Chạy trên SSH
- Mã hóa toàn bộ dữ liệu
- An toàn


============================================================
9. QUẢN LÝ TÀI NGUYÊN
============================================================

Sau khi dùng xong phải đóng:

sftp.disconnect();
session.disconnect();

Nếu không:
- Rò rỉ kết nối
- Tốn tài nguyên
- Server có thể từ chối kết nối mới


============================================================
10. ChannelSftp CÓ THREAD-SAFE KHÔNG?
============================================================

Không.

Không nên dùng chung một ChannelSftp cho nhiều thread.

Mỗi thread nên tạo riêng session và channel.


============================================================
11. XỬ LÝ LỖI
============================================================

ChannelSftp thường ném:

SftpException

Cần bắt lỗi để biết:

- File không tồn tại
- Sai quyền
- Sai đường dẫn
- Kết nối bị mất


============================================================
12. LUỒNG HOẠT ĐỘNG TỔNG QUÁT
============================================================

Backend Java
    ↓
JSch
    ↓
Session (SSH)
    ↓
ChannelSftp
    ↓
Server SFTP
    ↓
Hệ thống file của server


============================================================
13. TRONG HỆ THỐNG THỰC TẾ
============================================================

ChannelSftp thường dùng khi:

- Hệ thống A cần gửi file sang hệ thống B
- Đồng bộ file giữa các server
- Upload file batch ban đêm
- Nhận file dữ liệu từ đối tác


============================================================
14. TÓM TẮT NGẮN GỌN
============================================================

ChannelSftp là một class trong thư viện JSch dùng để truyền file qua giao thức SFTP (chạy trên SSH).

Nó là client, không phải server.

Nó cho phép:
- Upload
- Download
- Xóa
- Đổi tên
- Tạo thư mục
- Liệt kê file

Phải mở Session trước khi tạo ChannelSftp.
Phải đóng kết nối sau khi dùng.
Không thread-safe.


============================================================
15. KẾT LUẬN CUỐI CÙNG
============================================================

ChannelSftp là kênh giao tiếp file an toàn giữa máy chạy backend Java và server thông
qua SSH. Nó đóng vai trò trung gian truyền dữ liệu file giữa hai hệ thống, đảm bảo bảo
mật nhờ mã hóa SSH, và cần được quản lý kết nối cẩn thận trong hệ thống thực tế.

--- ChannelSftp channel;  channel.cd(...) CÓ TÁC DỤNG GÌ?

GIẢI THÍCH CHI TIẾT: ChannelSftp channel;  channel.cd(...) CÓ TÁC DỤNG GÌ?

============================================================
1. ChannelSftp channel; LÀ GÌ?
============================================================

Dòng:

ChannelSftp channel;

Chỉ là khai báo biến.

Nó khai báo một biến tên là "channel" có kiểu ChannelSftp.

Nó chưa tạo kết nối.
Nó chưa trỏ tới server.
Nó chỉ là một reference (tham chiếu).

Giống như:

String s;

Chỉ khai báo, chưa có giá trị.

Chỉ khi bạn gán:

channel = (ChannelSftp) session.openChannel("sftp");

và connect nó:

channel.connect();

thì biến channel mới thực sự đại diện cho một kết nối SFTP đang hoạt động.


============================================================
2. channel.cd(...) LÀ GÌ?
============================================================

cd = change directory

Nó có tác dụng:

→ Thay đổi thư mục làm việc hiện tại trên server SFTP.

Giống như khi bạn dùng command line Linux:

cd /home/user/data

Trong ChannelSftp cũng vậy.

Ví dụ:

channel.cd("/home/user/data");

Sau lệnh này:

Thư mục làm việc hiện tại của session SFTP
sẽ là:

/home/user/data


============================================================
3. TẠI SAO CẦN cd()?
============================================================

Vì nhiều thao tác SFTP hoạt động dựa trên "thư mục hiện tại".

Ví dụ:

channel.put("local.txt", "remote.txt");

Nếu bạn không cd trước,
remote.txt sẽ được upload vào thư mục hiện tại.

Nếu bạn đã cd("/home/a")
thì file sẽ được upload vào:

/home/a/remote.txt

Nếu bạn cd("/home/b")
thì file sẽ vào:

/home/b/remote.txt


============================================================
4. cd() ẢNH HƯỞNG ĐẾN NHỮNG HÀNH ĐỘNG NÀO?
============================================================

Sau khi cd:

- put()
- get()
- ls()
- rm()
- rename()

Tất cả đều dùng thư mục hiện tại nếu bạn không truyền full path.


============================================================
5. SỰ KHÁC BIỆT GIỮA DÙNG cd() VÀ DÙNG FULL PATH
============================================================

Cách 1: Dùng cd()

channel.cd("/home/data");
channel.put("a.txt", "b.txt");

Cách 2: Không dùng cd()

channel.put("a.txt", "/home/data/b.txt");

Hai cách đều được.

cd() giúp code gọn hơn khi bạn thao tác nhiều file trong cùng thư mục.


============================================================
6. cd() HOẠT ĐỘNG NHƯ THẾ NÀO BÊN TRONG?
============================================================

Khi bạn gọi:

channel.cd("/home/user");

ChannelSftp sẽ:

1) Gửi lệnh SFTP CHANGE_DIRECTORY tới server
2) Server kiểm tra:
   - Thư mục có tồn tại không
   - User có quyền truy cập không
3) Nếu hợp lệ → cập nhật thư mục làm việc
4) Nếu sai → ném SftpException


============================================================
7. NẾU THƯ MỤC KHÔNG TỒN TẠI THÌ SAO?
============================================================

Sẽ ném:

SftpException

Ví dụ lỗi thường gặp:

- No such file
- Permission denied

Do đó thường cần try-catch.


============================================================
8. cd("..") CÓ ĐƯỢC KHÔNG?
============================================================

Có.

Giống Linux:

channel.cd("..");

→ Lùi lên thư mục cha.

Hoặc:

channel.cd(".");

→ Ở lại thư mục hiện tại.


============================================================
9. LẤY THƯ MỤC HIỆN TẠI NHƯ THẾ NÀO?
============================================================

Dùng:

channel.pwd();

pwd = print working directory

Nó trả về String đường dẫn hiện tại trên server.


============================================================
10. cd() CÓ ẢNH HƯỞNG TỚI MÁY BACKEND KHÔNG?
============================================================

Không.

Nó chỉ thay đổi thư mục trên SERVER SFTP.

Nó không ảnh hưởng đến:

- Thư mục local
- File hệ thống máy chạy Java


============================================================
11. LUỒNG HOẠT ĐỘNG THỰC TẾ
============================================================

Backend Java
      ↓
ChannelSftp
      ↓
Server SFTP
      ↓
Thay đổi working directory của session SFTP

Nó không thay đổi gì trên máy local.


============================================================
12. VÍ DỤ THỰC TẾ
============================================================

Giả sử server có cấu trúc:

/home
   /report
   /backup

Nếu bạn:

channel.cd("/home/report");
channel.put("file1.xlsx", "file1.xlsx");

File sẽ vào:

/home/report/file1.xlsx

Nếu sau đó:

channel.cd("/home/backup");
channel.put("file1.xlsx", "file1.xlsx");

File sẽ vào:

/home/backup/file1.xlsx


============================================================
13. KHI NÀO NÊN DÙNG cd()?
============================================================

Nên dùng khi:

- Upload nhiều file cùng thư mục
- Download nhiều file cùng thư mục
- Duyệt file (ls) trong thư mục đó

Không bắt buộc nếu bạn luôn dùng full path.


============================================================
14. TÓM TẮT NGẮN GỌN
============================================================

ChannelSftp channel;
→ Chỉ là khai báo biến.

channel.cd(path);
→ Thay đổi thư mục làm việc hiện tại trên server SFTP.

Nó giống lệnh cd trong Linux.

Sau khi cd, các thao tác như put(), get(), ls()
sẽ hoạt động dựa trên thư mục mới nếu không dùng full path.

Nó không ảnh hưởng tới máy local.
Chỉ ảnh hưởng tới session SFTP trên server.


============================================================
15. KẾT LUẬN CUỐI CÙNG
============================================================

channel.cd(...) là lệnh thay đổi thư mục làm việc hiện tại trên server SFTP trong phiên
làm việc của ChannelSftp. Nó giúp bạn thao tác file thuận tiện hơn khi làm việc nhiều lần
trong cùng một thư mục và chỉ ảnh hưởng đến phía server, không ảnh hưởng đến máy chạy backend.

--- channel.connect() TRONG ChannelSftp (JSch)

GIẢI THÍCH CHI TIẾT: channel.connect() TRONG ChannelSftp (JSch)

============================================================
1. channel.connect() LÀ GÌ?
============================================================

channel.connect() là lệnh dùng để:

→ KÍCH HOẠT kênh (channel) SFTP sau khi đã mở từ Session.

Nó thực sự thiết lập kết nối logic giữa:
- ChannelSftp
- SSH Session
- Server SFTP

Nếu không gọi connect(), bạn không thể:
- upload file
- download file
- cd
- ls
- rm
- hoặc bất kỳ thao tác nào khác


============================================================
2. PHÂN BIỆT session.connect() VÀ channel.connect()
============================================================

Trong JSch có 2 tầng kết nối:

TẦNG 1 – SSH SESSION
session.connect();
→ Thiết lập kết nối SSH giữa máy backend và server.

TẦNG 2 – CHANNEL (SFTP, exec, shell…)
channel.connect();
→ Kích hoạt một kênh cụ thể bên trong SSH session.

So sánh đơn giản:

session.connect()
= Mở đường hầm SSH

channel.connect()
= Mở một đường truyền cụ thể trong đường hầm đó


============================================================
3. LUỒNG HOẠT ĐỘNG ĐẦY ĐỦ
============================================================

JSch jsch = new JSch();

Session session = jsch.getSession(user, host, port);
session.setPassword(password);
session.connect();           ← BƯỚC 1

Channel channel = session.openChannel("sftp");
channel.connect();           ← BƯỚC 2

ChannelSftp sftp = (ChannelSftp) channel;

Phải theo đúng thứ tự:

1) session.connect()
2) openChannel()
3) channel.connect()


============================================================
4. NẾU KHÔNG GỌI channel.connect() THÌ SAO?
============================================================

Nếu bạn chỉ:

Channel channel = session.openChannel("sftp");

Mà không gọi:

channel.connect();

Thì channel chưa hoạt động.

Khi bạn gọi:

sftp.put(...)

Sẽ bị lỗi kiểu:
- Channel is not opened
- Channel is not connected


============================================================
5. BÊN TRONG channel.connect() XẢY RA GÌ?
============================================================

Khi gọi channel.connect():

1) Gửi yêu cầu mở kênh SFTP qua SSH session
2) Server xác nhận quyền mở kênh
3) Thiết lập luồng truyền dữ liệu SFTP
4) Kênh chuyển sang trạng thái CONNECTED

Lúc này mới có thể truyền file.


============================================================
6. channel.connect() CÓ THỂ THROW LỖI GÌ?
============================================================

Nó có thể ném:

JSchException

Nguyên nhân thường là:
- SSH session chưa connect
- Mất kết nối mạng
- Server từ chối mở channel
- Sai cấu hình


============================================================
7. channel.connect(int timeout)
============================================================

Bạn có thể truyền timeout:

channel.connect(10000);

→ Timeout sau 10 giây nếu không kết nối được.


============================================================
8. KHI NÀO PHẢI DISCONNECT?
============================================================

Sau khi dùng xong:

channel.disconnect();
session.disconnect();

Nếu không:
- Tốn tài nguyên
- Server giữ session mở
- Có thể bị từ chối kết nối mới


============================================================
9. TRẠNG THÁI CHANNEL
============================================================

Trước connect:
channel.isConnected() → false

Sau connect:
channel.isConnected() → true

Sau disconnect:
channel.isConnected() → false


============================================================
10. channel.connect() KHÔNG LÀM GÌ?
============================================================

Nó không:

- Xác thực lại user (việc này do session làm)
- Tạo thư mục
- Upload file
- Thay đổi thư mục

Nó chỉ:
→ Mở kênh SFTP


============================================================
11. MỐI QUAN HỆ GIỮA SESSION VÀ CHANNEL
============================================================

Session = Kết nối SSH chính
Channel = Dịch vụ bên trong SSH

Một Session có thể mở nhiều Channel:

- 1 channel SFTP
- 1 channel exec
- 1 channel shell

Nhưng mỗi channel đều phải gọi connect().


============================================================
12. LUỒNG TƯ DUY ĐƠN GIẢN
============================================================

Máy backend
   ↓
session.connect()
   ↓
Đường hầm SSH được tạo
   ↓
openChannel("sftp")
   ↓
channel.connect()
   ↓
SFTP sẵn sàng hoạt động


============================================================
13. VÍ DỤ THỰC TẾ DỄ HIỂU
============================================================

Hãy tưởng tượng:

session.connect()
= Bạn vào được tòa nhà

channel.connect()
= Bạn mở cửa phòng làm việc cụ thể

Chỉ vào tòa nhà chưa đủ.
Bạn phải mở cửa phòng để làm việc.


============================================================
14. TÓM TẮT NGẮN GỌN
============================================================

channel.connect() dùng để kích hoạt kênh SFTP sau khi đã mở từ SSH session.

Nó là bước bắt buộc trước khi thao tác file.

Thứ tự đúng:

1) session.connect()
2) session.openChannel("sftp")
3) channel.connect()

Nếu không gọi channel.connect() thì không thể upload hoặc download file.


============================================================
15. KẾT LUẬN CUỐI CÙNG
============================================================

channel.connect() là bước thiết lập và kích hoạt kênh SFTP bên trong SSH session. Nó hoàn tất
quá trình mở kết nối để cho phép truyền file giữa backend và server. Không có bước này, ChannelSftp
sẽ không thể thực hiện bất kỳ thao tác file nào.

--- SftpATTRS LA GI?

GIAI THICH CHI TIET VE SftpATTRS

1. SftpATTRS LA GI?

SftpATTRS la mot class trong thu vien JSch (Java Secure Channel).
No duoc su dung khi lam viec voi SFTP (SSH File Transfer Protocol).

Chuc nang chinh:
- Dai dien cho TAP THUOC TINH (attributes) cua mot file hoac folder tren SFTP server.
- Khi ta goi lenh list file, stat file, lstat file... thi server se tra ve thong tin thuoc tinh, va thong tin nay duoc dong goi trong doi tuong SftpATTRS.

No giong nhu:
- FileAttributes trong he dieu hanh
- Hoac BasicFileAttributes trong Java NIO

2. SftpATTRS XUAT HIEN O DAU?

Thuong gap khi su dung class:
com.jcraft.jsch.ChannelSftp

Vi du:
ChannelSftp channel = ...
SftpATTRS attrs = channel.stat("/remote/path/file.txt");

Hoac:
Vector<ChannelSftp.LsEntry> list = channel.ls("/remote/path");
Trong LsEntry se co:
entry.getAttrs() -> tra ve SftpATTRS

3. BEN TRONG SftpATTRS CO NHUNG GI?

SftpATTRS chua cac thong tin ve file nhu:

- Kich thuoc file (size)
- Quyen truy cap (permission)
- Chu so huu (uid)
- Nhom (gid)
- Thoi gian tao / sua
- Loai file (file thuong, folder, link...)

No tuong duong voi cau truc stat trong Unix/Linux.

4. CAC PHUONG THUC QUAN TRONG

4.1 getSize()

Tra ve kich thuoc file (don vi: byte)

long size = attrs.getSize();

Neu la folder thi size thuong la 0 hoac gia tri dac trung tuy server.

4.2 getPermissions()

Tra ve permission duoi dang so nguyen (int)
Day la ma permission kieu Unix (vd: 0644, 0755...)

int perm = attrs.getPermissions();

Co the chuyen sang chuoi rwxr-xr-x bang:
attrs.getPermissionsString();

4.3 getPermissionsString()

Tra ve chuoi permission dang:

-rw-r--r--
drwxr-xr-x

Ky tu dau:
- '-' : file thuong
- 'd' : directory
- 'l' : symbolic link

4.4 getUId() va getGId()

Lay:
- User ID (chu so huu)
- Group ID (nhom so huu)

int uid = attrs.getUId();
int gid = attrs.getGId();

Luu y: Day la so ID, khong phai ten user.

4.5 getATime() va getMTime()

- getATime(): Access time (lan truy cap cuoi)
- getMTime(): Modified time (lan sua cuoi)

Gia tri tra ve la so giay tinh tu 01/01/1970 (Unix timestamp)

Can chuyen sang Date:

long mtime = attrs.getMTime() * 1000L;
Date date = new Date(mtime);

5. PHAN BIET STAT VA LSTAT

channel.stat(path)
- Lay attribute cua file.
- Neu la symbolic link thi tra ve attribute cua file dich.

channel.lstat(path)
- Lay attribute cua chinh symbolic link.

Ca hai deu tra ve SftpATTRS.

6. LOAI FILE

SftpATTRS khong co method isDirectory() truc tiep trong moi version,
nhung thuong co:

attrs.isDir()
attrs.isLink()
attrs.isReg()

Neu khong co, co the dua vao permissionString:
- Bat dau bang 'd' -> folder
- Bat dau bang '-' -> file
- Bat dau bang 'l' -> link

7. KHI NAO SU DUNG SftpATTRS?

Dung khi:
- Can kiem tra file co ton tai hay khong
- Can lay size de kiem tra file trong/khong trong
- Can check file la folder hay file
- Can kiem tra quyen truy cap
- Can so sanh thoi gian cap nhat

Vi du:
- Dong bo file
- Backup file
- Kiem tra file da duoc upload xong chua
- Validate quyen truy cap

8. VI DU DAY DU

ChannelSftp channel = ...
SftpATTRS attrs = channel.stat("/data/test.txt");

if (attrs.isDir()) {
    System.out.println("La folder");
} else {
    System.out.println("La file");
}

System.out.println("Size: " + attrs.getSize());
System.out.println("Permission: " + attrs.getPermissionsString());
System.out.println("Modified time: " + new Date(attrs.getMTime() * 1000L));

9. TOM TAT BAN CHAT

SftpATTRS la:
- Mot doi tuong chua THUOC TINH cua file tren SFTP server.
- Tuong tu lenh "ls -l" trong Linux.
- Duoc tra ve khi goi stat(), lstat(), ls().

No KHONG dung de:
- Doc noi dung file
- Upload file
- Download file

No chi dung de:
- Lay thong tin meta-data cua file.

10. TU DUY DE HIEU SAU HON

Hay hinh dung:

File tren SFTP co 2 phan:
1. Noi dung (data)
2. Thuoc tinh (metadata)

SftpATTRS chinh la phan metadata.

Neu khong co SftpATTRS:
Ban khong biet:
- File co bao nhieu byte
- La folder hay file
- Co quyen doc/ghi khong
- Sua lan cuoi khi nao

=> SftpATTRS la thanh phan rat quan trong khi lam viec voi SFTP trong Java.

--- channel.getHome()

GIẢI THÍCH CHI TIẾT: channel.getHome()

1. Tổng quan

channel.getHome() là một phương thức (method) dùng để lấy về giá trị "home directory" (thư mục gốc mặc định) của một channel.

Tuy nhiên, cần lưu ý cực kỳ quan trọng:
- Không có method channel.getHome() trong Java chuẩn (JDK).
- Method này thường xuất hiện trong các thư viện bên thứ ba, phổ biến nhất là thư viện SFTP như:
  - JSch
  - Apache Mina SSHD
  - Một số wrapper FTP/SFTP khác

Vì vậy, để hiểu đúng channel.getHome(), bạn phải biết "channel" thuộc thư viện nào.

Trường hợp phổ biến nhất:
ChannelSftp channel = session.openChannel("sftp");

Khi đó:
channel.getHome() thường là method của ChannelSftp (JSch).

------------------------------------------------------------
2. Ý nghĩa trong ngữ cảnh SFTP (phổ biến nhất)

Ví dụ với JSch:

ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
channel.connect();

String home = channel.getHome();

=> channel.getHome() sẽ trả về đường dẫn thư mục HOME của user trên server từ xa (remote server).

Ví dụ trả về:
"/home/username"
hoặc
"/Users/username"
hoặc
"/var/www"

Tùy vào hệ điều hành và cấu hình server.

------------------------------------------------------------
3. Home directory là gì?

Home directory là:
- Thư mục mặc định của user khi đăng nhập vào hệ thống
- Khi SSH vào server, bạn thường đứng ở thư mục home

Ví dụ:
Linux server
User: tuan

Home thường là:
/home/tuan

------------------------------------------------------------
4. Cơ chế hoạt động bên trong (SFTP)

Khi bạn gọi:

channel.getHome();

Thư viện SFTP sẽ:
- Gửi request tới server
- Hỏi server: "Home directory của user hiện tại là gì?"
- Server trả về path
- Thư viện convert thành String và trả về

------------------------------------------------------------
5. Phân biệt getHome() và pwd()

Rất nhiều người nhầm lẫn 2 method:

channel.getHome()
- Trả về home directory gốc của user
- Không phụ thuộc bạn đang đứng ở đâu

channel.pwd()
- Trả về current working directory (thư mục hiện tại)
- Thay đổi nếu bạn cd sang thư mục khác

Ví dụ:

Home: /home/tuan

Ban đầu:
pwd() = /home/tuan

Sau khi:
channel.cd("documents");

pwd() = /home/tuan/documents

Nhưng:
getHome() vẫn = /home/tuan

------------------------------------------------------------
6. Khi nào dùng channel.getHome()?

Dùng khi bạn:
- Muốn biết thư mục gốc của user
- Muốn build path tương đối từ home
- Muốn reset về home directory
- Muốn xác định base path an toàn

Ví dụ:

String home = channel.getHome();
channel.cd(home);

------------------------------------------------------------
7. Ví dụ đầy đủ (JSch)

Session session = jsch.getSession("user", "host", 22);
session.setPassword("password");
session.connect();

ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
channel.connect();

String homeDir = channel.getHome();

System.out.println("Home directory: " + homeDir);

------------------------------------------------------------
8. Trường hợp không phải SFTP

Nếu bạn thấy channel.getHome() trong code khác:
- Có thể đó là custom class
- Có thể là wrapper class
- Có thể là FTP library

Lúc này bạn phải:
Ctrl + Click vào channel
Xem class definition
Xem method getHome() được implement như thế nào

------------------------------------------------------------
9. Những lỗi thường gặp

1) Chưa connect channel mà gọi getHome()

Nếu chưa:
channel.connect();

thì có thể bị exception:
- SftpException
- IllegalStateException

2) Server không hỗ trợ trả home directory
Trường hợp hiếm.

------------------------------------------------------------
10. Tóm tắt cực ngắn

channel.getHome():

- Là method phổ biến trong ChannelSftp (JSch)
- Trả về thư mục home của user trên server
- Không thay đổi khi cd
- Khác với pwd()
- Dùng khi cần biết base directory của user

------------------------------------------------------------
KẾT LUẬN

channel.getHome() dùng để lấy đường dẫn thư mục HOME mặc định của user trên server (thường dùng trong SFTP).

Để hiểu chính xác 100%, bạn cần biết channel thuộc class nào.

--- channel.stat(...)

GIẢI THÍCH CHI TIẾT: channel.stat(...)

1. Tổng quan

channel.stat(...) là một method thường gặp trong SFTP, đặc biệt là khi dùng thư viện JSch (ChannelSftp).

Nó được dùng để:
→ Lấy thông tin metadata (thuộc tính) của một file hoặc thư mục trên server từ xa.

Nó tương đương với lệnh Linux:

stat <path>

------------------------------------------------------------
2. Ngữ cảnh phổ biến nhất (JSch - ChannelSftp)

Khai báo thường thấy:

ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
channel.connect();

Cú pháp:

SftpATTRS attrs = channel.stat(String path);

Trong đó:
- path: đường dẫn file hoặc thư mục trên server
- trả về: SftpATTRS (object chứa thông tin file)

------------------------------------------------------------
3. channel.stat() trả về cái gì?

Nó trả về object SftpATTRS.

SftpATTRS chứa:

- Kích thước file
- Quyền (permission)
- Owner
- Group
- Thời gian tạo / sửa
- Loại file (file hay directory)

------------------------------------------------------------
4. Ví dụ sử dụng

SftpATTRS attrs = channel.stat("/home/tuan/test.txt");

System.out.println("Size: " + attrs.getSize());
System.out.println("Permissions: " + attrs.getPermissions());
System.out.println("Is Directory: " + attrs.isDir());
System.out.println("Modified Time: " + attrs.getMTime());

------------------------------------------------------------
5. Cơ chế hoạt động bên trong

Khi bạn gọi:

channel.stat("/home/tuan/test.txt");

Thư viện sẽ:

1) Gửi SFTP request loại SSH_FXP_STAT tới server
2) Server tìm file đó
3) Server trả về thông tin file
4) Thư viện đóng gói vào SftpATTRS object
5) Trả về cho bạn

------------------------------------------------------------
6. Phân biệt stat() và lstat()

channel.stat(path)
→ Nếu path là symbolic link, nó sẽ theo link và trả về thông tin file thật.

channel.lstat(path)
→ Nếu path là symbolic link, nó trả về thông tin của chính link đó.

Ví dụ:

link.txt → trỏ đến real.txt

stat("link.txt")
→ trả thông tin của real.txt

lstat("link.txt")
→ trả thông tin của link.txt

------------------------------------------------------------
7. Các thuộc tính quan trọng của SftpATTRS

7.1 getSize()
Trả kích thước file (byte)

7.2 isDir()
Kiểm tra có phải directory không

7.3 isReg()
Kiểm tra có phải file thường không

7.4 getPermissions()
Trả số nguyên đại diện cho permission (ví dụ 755)

7.5 getMTime()
Thời gian sửa cuối (epoch time)

------------------------------------------------------------
8. Khi nào dùng channel.stat()?

Bạn dùng khi cần:

- Kiểm tra file có tồn tại không
- Kiểm tra file hay thư mục
- Lấy size trước khi download
- Kiểm tra quyền truy cập
- Lấy thời gian sửa đổi

------------------------------------------------------------
9. Cách kiểm tra file tồn tại

try {
    channel.stat("/home/tuan/test.txt");
    System.out.println("File tồn tại");
} catch (SftpException e) {
    System.out.println("File không tồn tại");
}

Nếu file không tồn tại:
→ channel.stat() sẽ throw SftpException

------------------------------------------------------------
10. Lỗi thường gặp

1) File không tồn tại
→ SftpException: No such file

2) Chưa connect channel
→ IllegalStateException hoặc SftpException

3) Không đủ quyền truy cập
→ Permission denied

------------------------------------------------------------
11. So sánh với ls()

channel.ls(path)
→ Liệt kê danh sách file trong thư mục

channel.stat(path)
→ Lấy thông tin chi tiết của 1 file cụ thể

------------------------------------------------------------
12. So sánh với Java local file

Java local:

File file = new File("test.txt");
file.length();
file.isDirectory();

SFTP remote:

SftpATTRS attrs = channel.stat("test.txt");
attrs.getSize();
attrs.isDir();

------------------------------------------------------------
13. Ví dụ thực tế đầy đủ

ChannelSftp channel = (ChannelSftp) session.openChannel("sftp");
channel.connect();

String path = "/home/tuan/report.pdf";

try {
    SftpATTRS attrs = channel.stat(path);

    if (attrs.isDir()) {
        System.out.println("Là thư mục");
    } else {
        System.out.println("Là file");
        System.out.println("Size: " + attrs.getSize());
    }

} catch (SftpException e) {
    System.out.println("Không tìm thấy file");
}

------------------------------------------------------------
14. Tóm tắt cực ngắn

channel.stat(path):

- Lấy thông tin metadata của file trên server
- Trả về SftpATTRS
- Throw exception nếu file không tồn tại
- Dùng để kiểm tra file tồn tại, loại file, kích thước, quyền

------------------------------------------------------------
KẾT LUẬN

channel.stat(...) là method SFTP dùng để truy vấn thông tin chi tiết của một file hoặc thư mục trên server từ xa.

Hiểu đơn giản:
Nó giống lệnh "stat" của Linux nhưng dùng qua SFTP trong Java.

--- ISTIO GW LÀ GÌ?

GIẢI THÍCH CHI TIẾT: ISTIO GW LÀ GÌ?

1. Tổng quan

ISTIO GW (Istio Gateway) là một tài nguyên (resource) trong Istio dùng để
định nghĩa cách traffic từ bên ngoài cluster đi vào hệ thống service bên trong.

Hiểu đơn giản:

Istio Gateway = Cổng vào (Ingress) của hệ thống service mesh.

Nó là nơi:
- Nhận request từ internet
- Lắng nghe port (80, 443...)
- Xử lý TLS/HTTPS
- Chuyển tiếp request vào các service nội bộ

------------------------------------------------------------
2. ISTIO là gì trước đã?

Istio là một service mesh chạy trên Kubernetes.

Service mesh giúp:
- Quản lý traffic giữa các service
- Bảo mật (mTLS)
- Quan sát (observability)
- Retry, circuit breaker
- Routing nâng cao

Istio không thay thế Kubernetes.
Nó chạy phía trên Kubernetes.

------------------------------------------------------------
3. Gateway trong Istio khác gì Kubernetes Ingress?

Kubernetes Ingress:
- Là resource mặc định của K8s
- Phụ thuộc vào ingress controller

Istio Gateway:
- Là resource riêng của Istio
- Kết hợp với Envoy proxy
- Routing mạnh hơn
- Hỗ trợ canary, A/B test
- Hỗ trợ mTLS nội bộ

------------------------------------------------------------
4. ISTIO Gateway hoạt động như thế nào?

Luồng xử lý:

Internet
   ↓
Load Balancer (Cloud)
   ↓
Istio Ingress Gateway Pod (Envoy proxy)
   ↓
VirtualService
   ↓
Service trong Kubernetes
   ↓
Pod backend

Gateway chỉ định:
- Port nào được mở
- Giao thức gì (HTTP, HTTPS, TCP)
- Host nào được chấp nhận

Routing chi tiết nằm ở VirtualService.

------------------------------------------------------------
5. Cấu trúc cơ bản của Istio Gateway

Ví dụ YAML:

apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: my-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "example.com"

Giải thích:

selector:
- Chọn ingressgateway pod của Istio

servers:
- Định nghĩa port lắng nghe
- protocol (HTTP, HTTPS, TLS...)
- host được phép truy cập

------------------------------------------------------------
6. Gateway KHÔNG routing trực tiếp

Rất quan trọng:

Gateway chỉ mở cửa.
VirtualService mới là thứ quyết định route đi đâu.

Ví dụ:

Gateway:
- Mở port 80
- Cho phép host example.com

VirtualService:
- Nếu path = /api → service A
- Nếu path = /web → service B

------------------------------------------------------------
7. Ví dụ đầy đủ Gateway + VirtualService

Gateway:

kind: Gateway
spec:
  servers:
  - port:
      number: 80
      protocol: HTTP
    hosts:
    - "example.com"

VirtualService:

kind: VirtualService
spec:
  hosts:
  - "example.com"
  gateways:
  - my-gateway
  http:
  - match:
    - uri:
        prefix: "/api"
    route:
    - destination:
        host: api-service

------------------------------------------------------------
8. HTTPS trong Istio Gateway

Gateway có thể cấu hình TLS:

- SIMPLE (terminate TLS tại gateway)
- PASSTHROUGH
- MUTUAL

Ví dụ:

servers:
- port:
    number: 443
    protocol: HTTPS
  tls:
    mode: SIMPLE
    credentialName: my-cert
  hosts:
  - "example.com"

Istio sẽ terminate HTTPS tại ingressgateway.

------------------------------------------------------------
9. ISTIO Ingress Gateway là gì?

Istio Ingress Gateway là:
- Một pod chạy Envoy proxy
- Nhận traffic từ ngoài vào

Gateway resource chỉ là cấu hình.
Ingress Gateway pod mới là thành phần xử lý thật.

------------------------------------------------------------
10. Các loại Gateway trong Istio

1) Ingress Gateway
- Traffic từ ngoài vào cluster

2) Egress Gateway
- Traffic từ trong cluster ra ngoài

------------------------------------------------------------
11. Khi nào cần dùng Istio Gateway?

Bạn cần dùng khi:

- Triển khai microservices
- Muốn routing nâng cao
- Canary release
- A/B testing
- JWT validation
- mTLS
- Rate limit
- Retry logic
- Traffic shifting

------------------------------------------------------------
12. So sánh nhanh

Kubernetes Ingress:
- Đơn giản
- Ít tính năng

Istio Gateway:
- Mạnh
- Routing phức tạp
- Bảo mật cao
- Quan sát tốt

------------------------------------------------------------
13. Tóm tắt cực ngắn

ISTIO GW (Istio Gateway):

- Là resource mở cổng cho traffic đi vào service mesh
- Định nghĩa port, protocol, host
- Kết hợp với VirtualService để routing
- Chạy cùng Envoy proxy
- Hỗ trợ HTTPS, TLS, mTLS

------------------------------------------------------------
14. Kết luận

Istio Gateway là thành phần kiểm soát traffic đầu vào của hệ thống service mesh.

Hiểu đơn giản:

Nếu cluster là một tòa nhà,
thì Istio Gateway là cổng bảo vệ ở ngoài.
VirtualService là người điều phối bên trong.
Service là các phòng làm việc.

--- DISCARD TẤT CẢ CÁC THAY ĐỔI TRÊN GIT BẰNG LỆNH

GIẢI THÍCH CHI TIẾT: DISCARD TẤT CẢ CÁC THAY ĐỔI TRÊN GIT BẰNG LỆNH

============================================================
I. VẤN ĐỀ CẦN GIẢI QUYẾT

Bạn đã chỉnh sửa file trong project Git và muốn:

- Hủy toàn bộ thay đổi
- Trả project về trạng thái như lần commit gần nhất
- Xóa cả file mới tạo
- Hoặc reset cả commit

Tùy mức độ discard (hủy) mà dùng lệnh khác nhau.

============================================================
II. CÁC TRẠNG THÁI TRONG GIT

Git có 3 vùng chính:

1) Working Directory (thư mục làm việc)
   - File bạn đang sửa

2) Staging Area (index)
   - File đã git add

3) Repository (commit)

Muốn discard đúng, bạn phải biết file đang ở vùng nào.

============================================================
III. TRƯỜNG HỢP 1: DISCARD FILE ĐÃ SỬA NHƯNG CHƯA ADD

Bạn chỉ sửa file nhưng chưa git add.

Lệnh:

git restore .

Giải thích:
- "." nghĩa là tất cả file
- Git sẽ đưa file về trạng thái commit gần nhất

Nếu dùng Git cũ:

git checkout -- .

============================================================
IV. TRƯỜNG HỢP 2: ĐÃ git add NHƯNG CHƯA COMMIT

Bạn đã add vào staging.

Bước 1: Bỏ staging

git restore --staged .

Bước 2: Bỏ thay đổi ở working directory

git restore .

Hoặc làm 1 lần:

git reset --hard

============================================================
V. TRƯỜNG HỢP 3: MUỐN HỦY TẤT CẢ VÀ VỀ COMMIT GẦN NHẤT

Lệnh mạnh nhất:

git reset --hard HEAD

Giải thích:

- reset: di chuyển HEAD
- --hard: reset cả working directory + staging
- HEAD: commit hiện tại

Kết quả:
- Mất toàn bộ thay đổi chưa commit
- Không thể undo (trừ khi dùng reflog)

============================================================
VI. TRƯỜNG HỢP 4: XÓA LUÔN FILE MỚI (UNTRACKED FILE)

git reset --hard không xóa file mới chưa add.

Muốn xóa cả file mới:

git clean -fd

Giải thích:
- -f = force
- -d = xóa cả folder

Xóa luôn file ignore:

git clean -fdx

============================================================
VII. LỆNH DISCARD TOÀN BỘ DỰ ÁN (MẠNH NHẤT)

git reset --hard HEAD
git clean -fd

Hai lệnh này:

- Xóa toàn bộ thay đổi
- Xóa file mới
- Trả project về sạch như commit gần nhất

============================================================
VIII. TRƯỜNG HỢP ĐÃ COMMIT NHƯNG CHƯA PUSH

Muốn quay lại commit trước:

git reset --hard HEAD~1

HEAD~1 = commit trước đó

HEAD~2 = lùi 2 commit

============================================================
IX. TRƯỜNG HỢP ĐÃ PUSH LÊN REMOTE

CẢNH BÁO: CỰC KỲ NGUY HIỂM

git reset --hard HEAD~1
git push --force

Có thể gây lỗi cho team.

============================================================
X. TÓM TẮT NHANH

1) Hủy file chưa add:
   git restore .

2) Hủy cả add:
   git reset --hard

3) Hủy và xóa file mới:
   git reset --hard
   git clean -fd

4) Lùi 1 commit:
   git reset --hard HEAD~1

============================================================
XI. KẾT LUẬN

Nếu mục tiêu của bạn là:

"Discard tất cả thay đổi chưa commit và đưa project về sạch"

→ Dùng:

git reset --hard
git clean -fd

Đây là cách mạnh và triệt để nhất.

--- CÁCH THIẾT LẬP TÀI KHOẢN TRÊN TORTOISEGIT

GIẢI THÍCH CHI TIẾT: CÁCH THIẾT LẬP TÀI KHOẢN TRÊN TORTOISEGIT

============================================================
I. TỔNG QUAN

TortoiseGit là một Git client chạy trên Windows,
tích hợp trực tiếp vào Windows Explorer (chuột phải).

Quan trọng:

TortoiseGit KHÔNG có tài khoản riêng.
Nó sử dụng:
- Git config (user.name, user.email)
- SSH key hoặc HTTPS credential
để xác thực với Git server (GitHub, GitLab, Bitbucket...)

Vì vậy "thiết lập tài khoản" gồm 2 phần:

1) Cấu hình user name và email
2) Cấu hình xác thực với remote (SSH hoặc HTTPS)

============================================================
II. CẤU HÌNH USER NAME VÀ EMAIL (BẮT BUỘC)

Đây là thông tin sẽ hiển thị trong commit.

Cách làm:

Bước 1:
Chuột phải Desktop hoặc thư mục bất kỳ
→ TortoiseGit
→ Settings

Bước 2:
Vào mục:
Git → Config

Bước 3:
Tại phần User Info:

- User Name: nhập tên của bạn
- Email: nhập email dùng cho Git

Ví dụ:
User Name: Nguyen Van A
Email: nguyenvana@gmail.com

Bước 4:
Chọn phạm vi cấu hình:

- Global (áp dụng cho tất cả project)
- Local (chỉ project hiện tại)

Khuyên dùng:
→ Global

Bước 5:
Nhấn OK

============================================================
III. KIỂM TRA ĐÃ CẤU HÌNH CHƯA

Mở Git Bash hoặc TortoiseGit Settings → Config

Kiểm tra:

git config --global user.name
git config --global user.email

============================================================
IV. CẤU HÌNH KẾT NỐI VỚI GITHUB / GITLAB

Có 2 cách phổ biến:

1) HTTPS (dùng username + token)
2) SSH (dùng SSH key)

============================================================
V. CÁCH 1: DÙNG HTTPS (ĐƠN GIẢN)

Ví dụ clone repo:

https://github.com/username/project.git

Khi push/pull lần đầu:
TortoiseGit sẽ hỏi:
- Username
- Password

LƯU Ý:
GitHub không còn dùng password thường.
Phải dùng Personal Access Token (PAT).

Cách tạo PAT trên GitHub:

1) Vào GitHub
2) Settings
3) Developer Settings
4) Personal Access Tokens
5) Generate new token
6) Copy token

Khi TortoiseGit hỏi password:
→ Dán token vào

Có thể tick:
"Save credential"

============================================================
VI. CÁCH 2: DÙNG SSH (CHUYÊN NGHIỆP HƠN)

Bước 1: Tạo SSH key

Chuột phải Desktop
→ TortoiseGit
→ Settings
→ Network

Nhấn:
"Generate"

Hoặc mở:
PuTTYgen (đi kèm TortoiseGit)

Chọn:
- RSA
- 4096 bits

Nhấn Generate
Di chuột để tạo key

Bước 2: Lưu key

- Save private key (.ppk)
- Copy public key

Bước 3: Thêm public key vào GitHub

GitHub:
Settings
→ SSH and GPG keys
→ New SSH key
→ Dán public key vào

Bước 4: Cấu hình TortoiseGit dùng private key

TortoiseGit → Settings → Network

SSH client:
Chọn đường dẫn tới:
TortoiseGitPlink.exe

Sau đó cấu hình repository dùng SSH:

git@github.com:username/project.git

============================================================
VII. KIỂM TRA KẾT NỐI SSH

Mở Git Bash:

ssh -T git@github.com

Nếu thành công:
Sẽ thấy thông báo xác thực thành công.

============================================================
VIII. THIẾT LẬP REMOTE TRONG TortoiseGit

Chuột phải thư mục project
→ TortoiseGit
→ Settings
→ Git
→ Remote

Thêm:

Name: origin
URL:
- HTTPS: https://github.com/username/project.git
- SSH: git@github.com:username/project.git

============================================================
IX. CÁC LỖI THƯỜNG GẶP

1) Permission denied (publickey)
→ SSH key chưa đúng
→ Chưa thêm vào GitHub

2) Authentication failed
→ Sai token
→ Token hết hạn

3) Author unknown
→ Chưa cấu hình user.name / user.email

============================================================
X. TÓM TẮT NGẮN GỌN

Thiết lập tài khoản TortoiseGit gồm:

1) Cấu hình:
   user.name
   user.email

2) Chọn cách xác thực:
   - HTTPS + token
   hoặc
   - SSH key

3) Cấu hình remote URL

============================================================
XI. KẾT LUẬN

TortoiseGit không có tài khoản riêng.

Nó chỉ:
- Ghi nhận tên và email để commit
- Dùng SSH hoặc HTTPS để xác thực với Git server

Muốn dùng được:
Bắt buộc phải cấu hình user info
và cấu hình xác thực remote đúng cách.

--- Click PuTTY Key -> Generate key -> Save private key

GIẢI THÍCH CHI TIẾT: Click PuTTY Key -> Generate key -> Save private key

============================================================
I. TỔNG QUAN

“PuTTY Key” ở đây thường ám chỉ công cụ PuTTYgen
(PuTTY Key Generator) – phần mềm dùng để tạo SSH key.

SSH key được dùng để:
- Xác thực khi kết nối SSH
- Kết nối Git (GitHub, GitLab) bằng SSH
- Đăng nhập server mà không cần nhập mật khẩu

Quy trình cơ bản:

1) Mở PuTTYgen
2) Click Generate
3) Save private key

Ba bước này tạo ra một cặp khóa:

- Public key (khóa công khai)
- Private key (khóa bí mật)

============================================================
II. SSH KEY LÀ GÌ?

SSH key là cơ chế xác thực dựa trên mật mã bất đối xứng.

Có 2 phần:

1) Public key
   - Được upload lên server (GitHub, Linux server…)
   - Có thể chia sẻ

2) Private key
   - Lưu trên máy bạn
   - Tuyệt đối không được chia sẻ

Khi kết nối:
Server kiểm tra private key của bạn có khớp với public key đã lưu không.

============================================================
III. BƯỚC 1: MỞ PuTTYgen

Có thể mở bằng cách:

- Start Menu → PuTTYgen
Hoặc
- TortoiseGit → Settings → Network → Generate

Khi mở PuTTYgen, bạn sẽ thấy giao diện gồm:

- Loại key (RSA, ECDSA, Ed25519...)
- Số bit
- Nút Generate
- Ô hiển thị public key
- Nút Save public key
- Nút Save private key

============================================================
IV. BƯỚC 2: CLICK "Generate key"

Khi bấm Generate:

PuTTYgen yêu cầu bạn di chuột ngẫu nhiên trong vùng trống.

Mục đích:
- Tạo entropy (độ ngẫu nhiên)
- Giúp key bảo mật cao hơn

Sau khi di chuột đủ:
PuTTYgen sẽ tạo xong key.

Kết quả:

1) Public key hiển thị ở ô trên cùng
2) Private key nằm trong bộ nhớ (chưa lưu ra file)

============================================================
V. LOẠI KEY NÊN CHỌN

Khuyến nghị:

- RSA 4096 bits (phổ biến và tương thích tốt)
hoặc
- Ed25519 (nhẹ hơn, bảo mật cao hơn, nhưng phải đảm bảo server hỗ trợ)

Trong PuTTYgen:
- Chọn RSA
- Number of bits: 4096

============================================================
VI. KEY PASSPHRASE (RẤT QUAN TRỌNG)

Trước khi Save private key,
bạn có thể nhập:

- Key passphrase
- Confirm passphrase

Passphrase là mật khẩu bảo vệ private key.

Nếu không đặt passphrase:
- Ai có file private key là có thể dùng ngay

Khuyến nghị:
→ NÊN đặt passphrase

============================================================
VII. BƯỚC 3: SAVE PRIVATE KEY

Click:

"Save private key"

PuTTYgen sẽ cảnh báo nếu bạn chưa đặt passphrase.

File được lưu dưới dạng:

*.ppk

Ví dụ:
id_rsa.ppk

Đây là file quan trọng nhất.

============================================================
VIII. FILE .PPK LÀ GÌ?

.ppk = PuTTY Private Key

Đây là định dạng riêng của PuTTY.

Lưu ý:
Git Bash mặc định dùng OpenSSH (.pem hoặc id_rsa)
TortoiseGit dùng .ppk thông qua TortoiseGitPlink.

============================================================
IX. SAVE PUBLIC KEY (KHÔNG BẮT BUỘC NHƯNG NÊN LƯU)

Bạn có 2 cách lấy public key:

1) Copy nội dung trong ô trên cùng
2) Click Save public key

Public key thường có dạng:

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC...

Bạn sẽ upload nội dung này lên:

- GitHub
- GitLab
- Server Linux (~/.ssh/authorized_keys)

============================================================
X. SAU KHI SAVE PRIVATE KEY DÙNG ĐỂ LÀM GÌ?

Private key (.ppk) sẽ được dùng khi:

1) SSH vào server
2) Push/pull Git qua SSH
3) Kết nối SFTP

Trong TortoiseGit:

Settings → Network
SSH client:
Chọn TortoiseGitPlink.exe

Khi kết nối lần đầu:
Nó sẽ yêu cầu chọn file .ppk

============================================================
XI. QUY TRÌNH ĐẦY ĐỦ THỰC TẾ

1) Mở PuTTYgen
2) Chọn RSA 4096
3) Click Generate
4) Di chuột tạo entropy
5) Nhập passphrase
6) Save private key (.ppk)
7) Copy public key
8) Upload public key lên GitHub (SSH Keys)
9) Dùng URL dạng SSH:

git@github.com:username/project.git

============================================================
XII. LỖI THƯỜNG GẶP

1) Permission denied (publickey)
→ Chưa upload public key
→ Sai private key
→ Sai URL (đang dùng HTTPS)

2) Wrong passphrase
→ Nhập sai mật khẩu bảo vệ key

3) File .ppk bị mất
→ Không thể kết nối nữa
→ Phải tạo lại key mới

============================================================
XIII. CẢNH BÁO BẢO MẬT

KHÔNG BAO GIỜ:

- Gửi file .ppk qua email
- Upload .ppk lên GitHub
- Commit private key vào repository

Private key phải giữ bí mật tuyệt đối.

============================================================
XIV. TÓM TẮT NGẮN GỌN

Click PuTTY Key → Generate key → Save private key
là quy trình:

- Tạo cặp SSH key
- Sinh public key và private key
- Lưu private key (.ppk) để xác thực SSH
- Upload public key lên server để cho phép truy cập

Private key = chìa khóa bí mật
Public key = ổ khóa đặt trên server

Ai có private key tương ứng
sẽ mở được server.

--- ServletFileUpload.isMultipartContent(request)

GIẢI THÍCH CHI TIẾT: ServletFileUpload.isMultipartContent(request)

============================================================
I. TỔNG QUAN

ServletFileUpload.isMultipartContent(request)
là một method trong thư viện Apache Commons FileUpload.

Mục đích:
→ Kiểm tra xem HTTP request hiện tại có phải là multipart/form-data hay không.

Hiểu đơn giản:
Nó dùng để xác định request có chứa upload file hay không.

============================================================
II. THƯ VIỆN LIÊN QUAN

Class này thuộc thư viện:

Apache Commons FileUpload

Package thường thấy:
org.apache.commons.fileupload.servlet.ServletFileUpload

Dùng trong ứng dụng Java Servlet để xử lý upload file.

============================================================
III. MULTIPART/FORM-DATA LÀ GÌ?

Khi bạn upload file từ HTML form:

<form method="post" enctype="multipart/form-data">
    <input type="file" name="file">
</form>

Trình duyệt sẽ gửi request với:

Content-Type: multipart/form-data; boundary=----

Multipart nghĩa là:
- Dữ liệu được chia thành nhiều phần (part)
- Mỗi part có header riêng
- Có thể chứa file hoặc field thường

============================================================
IV. VẤN ĐỀ NẾU KHÔNG DÙNG MULTIPART

Nếu form không có:

enctype="multipart/form-data"

Thì:
- File sẽ không được gửi đúng cách
- request.getParameter() không đọc được file
- Server không xử lý được upload

============================================================
V. CÁCH HOẠT ĐỘNG CỦA isMultipartContent()

Cú pháp:

boolean isMultipart = ServletFileUpload.isMultipartContent(request);

Method này kiểm tra:

1) HTTP method có phải POST không
2) Header "Content-Type" có bắt đầu bằng "multipart/" không

Nếu đúng:
→ Trả về true

Nếu không:
→ Trả về false

============================================================
VI. BÊN TRONG NÓ KIỂM TRA GÌ?

Nó sẽ:

1) request.getMethod()
   Nếu không phải POST → return false

2) request.getContentType()
   Nếu null → false
   Nếu không chứa "multipart/" → false

3) Nếu chứa "multipart/" → true

============================================================
VII. VÍ DỤ THỰC TẾ

protected void doPost(HttpServletRequest request,
                      HttpServletResponse response)
        throws ServletException, IOException {

    if (!ServletFileUpload.isMultipartContent(request)) {
        response.getWriter().println("Không phải multipart request");
        return;
    }

    // Nếu là multipart thì xử lý upload
}

============================================================
VIII. TẠI SAO PHẢI KIỂM TRA TRƯỚC?

Nếu bạn không kiểm tra mà gọi parseRequest():

upload.parseRequest(request);

Trong khi request không phải multipart:
→ Sẽ bị exception
→ Gây lỗi runtime

Vì vậy isMultipartContent() là bước kiểm tra an toàn.

============================================================
IX. SAU KHI TRUE THÌ LÀM GÌ?

Sau khi xác nhận là multipart:

DiskFileItemFactory factory = new DiskFileItemFactory();
ServletFileUpload upload = new ServletFileUpload(factory);

List<FileItem> items = upload.parseRequest(request);

Sau đó:
- Lặp qua items
- Kiểm tra item.isFormField()
- Hoặc xử lý file

============================================================
X. PHÂN BIỆT PARAMETER BÌNH THƯỜNG VÀ MULTIPART

Request thường:
application/x-www-form-urlencoded

→ request.getParameter() hoạt động

Multipart request:
multipart/form-data

→ request.getParameter() không hoạt động đúng
→ Phải dùng FileUpload parseRequest()

============================================================
XI. LỖI THƯỜNG GẶP

1) Form thiếu enctype="multipart/form-data"
→ isMultipartContent() trả false

2) Gửi bằng GET thay vì POST
→ Trả false

3) Content-Type sai
→ Trả false

============================================================
XII. SO SÁNH VỚI Servlet 3.0+

Từ Servlet 3.0 trở lên:

Có annotation:

@MultipartConfig

Và có thể dùng:

request.getParts();

Lúc này:
Không cần Apache Commons FileUpload nữa.

============================================================
XIII. TÓM TẮT NGẮN GỌN

ServletFileUpload.isMultipartContent(request):

- Kiểm tra request có phải multipart/form-data không
- Dùng trước khi parseRequest()
- Trả về true nếu là upload request
- Trả về false nếu là request thường

============================================================
XIV. KẾT LUẬN

Đây là method dùng để:

"Xác định request có chứa upload file hay không."

Nó giúp tránh lỗi khi xử lý file upload trong Java Servlet.

--- GIẢI THÍCH CHI TIẾT VỀ OFS VÀ GỬI OFS BẰNG QUEUE TRONG LẬP TRÌNH WEB

GIẢI THÍCH CHI TIẾT VỀ OFS VÀ GỬI OFS BẰNG QUEUE TRONG LẬP TRÌNH WEB

I. OFS LÀ GÌ?

1. OFS là viết tắt của gì?

OFS là viết tắt của: Open Financial Services.

Trong thực tế, khi làm việc với hệ thống ngân hàng lõi (Core Banking) như T24 (Temenos Transact), OFS được hiểu là:

OFS = Chuỗi lệnh (message) theo định dạng chuẩn dùng để giao tiếp với hệ thống Core Banking.

Nó là một dạng message text (chuỗi ký tự) dùng để:
- Tạo giao dịch
- Sửa giao dịch
- Truy vấn dữ liệu
- Xử lý nghiệp vụ tài chính

OFS không phải là một class Java, không phải API HTTP, mà là một định dạng message đặc thù của hệ thống ngân hàng (thường là T24).

------------------------------------------------------------

2. OFS hoạt động như thế nào?

Trong mô hình tích hợp:

Hệ thống Web / Middleware  --->  Core Banking (ví dụ T24)

Web không truy cập trực tiếp database của Core Banking.
Thay vào đó:

Web tạo một chuỗi OFS
→ gửi vào Core Banking
→ Core Banking parse OFS
→ xử lý nghiệp vụ
→ trả kết quả về

Ví dụ đơn giản:

OFS message có thể có dạng như:

APPLICATION,FUNCTION,USER,PASSWORD,FIELD1=VALUE1,FIELD2=VALUE2,...

Ví dụ:

FUNDS.TRANSFER,INPUT,USER1/123456,,
DEBIT.ACCT.NO=123456,
CREDIT.ACCT.NO=654321,
AMOUNT=100000

Ý nghĩa:
- Gọi application FUNDS.TRANSFER
- Thực hiện chức năng INPUT
- Truyền các field nghiệp vụ

------------------------------------------------------------

3. OFS trong lập trình web là gì?

Trong lập trình web (Java Spring, Servlet, v.v.), OFS thường xuất hiện khi:

- Web là front-end cho ngân hàng
- Web cần tạo giao dịch trong Core Banking

Luồng xử lý:

1. User nhập form trên web
2. Controller nhận request
3. Backend build chuỗi OFS
4. Gửi OFS sang Core Banking
5. Nhận response
6. Trả kết quả về cho user

Như vậy:

OFS là cầu nối giữa Web Application và Core Banking.

------------------------------------------------------------

II. GỬI OFS BẰNG QUEUE LÀ GÌ?

1. Queue là gì?

Queue (hàng đợi) là cơ chế giao tiếp bất đồng bộ (asynchronous communication).

Ví dụ phổ biến:
- JMS (Java Message Service)
- IBM MQ
- ActiveMQ
- RabbitMQ

Queue cho phép:
- Hệ thống A gửi message
- Hệ thống B nhận message sau đó
- Không cần xử lý ngay lập tức

------------------------------------------------------------

2. Gửi OFS trực tiếp vs gửi OFS qua queue

Cách 1: Gửi trực tiếp (synchronous)

Web → gọi API / socket → Core Banking
→ đợi response
→ trả kết quả cho user

Nhược điểm:
- Web phải chờ
- Nếu Core Banking chậm → web bị treo
- Dễ timeout

------------------------------------------------------------

Cách 2: Gửi OFS qua queue (asynchronous)

Web → đưa OFS vào queue
→ trả về "đã nhận yêu cầu"
→ một hệ thống khác lấy OFS từ queue
→ gửi sang Core Banking
→ xử lý kết quả

------------------------------------------------------------

3. Gửi OFS bằng queue mang ý nghĩa gì?

Nó mang các ý nghĩa quan trọng sau:

A. Xử lý bất đồng bộ (Asynchronous Processing)

Web không cần chờ Core Banking xử lý xong.
Điều này giúp:

- Tăng tốc độ phản hồi cho user
- Tránh timeout
- Tăng trải nghiệm người dùng

------------------------------------------------------------

B. Giảm coupling (giảm phụ thuộc trực tiếp)

Web không cần biết:
- Core Banking đang hoạt động hay không
- Có đang bảo trì không

Web chỉ cần đẩy OFS vào queue.

Queue đóng vai trò trung gian.

------------------------------------------------------------

C. Tăng độ ổn định hệ thống

Nếu Core Banking tạm thời down:

OFS vẫn nằm trong queue
Khi hệ thống lên lại → xử lý tiếp

Tránh mất giao dịch.

------------------------------------------------------------

D. Tăng khả năng mở rộng (Scalability)

Có thể có nhiều consumer đọc queue:

- Consumer 1 xử lý OFS loại A
- Consumer 2 xử lý OFS loại B

Giúp hệ thống chịu tải lớn.

------------------------------------------------------------

III. MÔ HÌNH KIẾN TRÚC KHI GỬI OFS QUA QUEUE

Mô hình thường thấy:

User
  ↓
Web Application
  ↓
Build OFS
  ↓
Push vào Message Queue
  ↓
Middleware Service (Consumer)
  ↓
Gửi OFS vào Core Banking
  ↓
Nhận Response
  ↓
Cập nhật Database / Gửi callback

------------------------------------------------------------

IV. SO SÁNH SỬ DỤNG QUEUE TRONG THỰC TẾ NGÂN HÀNG

Trong ngân hàng, giao dịch tài chính rất quan trọng:

Nếu gửi trực tiếp:
- Mạng chậm → lỗi
- Core Banking bận → timeout
- Web treo

Nếu gửi qua queue:
- Hệ thống ổn định hơn
- Có thể retry
- Có log message
- Dễ audit

------------------------------------------------------------

V. TÓM TẮT NGẮN GỌN

1. OFS là gì?

OFS là một chuỗi message chuẩn dùng để giao tiếp với Core Banking (thường là T24).

2. Gửi OFS bằng queue là gì?

Là việc:
- Không gửi trực tiếp sang Core Banking
- Mà đưa OFS vào hàng đợi (queue)
- Một service khác sẽ lấy ra và xử lý

3. Ý nghĩa của việc gửi OFS bằng queue:

- Xử lý bất đồng bộ
- Tăng hiệu năng
- Giảm phụ thuộc
- Tăng độ ổn định
- Hỗ trợ retry
- Hỗ trợ logging và audit

------------------------------------------------------------

VI. KẾT LUẬN

Trong lập trình web tích hợp ngân hàng:

OFS = Ngôn ngữ giao tiếp với Core Banking
Queue = Cơ chế truyền OFS an toàn và ổn định

Việc "gửi OFS bằng queue" là một thiết kế kiến trúc quan trọng giúp hệ thống ngân hàng:

- Chịu tải cao
- Không mất giao dịch
- Hoạt động ổn định
- Dễ mở rộng và bảo trì

Đây là một mô hình rất phổ biến trong hệ thống tài chính, ngân hàng và các hệ thống xử lý giao dịch lớn.

--- Core banking

GIẢI THÍCH CHI TIẾT VỀ CORE BANKING

I. CORE BANKING LÀ GÌ?

1. Định nghĩa

Core Banking (viết tắt của: Core Banking System) là hệ thống phần mềm trung tâm của ngân hàng, dùng để quản lý toàn bộ dữ liệu và nghiệp vụ chính của ngân hàng.

"Core" = lõi, trung tâm
"Banking" = ngân hàng

=> Core Banking = Hệ thống lõi của ngân hàng.

Đây là hệ thống quan trọng nhất, nơi:
- Lưu trữ dữ liệu tài khoản khách hàng
- Xử lý giao dịch tiền tệ
- Quản lý tiền gửi, tiền vay
- Tính lãi
- Quản lý số dư
- Xử lý thanh toán

Nếu Core Banking ngừng hoạt động, toàn bộ ngân hàng gần như ngừng hoạt động.

------------------------------------------------------------

II. CORE BANKING QUẢN LÝ NHỮNG GÌ?

1. Quản lý khách hàng (Customer Information)

- Thông tin cá nhân
- CMND/CCCD
- Địa chỉ
- Số điện thoại
- Hồ sơ tín dụng
- Lịch sử giao dịch

2. Quản lý tài khoản (Account Management)

- Tài khoản thanh toán
- Tài khoản tiết kiệm
- Tài khoản tiền gửi
- Tài khoản vay

Mỗi tài khoản có:
- Số tài khoản
- Số dư
- Trạng thái
- Loại tiền tệ

3. Xử lý giao dịch (Transaction Processing)

Core Banking xử lý:

- Chuyển khoản nội bộ
- Chuyển khoản liên ngân hàng
- Rút tiền
- Gửi tiền
- Thanh toán hóa đơn
- Ghi nợ / Ghi có

Mỗi giao dịch phải đảm bảo:

- Chính xác
- Không trùng lặp
- Không mất tiền
- Có log để truy vết

4. Quản lý tiền gửi (Deposits)

- Tiền gửi có kỳ hạn
- Tiền gửi không kỳ hạn
- Tính lãi định kỳ
- Đáo hạn tự động

5. Quản lý khoản vay (Loans)

- Cho vay cá nhân
- Cho vay doanh nghiệp
- Tính lãi suất
- Lập lịch trả nợ
- Theo dõi dư nợ

6. Tính lãi và phí

- Lãi tiền gửi
- Lãi tiền vay
- Phí dịch vụ
- Phí chuyển khoản

------------------------------------------------------------

III. CORE BANKING HOẠT ĐỘNG NHƯ THẾ NÀO?

1. Mô hình hoạt động cơ bản

Khách hàng (ATM / Internet Banking / Mobile Banking / Quầy)
                ↓
        Hệ thống kênh giao dịch (Channel)
                ↓
          Middleware / API Layer
                ↓
             Core Banking
                ↓
             Database

Core Banking là nơi xử lý cuối cùng và cập nhật dữ liệu chính thức.

------------------------------------------------------------

2. Ví dụ một giao dịch chuyển tiền

Bước 1: Khách hàng nhập lệnh chuyển tiền trên Internet Banking
Bước 2: Hệ thống gửi yêu cầu về server
Bước 3: Middleware gửi yêu cầu vào Core Banking
Bước 4: Core Banking kiểm tra:

- Tài khoản có tồn tại không?
- Có đủ số dư không?
- Tài khoản có bị khóa không?

Bước 5: Nếu hợp lệ:

- Trừ tiền tài khoản A
- Cộng tiền tài khoản B
- Ghi log giao dịch
- Cập nhật database

Bước 6: Trả kết quả thành công

------------------------------------------------------------

IV. ĐẶC ĐIỂM QUAN TRỌNG CỦA CORE BANKING

1. Tính chính xác cực cao

Một sai sót nhỏ có thể gây:

- Mất tiền
- Sai lệch số dư
- Ảnh hưởng pháp lý

2. Tính nhất quán (Consistency)

Phải đảm bảo nguyên tắc ACID:

- Atomicity (hoặc thành công hết, hoặc rollback hết)
- Consistency
- Isolation
- Durability

3. Xử lý giao dịch theo thời gian thực (Real-time Processing)

Khi khách rút tiền ATM:
Số dư phải thay đổi ngay lập tức.

4. Bảo mật cực cao

- Phân quyền người dùng
- Mã hóa dữ liệu
- Kiểm soát truy cập
- Log audit đầy đủ

------------------------------------------------------------

V. VÍ DỤ CÁC HỆ THỐNG CORE BANKING PHỔ BIẾN

1. T24 (Temenos Transact)
Rất phổ biến tại các ngân hàng.

2. Finacle (Infosys)
Hệ thống core banking nổi tiếng của Ấn Độ.

3. Flexcube (Oracle)
Giải pháp core banking của Oracle.

4. Silverlake
Phổ biến tại khu vực châu Á.

------------------------------------------------------------

VI. CORE BANKING KHÁC GÌ INTERNET BANKING?

Core Banking:
- Là hệ thống lõi
- Xử lý nghiệp vụ
- Lưu dữ liệu chính thức

Internet Banking:
- Là giao diện cho khách hàng
- Chỉ là kênh giao tiếp
- Không xử lý nghiệp vụ lõi

Internet Banking phải gọi về Core Banking để thực hiện giao dịch.

------------------------------------------------------------

VII. CORE BANKING TRONG LẬP TRÌNH WEB

Trong lập trình web ngân hàng:

Web không xử lý tiền thật.
Web chỉ:

- Nhận input
- Kiểm tra sơ bộ
- Gửi request vào Core Banking
- Nhận response
- Hiển thị kết quả

Core Banking mới là nơi thực sự:

- Trừ tiền
- Cộng tiền
- Tính lãi
- Ghi sổ kế toán

------------------------------------------------------------

VIII. CORE BANKING THƯỜNG KHÔNG PHẢI LÀ WEB

Nhiều hệ thống core banking:

- Chạy trên server chuyên dụng
- Có thể viết bằng ngôn ngữ riêng
- Có cấu trúc đặc biệt
- Có giao tiếp thông qua message (ví dụ OFS)

Lập trình viên web thường không truy cập database core trực tiếp.
Mà phải gọi qua:

- API
- Message queue
- OFS message
- Web service

------------------------------------------------------------

IX. TẠI SAO CORE BANKING QUAN TRỌNG?

1. Là trái tim của ngân hàng
2. Lưu giữ toàn bộ tài sản dữ liệu
3. Đảm bảo mọi giao dịch tài chính hợp lệ
4. Là nền tảng cho mọi dịch vụ ngân hàng

Nếu core banking gặp lỗi:
- ATM không rút được tiền
- Không chuyển khoản được
- Không xem được số dư

------------------------------------------------------------

X. TÓM TẮT NGẮN GỌN

Core Banking là:

Hệ thống phần mềm lõi của ngân hàng dùng để quản lý tài khoản, xử lý giao dịch, tính lãi và lưu trữ dữ liệu chính thức.

Trong kiến trúc ngân hàng:

- Core Banking = xử lý nghiệp vụ tài chính
- Web/App/ATM = chỉ là kênh giao tiếp

Core Banking là hệ thống quan trọng nhất, yêu cầu độ chính xác, bảo mật và ổn định ở mức cao nhất.

--- FileItem item; item.isFormField() LÀ GÌ?

GIẢI THÍCH CHI TIẾT VỀ:

FileItem item;
item.isFormField() LÀ GÌ?

------------------------------------------------------------

I. BỐI CẢNH XUẤT HIỆN FileItem

Trong lập trình Java Web (Servlet), khi xử lý form upload file (multipart/form-data), chúng ta thường sử dụng thư viện Apache Commons FileUpload.

Khi request có enctype="multipart/form-data", ta không thể dùng request.getParameter() để lấy dữ liệu như bình thường.

Thay vào đó, ta phải:

1. Kiểm tra request có phải multipart không
2. Parse request
3. Nhận về danh sách các FileItem

Ví dụ:

List<FileItem> items = upload.parseRequest(request);

Mỗi FileItem đại diện cho một phần (part) trong form.

------------------------------------------------------------

II. FileItem LÀ GÌ?

FileItem là một đối tượng đại diện cho một phần dữ liệu trong request multipart.

Một form multipart có thể chứa:

- Các input text
- Các input hidden
- Các select
- Các file upload

Ví dụ form:

<form method="post" enctype="multipart/form-data">
    <input type="text" name="username">
    <input type="file" name="avatar">
</form>

Sau khi parseRequest, ta sẽ có 2 FileItem:

1. FileItem cho username
2. FileItem cho avatar

------------------------------------------------------------

III. item.isFormField() LÀ GÌ?

Cú pháp:

boolean result = item.isFormField();

Ý nghĩa:

item.isFormField() dùng để kiểm tra xem FileItem hiện tại có phải là một field thông thường (input text, hidden, select...) hay là một file upload.

Trả về:

true  → Nếu là field thông thường
false → Nếu là file upload

------------------------------------------------------------

IV. PHÂN BIỆT FORM FIELD VÀ FILE FIELD

1. Form Field (trả về true)

Là các input không phải file, ví dụ:

<input type="text">
<input type="hidden">
<select>
<textarea>

Khi item.isFormField() == true:

Ta có thể lấy giá trị bằng:

item.getString();

Ví dụ:

if (item.isFormField()) {
    String name = item.getFieldName();
    String value = item.getString();
}

------------------------------------------------------------

2. File Field (trả về false)

Là input type="file"

<input type="file" name="avatar">

Khi item.isFormField() == false:

Ta biết đây là file upload.

Ta có thể lấy:

- Tên file: item.getName()
- Dung lượng: item.getSize()
- InputStream: item.getInputStream()
- Ghi file xuống disk: item.write(file)

Ví dụ:

if (!item.isFormField()) {
    String fileName = item.getName();
    InputStream input = item.getInputStream();
}

------------------------------------------------------------

V. LUỒNG XỬ LÝ CHUẨN KHI PARSE MULTIPART

Ví dụ đầy đủ:

List<FileItem> items = upload.parseRequest(request);

for (FileItem item : items) {

    if (item.isFormField()) {
        // Đây là input text
        String fieldName = item.getFieldName();
        String value = item.getString("UTF-8");
    } else {
        // Đây là file upload
        String fileName = item.getName();
        long size = item.getSize();
    }
}

Ý nghĩa:

isFormField() giúp ta phân loại từng phần trong request.

------------------------------------------------------------

VI. TẠI SAO PHẢI DÙNG isFormField()?

Vì trong multipart/form-data:

Tất cả dữ liệu (text + file) đều được đóng gói chung.

Server không tự động tách như request.getParameter().

Khi parse, ta chỉ nhận danh sách FileItem.
Ta phải tự kiểm tra:

- Cái nào là text
- Cái nào là file

Nếu không kiểm tra:

Ta có thể xử lý sai kiểu dữ liệu.

------------------------------------------------------------

VII. SO SÁNH VỚI request.getParameter()

Trong form bình thường:

<form method="post">
    <input type="text" name="username">
</form>

Ta dùng:

request.getParameter("username");

Nhưng khi có:

enctype="multipart/form-data"

request.getParameter() sẽ trả về null.

Lúc này bắt buộc dùng FileItem và isFormField().

------------------------------------------------------------

VIII. KẾT LUẬN NGẮN GỌN

FileItem item;

item.isFormField() là phương thức dùng để:

Phân biệt giữa field thông thường (text input) và file upload trong request multipart.

- Trả về true  → nếu là input text
- Trả về false → nếu là file upload

Nó là bước bắt buộc khi xử lý form upload file bằng Apache Commons FileUpload trong Java Servlet.

Không có isFormField(), ta không thể biết FileItem hiện tại là dữ liệu text hay file.

--- BufferedReader ĐỌC FILE EXCEL ĐƯỢC KHÔNG?

GIẢI THÍCH CHI TIẾT:

BufferedReader ĐỌC FILE EXCEL ĐƯỢC KHÔNG?

------------------------------------------------------------

I. CÂU TRẢ LỜI NGẮN GỌN

BufferedReader KHÔNG thể đọc đúng file Excel (.xls, .xlsx).

Lý do:
Vì file Excel là file nhị phân (binary file), còn BufferedReader chỉ dùng để đọc file văn bản (text file).

------------------------------------------------------------

II. BufferedReader LÀ GÌ?

BufferedReader là lớp trong Java dùng để đọc dữ liệu dạng text theo từng dòng.

Ví dụ:

BufferedReader br = new BufferedReader(
        new FileReader("data.txt")
);

String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

BufferedReader hoạt động với:

- .txt
- .csv (nếu là text thuần)
- .xml
- .json
- .log
- Bất kỳ file nào lưu dưới dạng text

------------------------------------------------------------

III. FILE EXCEL LÀ LOẠI FILE GÌ?

1. File .xls (Excel 2003 trở về trước)

- Là file nhị phân (binary format)
- Không phải text
- Không thể đọc bằng BufferedReader

2. File .xlsx (Excel 2007 trở đi)

- Thực chất là file ZIP
- Bên trong chứa nhiều file XML
- Vẫn không phải file text thuần
- Không thể đọc trực tiếp bằng BufferedReader

------------------------------------------------------------

IV. TẠI SAO BufferedReader KHÔNG ĐỌC ĐƯỢC FILE EXCEL?

BufferedReader đọc từng ký tự dựa trên encoding (UTF-8, UTF-16...).

Nhưng file Excel:

- Lưu dưới dạng nhị phân
- Không phải ký tự text
- Có cấu trúc phức tạp

Nếu bạn thử:

BufferedReader br = new BufferedReader(
        new FileReader("file.xlsx")
);

Bạn sẽ thấy:

- Ký tự rác
- Ký tự lạ
- Không có cấu trúc dòng hợp lệ

Vì Java đang cố gắng đọc binary như text → sai định dạng.

------------------------------------------------------------

V. TRƯỜNG HỢP ĐẶC BIỆT: FILE CSV

Nếu file được lưu dạng:

Save As → CSV (Comma Separated Values)

Ví dụ:

name,age,city
Tuan,25,Hanoi
Lan,23,HCM

Thì đây là file text thuần.

Lúc này:

BufferedReader đọc được bình thường.

------------------------------------------------------------

VI. CÁCH ĐỌC FILE EXCEL ĐÚNG CÁCH

Để đọc file Excel (.xls, .xlsx) trong Java, ta dùng thư viện chuyên dụng.

Phổ biến nhất: Apache POI

Ví dụ đọc .xlsx:

Workbook workbook = new XSSFWorkbook(new FileInputStream("file.xlsx"));
Sheet sheet = workbook.getSheetAt(0);

for (Row row : sheet) {
    for (Cell cell : row) {
        System.out.println(cell.toString());
    }
}

Apache POI hiểu cấu trúc Excel và đọc đúng dữ liệu.

------------------------------------------------------------

VII. SO SÁNH TỔNG HỢP

1. BufferedReader

- Dùng cho file text
- Đọc từng dòng
- Không hiểu cấu trúc Excel
- Không đọc được .xls, .xlsx

2. Apache POI

- Dùng cho Excel
- Hiểu sheet, row, cell
- Đọc được .xls và .xlsx
- Hỗ trợ ghi file Excel

------------------------------------------------------------

VIII. VÌ SAO NHIỀU NGƯỜI NHẦM LẪN?

Vì khi mở file Excel, ta thấy giống bảng dữ liệu.

Nhưng:

File Excel không phải là text file.
Nó có cấu trúc nội bộ phức tạp.

Chỉ khi lưu dưới dạng CSV thì mới có thể dùng BufferedReader.

------------------------------------------------------------

IX. KẾT LUẬN

BufferedReader không đọc được file Excel (.xls, .xlsx).

Lý do:
Vì Excel là file nhị phân, không phải text.

Nếu muốn đọc Excel:
Phải dùng thư viện như Apache POI.

Nếu file được lưu dưới dạng CSV:
BufferedReader đọc được bình thường.

------------------------------------------------------------

TÓM LẠI:

BufferedReader → Chỉ dùng cho file text.
Excel (.xls, .xlsx) → Phải dùng thư viện chuyên dụng.
CSV → Có thể dùng BufferedReader.

--- WORKFLOW VÀ DIAGRAM KHÁC GÌ NHAU?

GIẢI THÍCH CHI TIẾT:

WORKFLOW VÀ DIAGRAM KHÁC GÌ NHAU?

------------------------------------------------------------

I. ĐỊNH NGHĨA CƠ BẢN

1. Workflow là gì?

Workflow là luồng công việc (quy trình xử lý công việc).

Nó mô tả:

- Công việc được thực hiện theo thứ tự nào
- Ai thực hiện
- Điều kiện rẽ nhánh ra sao
- Khi nào kết thúc

Workflow tập trung vào:

CÁCH công việc được thực hiện trong thực tế.

Ví dụ:

Quy trình duyệt đơn nghỉ phép:

Bước 1: Nhân viên gửi đơn
Bước 2: Trưởng phòng duyệt
Bước 3: HR xác nhận
Bước 4: Hoàn tất

Đây chính là workflow.

------------------------------------------------------------

2. Diagram là gì?

Diagram là sơ đồ, hình vẽ mô tả một thứ gì đó.

Nó có thể là:

- Sơ đồ luồng
- Sơ đồ kiến trúc
- Sơ đồ lớp
- Sơ đồ trình tự
- Sơ đồ mạng
- Sơ đồ quy trình

Diagram là công cụ trực quan hóa (visual representation).

------------------------------------------------------------

II. SỰ KHÁC NHAU CỐT LÕI

1. Workflow là nội dung (logic, quy trình thực tế).

2. Diagram là cách thể hiện bằng hình ảnh.

Nói đơn giản:

Workflow = Quy trình
Diagram = Hình vẽ mô tả quy trình (hoặc mô tả thứ khác)

------------------------------------------------------------

III. VÍ DỤ ĐỂ HIỂU RÕ

Ví dụ 1:

Quy trình đăng ký tài khoản:

- Người dùng nhập thông tin
- Hệ thống kiểm tra hợp lệ
- Nếu hợp lệ → tạo tài khoản
- Nếu không hợp lệ → báo lỗi

Đây là workflow.

Nếu bạn vẽ nó bằng các hình tròn, mũi tên, hình thoi:

Start → Nhập thông tin → Kiểm tra → (Đúng?) → Tạo tài khoản → End

Thì đó là workflow diagram.

------------------------------------------------------------

IV. WORKFLOW CÓ THỂ KHÔNG CẦN DIAGRAM KHÔNG?

Có.

Workflow có thể chỉ được viết dưới dạng text:

1. Người dùng đăng nhập
2. Hệ thống xác thực
3. Nếu sai → báo lỗi
4. Nếu đúng → vào trang chủ

Đây vẫn là workflow dù không có hình vẽ.

------------------------------------------------------------

V. DIAGRAM KHÔNG CHỈ DÙNG CHO WORKFLOW

Diagram không chỉ mô tả workflow.

Ví dụ:

1. Class Diagram
Mô tả cấu trúc class trong hệ thống.

2. Sequence Diagram
Mô tả thứ tự gọi method.

3. Deployment Diagram
Mô tả server và hệ thống triển khai.

4. Network Diagram
Mô tả hệ thống mạng.

Những cái này không phải workflow, nhưng vẫn là diagram.

------------------------------------------------------------

VI. SO SÁNH CHI TIẾT

1. Về bản chất

Workflow:
- Là quy trình
- Là logic xử lý
- Là luồng công việc

Diagram:
- Là sơ đồ
- Là công cụ biểu diễn
- Không phải bản thân quy trình

------------------------------------------------------------

2. Về mục đích

Workflow:
- Tổ chức công việc
- Chuẩn hóa quy trình
- Tự động hóa xử lý

Diagram:
- Giúp dễ hiểu
- Trình bày cho người khác
- Tài liệu hóa hệ thống

------------------------------------------------------------

3. Về phạm vi

Workflow:
- Chỉ liên quan đến luồng xử lý công việc

Diagram:
- Có thể mô tả workflow
- Có thể mô tả kiến trúc
- Có thể mô tả cấu trúc dữ liệu
- Có thể mô tả tương tác hệ thống

------------------------------------------------------------

VII. TRONG LẬP TRÌNH WEB

Ví dụ hệ thống duyệt giao dịch:

Workflow:

1. User gửi yêu cầu
2. Hệ thống kiểm tra số dư
3. Nếu đủ tiền → gửi sang Core
4. Nếu không đủ → trả lỗi

Đó là workflow.

Nếu bạn dùng:

- Flowchart
- BPMN

--- org.hibernate.lob.BlobImpl LÀ GÌ?

GIẢI THÍCH CHI TIẾT:

org.hibernate.lob.BlobImpl LÀ GÌ?

------------------------------------------------------------

I. TỔNG QUAN

org.hibernate.lob.BlobImpl là một class trong Hibernate dùng để đại diện cho dữ liệu kiểu BLOB (Binary Large Object).

BLOB = Binary Large Object
→ Dữ liệu nhị phân dung lượng lớn.

Ví dụ dữ liệu BLOB:

- File ảnh
- File PDF
- File Word
- File Excel
- File nhị phân bất kỳ

BlobImpl là một implementation (cài đặt cụ thể) của interface java.sql.Blob trong Hibernate.

------------------------------------------------------------

II. BLOB LÀ GÌ TRONG DATABASE?

Trong database, BLOB là kiểu dữ liệu dùng để lưu dữ liệu nhị phân lớn.

Ví dụ trong MySQL:

- BLOB
- MEDIUMBLOB
- LONGBLOB

Trong Oracle:

- BLOB

BLOB không lưu text, mà lưu dữ liệu dạng byte[].

------------------------------------------------------------

III. VAI TRÒ CỦA BlobImpl TRONG HIBERNATE

Khi bạn dùng Hibernate để mapping entity với database:

@Entity
public class Document {

    @Lob
    private byte[] fileData;
}

Hoặc:

@Lob
private Blob fileData;

Hibernate cần một đối tượng đại diện cho kiểu Blob trong Java.

Lúc này:
Hibernate sẽ dùng org.hibernate.lob.BlobImpl để quản lý dữ liệu BLOB.

------------------------------------------------------------

IV. BlobImpl LÀ IMPLEMENTATION CỦA GÌ?

BlobImpl implements:

java.sql.Blob

Interface java.sql.Blob định nghĩa các phương thức như:

- getBinaryStream()
- getBytes()
- length()
- free()

BlobImpl cung cấp cách cài đặt cụ thể các phương thức này.

------------------------------------------------------------

V. CÁCH BlobImpl HOẠT ĐỘNG

1. Khi lưu dữ liệu

Ví dụ:

byte[] data = Files.readAllBytes(path);

Blob blob = new BlobImpl(data);

entity.setFile(blob);
session.save(entity);

Hibernate:

- Chuyển BlobImpl thành dữ liệu database
- Lưu vào cột BLOB

------------------------------------------------------------

2. Khi đọc dữ liệu

Khi load entity từ database:

Document doc = session.get(Document.class, id);

Blob blob = doc.getFile();

InputStream input = blob.getBinaryStream();

Hibernate:

- Đọc dữ liệu BLOB từ database
- Tạo đối tượng BlobImpl
- Gắn vào entity

------------------------------------------------------------

VI. TẠI SAO KHÔNG DÙNG TRỰC TIẾP byte[]?

Có 2 cách lưu dữ liệu nhị phân:

Cách 1: Dùng byte[]

@Lob
private byte[] data;

Cách 2: Dùng Blob

@Lob
private Blob data;

Khi dùng Blob:
Hibernate cần một implementation cụ thể → BlobImpl.

Blob cho phép:

- Streaming dữ liệu
- Không cần load toàn bộ vào RAM
- Phù hợp file lớn

byte[]:
- Load toàn bộ vào bộ nhớ
- Dễ gây OutOfMemory nếu file lớn

------------------------------------------------------------

VII. CÁC PHƯƠNG THỨC QUAN TRỌNG CỦA BlobImpl

1. length()

Trả về kích thước dữ liệu BLOB.

2. getBytes(long pos, int length)

Lấy một phần dữ liệu dưới dạng byte[].

3. getBinaryStream()

Trả về InputStream để đọc dữ liệu.

4. free()

Giải phóng tài nguyên.

------------------------------------------------------------

VIII. LƯU Ý QUAN TRỌNG

1. BlobImpl thường không được tạo thủ công trong code mới.

Trong các phiên bản Hibernate mới:
- BlobImpl có thể đã deprecated
- Hibernate có cơ chế LobCreator

Ví dụ:

Blob blob = session.getLobHelper().createBlob(data);

Đây là cách chuẩn hơn thay vì new BlobImpl(data).

------------------------------------------------------------

IX. KHI NÀO GẶP BlobImpl?

Bạn thường thấy BlobImpl khi:

- Debug entity có trường @Lob
- Log ra object kiểu Blob
- Xem stack trace liên quan đến BLOB
- Làm việc với file upload lưu trong database

Ví dụ khi debug:

fileData = org.hibernate.lob.BlobImpl@4a23fd

------------------------------------------------------------

X. TÓM TẮT NGẮN GỌN

org.hibernate.lob.BlobImpl là:

- Class của Hibernate
- Cài đặt interface java.sql.Blob
- Dùng để đại diện dữ liệu BLOB (nhị phân lớn)
- Được sử dụng khi lưu hoặc đọc file từ database bằng Hibernate

Nó đóng vai trò cầu nối giữa:

Dữ liệu nhị phân trong database
và
Đối tượng Java trong ứng dụng.

------------------------------------------------------------

KẾT LUẬN CUỐI CÙNG:

BlobImpl là implementation của java.sql.Blob trong Hibernate, dùng để quản lý dữ liệu BLOB khi làm việc với @Lob trong entity.

--- CÁCH LẤY NỘI DUNG FILE TỪ FORM TRONG FILE .ZUL (ZK FRAMEWORK)

GIẢI THÍCH CHI TIẾT:

CÁCH LẤY NỘI DUNG FILE TỪ FORM TRONG FILE .ZUL (ZK FRAMEWORK)

------------------------------------------------------------

I. .ZUL LÀ GÌ?

.zul là file giao diện của ZK Framework.

ZK là một framework Java dùng để xây dựng web application theo mô hình component-based.

File .zul giống như:
- JSP
- HTML
Nhưng được viết theo cấu trúc component của ZK.

------------------------------------------------------------

II. UPLOAD FILE TRONG ZK HOẠT ĐỘNG NHƯ THẾ NÀO?

Trong ZK, để upload file, ta dùng component:

<fileupload> hoặc <button upload="true">

ZK không xử lý theo kiểu truyền thống Servlet (multipart) mà xử lý event-based.

Khi user chọn file:

ZK sẽ tạo ra đối tượng:
org.zkoss.util.media.Media

Media chính là đối tượng đại diện cho file được upload.

------------------------------------------------------------

III. CÁCH TẠO FORM UPLOAD TRONG FILE .ZUL

Ví dụ cơ bản:

<window apply="com.example.UploadController">
    <button label="Upload File" upload="true"
            onUpload="onUploadFile(event)" />
</window>

Ở đây:

- upload="true" → bật chức năng upload
- onUpload → xử lý sự kiện upload

------------------------------------------------------------

IV. LẤY FILE TRONG CONTROLLER (JAVA)

Trong controller:

import org.zkoss.zk.ui.event.UploadEvent;
import org.zkoss.util.media.Media;

public void onUploadFile(UploadEvent event) {

    Media media = event.getMedia();

}

Media chính là file mà người dùng chọn.

------------------------------------------------------------

V. LẤY NỘI DUNG FILE TỪ Media

Media cung cấp các phương thức sau:

1. media.getName()

Lấy tên file.

2. media.getContentType()

Lấy MIME type.

3. media.getByteData()

Lấy nội dung file dưới dạng byte[].

4. media.getStreamData()

Lấy nội dung file dưới dạng InputStream.

------------------------------------------------------------

VI. CÁCH LẤY NỘI DUNG FILE DƯỚI DẠNG BYTE[]

Ví dụ:

public void onUploadFile(UploadEvent event) {

    Media media = event.getMedia();

    if (media != null) {

        String fileName = media.getName();

        byte[] data = media.getByteData();

        System.out.println("Ten file: " + fileName);
        System.out.println("So byte: " + data.length);
    }
}

media.getByteData() sẽ trả về toàn bộ nội dung file.

------------------------------------------------------------

VII. CÁCH LẤY NỘI DUNG FILE DƯỚI DẠNG InputStream

Cách này phù hợp file lớn.

public void onUploadFile(UploadEvent event) throws Exception {

    Media media = event.getMedia();

    if (media != null) {

        InputStream input = media.getStreamData();

        BufferedReader reader = new BufferedReader(
                new InputStreamReader(input)
        );

        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
    }
}

------------------------------------------------------------

VIII. TRƯỜNG HỢP UPLOAD NHIỀU FILE

Nếu cấu hình:

<button upload="true,multiple=true"
        onUpload="onUploadFile(event)" />

Trong controller:

public void onUploadFile(UploadEvent event) {

    Media[] medias = event.getMedias();

    for (Media media : medias) {
        String fileName = media.getName();
        byte[] data = media.getByteData();
    }
}

------------------------------------------------------------

IX. SO SÁNH VỚI SERVLET THÔNG THƯỜNG

Servlet truyền thống:

- Dùng multipart/form-data
- Dùng FileItem
- Dùng ServletFileUpload

ZK:

- Không cần parse multipart
- Không cần request.getParameter()
- ZK tự xử lý và trả về Media

ZK đơn giản hơn vì framework đã xử lý phía sau.

------------------------------------------------------------

X. LƯU FILE XUỐNG DISK

Ví dụ lưu file:

public void onUploadFile(UploadEvent event) throws Exception {

    Media media = event.getMedia();

    if (media != null) {

        InputStream input = media.getStreamData();

        Files.copy(input,
                Paths.get("C:/upload/" + media.getName()),
                StandardCopyOption.REPLACE_EXISTING);
    }
}

------------------------------------------------------------

XI. TÓM TẮT NGẮN GỌN

Để lấy nội dung file từ form trong .zul:

1. Dùng component có upload="true"
2. Bắt sự kiện UploadEvent
3. Lấy đối tượng Media từ event
4. Dùng:
   - getByteData() → lấy byte[]
   - getStreamData() → lấy InputStream

Media chính là đại diện của file upload trong ZK.

------------------------------------------------------------

KẾT LUẬN:

Trong ZK (.zul), bạn không xử lý multipart như Servlet truyền thống.

ZK tự động convert file upload thành đối tượng Media.

Bạn chỉ cần lấy Media từ UploadEvent và đọc nội dung thông qua:

- getByteData()
hoặc
- getStreamData()

Đây là cách chuẩn và đơn giản nhất để lấy nội dung file từ form trong file .zul.

--- DÙNG FileItem CÓ THỂ LẤY ĐƯỢC NỘI DUNG CỦA FILE KHÔNG?

GIẢI THÍCH CHI TIẾT:

DÙNG FileItem CÓ THỂ LẤY ĐƯỢC NỘI DUNG CỦA FILE KHÔNG?

------------------------------------------------------------

I. CÂU TRẢ LỜI NGẮN GỌN

CÓ.

FileItem hoàn toàn có thể lấy được nội dung của file upload.

FileItem không chỉ đại diện cho file, mà còn cho phép:

- Lấy nội dung file dưới dạng byte[]
- Lấy nội dung dưới dạng InputStream
- Ghi file xuống disk

------------------------------------------------------------

II. FileItem LÀ GÌ?

FileItem là class của thư viện:

Apache Commons FileUpload

Nó đại diện cho một phần dữ liệu trong request multipart/form-data.

Một FileItem có thể là:

- Field text (input type="text")
- Hoặc file upload (input type="file")

------------------------------------------------------------

III. KHI NÀO FileItem LÀ FILE?

Ta kiểm tra bằng:

item.isFormField()

- true  → là field text
- false → là file upload

Chỉ khi:

item.isFormField() == false

thì FileItem mới là file thực sự.

------------------------------------------------------------

IV. CÁCH LẤY NỘI DUNG FILE TỪ FileItem

Có 3 cách chính:

------------------------------------------------------------

1. LẤY DƯỚI DẠNG byte[]

byte[] data = item.get();

Giải thích:

item.get() trả về toàn bộ nội dung file dưới dạng mảng byte.

Ví dụ:

if (!item.isFormField()) {

    byte[] fileContent = item.get();

    System.out.println("So byte: " + fileContent.length);
}

Phù hợp khi:

- File nhỏ
- Cần xử lý toàn bộ file trong RAM

------------------------------------------------------------

2. LẤY DƯỚI DẠNG InputStream

InputStream input = item.getInputStream();

Ví dụ:

if (!item.isFormField()) {

    InputStream input = item.getInputStream();

    BufferedReader reader = new BufferedReader(
            new InputStreamReader(input)
    );

    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}

Phù hợp khi:

- File lớn
- Không muốn load toàn bộ vào RAM
- Muốn đọc từng dòng

------------------------------------------------------------

3. GHI FILE TRỰC TIẾP XUỐNG DISK

File file = new File("C:/upload/" + item.getName());
item.write(file);

Giải thích:

FileItem có thể tự ghi nội dung file xuống ổ đĩa.

Không cần đọc byte[] thủ công.

------------------------------------------------------------

V. LUỒNG XỬ LÝ HOÀN CHỈNH

Ví dụ đầy đủ:

List<FileItem> items = upload.parseRequest(request);

for (FileItem item : items) {

    if (!item.isFormField()) {

        String fileName = item.getName();
        long size = item.getSize();

        byte[] data = item.get();

        System.out.println("Ten file: " + fileName);
        System.out.println("Dung luong: " + size);
    }
}

------------------------------------------------------------

VI. LƯU Ý QUAN TRỌNG

1. FileItem có thể lưu file ở RAM hoặc disk tạm.

Tùy cấu hình DiskFileItemFactory:

- File nhỏ → lưu trong RAM
- File lớn → lưu tạm trên disk

Nhưng bạn vẫn truy cập được nội dung thông qua:

- get()
- getInputStream()

------------------------------------------------------------

2. Nếu file rất lớn

Không nên dùng:

item.get()

Vì sẽ load toàn bộ file vào RAM → dễ gây OutOfMemoryError.

Nên dùng:

item.getInputStream()

Để đọc từng phần.

------------------------------------------------------------

VII. SO SÁNH CÁC CÁCH LẤY DỮ LIỆU

item.get()
- Trả về byte[]
- Nhanh
- Dễ dùng
- Tốn RAM

item.getInputStream()
- Trả về InputStream
- Phù hợp file lớn
- An toàn bộ nhớ hơn

item.write(file)
- Lưu trực tiếp xuống disk
- Không cần xử lý thủ công

------------------------------------------------------------

VIII. KẾT LUẬN

Dùng FileItem hoàn toàn có thể lấy được nội dung của file upload.

Các cách lấy nội dung:

1. item.get() → byte[]
2. item.getInputStream() → InputStream
3. item.write(file) → ghi xuống disk

FileItem không chỉ đại diện file, mà còn cho phép truy cập trực tiếp nội dung file.

------------------------------------------------------------

TÓM LẠI:

Có.
FileItem có thể lấy được toàn bộ nội dung file upload thông qua get() hoặc getInputStream().

--- BIẾN KIỂU byte[] THÌ LÀM SAO LƯU NÓ VÀO KIỂU Blob?

GIẢI THÍCH CHI TIẾT:

BIẾN KIỂU byte[] THÌ LÀM SAO LƯU NÓ VÀO KIỂU Blob?

------------------------------------------------------------

I. VẤN ĐỀ ĐẶT RA

Bạn có:

byte[] data;

Và bạn muốn:

Lưu data này vào database dưới dạng Blob (Binary Large Object).

Blob là kiểu dữ liệu dùng để lưu dữ liệu nhị phân lớn trong database.

------------------------------------------------------------

II. HIỂU RÕ 2 KIỂU DỮ LIỆU

1. byte[] là gì?

- Là mảng byte trong Java.
- Lưu dữ liệu nhị phân trong bộ nhớ RAM.
- Thường dùng cho file ảnh, pdf, excel...

2. Blob là gì?

- Là interface java.sql.Blob.
- Đại diện cho dữ liệu BLOB trong database.
- Cho phép streaming, đọc từng phần dữ liệu.

------------------------------------------------------------

III. CÁC CÁCH CHUYỂN byte[] → Blob

Có 3 cách phổ biến:

------------------------------------------------------------

CÁCH 1: DÙNG Hibernate (KHUYẾN NGHỊ)

Nếu bạn đang dùng Hibernate:

Blob blob = session
                .getLobHelper()
                .createBlob(data);

Giải thích:

- getLobHelper() cung cấp công cụ tạo LOB.
- createBlob(data) tạo Blob từ byte[].
- Đây là cách chuẩn và an toàn.

Sau đó:

entity.setFile(blob);
session.save(entity);

------------------------------------------------------------

CÁCH 2: DÙNG javax.sql.rowset.serial.SerialBlob

Nếu không dùng Hibernate session:

import javax.sql.rowset.serial.SerialBlob;

Blob blob = new SerialBlob(data);

Giải thích:

SerialBlob là implementation sẵn có của java.sql.Blob.
Nó cho phép tạo Blob trực tiếp từ byte[].

Phù hợp khi:

- Không có Hibernate session
- Dùng JDBC thuần

------------------------------------------------------------

CÁCH 3: DÙNG PreparedStatement (JDBC thuần)

Nếu dùng JDBC:

PreparedStatement ps = connection.prepareStatement(
    "INSERT INTO document (file_data) VALUES (?)"
);

ps.setBytes(1, data);

Hoặc:

ps.setBlob(1, new SerialBlob(data));

Giải thích:

JDBC có thể set trực tiếp byte[] vào cột BLOB.

------------------------------------------------------------

IV. TRƯỜNG HỢP DÙNG @Lob VỚI byte[] (CÁCH ĐƠN GIẢN NHẤT)

Trong Hibernate/JPA:

@Entity
public class Document {

    @Lob
    private byte[] fileData;

}

Lúc này:

Bạn KHÔNG cần tự tạo Blob.

Chỉ cần:

entity.setFileData(data);

Hibernate sẽ tự động convert byte[] thành BLOB trong database.

Đây là cách đơn giản nhất.

------------------------------------------------------------

V. SO SÁNH CÁC CÁCH

1. @Lob + byte[]
- Đơn giản nhất
- Không cần tạo Blob thủ công
- Phù hợp đa số trường hợp

2. Hibernate LobHelper
- Chuẩn khi cần Blob object
- Phù hợp file lớn

3. SerialBlob
- Dùng được với JDBC
- Không phụ thuộc Hibernate

4. setBytes()
- Đơn giản với JDBC
- Không cần Blob object

------------------------------------------------------------

VI. NÊN DÙNG CÁCH NÀO?

Nếu dùng JPA/Hibernate:

→ Dùng @Lob + byte[] là tốt nhất.

Chỉ khi bạn cần xử lý kiểu Blob trực tiếp (streaming lớn), mới cần tạo Blob.

------------------------------------------------------------

VII. VÍ DỤ HOÀN CHỈNH (Hibernate)

byte[] data = Files.readAllBytes(path);

Blob blob = session
                .getLobHelper()
                .createBlob(data);

Document doc = new Document();
doc.setFile(blob);

session.save(doc);

------------------------------------------------------------

VIII. KẾT LUẬN

Để lưu byte[] vào kiểu Blob, bạn có thể:

1. Dùng Hibernate LobHelper để tạo Blob
2. Dùng SerialBlob
3. Dùng setBytes() với JDBC
4. Hoặc đơn giản nhất: dùng @Lob với byte[] và để Hibernate tự xử lý

------------------------------------------------------------

TÓM LẠI:

byte[] có thể chuyển thành Blob bằng cách tạo Blob object (SerialBlob hoặc LobHelper), hoặc để Hibernate tự động convert thông qua @Lob.

--- WebApplication applicationContext; applicationContext.getBean(beanName);

GIẢI THÍCH CHI TIẾT:

WebApplication applicationContext;
applicationContext.getBean(beanName);

------------------------------------------------------------

I. BỐI CẢNH CHUNG

Đoạn code:

WebApplication applicationContext;
applicationContext.getBean(beanName);

thường xuất hiện trong môi trường dùng Spring Framework.

Ở đây:

- applicationContext là container quản lý các Bean.
- getBean(beanName) là cách lấy một Bean từ Spring Container.

------------------------------------------------------------

II. APPLICATION CONTEXT LÀ GÌ?

1. Khái niệm

ApplicationContext là một interface trung tâm của Spring.

Nó đóng vai trò:

- IoC Container (Inversion of Control)
- Quản lý vòng đời Bean
- Tạo và inject dependency
- Quản lý cấu hình hệ thống

Nói đơn giản:

ApplicationContext là “bộ não” quản lý toàn bộ object trong hệ thống Spring.

------------------------------------------------------------

III. BEAN LÀ GÌ?

Bean trong Spring là:

Một object được tạo và quản lý bởi Spring Container.

Ví dụ:

@Service
public class UserService {
}

Khi ứng dụng khởi động:

Spring sẽ:
- Tạo instance của UserService
- Lưu nó vào container
- Quản lý lifecycle của nó

UserService lúc này là một Bean.

------------------------------------------------------------

IV. getBean(beanName) LÀ GÌ?

Cú pháp:

Object obj = applicationContext.getBean("beanName");

Ý nghĩa:

Lấy một Bean từ Spring Container theo tên bean.

Ví dụ:

UserService service = 
    (UserService) applicationContext.getBean("userService");

Spring sẽ:

- Tìm bean có tên "userService"
- Trả về instance tương ứng

------------------------------------------------------------

V. BEAN NAME LÀ GÌ?

Bean name thường là:

1. Tên class viết thường chữ cái đầu:

UserService → "userService"

2. Hoặc được chỉ định rõ:

@Service("myService")

Lúc này beanName = "myService"

------------------------------------------------------------

VI. CÁC CÁCH getBean KHÁC

1. Lấy theo tên:

getBean("userService")

2. Lấy theo class:

getBean(UserService.class)

3. Lấy theo tên + class:

getBean("userService", UserService.class)

Cách lấy theo class an toàn hơn vì không cần ép kiểu.

------------------------------------------------------------

VII. CƠ CHẾ BÊN TRONG

Khi gọi:

applicationContext.getBean(beanName);

Spring sẽ:

1. Kiểm tra bean đã tồn tại chưa
2. Nếu là singleton → trả instance đã tạo
3. Nếu là prototype → tạo instance mới
4. Inject dependency nếu có
5. Trả về object

------------------------------------------------------------

VIII. SINGLETON VS PROTOTYPE

Nếu bean mặc định (singleton):

getBean() luôn trả về cùng một object.

Nếu bean là prototype:

Mỗi lần gọi getBean() → tạo object mới.

------------------------------------------------------------

IX. TẠI SAO KHÔNG NÊN DÙNG getBean TRỰC TIẾP?

Trong Spring hiện đại:

Không nên gọi getBean thủ công nhiều.

Thay vào đó nên dùng:

@Autowired

Ví dụ:

@Autowired
private UserService userService;

Spring sẽ tự inject.

getBean thường dùng khi:

- Cần lấy bean động theo tên
- Không thể dùng @Autowired
- Trong code framework
- Trong util hoặc legacy code

------------------------------------------------------------

X. VÍ DỤ ĐẦY ĐỦ

ApplicationContext context =
        new AnnotationConfigApplicationContext(AppConfig.class);

UserService service =
        (UserService) context.getBean("userService");

service.doSomething();

------------------------------------------------------------

XI. TRONG WEB APPLICATION

Trong môi trường web (Spring MVC):

ApplicationContext thường được load khi server start.

Có thể lấy bằng:

WebApplicationContext context =
    WebApplicationContextUtils.getRequiredWebApplicationContext(
        servletContext
    );

Sau đó:

Object bean = context.getBean("beanName");

------------------------------------------------------------

XII. KẾT LUẬN

applicationContext.getBean(beanName) là phương thức dùng để:

Lấy một Bean đã được Spring quản lý từ container theo tên bean.

Nó cho phép:

- Truy cập object do Spring quản lý
- Tận dụng dependency injection
- Tái sử dụng instance theo scope đã cấu hình

------------------------------------------------------------

TÓM LẠI:

ApplicationContext là container quản lý Bean.
getBean(beanName) là cách lấy Bean từ container theo tên.

Đây là cơ chế cốt lõi của IoC trong Spring Framework.

--- HQL TRONG HIBERNATE

GIẢI THÍCH CHI TIẾT VỀ HQL TRONG HIBERNATE

------------------------------------------------------------
I. HQL LÀ GÌ?

HQL là viết tắt của: Hibernate Query Language.

HQL là ngôn ngữ truy vấn do Hibernate cung cấp để thao tác dữ liệu trong database thông qua Entity (đối tượng Java), thay vì thao tác trực tiếp trên bảng (table).

Nói đơn giản:

SQL → truy vấn dựa trên bảng và cột trong database
HQL → truy vấn dựa trên class và thuộc tính trong Java

------------------------------------------------------------
II. BẢN CHẤT CỦA HQL

HQL là ngôn ngữ hướng đối tượng (object-oriented query language).

HQL không làm việc trực tiếp với:

- Tên bảng
- Tên cột

Mà làm việc với:

- Tên Entity
- Tên thuộc tính trong class

Hibernate sẽ tự động chuyển HQL thành SQL tương ứng với database.

------------------------------------------------------------
III. VÍ DỤ SO SÁNH SQL VÀ HQL

Giả sử có entity:

@Entity
@Table(name = "users")
public class User {

    @Id
    private Long id;

    private String username;
    private int age;
}

SQL:

SELECT * FROM users WHERE age > 18;

HQL:

FROM User WHERE age > 18

Khác biệt quan trọng:

- SQL dùng tên bảng: users
- HQL dùng tên class: User

------------------------------------------------------------
IV. CẤU TRÚC CƠ BẢN CỦA HQL

1. SELECT

HQL:

SELECT u FROM User u

Hoặc đơn giản hơn:

FROM User

Mặc định sẽ select toàn bộ object.

------------------------------------------------------------
2. WHERE

FROM User u WHERE u.age > 18

------------------------------------------------------------
3. ORDER BY

FROM User u ORDER BY u.age DESC

------------------------------------------------------------
4. GROUP BY

SELECT u.age, COUNT(u)
FROM User u
GROUP BY u.age

------------------------------------------------------------
5. JOIN

Giả sử:

User có quan hệ với Role

FROM User u JOIN u.role r WHERE r.name = 'ADMIN'

HQL join dựa trên quan hệ object, không join bằng khóa ngoại thủ công như SQL.

------------------------------------------------------------
V. CÁCH SỬ DỤNG HQL

Ví dụ:

Session session = sessionFactory.openSession();

Query<User> query = session.createQuery(
    "FROM User WHERE age > :age",
    User.class
);

query.setParameter("age", 18);

List<User> users = query.list();

------------------------------------------------------------
VI. PARAMETER TRONG HQL

Có 2 loại:

1. Named Parameter

FROM User WHERE age > :age

setParameter("age", 18)

2. Positional Parameter

FROM User WHERE age > ?1

setParameter(1, 18)

Khuyến nghị dùng Named Parameter để dễ đọc.

------------------------------------------------------------
VII. HQL KHÔNG PHẢI LÀ SQL

Một số điểm khác biệt:

1. Không dùng SELECT *

HQL dùng:

FROM User

2. Không dùng tên bảng

Dùng tên Entity.

3. Không dùng tên cột

Dùng tên thuộc tính trong class.

Ví dụ:

Nếu column là user_name nhưng property là username,
HQL phải dùng:

username

------------------------------------------------------------
VIII. CÁC LOẠI TRUY VẤN TRONG HQL

1. SELECT (truy vấn dữ liệu)

FROM User

2. UPDATE

UPDATE User SET age = 30 WHERE id = 1

3. DELETE

DELETE FROM User WHERE age < 18

Lưu ý:

UPDATE và DELETE trong HQL là bulk operation.
Chúng không trigger lifecycle event của entity.

------------------------------------------------------------
IX. HQL VS CRITERIA API

Hibernate có 2 cách truy vấn:

1. HQL (viết chuỗi query)
2. Criteria API (viết bằng code Java)

HQL:
- Ngắn gọn
- Giống SQL
- Dễ đọc

Criteria:
- Type-safe
- Phù hợp dynamic query
- Dài hơn

------------------------------------------------------------
X. ƯU ĐIỂM CỦA HQL

1. Độc lập database

Hibernate sẽ chuyển HQL thành SQL phù hợp với:

- MySQL
- Oracle
- PostgreSQL
- SQL Server

2. Làm việc theo object

Không cần quan tâm đến cấu trúc bảng phức tạp.

3. Tận dụng mapping

HQL hiểu quan hệ:

- @OneToMany
- @ManyToOne
- @OneToOne

------------------------------------------------------------
XI. NHƯỢC ĐIỂM CỦA HQL

1. Không tận dụng được một số tính năng đặc thù của từng database.

2. Không mạnh bằng native SQL trong các query phức tạp.

3. Dễ lỗi runtime nếu viết sai tên property.

------------------------------------------------------------
XII. HQL VS NATIVE SQL

Hibernate cho phép:

session.createNativeQuery("SELECT * FROM users");

Đây là SQL thuần.

Khác với:

session.createQuery("FROM User");

Đây là HQL.

------------------------------------------------------------
XIII. TÓM TẮT NGẮN GỌN

HQL là:

Ngôn ngữ truy vấn của Hibernate dùng để thao tác dữ liệu dựa trên Entity và thuộc tính Java thay vì bảng và cột trong database.

Đặc điểm chính:

- Hướng đối tượng
- Độc lập database
- Dùng tên class và property
- Được Hibernate chuyển thành SQL

------------------------------------------------------------
KẾT LUẬN

HQL là công cụ truy vấn cốt lõi trong Hibernate.

Nó giúp lập trình viên:

- Làm việc ở mức object
- Không phụ thuộc database cụ thể
- Tận dụng sức mạnh của ORM

Hiểu HQL là bước quan trọng để làm chủ Hibernate và JPA trong lập trình Java.

--- TRONG HIBERNATE, ĐỂ MAP 1 CLASS VỚI 1 TABLE THÌ DÙNG CÁCH NÀO?

GIẢI THÍCH CHI TIẾT: TRONG HIBERNATE, ĐỂ MAP 1 CLASS VỚI 1 TABLE THÌ DÙNG CÁCH NÀO?

---------------------------------------------------------------------
I. KHÁI NIỆM MAP (MAPPING) TRONG HIBERNATE LÀ GÌ?

Mapping là quá trình ánh xạ (liên kết) giữa:

- Class Java (Entity)
và
- Table trong Database

Hibernate là ORM (Object Relational Mapping), nên nó cần biết:

Class nào tương ứng với table nào
Thuộc tính nào tương ứng với cột nào
Khóa chính là gì
Quan hệ giữa các bảng là gì

Nếu không mapping, Hibernate không thể lưu hoặc đọc dữ liệu.

---------------------------------------------------------------------
II. CÓ BA CÁCH MAP CLASS VỚI TABLE TRONG HIBERNATE

1. Dùng Annotation (Cách phổ biến nhất hiện nay)
2. Dùng file XML (.hbm.xml)
3. Kết hợp cả hai (ít dùng)

Hiện nay, cách 1 (Annotation) là tiêu chuẩn và được khuyến khích sử dụng.

---------------------------------------------------------------------
III. CÁCH 1 – MAP BẰNG ANNOTATION (PHỔ BIẾN NHẤT)

Đây là cách dùng annotation của JPA/Hibernate để khai báo mapping trực tiếp trong class.

Ví dụ:

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username", length = 100, nullable = false)
    private String username;

    @Column(name = "age")
    private int age;

}

-------------------------------------------------------------
1. @Entity

Đánh dấu class này là một Entity (được Hibernate quản lý).

Nếu không có @Entity → Hibernate sẽ không map class này.

-------------------------------------------------------------
2. @Table

@Table(name = "users")

Dùng để chỉ rõ tên bảng trong database.

Nếu không ghi @Table → Hibernate mặc định dùng tên class làm tên bảng.

-------------------------------------------------------------
3. @Id

Đánh dấu thuộc tính là khóa chính (Primary Key).

Mỗi Entity bắt buộc phải có @Id.

-------------------------------------------------------------
4. @GeneratedValue

Dùng để cấu hình cách sinh khóa chính.

Ví dụ:

- GenerationType.IDENTITY (auto increment)
- GenerationType.SEQUENCE
- GenerationType.AUTO

-------------------------------------------------------------
5. @Column

Dùng để cấu hình chi tiết mapping giữa property và column.

Có thể cấu hình:

- name (tên cột)
- nullable (cho phép null hay không)
- length (độ dài)
- unique
- precision, scale (cho số)

Nếu không ghi @Column → Hibernate tự động map theo tên property.

---------------------------------------------------------------------
IV. CÁCH 2 – MAP BẰNG FILE XML (.hbm.xml)

Cách cũ, phổ biến trong Hibernate đời đầu.

Ví dụ file: User.hbm.xml

<class name="User" table="users">

    <id name="id" column="id">
        <generator class="identity"/>
    </id>

    <property name="username" column="username"/>
    <property name="age" column="age"/>

</class>

Sau đó phải khai báo file này trong hibernate.cfg.xml:

<mapping resource="User.hbm.xml"/>

-------------------------------------------------------------
Ưu điểm:

- Tách biệt cấu hình và code

Nhược điểm:

- Dài dòng
- Khó bảo trì
- Không phổ biến hiện nay

---------------------------------------------------------------------
V. CÁCH 3 – DÙNG JPA (TIÊU CHUẨN HIỆN ĐẠI)

Hibernate hiện nay thường dùng theo chuẩn JPA.

Annotation dùng là của:

javax.persistence.*

Hibernate chỉ là implementation của JPA.

Vì vậy khi map class, ta dùng:

- @Entity
- @Table
- @Id
- @Column
- @OneToMany
- @ManyToOne
- @JoinColumn

Đây là cách chuẩn hiện nay.

---------------------------------------------------------------------
VI. MAP CÁC KIỂU DỮ LIỆU

Hibernate tự động map kiểu Java sang SQL:

String → VARCHAR
int → INTEGER
long → BIGINT
Date → TIMESTAMP
boolean → BIT / BOOLEAN
byte[] → BLOB

Ví dụ:

@Column(name = "file_data")
private byte[] fileData;

Hibernate sẽ map thành BLOB.

---------------------------------------------------------------------
VII. MAP QUAN HỆ GIỮA CÁC BẢNG

Ví dụ:

User và Role có quan hệ ManyToOne

@ManyToOne
@JoinColumn(name = "role_id")
private Role role;

@JoinColumn dùng để chỉ cột khóa ngoại.

-------------------------------------------------------------
OneToMany:

@OneToMany(mappedBy = "user")
private List<Order> orders;

---------------------------------------------------------------------
VIII. QUY TRÌNH MAP CLASS VỚI TABLE

Bước 1: Tạo class
Bước 2: Đánh dấu @Entity
Bước 3: Đánh dấu @Table
Bước 4: Xác định @Id
Bước 5: Map các thuộc tính bằng @Column
Bước 6: Map quan hệ nếu có

Sau đó Hibernate sẽ:

- Tự động tạo table (nếu cấu hình auto create)
- Hoặc map với table có sẵn

---------------------------------------------------------------------
IX. CẤU HÌNH HIBERNATE TẠO TABLE TỰ ĐỘNG

Trong application.properties:

hibernate.hbm2ddl.auto=update

Các giá trị:

create      → tạo lại table mỗi lần chạy
update      → cập nhật cấu trúc
validate    → kiểm tra cấu trúc
none        → không làm gì

---------------------------------------------------------------------
X. TÓM TẮT NGẮN GỌN

Để map 1 class với 1 table trong Hibernate ta dùng:

1. Annotation (@Entity, @Table, @Id, @Column) → cách chuẩn hiện nay
2. Hoặc file XML (.hbm.xml) → cách cũ

Cách được khuyến nghị hiện nay là dùng Annotation theo chuẩn JPA.

---------------------------------------------------------------------
KẾT LUẬN

Mapping là bước quan trọng nhất khi sử dụng Hibernate.

Nếu không mapping đúng:

- Hibernate không thể truy vấn dữ liệu
- Không thể lưu object xuống database

Cách hiện đại và chuẩn nhất là:

Dùng annotation JPA để map class với table một cách rõ ràng, dễ đọc và dễ bảo trì.

--- LUỒNG ĐẦY ĐỦ ĐỂ GỌI ĐƯỢC DATABASE KHI DÙNG org.hibernate

GIẢI THÍCH CHI TIẾT: LUỒNG ĐẦY ĐỦ ĐỂ GỌI ĐƯỢC DATABASE KHI DÙNG org.hibernate

---------------------------------------------------------------------
I. TỔNG QUAN

Để gọi (truy vấn, insert, update, delete) được Database bằng Hibernate,
ta cần đi qua một luồng đầy đủ gồm các bước:

1. Cấu hình Hibernate
2. Tạo Entity (map class với table)
3. Tạo SessionFactory
4. Mở Session
5. Bắt đầu Transaction
6. Tạo Query hoặc thao tác trực tiếp
7. Thực thi lệnh
8. Commit/Rollback Transaction
9. Đóng Session

Đây là luồng chuẩn và đầy đủ nhất.

---------------------------------------------------------------------
II. BƯỚC 1 – CẤU HÌNH HIBERNATE

Có 2 cách cấu hình:

- hibernate.cfg.xml
- application.properties (Spring)

Ví dụ hibernate.cfg.xml:

<hibernate-configuration>
    <session-factory>

        <property name="hibernate.connection.driver_class">
            com.mysql.cj.jdbc.Driver
        </property>

        <property name="hibernate.connection.url">
            jdbc:mysql://localhost:3306/testdb
        </property>

        <property name="hibernate.connection.username">
            root
        </property>

        <property name="hibernate.connection.password">
            123456
        </property>

        <property name="hibernate.dialect">
            org.hibernate.dialect.MySQL8Dialect
        </property>

        <property name="hibernate.hbm2ddl.auto">
            update
        </property>

        <mapping class="com.example.User"/>

    </session-factory>
</hibernate-configuration>

Hibernate cần:

- Driver
- URL
- Username
- Password
- Dialect

---------------------------------------------------------------------
III. BƯỚC 2 – TẠO ENTITY

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private int age;

    // getter/setter
}

Entity giúp Hibernate biết map class với table.

---------------------------------------------------------------------
IV. BƯỚC 3 – TẠO SessionFactory

SessionFactory là đối tượng nặng, tạo 1 lần duy nhất.

Configuration configuration = new Configuration();
configuration.configure("hibernate.cfg.xml");
configuration.addAnnotatedClass(User.class);

SessionFactory sessionFactory =
        configuration.buildSessionFactory();

---------------------------------------------------------------------
V. BƯỚC 4 – MỞ SESSION

Session session = sessionFactory.openSession();

Session đại diện cho 1 kết nối tới database.

---------------------------------------------------------------------
VI. BƯỚC 5 – BẮT ĐẦU TRANSACTION

Transaction tx = session.beginTransaction();

Tất cả thao tác với database nên nằm trong transaction.

---------------------------------------------------------------------
VII. BƯỚC 6 – THỰC HIỆN THAO TÁC DATABASE

1. INSERT

User user = new User();
user.setUsername("Nam");
user.setAge(25);

session.save(user);

-------------------------------------------------------------
2. SELECT

Query<User> query =
    session.createQuery("FROM User", User.class);

List<User> users = query.list();

-------------------------------------------------------------
3. UPDATE

User user = session.get(User.class, 1L);
user.setAge(30);

session.update(user);

-------------------------------------------------------------
4. DELETE

User user = session.get(User.class, 1L);
session.delete(user);

---------------------------------------------------------------------
VIII. BƯỚC 7 – COMMIT TRANSACTION

tx.commit();

Nếu có lỗi:

tx.rollback();

Commit sẽ:

- Gửi SQL xuống database
- Hoàn tất thay đổi

---------------------------------------------------------------------
IX. BƯỚC 8 – ĐÓNG SESSION

session.close();

Giải phóng connection.

---------------------------------------------------------------------
X. LUỒNG HOẠT ĐỘNG BÊN TRONG

Khi ta gọi:

session.save(user);

Hibernate sẽ:

1. Đưa object vào Persistence Context
2. Theo dõi thay đổi (dirty checking)
3. Khi commit → generate SQL
4. Gửi SQL qua JDBC
5. Database thực thi
6. Trả kết quả về

Hibernate hoạt động dựa trên:

- JDBC bên dưới
- Connection Pool
- SQL được sinh tự động

---------------------------------------------------------------------
XI. LUỒNG TỔNG THỂ ĐẦY ĐỦ

Application
    ↓
Configuration
    ↓
SessionFactory (singleton)
    ↓
Session (mỗi request 1 session)
    ↓
Transaction
    ↓
Query / save / update / delete
    ↓
Hibernate generate SQL
    ↓
JDBC Driver
    ↓
Database
    ↓
Trả kết quả về Application

---------------------------------------------------------------------
XII. VÍ DỤ HOÀN CHỈNH

public static void main(String[] args) {

    SessionFactory sessionFactory =
        new Configuration()
            .configure("hibernate.cfg.xml")
            .addAnnotatedClass(User.class)
            .buildSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction tx = session.beginTransaction();

    User user = new User();
    user.setUsername("Nam");
    user.setAge(25);

    session.save(user);

    tx.commit();
    session.close();
    sessionFactory.close();
}

---------------------------------------------------------------------
XIII. NHỮNG LƯU Ý QUAN TRỌNG

1. SessionFactory tạo 1 lần duy nhất
2. Session không thread-safe
3. Luôn dùng Transaction
4. Luôn đóng Session
5. Không nên giữ Session quá lâu

---------------------------------------------------------------------
XIV. TÓM TẮT NGẮN GỌN

Để gọi được database bằng org.hibernate cần:

1. Cấu hình kết nối
2. Map Entity
3. Tạo SessionFactory
4. Mở Session
5. Begin Transaction
6. Thực thi thao tác
7. Commit/Rollback
8. Đóng Session

Đây là luồng đầy đủ và chuẩn khi làm việc với Hibernate thuần.

---------------------------------------------------------------------
KẾT LUẬN

Hibernate không gọi database trực tiếp.

Nó hoạt động theo mô hình:

Entity → Session → Transaction → SQL → JDBC → Database

Hiểu rõ luồng này giúp bạn:

- Debug lỗi tốt hơn
- Tối ưu hiệu năng
- Tránh lỗi transaction
- Thiết kế hệ thống đúng chuẩn

--- Properties p; p.getProperties("a", "true");

GIẢI THÍCH CHI TIẾT:

Properties p;
p.getProperties("a", "true");

---------------------------------------------------------------------
I. TRƯỚC HẾT: ĐOẠN CODE TRÊN CÓ ĐÚNG KHÔNG?

Trong Java chuẩn (java.util.Properties), KHÔNG tồn tại method:

getProperties(String key, String defaultValue)

Vì vậy:

p.getProperties("a", "true");

=> SAI cú pháp nếu p là kiểu:

java.util.Properties

---------------------------------------------------------------------
II. PROPERTIES LÀ GÌ?

Properties là một class trong:

java.util.Properties

Nó dùng để:

- Lưu trữ các cặp key-value
- Cấu hình hệ thống
- Đọc file .properties

Ví dụ:

a=true
b=123
name=Nam

---------------------------------------------------------------------
III. METHOD ĐÚNG PHẢI LÀ getProperty()

Trong java.util.Properties, method đúng là:

getProperty(String key)
getProperty(String key, String defaultValue)

Cú pháp đúng:

Properties p = new Properties();

String value = p.getProperty("a", "true");

---------------------------------------------------------------------
IV. GIẢI THÍCH getProperty("a", "true")

Cú pháp:

getProperty(key, defaultValue)

Ý nghĩa:

- Tìm key = "a"
- Nếu tồn tại → trả về giá trị tương ứng
- Nếu KHÔNG tồn tại → trả về defaultValue ("true")

---------------------------------------------------------------------
V. VÍ DỤ CỤ THỂ

Properties p = new Properties();

p.setProperty("a", "false");

String value = p.getProperty("a", "true");

Kết quả:

value = "false"

Vì key "a" tồn tại.

-------------------------------------------------------------

Nếu:

Properties p = new Properties();

String value = p.getProperty("a", "true");

Kết quả:

value = "true"

Vì key "a" không tồn tại nên trả defaultValue.

---------------------------------------------------------------------
VI. TẠI SAO CẦN defaultValue?

Để tránh:

- NullPointerException
- Phải kiểm tra null

Thay vì:

String v = p.getProperty("a");
if (v == null) {
    v = "true";
}

Ta chỉ cần:

String v = p.getProperty("a", "true");

---------------------------------------------------------------------
VII. LƯU Ý QUAN TRỌNG

1. Properties chỉ lưu String-String

Không lưu Boolean trực tiếp.

Ví dụ:

p.setProperty("a", "true");

Lấy ra:

String value = p.getProperty("a");

Nếu muốn boolean:

boolean flag = Boolean.parseBoolean(value);

---------------------------------------------------------------------
VIII. TRƯỜNG HỢP getProperties() CÓ THỂ TỒN TẠI

Nếu trong project có:

- Một class custom tên Properties
- Hoặc framework riêng

Thì getProperties() có thể là method tự định nghĩa.

Nhưng trong Java chuẩn:

java.util.Properties
KHÔNG có method getProperties()

---------------------------------------------------------------------
IX. SO SÁNH getProperty() VÀ get()

Properties kế thừa từ Hashtable<Object,Object>

Nên có method:

p.get("a");

Nhưng:

get() trả Object
getProperty() trả String

Vì vậy nên dùng:

getProperty()

---------------------------------------------------------------------
X. TỔNG KẾT

1. Đoạn code:

p.getProperties("a", "true");

→ Sai nếu p là java.util.Properties

2. Cú pháp đúng là:

p.getProperty("a", "true");

3. Ý nghĩa:

- Lấy giá trị key "a"
- Nếu không tồn tại → trả "true"

4. Luôn trả về String

---------------------------------------------------------------------
KẾT LUẬN

Nếu bạn đang thấy:

p.getProperties("a", "true");

thì:

- Hoặc đó là lỗi code
- Hoặc p không phải là java.util.Properties
- Hoặc đó là method custom

Còn trong Java chuẩn, phải dùng:

getProperty(key, defaultValue)

--- ĐỂ CÓ THỂ DÙNG org.hibernate.Query VỚI query.list() THÌ CẦN LÀM NHỮNG VIỆC GÌ TRƯỚC ĐÓ?

GIẢI THÍCH CHI TIẾT NHẤT:

ĐỂ CÓ THỂ DÙNG org.hibernate.Query VỚI query.list()
THÌ CẦN LÀM NHỮNG VIỆC GÌ TRƯỚC ĐÓ?

---------------------------------------------------------------------
I. TỔNG QUAN

Để gọi được:

Query query = session.createQuery("FROM User");
List list = query.list();

Thì phía trước đó hệ thống phải được chuẩn bị đầy đủ theo đúng luồng Hibernate.

Nếu thiếu 1 bước, query.list() sẽ lỗi.

Luồng chuẩn gồm 8 bước lớn.

---------------------------------------------------------------------
II. BƯỚC 1 – THÊM DEPENDENCY HIBERNATE

Trong project phải có:

- hibernate-core
- jdbc driver (MySQL / Oracle / PostgreSQL)
- javax.persistence (nếu dùng annotation)

Nếu thiếu thư viện → không compile được.

---------------------------------------------------------------------
III. BƯỚC 2 – CẤU HÌNH KẾT NỐI DATABASE

Phải có cấu hình:

hibernate.cfg.xml

Hoặc cấu hình bằng code.

Ví dụ:

<property name="hibernate.connection.driver_class">
    com.mysql.cj.jdbc.Driver
</property>

<property name="hibernate.connection.url">
    jdbc:mysql://localhost:3306/testdb
</property>

<property name="hibernate.connection.username">
    root
</property>

<property name="hibernate.connection.password">
    123456
</property>

<property name="hibernate.dialect">
    org.hibernate.dialect.MySQL8Dialect
</property>

Nếu không cấu hình đúng → không kết nối được DB.

---------------------------------------------------------------------
IV. BƯỚC 3 – MAP ENTITY VỚI TABLE

Phải có class Entity được map.

Ví dụ:

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
}

Nếu chưa map entity → query "FROM User" sẽ lỗi.

Và phải khai báo mapping trong cfg:

<mapping class="com.example.User"/>

---------------------------------------------------------------------
V. BƯỚC 4 – TẠO SessionFactory

SessionFactory là bắt buộc.

SessionFactory sessionFactory =
    new Configuration()
        .configure("hibernate.cfg.xml")
        .addAnnotatedClass(User.class)
        .buildSessionFactory();

Nếu không có SessionFactory → không thể mở Session.

---------------------------------------------------------------------
VI. BƯỚC 5 – MỞ SESSION

Session session = sessionFactory.openSession();

Session đại diện cho một kết nối tới DB.

Không có session → không thể tạo Query.

---------------------------------------------------------------------
VII. BƯỚC 6 – BẮT ĐẦU TRANSACTION

Transaction tx = session.beginTransaction();

Mặc dù SELECT có thể chạy không cần commit,
nhưng best practice là luôn dùng transaction.

Không có transaction đôi khi gây lỗi trong môi trường thật.

---------------------------------------------------------------------
VIII. BƯỚC 7 – TẠO QUERY

Lúc này mới tạo được:

Query query = session.createQuery("FROM User");

Hoặc:

Query<User> query =
    session.createQuery("FROM User", User.class);

Nếu HQL sai → lỗi QuerySyntaxException.

---------------------------------------------------------------------
IX. BƯỚC 8 – GỌI query.list()

List<User> users = query.list();

Khi gọi list():

1. Hibernate parse HQL
2. Convert sang SQL
3. Gửi SQL qua JDBC
4. DB thực thi
5. Trả ResultSet
6. Hibernate map thành object
7. Trả List

---------------------------------------------------------------------
X. BƯỚC 9 – COMMIT TRANSACTION

tx.commit();

Nếu không commit:

- INSERT / UPDATE / DELETE không có hiệu lực
- SELECT vẫn chạy nhưng không chuẩn luồng

---------------------------------------------------------------------
XI. BƯỚC 10 – ĐÓNG SESSION

session.close();

Giải phóng connection.

---------------------------------------------------------------------
XII. TÓM TẮT ĐIỀU KIỆN BẮT BUỘC TRƯỚC KHI DÙNG query.list()

1. Có thư viện Hibernate
2. Có JDBC driver
3. Cấu hình kết nối DB
4. Map entity với table
5. Tạo SessionFactory
6. Mở Session
7. Bắt đầu Transaction
8. Tạo Query hợp lệ

Thiếu 1 trong các bước trên → query.list() sẽ không chạy.

---------------------------------------------------------------------
XIII. VÍ DỤ LUỒNG ĐẦY ĐỦ

SessionFactory sessionFactory =
    new Configuration()
        .configure("hibernate.cfg.xml")
        .addAnnotatedClass(User.class)
        .buildSessionFactory();

Session session = sessionFactory.openSession();

Transaction tx = session.beginTransaction();

Query<User> query =
    session.createQuery("FROM User", User.class);

List<User> users = query.list();

tx.commit();
session.close();
sessionFactory.close();

---------------------------------------------------------------------
XIV. CÁC LỖI THƯỜNG GẶP

1. Không có entity → QuerySyntaxException
2. Sai tên class trong HQL → lỗi
3. Không mở transaction → lỗi môi trường production
4. Không cấu hình dialect → Hibernate không generate SQL
5. DB không chạy → Connection refused

---------------------------------------------------------------------
XV. LUỒNG TỔNG QUÁT

Application
    ↓
Configuration
    ↓
SessionFactory
    ↓
Session
    ↓
Transaction
    ↓
createQuery()
    ↓
query.list()
    ↓
Hibernate generate SQL
    ↓
JDBC
    ↓
Database

---------------------------------------------------------------------
KẾT LUẬN

Để dùng được org.hibernate.Query với query.list(),
bạn phải thiết lập hoàn chỉnh toàn bộ môi trường Hibernate:

- Cấu hình
- Mapping
- SessionFactory
- Session
- Transaction

query.list() chỉ là bước cuối của cả một hệ thống phía sau.

Nếu hiểu rõ luồng này,
bạn sẽ debug và thiết kế hệ thống Hibernate tốt hơn rất nhiều.

--- hibernate.cfg.xml

GIẢI THÍCH CHI TIẾT NHẤT VỀ FILE hibernate.cfg.xml

---------------------------------------------------------------------
I. hibernate.cfg.xml LÀ GÌ?

hibernate.cfg.xml là file cấu hình trung tâm của Hibernate
(khi dùng Hibernate thuần, không dùng Spring Boot).

Nó chứa:

- Thông tin kết nối database
- Dialect
- Mapping entity
- Các cấu hình hành vi của Hibernate

Hibernate sẽ đọc file này để khởi tạo SessionFactory.

---------------------------------------------------------------------
II. VỊ TRÍ ĐẶT FILE

Thông thường đặt trong:

src/main/resources/

Hoặc đặt trong classpath.

Khi gọi:

new Configuration().configure("hibernate.cfg.xml");

Hibernate sẽ tự tìm trong classpath.

---------------------------------------------------------------------
III. CẤU TRÚC CƠ BẢN CỦA FILE

Cấu trúc chuẩn:

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- cấu hình ở đây -->

    </session-factory>
</hibernate-configuration>

---------------------------------------------------------------------
IV. CÁC NHÓM CẤU HÌNH CHÍNH

1. CẤU HÌNH KẾT NỐI DATABASE

<property name="hibernate.connection.driver_class">
    com.mysql.cj.jdbc.Driver
</property>

<property name="hibernate.connection.url">
    jdbc:mysql://localhost:3306/testdb
</property>

<property name="hibernate.connection.username">
    root
</property>

<property name="hibernate.connection.password">
    123456
</property>

Ý nghĩa:

- driver_class: driver JDBC
- url: địa chỉ database
- username/password: thông tin đăng nhập

Nếu sai → không kết nối được DB.

---------------------------------------------------------------------
2. DIALECT

<property name="hibernate.dialect">
    org.hibernate.dialect.MySQL8Dialect
</property>

Dialect giúp Hibernate biết:

- Database là loại nào
- Cú pháp SQL đặc thù

Ví dụ:

- MySQL
- Oracle
- PostgreSQL
- SQL Server

Nếu chọn sai dialect → SQL sinh ra có thể lỗi.

---------------------------------------------------------------------
3. HBM2DDL (TỰ ĐỘNG TẠO TABLE)

<property name="hibernate.hbm2ddl.auto">
    update
</property>

Các giá trị:

- validate  → chỉ kiểm tra
- update    → cập nhật table
- create    → tạo mới
- create-drop → tạo và xóa khi shutdown
- none      → không làm gì

Trong production nên dùng validate hoặc none.

---------------------------------------------------------------------
4. HIỂN THỊ SQL

<property name="hibernate.show_sql">true</property>
<property name="hibernate.format_sql">true</property>

Giúp in SQL ra console khi chạy.

Dùng để debug.

---------------------------------------------------------------------
5. MAPPING ENTITY

Cách 1 – annotation:

<mapping class="com.example.User"/>

Cách 2 – file XML mapping:

<mapping resource="User.hbm.xml"/>

Nếu không mapping → Hibernate không biết entity.

---------------------------------------------------------------------
V. VÍ DỤ FILE HOÀN CHỈNH

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- Database connection -->
        <property name="hibernate.connection.driver_class">
            com.mysql.cj.jdbc.Driver
        </property>

        <property name="hibernate.connection.url">
            jdbc:mysql://localhost:3306/testdb
        </property>

        <property name="hibernate.connection.username">
            root
        </property>

        <property name="hibernate.connection.password">
            123456
        </property>

        <!-- Dialect -->
        <property name="hibernate.dialect">
            org.hibernate.dialect.MySQL8Dialect
        </property>

        <!-- Auto table -->
        <property name="hibernate.hbm2ddl.auto">
            update
        </property>

        <!-- Show SQL -->
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>

        <!-- Mapping -->
        <mapping class="com.example.User"/>

    </session-factory>
</hibernate-configuration>

---------------------------------------------------------------------
VI. LUỒNG HOẠT ĐỘNG

Khi gọi:

SessionFactory sessionFactory =
    new Configuration().configure().buildSessionFactory();

Hibernate sẽ:

1. Đọc hibernate.cfg.xml
2. Load cấu hình DB
3. Load entity mapping
4. Tạo SessionFactory
5. Chuẩn bị connection pool

---------------------------------------------------------------------
VII. MỐI QUAN HỆ VỚI CÁC THÀNH PHẦN KHÁC

hibernate.cfg.xml
    ↓
Configuration
    ↓
SessionFactory
    ↓
Session
    ↓
Transaction
    ↓
Query

File này là điểm bắt đầu của toàn bộ hệ thống Hibernate.

---------------------------------------------------------------------
VIII. LƯU Ý QUAN TRỌNG

1. Không commit password thật lên Git
2. Không dùng create-drop ở production
3. Luôn chọn đúng dialect
4. SessionFactory chỉ tạo 1 lần

---------------------------------------------------------------------
IX. KHI DÙNG SPRING BOOT

Spring Boot KHÔNG dùng hibernate.cfg.xml.

Nó thay bằng:

application.properties
hoặc
application.yml

Hibernate sẽ được Spring cấu hình tự động.

---------------------------------------------------------------------
X. TÓM TẮT NGẮN GỌN

hibernate.cfg.xml là:

- File cấu hình trung tâm của Hibernate thuần
- Chứa thông tin kết nối DB
- Chứa dialect
- Chứa mapping entity
- Ảnh hưởng trực tiếp đến cách Hibernate sinh SQL

Nếu file này sai → toàn bộ Hibernate không hoạt động.

---------------------------------------------------------------------
KẾT LUẬN

hibernate.cfg.xml là nền tảng cấu hình của Hibernate.

Hiểu rõ file này giúp bạn:

- Biết Hibernate kết nối DB như thế nào
- Biết cách SQL được sinh ra
- Debug lỗi kết nối nhanh hơn
- Cấu hình hệ thống đúng chuẩn production

--- CÁCH GHI DỮ LIỆU FILE VÀO BLOB BẰNG BlobImpl TRONG JAVA (HIBERNATE)

GIẢI THÍCH CHI TIẾT NHẤT

CÁCH GHI DỮ LIỆU FILE VÀO BLOB BẰNG BlobImpl TRONG JAVA (HIBERNATE)

---------------------------------------------------------------------
I. BLOB LÀ GÌ?

BLOB (Binary Large Object) là kiểu dữ liệu trong database dùng để lưu:

- File
- Hình ảnh
- PDF
- Excel
- Video
- Dữ liệu nhị phân bất kỳ

Trong Java, BLOB tương ứng với:

java.sql.Blob

Trong Hibernate có class:

org.hibernate.engine.jdbc.BlobImpl
hoặc
org.hibernate.lob.BlobImpl (tùy version)

---------------------------------------------------------------------
II. MỤC TIÊU

Chúng ta muốn:

File trên máy → đọc thành byte[] → tạo BlobImpl → lưu vào database.

---------------------------------------------------------------------
III. LUỒNG THỰC HIỆN

File
   ↓
FileInputStream
   ↓
byte[]
   ↓
BlobImpl
   ↓
set vào entity
   ↓
session.save()
   ↓
commit
   ↓
database

---------------------------------------------------------------------
IV. BƯỚC 1 – MAP ENTITY VỚI BLOB

@Entity
@Table(name = "documents")
public class Document {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Lob
    @Column(name = "file_data")
    private Blob fileData;

    // getter / setter
}

@Lob giúp Hibernate hiểu đây là dữ liệu lớn (BLOB).

---------------------------------------------------------------------
V. BƯỚC 2 – ĐỌC FILE THÀNH byte[]

File file = new File("C:/test/sample.pdf");

FileInputStream fis = new FileInputStream(file);

byte[] fileBytes = new byte[(int) file.length()];

fis.read(fileBytes);
fis.close();

Lúc này fileBytes chứa toàn bộ dữ liệu nhị phân của file.

---------------------------------------------------------------------
VI. BƯỚC 3 – TẠO BlobImpl

Blob blob = new BlobImpl(fileBytes);

Hoặc tùy version:

Blob blob = Hibernate.getLobCreator(session)
                     .createBlob(fileBytes);

Lưu ý:
BlobImpl constructor nhận byte[].

---------------------------------------------------------------------
VII. BƯỚC 4 – SET VÀO ENTITY

Document doc = new Document();

doc.setFileData(blob);

---------------------------------------------------------------------
VIII. BƯỚC 5 – LƯU VÀO DATABASE

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

session.save(doc);

tx.commit();
session.close();

Sau khi commit, file sẽ được lưu vào cột BLOB trong database.

---------------------------------------------------------------------
IX. VÍ DỤ ĐẦY ĐỦ

Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

File file = new File("C:/test/sample.pdf");
FileInputStream fis = new FileInputStream(file);

byte[] bytes = new byte[(int) file.length()];
fis.read(bytes);
fis.close();

Blob blob = new BlobImpl(bytes);

Document doc = new Document();
doc.setFileData(blob);

session.save(doc);

tx.commit();
session.close();

---------------------------------------------------------------------
X. CÁCH TỐT HƠN TRONG HIBERNATE MỚI

Hibernate mới khuyến nghị:

@Lob
private byte[] fileData;

Không cần dùng BlobImpl.

Hibernate sẽ tự convert byte[] → BLOB.

Ví dụ:

@Lob
@Column(name = "file_data")
private byte[] fileData;

Sau đó:

doc.setFileData(bytes);

Đây là cách đơn giản và chuẩn hơn.

---------------------------------------------------------------------
XI. KHI NÀO NÊN DÙNG BlobImpl?

Chỉ khi:

- Hệ thống cũ
- Hibernate version rất cũ
- Cần xử lý java.sql.Blob trực tiếp

Trong hệ thống mới:
KHÔNG khuyến khích dùng BlobImpl.

---------------------------------------------------------------------
XII. LƯU Ý QUAN TRỌNG

1. Không load file quá lớn vào memory (dễ OutOfMemory)
2. Với file > vài chục MB nên dùng streaming
3. Database BLOB có giới hạn kích thước
4. BlobImpl giữ toàn bộ dữ liệu trong RAM

---------------------------------------------------------------------
XIII. SO SÁNH

Dùng BlobImpl:
- Phức tạp hơn
- Phụ thuộc version
- Ít dùng hiện nay

Dùng byte[] + @Lob:
- Đơn giản
- Chuẩn JPA
- Hibernate tự xử lý

---------------------------------------------------------------------
XIV. TÓM TẮT

Cách ghi file vào BLOB bằng BlobImpl:

1. Đọc file thành byte[]
2. Tạo BlobImpl(byte[])
3. Set vào entity
4. session.save()
5. commit

Nhưng cách hiện đại và khuyến nghị:

@Lob
private byte[] data;

Hibernate tự chuyển byte[] thành BLOB.

---------------------------------------------------------------------
KẾT LUẬN

BlobImpl là cách cũ để tạo Blob từ byte[].

Trong Hibernate hiện đại, bạn nên dùng:

@Lob + byte[]

để đơn giản, an toàn và đúng chuẩn JPA.

--- T24 TEMENOS

GIẢI THÍCH CHI TIẾT NHẤT VỀ T24 TEMENOS

---------------------------------------------------------------------
I. T24 TEMENOS LÀ GÌ?

T24 (hiện nay gọi là Temenos Transact) là hệ thống Core Banking
do công ty Temenos phát triển.

Temenos là một công ty phần mềm ngân hàng toàn cầu,
cung cấp giải pháp cho:

- Ngân hàng thương mại
- Ngân hàng số (Digital Bank)
- Ngân hàng bán lẻ
- Ngân hàng doanh nghiệp

T24 là một trong những hệ thống core banking phổ biến nhất thế giới.

---------------------------------------------------------------------
II. CORE BANKING LÀ GÌ?

Core Banking là hệ thống lõi của ngân hàng,
quản lý các nghiệp vụ chính như:

- Tài khoản (Account)
- Tiền gửi (Deposit)
- Cho vay (Loan)
- Thanh toán (Payment)
- Chuyển tiền (Transfer)
- Lãi suất
- Hạn mức tín dụng
- Khách hàng (Customer / CIF)

Tất cả giao dịch của ngân hàng đều phải đi qua core banking.

---------------------------------------------------------------------
III. TẠI SAO GỌI LÀ T24?

T24 là tên phiên bản đầu tiên của hệ thống.

Sau này Temenos đổi tên thành:

Temenos Transact

Nhưng nhiều ngân hàng vẫn gọi là T24.

---------------------------------------------------------------------
IV. KIẾN TRÚC CỦA T24

T24 có kiến trúc gồm:

1. Application Layer
2. Business Logic Layer
3. Database Layer

T24 chạy trên nền:

- Java
- JBoss / WebSphere
- Database: Oracle / DB2 / SQL Server

Ngoài ra T24 sử dụng nền tảng dữ liệu gọi là:

TAFJ (Temenos Application Framework for Java)
hoặc
TAFC (phiên bản cũ)

---------------------------------------------------------------------
V. CÁC MODULE CHÍNH TRONG T24

1. CUSTOMER (CIF)
   Quản lý thông tin khách hàng

2. ACCOUNT
   Quản lý tài khoản

3. DEPOSIT
   Quản lý tiền gửi

4. LOAN
   Quản lý khoản vay

5. PAYMENT
   Thanh toán

6. FUNDS TRANSFER
   Chuyển khoản

7. LIMIT
   Quản lý hạn mức

8. TREASURY
   Nghiệp vụ ngoại hối

Mỗi module là một application riêng trong T24.

---------------------------------------------------------------------
VI. OFS TRONG T24

OFS (Open Financial Services) là cơ chế để:

- Gửi giao dịch vào T24
- Tích hợp hệ thống ngoài với T24

Ví dụ:

Web application → gửi OFS → T24 xử lý → trả kết quả

OFS thường đi qua:

- Queue
- API
- Socket

---------------------------------------------------------------------
VII. CÁCH T24 XỬ LÝ GIAO DỊCH

Luồng xử lý:

Hệ thống ngoài
    ↓
Gửi OFS
    ↓
T24 nhận
    ↓
Validate
    ↓
Business Logic
    ↓
Ghi database
    ↓
Trả response

T24 có cơ chế:

- Authorize (4 mắt)
- Input
- Verify
- Commit

---------------------------------------------------------------------
VIII. ĐẶC ĐIỂM KỸ THUẬT

1. Multi-currency
2. Multi-branch
3. Real-time processing
4. Online transaction
5. Batch processing cuối ngày (EOD)

EOD (End Of Day) rất quan trọng trong ngân hàng.

---------------------------------------------------------------------
IX. T24 TRONG THỰC TẾ

Nhiều ngân hàng lớn sử dụng T24.

T24 thường được tích hợp với:

- Internet Banking
- Mobile Banking
- ATM
- CRM
- Payment Gateway

T24 đóng vai trò là hệ thống lõi trung tâm.

---------------------------------------------------------------------
X. CÁCH LẬP TRÌNH VỚI T24

Có 2 cách chính:

1. Lập trình nội bộ trong T24 (InfoBasic)
2. Tích hợp từ hệ thống ngoài qua OFS / API

Lập trình viên thường:

- Gửi OFS message
- Đọc response
- Xử lý giao dịch

---------------------------------------------------------------------
XI. T24 KHÁC GÌ SO VỚI DATABASE THƯỜNG?

T24 không chỉ là database.

Nó là:

- Hệ thống nghiệp vụ hoàn chỉnh
- Có rule ngân hàng
- Có kiểm soát giao dịch
- Có workflow phê duyệt

Bạn không được update DB trực tiếp.
Mọi thứ phải đi qua logic của T24.

---------------------------------------------------------------------
XII. CÁC KHÁI NIỆM THƯỜNG GẶP

1. VERSION
   Định nghĩa màn hình nhập liệu

2. ENQUIRY
   Màn hình tra cứu

3. APPLICATION
   Module nghiệp vụ

4. OFS.MESSAGE
   Giao dịch gửi vào T24

5. EOD
   Batch cuối ngày

---------------------------------------------------------------------
XIII. T24 DÙNG TRONG LẬP TRÌNH WEB

Ví dụ:

Web App (Java)
    ↓
Tạo OFS string
    ↓
Gửi qua queue hoặc socket
    ↓
T24 xử lý
    ↓
Trả response
    ↓
Hiển thị cho user

T24 không gọi trực tiếp bằng SQL.

---------------------------------------------------------------------
XIV. TẠI SAO T24 PHỔ BIẾN?

1. Phù hợp chuẩn ngân hàng quốc tế
2. Hỗ trợ nhiều quốc gia
3. Hỗ trợ nhiều loại tiền tệ
4. Có hệ sinh thái lớn
5. Tùy biến cao

---------------------------------------------------------------------
XV. TÓM TẮT NGẮN GỌN

T24 Temenos là:

- Hệ thống Core Banking
- Xử lý toàn bộ nghiệp vụ ngân hàng
- Tích hợp qua OFS
- Không thao tác trực tiếp database
- Có kiến trúc phức tạp và bảo mật cao

---------------------------------------------------------------------
KẾT LUẬN

T24 (Temenos Transact) là hệ thống lõi ngân hàng cực kỳ quan trọng.

Nếu bạn làm việc với T24, bạn không chỉ làm lập trình,
mà đang làm với:

- Hệ thống tài chính
- Quy trình ngân hàng
- Giao dịch tiền thật

Vì vậy phải hiểu rõ:

- OFS
- Workflow
- Authorization
- EOD
- Module nghiệp vụ

Đây là nền tảng quan trọng nếu bạn làm trong lĩnh vực ngân hàng.

--- NCR

GIẢI THÍCH CHI TIẾT NHẤT VỀ NCR

---------------------------------------------------------------------
I. NCR LÀ GÌ?

NCR là viết tắt của:

National Cash Register

Hiện nay tên chính thức là NCR Corporation.

Đây là một công ty công nghệ của Mỹ chuyên về:

- Hệ thống ATM
- Máy POS (Point of Sale)
- Giải pháp ngân hàng
- Phần mềm thanh toán
- Hệ thống bán lẻ

NCR là một trong những công ty lớn và lâu đời nhất trong lĩnh vực công nghệ tài chính.

---------------------------------------------------------------------
II. LỊCH SỬ HÌNH THÀNH

- Thành lập năm 1884 tại Mỹ
- Ban đầu sản xuất máy tính tiền cơ học (cash register)
- Sau đó phát triển sang ATM và hệ thống ngân hàng

NCR là một trong những hãng sản xuất ATM lớn nhất thế giới.

---------------------------------------------------------------------
III. NCR TRONG NGÂN HÀNG LÀ GÌ?

Trong môi trường ngân hàng, khi nói đến NCR thường là nói đến:

1. Hệ thống ATM NCR
2. Switch ATM
3. Phần mềm điều khiển ATM
4. Hệ thống xử lý giao dịch ATM

Ví dụ:

Khi khách hàng rút tiền:

ATM NCR → gửi giao dịch → Core Banking → trả kết quả → ATM nhả tiền

---------------------------------------------------------------------
IV. NCR ATM

NCR cung cấp:

- Máy ATM vật lý
- Phần mềm điều khiển ATM
- Giải pháp quản lý ATM từ xa

Các thành phần chính của ATM NCR:

1. Card Reader
2. Cash Dispenser
3. Printer
4. Encrypt PIN Pad
5. Controller

---------------------------------------------------------------------
V. NCR TRONG TÍCH HỢP HỆ THỐNG

Trong hệ thống ngân hàng:

ATM NCR
   ↓
Switch ATM
   ↓
Core Banking (ví dụ T24)
   ↓
Trả kết quả

NCR không phải core banking.
Nó là hệ thống đầu cuối (front-end device).

---------------------------------------------------------------------
VI. NCR TRONG LẬP TRÌNH

Nếu bạn làm lập trình trong ngân hàng,
NCR có thể xuất hiện ở:

1. Tích hợp ATM
2. Xử lý ISO8583 message
3. Giao tiếp switch ATM
4. Log giao dịch ATM

Bạn có thể thấy:

- Message từ ATM
- Log NCR
- Transaction NCR

---------------------------------------------------------------------
VII. NCR KHÔNG CHỈ LÀ ATM

Ngoài ATM, NCR còn cung cấp:

1. POS cho cửa hàng bán lẻ
2. Self-checkout machine
3. Kiosk tự phục vụ
4. Phần mềm thanh toán

---------------------------------------------------------------------
VIII. NCR TRONG HỆ SINH THÁI NGÂN HÀNG

Trong một hệ thống hoàn chỉnh:

ATM NCR
    ↓
Switch (ví dụ Base24, Postilion)
    ↓
Core Banking (ví dụ T24)
    ↓
Database

NCR nằm ở lớp thiết bị đầu cuối.

---------------------------------------------------------------------
IX. KHÁI NIỆM LIÊN QUAN

1. ISO8583
   Chuẩn message giao dịch ATM

2. Switch
   Hệ thống trung gian xử lý giao dịch ATM

3. Core Banking
   Hệ thống lõi xử lý tài khoản

NCR chủ yếu xử lý phần ATM và thiết bị.

---------------------------------------------------------------------
X. TRONG THỰC TẾ CÔNG VIỆC

Nếu bạn nghe:

- Lỗi NCR
- Log NCR
- Transaction NCR
- File reconciliation NCR

Thường liên quan đến giao dịch ATM.

Ví dụ:

ATM NCR gửi giao dịch rút tiền
Core Banking approve
ATM NCR phát tiền
Giao dịch được ghi log

---------------------------------------------------------------------
XI. NCR KHÁC GÌ SO VỚI CORE BANKING?

NCR:
- Thiết bị và phần mềm ATM
- Front-end

Core Banking:
- Xử lý tài khoản
- Xử lý tiền thật
- Back-end

---------------------------------------------------------------------
XII. TÓM TẮT NGẮN GỌN

NCR là:

- Công ty công nghệ Mỹ
- Sản xuất ATM và hệ thống thanh toán
- Phổ biến trong ngân hàng
- Không phải core banking
- Là thiết bị đầu cuối giao dịch

---------------------------------------------------------------------
KẾT LUẬN

Trong môi trường ngân hàng,
khi nói đến NCR thường là nói đến:

Hệ thống ATM và giải pháp giao dịch ATM.

Nếu bạn làm trong ngân hàng và nghe đến NCR,
gần như chắc chắn bạn đang nói về hệ thống ATM
hoặc giao dịch liên quan đến ATM.

--- UTF-8 CHO HTML

GIẢI THÍCH CHI TIẾT NHẤT VỀ UTF-8 CHO HTML

---------------------------------------------------------------------
I. UTF-8 LÀ GÌ?

UTF-8 (Unicode Transformation Format - 8 bit) là một chuẩn mã hóa ký tự
dùng để biểu diễn văn bản dưới dạng byte trong máy tính.

UTF-8 thuộc hệ Unicode và có khả năng biểu diễn:

- Tất cả ngôn ngữ trên thế giới
- Tiếng Việt có dấu
- Tiếng Trung, Nhật, Hàn
- Emoji
- Ký hiệu đặc biệt

UTF-8 hiện là chuẩn mã hóa phổ biến nhất trên Internet.

---------------------------------------------------------------------
II. TẠI SAO HTML CẦN UTF-8?

HTML là văn bản.
Trình duyệt cần biết:

File này đang được mã hóa theo chuẩn nào?

Nếu không khai báo đúng encoding:

- Tiếng Việt bị lỗi font
- Ký tự hiển thị sai (????)
- Dấu bị biến dạng

Ví dụ lỗi thường gặp:

Tiếng Việt → Tiáº¿ng Viá»‡t

Đó là do sai encoding.

---------------------------------------------------------------------
III. CÁCH KHAI BÁO UTF-8 TRONG HTML

Cách chuẩn và hiện đại:

<meta charset="UTF-8">

Phải đặt trong thẻ <head> và càng gần đầu càng tốt.

Ví dụ:

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Trang web</title>
</head>
<body>
    Xin chào Việt Nam
</body>
</html>

---------------------------------------------------------------------
IV. CÁCH KHAI BÁO CŨ (HTML4)

Trước đây dùng:

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

Hiện nay không còn khuyến nghị.
Nên dùng:

<meta charset="UTF-8">

---------------------------------------------------------------------
V. CÁCH HOẠT ĐỘNG

Khi trình duyệt đọc file HTML:

1. Đọc thẻ meta charset
2. Biết file được mã hóa theo UTF-8
3. Giải mã byte thành ký tự đúng

Nếu không có meta charset:

Trình duyệt sẽ đoán encoding → dễ sai.

---------------------------------------------------------------------
VI. UTF-8 HOẠT ĐỘNG NHƯ THẾ NÀO?

UTF-8 dùng từ 1 đến 4 byte cho mỗi ký tự:

- Ký tự ASCII (A, B, C, 1, 2, 3) → 1 byte
- Tiếng Việt → 2 hoặc 3 byte
- Emoji → 4 byte

Ưu điểm:

- Tương thích ASCII
- Tiết kiệm dung lượng
- Chuẩn quốc tế

---------------------------------------------------------------------
VII. UTF-8 TRONG SERVER (RẤT QUAN TRỌNG)

Ngoài HTML, server cũng phải cấu hình UTF-8.

Ví dụ trong Java Servlet:

response.setContentType("text/html; charset=UTF-8");
request.setCharacterEncoding("UTF-8");

Nếu chỉ set trong HTML mà không set ở server,
form submit có thể bị lỗi tiếng Việt.

---------------------------------------------------------------------
VIII. UTF-8 TRONG FORM SUBMIT

Khi submit form:

<form method="post" accept-charset="UTF-8">

Nếu không set đúng:

Dữ liệu gửi lên server có thể bị lỗi ký tự.

---------------------------------------------------------------------
IX. UTF-8 VÀ DATABASE

Database cũng phải dùng UTF-8.

Ví dụ MySQL:

CHARACTER SET utf8mb4

Nếu database không phải UTF-8:

Lưu tiếng Việt sẽ lỗi hoặc mất dấu.

---------------------------------------------------------------------
X. UTF-8 VÀ FILE HTML

Ngoài khai báo meta,
file HTML phải được lưu dưới dạng UTF-8.

Trong IDE (IntelliJ, Eclipse, VS Code):

Save with encoding UTF-8.

Nếu file lưu dạng ANSI mà khai báo UTF-8,
vẫn bị lỗi.

---------------------------------------------------------------------
XI. UTF-8 VS UTF-8-BOM

Có 2 dạng:

1. UTF-8
2. UTF-8 with BOM

BOM = Byte Order Mark

Trong web, nên dùng:

UTF-8 không BOM

Vì BOM có thể gây lỗi header trong một số trường hợp.

---------------------------------------------------------------------
XII. LỖI THƯỜNG GẶP

1. Quên khai báo <meta charset="UTF-8">
2. Server không set UTF-8
3. Database không dùng UTF-8
4. File lưu sai encoding

Kết quả:

- Tiếng Việt bị lỗi
- Ký tự hiển thị sai
- Form submit lỗi

---------------------------------------------------------------------
XIII. TÓM TẮT NGẮN GỌN

UTF-8 cho HTML là:

- Chuẩn mã hóa ký tự
- Giúp hiển thị đúng tiếng Việt và mọi ngôn ngữ
- Phải khai báo bằng:

<meta charset="UTF-8">

- Phải đồng bộ giữa:
  HTML
  Server
  Database
  File encoding

---------------------------------------------------------------------
KẾT LUẬN

UTF-8 là tiêu chuẩn bắt buộc trong lập trình web hiện đại.

Nếu làm web mà không hiểu encoding,
bạn sẽ gặp lỗi tiếng Việt rất khó debug.

Luôn đảm bảo:

1. HTML khai báo UTF-8
2. Server set UTF-8
3. Database dùng UTF-8
4. File lưu UTF-8

Khi đó hệ thống sẽ xử lý ký tự chính xác và ổn định.

--- TRONG DU AN SPRING MVC, KHI CO LOI TOI XEM LOG O DAU?

GIAI THICH CHI TIET:
TRONG DU AN SPRING MVC, KHI CO LOI TOI XEM LOG O DAU?

1. TONG QUAN

Trong du an Spring MVC, khi xay ra loi (exception, bug, loi cau hinh, loi database, loi 404, 500, NullPointerException, v.v.), thong tin loi se duoc ghi (log) ra mot trong cac noi sau:

- Console (man hinh khi chay server)
- File log tren o dia
- Log cua application server (Tomcat, Jetty, v.v.)
- Log cua IDE (IntelliJ, Eclipse)
- Log he thong (neu deploy len server Linux/Windows)

Noi xem log phu thuoc vao:
- Ban chay bang cach nao (run tu IDE hay deploy WAR)
- Ban dung server nao (Tomcat embed hay Tomcat ngoai)
- Ban cau hinh logging framework gi (Log4j, Logback, JUL, v.v.)

----------------------------------------------------------------

2. TRUONG HOP 1: CHAY SPRING MVC TU IDE (IntelliJ / Eclipse)

Neu ban:
- Run project bang Tomcat embed
hoac
- Run bang "Run as Spring Boot App"

Thi xem log o:

=> TAB CONSOLE trong IDE

Cach xem:
- IntelliJ: tab "Run" hoac "Console"
- Eclipse: tab "Console"

Moi loi se in stacktrace tai day.

Vi du:
java.lang.NullPointerException
    at com.example.controller.UserController.save(UserController.java:45)

Ban chi can scroll len de xem.

----------------------------------------------------------------

3. TRUONG HOP 2: DEPLOY FILE WAR LEN TOMCAT NGOAI

Neu ban build ra file WAR va deploy len Tomcat:

3.1 Xem log trong thu muc logs cua Tomcat

Thu muc:
TOMCAT_HOME/logs/

Ben trong se co cac file:

- catalina.out
- catalina.YYYY-MM-DD.log
- localhost.YYYY-MM-DD.log
- manager.YYYY-MM-DD.log

Quan trong nhat:
=> catalina.out (Linux)
=> catalina.<date>.log (Windows)

Day la noi chua:
- Stacktrace exception
- Loi 500
- Loi bean
- Loi database
- Loi Spring MVC

----------------------------------------------------------------

4. TRUONG HOP 3: NEU DUNG SPRING BOOT (EMBEDDED TOMCAT)

Neu la Spring Boot:

Mac dinh log se in ra:
=> Console

Neu ban cau hinh ghi file log trong application.properties:

Vi du:
logging.file.name=app.log

Thi log se nam o:
=> thu muc goc project (noi chay file jar)

Neu deploy jar len server Linux:
=> log nam o cung thu muc voi file jar

----------------------------------------------------------------

5. NEU CO CAU HINH LOG4J / LOGBACK

Trong project Spring MVC thuong co:

- log4j.properties
- log4j2.xml
- logback.xml

Trong do co dong:

<appender name="FILE" ...>
    <file>logs/app.log</file>

Luc nay:
=> log se nam trong thu muc logs/

Neu la duong dan tuong doi:
=> no tinh tu thu muc root khi chay server

Ban can doc file cau hinh logging de biet log nam o dau.

----------------------------------------------------------------

6. PHAN BIET CAC LOAI LOI VA NOI XEM

6.1 Loi 404 (Not Found)
- Co the khong in stacktrace
- Xem trong console hoac catalina log

6.2 Loi 500 (Internal Server Error)
- Se co stacktrace trong log
- Xem console hoac catalina

6.3 Loi Bean Creation
- Xay ra khi start server
- Xem console ngay khi khoi dong

6.4 Loi SQL / Database
- Xem stacktrace trong log
- Neu dung Hibernate se co SQL log

----------------------------------------------------------------

7. NEU KHONG THAY LOG

Neu ban khong thay gi:

Kiem tra:

- Logging level co dang INFO khong?
- Co de logging.level.root=ERROR khong?
- Co tat log khong?
- Server co start thanh cong khong?

Thu them:
logging.level.root=DEBUG

----------------------------------------------------------------

8. TOM LAI – TRA LOI NGAN GON

Trong du an Spring MVC, khi co loi thi ban xem log o:

1) Neu chay tu IDE:
   => Xem tab Console

2) Neu deploy len Tomcat:
   => TOMCAT_HOME/logs/catalina.out

3) Neu dung Spring Boot:
   => Console hoac file log neu da cau hinh

4) Neu co log4j/logback:
   => Xem duong dan file trong file cau hinh logging

----------------------------------------------------------------

9. KINH NGHIEM THUC TE

- 90% truong hop: loi nam trong Console
- Neu deploy server that: vao thu muc logs cua server
- Neu deploy len Linux: dung lenh:
  tail -f catalina.out
  de xem log realtime

----------------------------------------------------------------

10. KET LUAN

Spring MVC khong tu tao mot noi log rieng.
No su dung logging framework.

Vi vay:
Ban phai xac dinh:

- Ung dung dang chay o dau?
- Server nao?
- Logging framework nao?
- File cau hinh log ghi o dau?

Sau do vao dung noi de xem log.

--- LENH SQL DE THIET LAP COT A CO THE NHAN GIA TRI NULL

GIAI THICH CHI TIET:
LENH SQL DE THIET LAP COT A CO THE NHAN GIA TRI NULL

====================================================================

1. KHÁI NIỆM NULL TRONG SQL

- NULL la gia tri dac biet trong SQL.
- NULL khong phai la 0.
- NULL khong phai la chuoi rong ''.
- NULL co nghia la: khong co gia tri / chua duoc xac dinh.

Khi mot cot cho phep NULL, nghia la:
- Ban co the INSERT ma khong can cung cap gia tri cho cot do.
- Hoac ban co the gan truc tiep gia tri NULL.

====================================================================

2. THIET LAP COT CHO PHEP NULL KHI TAO BANG

Cu phap tong quat:

CREATE TABLE ten_bang (
    a kieu_du_lieu NULL
);

Vi du:

CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100) NULL
);

O day:
- Cot name duoc phep NULL.
- Neu khong ghi gi, trong nhieu he quan tri CSDL, mac dinh la cho phep NULL.

====================================================================

3. THAY DOI COT DA TON TAI DE CHO PHEP NULL

Truong hop bang da ton tai, muon sua cot a de cho phep NULL.

Tuy thuoc vao he quan tri CSDL.

--------------------------------------------------------------------
3.1 DOI VOI MYSQL

Cu phap:

ALTER TABLE ten_bang
MODIFY a kieu_du_lieu NULL;

Vi du:

ALTER TABLE users
MODIFY name VARCHAR(100) NULL;

Luu y:
- Phai ghi lai kieu du lieu day du.
- Neu truoc do la NOT NULL, lenh tren se bo rang buoc NOT NULL.

--------------------------------------------------------------------
3.2 DOI VOI SQL SERVER

Cu phap:

ALTER TABLE ten_bang
ALTER COLUMN a kieu_du_lieu NULL;

Vi du:

ALTER TABLE users
ALTER COLUMN name VARCHAR(100) NULL;

--------------------------------------------------------------------
3.3 DOI VOI ORACLE

Oracle mac dinh cho phep NULL.
Neu muon bo NOT NULL:

ALTER TABLE ten_bang
MODIFY (a kieu_du_lieu NULL);

Vi du:

ALTER TABLE users
MODIFY (name VARCHAR2(100) NULL);

--------------------------------------------------------------------
3.4 DOI VOI POSTGRESQL

Cu phap:

ALTER TABLE ten_bang
ALTER COLUMN a DROP NOT NULL;

Vi du:

ALTER TABLE users
ALTER COLUMN name DROP NOT NULL;

====================================================================

4. KIEM TRA COT CO CHO PHEP NULL HAY KHONG

Ban co the dung:

DESCRIBE users;          (MySQL)
sp_help users;           (SQL Server)
\d users                 (PostgreSQL)

Hoac truy van INFORMATION_SCHEMA:

SELECT column_name, is_nullable
FROM information_schema.columns
WHERE table_name = 'users';

====================================================================

5. CAC LOI CO THE GAP

5.1 Neu cot dang la PRIMARY KEY
=> Khong the cho phep NULL.
Vi PRIMARY KEY mac dinh la NOT NULL.

5.2 Neu cot dang co FOREIGN KEY
=> Can kiem tra rang buoc lien quan.

5.3 Neu cot dang co CHECK constraint
=> Co the can xem lai rang buoc.

====================================================================

6. PHAN BIET NULL

--- KHI NAO DUNG BufferedReader TRONG JAVA

KHI NAO DUNG BufferedReader TRONG JAVA

1. BufferedReader la gi?

BufferedReader la mot lop (class) trong java.io, duoc thiet ke de doc du lieu dang ky tu (character stream) mot cach hieu qua hon thong qua co che bo dem (buffer).

No thuong duoc dung ket hop voi:
- FileReader (doc file text)
- InputStreamReader (doc tu InputStream va chuyen byte sang ky tu)
- System.in (doc du lieu nguoi dung nhap tu ban phim)

Vi du:
BufferedReader br = new BufferedReader(new FileReader("data.txt"));

------------------------------------------------------------

2. Ban chat cua BufferedReader

Thong thuong, neu ban doc du lieu tung ky tu mot (read()), moi lan goi se phai truy cap he thong I/O (rat cham).

BufferedReader se:
- Doc mot khoi du lieu lon vao bo dem (vi du 8KB)
- Sau do tra ve tung ky tu hoac tung dong tu bo dem trong RAM
=> Giam so lan truy cap I/O
=> Tang hieu nang dang ke

------------------------------------------------------------

3. Khi nao nen dung BufferedReader?

3.1 Khi doc file text co kich thuoc lon

Neu ban doc file log, file CSV, file XML, file TXT lon:
-> Nen dung BufferedReader de tang toc do

Vi du:
- Doc file log server
- Doc file cau hinh
- Doc file import du lieu

------------------------------------------------------------

3.2 Khi can doc tung dong (line-by-line)

BufferedReader cung cap:
String line = br.readLine();

Day la ly do quan trong nhat de dung BufferedReader.

Ban nen dung BufferedReader khi:
- Muon doc tung dong
- Xu ly tung dong mot
- Can tach chuoi theo tung line

Vi du:
while ((line = br.readLine()) != null) {
    // xu ly tung dong
}

------------------------------------------------------------

3.3 Khi doc du lieu tu console (System.in)

Thay vi dung:
Scanner scanner = new Scanner(System.in);

Ban co the dung:
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

BufferedReader nhanh hon Scanner vi:
- Scanner co xu ly regex
- BufferedReader chi doc raw text

Dung BufferedReader khi:
- Can toc do nhanh
- Khong can parse phuc tap
- Chi can doc chuoi

------------------------------------------------------------

3.4 Khi muon toi uu hieu nang I/O

Trong cac he thong:
- Doc file lon
- Xu ly du lieu hang loat
- He thong server
- Xu ly log
- Xu ly du lieu batch

=> Nen dung BufferedReader thay vi FileReader don thuan.

------------------------------------------------------------

4. Khi nao KHONG nen dung BufferedReader?

4.1 Khi lam viec voi binary file

BufferedReader chi dung cho text (character stream).

Khong dung cho:
- Anh
- File PDF
- File zip
- File nhi phan

Khi do nen dung:
- BufferedInputStream
- FileInputStream

------------------------------------------------------------

4.2 Khi can parse du lieu truc tiep thanh so

Neu ban can:
- parse int
- parse double
- tach token

Scanner tien loi hon vi co:
scanner.nextInt()
scanner.nextDouble()

------------------------------------------------------------

4.3 Khi su dung NIO (java.nio)

Trong cac ung dung hien dai, ban co the dung:

Files.newBufferedReader(path)

Hoac dung Stream API:
Files.lines(path)

Khi do khong can tao BufferedReader thu cong.

------------------------------------------------------------

5. So sanh BufferedReader va FileReader

FileReader:
- Doc tung ky tu
- Khong co bo dem rieng
- Cham hon neu doc file lon

BufferedReader:
- Co bo dem
- Co readLine()
- Nhanh hon

Tot nhat:
Khong dung FileReader truc tiep
Nen boc no bang BufferedReader.

------------------------------------------------------------

6. So sanh BufferedReader va Scanner

BufferedReader:
- Nhanh hon
- Khong parse san
- Chi doc chuoi
- Phu hop xu ly file lon

Scanner:
- Cham hon
- Tien loi
- Co nextInt(), nextDouble()
- Phu hop input don gian

------------------------------------------------------------

7. Tom tat khi nao dung BufferedReader

Nen dung BufferedReader khi:

✓ Doc file text
✓ Doc file lon
✓ Can doc tung dong
✓ Can hieu nang cao
✓ Xu ly log
✓ Xu ly batch
✓ Doc tu InputStream va chuyen sang text

Khong dung khi:

✗ Xu ly file nhi phan
✗ Can parse so truc tiep (uu tien Scanner)
✗ Dung NIO API hien dai thay the

------------------------------------------------------------

8. Ket luan

BufferedReader duoc dung khi:
- Ban lam viec voi text
- Ban muon doc tung dong
- Ban can toi uu hieu nang I/O
- Ban muon giam so lan truy cap he thong

No la lua chon tot nhat cho:
Doc file text lon va xu ly du lieu tung dong mot.

Neu lam viec voi he thong backend, xu ly file, log, import du lieu,
BufferedReader gan nhu la lua chon mac dinh.

--- KHI NÀO DÙNG FileInputStream, KHI NÀO DÙNG FileReader

KHI NÀO DÙNG FileInputStream, KHI NÀO DÙNG FileReader

I. TỔNG QUAN

Trong Java, cả FileInputStream và FileReader đều dùng để đọc dữ liệu từ file,
nhưng chúng phục vụ hai mục đích hoàn toàn khác nhau:

- FileInputStream  -> đọc dữ liệu dạng BYTE (nhị phân)
- FileReader       -> đọc dữ liệu dạng CHARACTER (ký tự văn bản)

Hiểu đơn giản:

FileInputStream = làm việc với dữ liệu thô (raw bytes)
FileReader      = làm việc với văn bản (text)

------------------------------------------------------

II. KHI NÀO DÙNG FileInputStream

Dùng FileInputStream khi:

1) File chứa dữ liệu nhị phân (binary file)
   Ví dụ:
   - file ảnh (.jpg, .png)
   - file PDF
   - file Word, Excel
   - file zip
   - file âm thanh, video

2) Khi bạn cần xử lý dữ liệu ở mức byte
   Ví dụ:
   - upload file
   - mã hóa (encryption)
   - tính checksum
   - truyền file qua mạng
   - copy file nhị phân

3) Khi bạn không quan tâm đến encoding ký tự

Ví dụ:

FileInputStream fis = new FileInputStream("image.jpg");
int data;
while ((data = fis.read()) != -1) {
    // xử lý từng byte
}

Hoặc:

byte[] buffer = new byte[1024];
int bytesRead = fis.read(buffer);

------------------------------------------------------

III. KHI NÀO DÙNG FileReader

Dùng FileReader khi:

1) File là file văn bản (text file)
   Ví dụ:
   - .txt
   - .csv
   - .xml
   - .html
   - .json
   - .properties
   - source code (.java, .js...)

2) Khi bạn muốn đọc theo ký tự (char) thay vì byte

3) Khi bạn xử lý nội dung text:
   - đọc từng dòng
   - tìm kiếm chuỗi
   - parse dữ liệu văn bản

Ví dụ:

FileReader fr = new FileReader("data.txt");
int ch;
while ((ch = fr.read()) != -1) {
    System.out.print((char) ch);
}

Thực tế thường dùng kèm BufferedReader:

BufferedReader br = new BufferedReader(new FileReader("data.txt"));
String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

------------------------------------------------------

IV. SỰ KHÁC BIỆT CỐT LÕI

1) Kiểu dữ liệu đọc

FileInputStream  -> đọc byte (8 bit)
FileReader       -> đọc char (16 bit - Unicode)

2) Có xử lý encoding không?

FileInputStream  -> KHÔNG
FileReader       -> CÓ (dựa vào encoding mặc định của hệ thống)

3) Rủi ro khi dùng sai

Nếu dùng FileReader để đọc file nhị phân:
=> file sẽ bị lỗi dữ liệu (corrupted)

Nếu dùng FileInputStream để đọc text:
=> vẫn đọc được, nhưng phải tự convert byte -> String
=> dễ lỗi encoding

------------------------------------------------------

V. VẤN ĐỀ ENCODING (RẤT QUAN TRỌNG)

FileReader sử dụng encoding mặc định của hệ điều hành.

Ví dụ:
- Windows có thể là Cp1252
- Linux thường là UTF-8

Điều này có thể gây lỗi font tiếng Việt.

Giải pháp tốt hơn:

KHÔNG nên dùng FileReader trực tiếp nếu cần kiểm soát encoding.

Thay vào đó dùng:

InputStreamReader + FileInputStream

Ví dụ chuẩn hơn:

FileInputStream fis = new FileInputStream("data.txt");
InputStreamReader isr = new InputStreamReader(fis, "UTF-8");
BufferedReader br = new BufferedReader(isr);

=> Cách này kiểm soát được encoding.

------------------------------------------------------

VI. SO SÁNH THỰC TẾ

Tình huống 1:
Đọc file ảnh để upload
=> DÙNG FileInputStream

Tình huống 2:
Đọc file config.properties
=> DÙNG FileReader (hoặc InputStreamReader UTF-8)

Tình huống 3:
Đọc file CSV để parse dữ liệu
=> DÙNG FileReader hoặc BufferedReader

Tình huống 4:
Copy file PDF
=> DÙNG FileInputStream

------------------------------------------------------

VII. SƠ ĐỒ NHỚ NHANH

File là TEXT?
    YES -> FileReader (hoặc InputStreamReader)
    NO  -> FileInputStream

Bạn có cần kiểm soát encoding?
    YES -> FileInputStream + InputStreamReader
    NO  -> FileReader

------------------------------------------------------

VIII. KẾT LUẬN NGẮN GỌN

FileInputStream:
- Dùng cho dữ liệu nhị phân
- Làm việc ở mức byte
- Không xử lý encoding

FileReader:
- Dùng cho file văn bản
- Làm việc ở mức ký tự
- Có phụ thuộc encoding hệ thống

------------------------------------------------------

IX. LỜI KHUYÊN THỰC TẾ CHO LẬP TRÌNH WEB

Trong lập trình web:

- Upload file  -> FileInputStream
- Đọc file log -> BufferedReader
- Đọc config   -> InputStreamReader (UTF-8)
- Đọc JSON/XML -> thường dùng Reader

Trong môi trường production:
Hạn chế dùng FileReader trực tiếp.
Ưu tiên dùng InputStreamReader với encoding rõ ràng (UTF-8).

------------------------------------------------------

TÓM LẠI MỘT CÂU:

FileInputStream dùng cho BINARY.
FileReader dùng cho TEXT.
Nếu cần kiểm soát encoding -> dùng InputStreamReader.

--- ĐỌC FILE EXCEL TA DÙNG GÌ TRONG JAVA?

ĐỌC FILE EXCEL TA DÙNG GÌ TRONG JAVA?

I. CÂU TRẢ LỜI NGẮN GỌN

KHÔNG dùng:
- FileReader
- BufferedReader
- Scanner

Vì file Excel là file NHỊ PHÂN (binary), không phải file text.

Ta phải dùng:
- FileInputStream
- Thư viện Apache POI

------------------------------------------------------

II. VÌ SAO KHÔNG DÙNG FileReader?

File Excel (.xls, .xlsx) không phải văn bản thuần.
Nó chứa dữ liệu nhị phân (binary format).

Nếu dùng:

FileReader fr = new FileReader("data.xlsx");

=> sẽ bị lỗi
=> hoặc đọc ra ký tự rác
=> vì Excel không phải text

Do đó phải đọc ở mức BYTE.

------------------------------------------------------

III. THƯ VIỆN PHỔ BIẾN ĐỂ ĐỌC EXCEL

Trong Java, thư viện chuẩn và phổ biến nhất là:

Apache POI

Apache POI hỗ trợ:
- .xls  (Excel 2003 trở xuống)
- .xlsx (Excel 2007 trở lên)

------------------------------------------------------

IV. PHÂN BIỆT .XLS VÀ .XLSX

1) .xls
   - Định dạng cũ
   - Dùng HSSFWorkbook

2) .xlsx
   - Định dạng mới
   - Dùng XSSFWorkbook

------------------------------------------------------

V. CÁCH ĐỌC FILE EXCEL (.xlsx) CHUẨN

Bước 1: Tạo FileInputStream

FileInputStream fis = new FileInputStream("data.xlsx");

Bước 2: Tạo Workbook

XSSFWorkbook workbook = new XSSFWorkbook(fis);

Bước 3: Lấy Sheet

XSSFSheet sheet = workbook.getSheetAt(0);

Bước 4: Duyệt từng dòng

for (Row row : sheet) {
    for (Cell cell : row) {
        System.out.print(cell.toString() + " ");
    }
    System.out.println();
}

------------------------------------------------------

VI. CẤU TRÚC OBJECT TRONG EXCEL (POI)

Workbook
   -> Sheet
       -> Row
           -> Cell

Hiểu như sau:

Workbook = toàn bộ file Excel
Sheet    = từng tab
Row      = từng dòng
Cell     = từng ô

------------------------------------------------------

VII. ĐỌC ĐÚNG THEO KIỂU DỮ LIỆU CELL

Cell trong Excel có thể là:

- STRING
- NUMERIC
- BOOLEAN
- FORMULA
- BLANK

Ví dụ xử lý chuẩn:

switch (cell.getCellType()) {
    case STRING:
        value = cell.getStringCellValue();
        break;
    case NUMERIC:
        value = cell.getNumericCellValue();
        break;
    case BOOLEAN:
        value = cell.getBooleanCellValue();
        break;
}

------------------------------------------------------

VIII. TRƯỜNG HỢP FILE .XLS (CŨ)

FileInputStream fis = new FileInputStream("data.xls");
HSSFWorkbook workbook = new HSSFWorkbook(fis);

Khác mỗi class Workbook.

------------------------------------------------------

IX. TRONG LẬP TRÌNH WEB (UPLOAD EXCEL)

Khi người dùng upload file Excel:

1) Nhận InputStream từ request
2) Truyền vào XSSFWorkbook

Ví dụ:

InputStream is = file.getInputStream();
XSSFWorkbook workbook = new XSSFWorkbook(is);

Không cần tạo FileInputStream nếu đọc trực tiếp từ upload.

------------------------------------------------------

X. TÓM TẮT NÊN DÙNG GÌ

Đọc file Excel trong Java:

BẮT BUỘC:
- Dùng FileInputStream (hoặc InputStream)
- Dùng thư viện Apache POI

KHÔNG BAO GIỜ:
- Dùng FileReader
- Dùng BufferedReader
- Dùng Scanner

------------------------------------------------------

XI. TƯ DUY HỆ THỐNG QUAN TRỌNG

Quy tắc nhớ:

File TEXT  -> Reader (FileReader, BufferedReader)
File BINARY -> InputStream (FileInputStream)

Excel = BINARY
=> Phải dùng InputStream

------------------------------------------------------

XII. KẾT LUẬN CUỐI CÙNG

Đọc file Excel trong Java ta dùng:

FileInputStream + Apache POI

Vì Excel là file nhị phân,
không thể đọc bằng Reader được.

--- CÁC THUẬT NGỮ HAY DÙNG TRONG LẬP TRÌNH DOMAIN NGÂN HÀNG

CÁC THUẬT NGỮ HAY DÙNG TRONG LẬP TRÌNH DOMAIN NGÂN HÀNG
(giải thích theo góc nhìn kỹ thuật + nghiệp vụ)

========================================================
I. BÚT TOÁN (Accounting Entry)

1) Khái niệm

Bút toán là một bản ghi kế toán ghi nhận sự thay đổi số dư
giữa các tài khoản.

Trong ngân hàng, mọi giao dịch cuối cùng đều được quy về bút toán.

2) Đặc điểm quan trọng

- Luôn có ít nhất 2 vế:
    + Nợ (Debit)
    + Có (Credit)

- Tổng Nợ = Tổng Có (nguyên tắc cân bằng)

3) Trong hệ thống phần mềm

Một giao dịch chuyển tiền 1 triệu có thể tạo ra:

- 1 bút toán trừ tiền tài khoản A
- 1 bút toán cộng tiền tài khoản B

Hoặc phức tạp hơn:
- trừ tài khoản khách hàng
- cộng tài khoản trung gian
- cộng tài khoản phí
- cộng tài khoản thu nhập ngân hàng

=> Một giao dịch nghiệp vụ có thể sinh ra nhiều bút toán.

4) Trong database thường có:

- bảng transaction (giao dịch nghiệp vụ)
- bảng accounting_entry (bút toán)
- bảng account_balance (số dư)

========================================================
II. ĐỐI SOÁT (Reconciliation)

1) Khái niệm

Đối soát là quá trình so sánh dữ liệu giữa hai hệ thống
để đảm bảo số liệu khớp nhau.

2) Ví dụ

- Ngân hàng đối soát với:
    + Ví điện tử
    + Cổng thanh toán
    + Tổ chức thẻ (Visa/Master)
    + Hệ thống core banking khác

3) Mục tiêu

- Phát hiện giao dịch lệch
- Phát hiện thiếu tiền
- Phát hiện trùng lặp

4) Trong lập trình

Thường có:

- file đối soát (file batch cuối ngày)
- job chạy định kỳ (cron job)
- bảng reconciliation_log

========================================================
III. GIAO DỊCH (Transaction)

1) Nghĩa nghiệp vụ

Một hành động tài chính:
- chuyển tiền
- thanh toán
- nạp tiền
- rút tiền

2) Nghĩa kỹ thuật (database transaction)

ACID:
- Atomicity
- Consistency
- Isolation
- Durability

Trong ngân hàng:
Tính Atomic là cực kỳ quan trọng.
Không được phép trừ tiền mà không cộng tiền.

========================================================
IV. SỐ DƯ (Balance)

1) Số dư khả dụng (Available Balance)

Số tiền khách hàng có thể sử dụng ngay.

2) Số dư sổ cái (Ledger Balance)

Số tiền đã ghi nhận kế toán,
có thể bao gồm khoản đang chờ xử lý.

Trong hệ thống thường lưu:
- balance
- available_balance
- hold_amount

========================================================
V. PHONG TỎA (Hold / Freeze)

Là việc giữ lại một khoản tiền tạm thời,
không cho khách hàng sử dụng.

Ví dụ:
- Thanh toán thẻ khách sạn
- Đặt vé máy bay

Trong hệ thống:
- không trừ tiền thật
- chỉ tăng hold_amount

========================================================
VI. HOÀN TIỀN (Refund)

Giao dịch trả lại tiền cho khách hàng.

Có thể:
- hoàn toàn phần tiền
- hoàn một phần

Trong hệ thống thường tạo:
- một giao dịch mới
- một bộ bút toán ngược

========================================================
VII. ĐẢO GIAO DỊCH (Reversal)

Khác với refund.

Reversal là hủy giao dịch trước khi nó hoàn tất.

Thường dùng khi:
- timeout
- lỗi hệ thống

Refund = trả tiền sau khi đã hoàn tất
Reversal = hủy trước khi hoàn tất

========================================================
VIII. SOÁT LỖI / TRA SOÁT (Dispute)

Khi khách hàng khiếu nại giao dịch.

Hệ thống cần:
- lưu ticket
- lưu log
- đối soát lại giao dịch

========================================================
IX. HẠCH TOÁN (Posting)

Là hành động ghi bút toán vào sổ cái.

Có thể:
- hạch toán realtime
- hạch toán cuối ngày (EOD - End Of Day)

========================================================
X. CLEARING

Quá trình xác nhận giao dịch giữa các ngân hàng.

Ví dụ:
Ngân hàng A gửi tiền sang ngân hàng B.
Cuối ngày hai bên xác nhận tổng số tiền phải thanh toán.

========================================================
XI. SETTLEMENT

Quá trình chuyển tiền thực tế sau khi clearing xong.

Clearing = tính toán ai nợ ai
Settlement = trả tiền thật

========================================================
XII. CORE BANKING

Hệ thống lõi của ngân hàng,
quản lý:

- tài khoản
- số dư
- bút toán
- khách hàng

Các hệ thống vệ tinh phải gọi API core để ghi nhận bút toán.

========================================================
XIII. ID GIAO DỊCH

Thường có:

- transaction_id (nội bộ)
- external_id (đối tác gửi)
- reference_no
- trace_no

Phải đảm bảo idempotent:
Không được xử lý trùng giao dịch.

========================================================
XIV. IDEMPOTENT

Nếu gọi API nhiều lần với cùng transaction_id
thì chỉ được xử lý một lần.

Rất quan trọng trong ngân hàng.

========================================================
XV. EOD (END OF DAY)

Quy trình cuối ngày:

- tổng hợp giao dịch
- tính lãi
- chốt sổ
- sinh file đối soát

Thường chạy batch vào ban đêm.

========================================================
XVI. BATCH JOB

Chương trình chạy định kỳ:
- tính lãi
- gửi SMS
- đối soát
- trích phí

========================================================
XVII. GL (GENERAL LEDGER)

Sổ cái tổng.

Mọi bút toán cuối cùng phải map về GL.

========================================================
XVIII. AUDIT LOG

Lưu lại toàn bộ:

- ai thực hiện
- lúc nào
- trước và sau thay đổi

Trong ngân hàng:
Audit là bắt buộc.

========================================================
XIX. FRAUD

Phát hiện gian lận.

Hệ thống có thể:
- rule engine
- scoring
- block giao dịch

========================================================
XX. TỔNG KẾT TƯ DUY KHI LẬP TRÌNH NGÂN HÀNG

1) Mọi giao dịch phải sinh bút toán
2) Tổng Nợ phải bằng Tổng Có
3) Không bao giờ mất tiền do lỗi hệ thống
4) Phải có cơ chế đối soát
5) Phải có audit log
6) Phải chống xử lý trùng

========================================================

TÓM LẠI:

Khi lập trình domain ngân hàng,
bạn không chỉ viết code,
mà bạn đang xử lý TIỀN THẬT.

Vì vậy:
- chính xác tuyệt đối
- không được sai số
- phải đảm bảo tính toàn vẹn dữ liệu
- phải có cơ chế kiểm soát và đối soát

Đó là lý do domain ngân hàng phức tạp hơn hệ thống thông thường.

--- KHI NÀO DÙNG: BufferedReader br = new BufferedReader(new FileReader(file));

KHI NÀO DÙNG:

BufferedReader br = new BufferedReader(new FileReader(file));

========================================================
I. HIỂU TỪNG THÀNH PHẦN TRƯỚC

1) FileReader
- Dùng để đọc file TEXT
- Đọc theo ký tự (char)
- Phụ thuộc encoding mặc định của hệ điều hành

2) BufferedReader
- Bọc (wrap) một Reader
- Tăng tốc độ đọc nhờ buffer
- Có thêm phương thức readLine()

=> Khi kết hợp:

BufferedReader + FileReader
= đọc file văn bản hiệu quả và theo từng dòng

========================================================
II. KHI NÀO NÊN DÙNG

Bạn dùng:

BufferedReader br = new BufferedReader(new FileReader(file));

KHI:

1) File là file văn bản (TEXT FILE)

Ví dụ:
- .txt
- .csv
- .log
- .json
- .xml
- .properties
- source code (.java, .js, ...)

KHÔNG dùng cho:
- .xlsx
- .pdf
- .jpg
- .zip

Vì những file đó là binary.

--------------------------------------------------------

2) Khi bạn muốn đọc theo từng dòng

BufferedReader có phương thức:

readLine()

Ví dụ:

String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

Rất phù hợp khi:
- đọc file log
- parse file CSV
- đọc config
- tìm kiếm chuỗi

--------------------------------------------------------

3) Khi file có kích thước vừa hoặc lớn

Nếu dùng FileReader.read() từng ký tự:

- mỗi lần đọc là 1 lần truy cập I/O
- rất chậm

BufferedReader:
- đọc một khối dữ liệu lớn vào bộ nhớ trước
- giảm số lần truy cập đĩa
- tăng hiệu suất đáng kể

========================================================
III. KHI NÀO KHÔNG NÊN DÙNG

1) Khi file là BINARY

Ví dụ:

BufferedReader br = new BufferedReader(new FileReader("image.jpg"));

=> SAI
=> đọc ra ký tự rác
=> có thể làm hỏng dữ liệu

--------------------------------------------------------

2) Khi bạn cần kiểm soát encoding

FileReader dùng encoding mặc định của hệ điều hành.

Ví dụ:
- Windows có thể Cp1258
- Linux thường UTF-8

Nếu file là UTF-8 nhưng hệ thống mặc định không phải UTF-8
=> lỗi font tiếng Việt

Trong trường hợp này nên dùng:

BufferedReader br = new BufferedReader(
    new InputStreamReader(
        new FileInputStream(file),
        "UTF-8"
    )
);

========================================================
IV. TRƯỜNG HỢP THỰC TẾ NÊN DÙNG

1) Đọc file cấu hình .properties
2) Đọc file CSV để import dữ liệu
3) Đọc file log server
4) Đọc file text người dùng upload
5) Đọc script SQL dạng text

========================================================
V. SO SÁNH NHANH

FileReader.read()
- đọc từng ký tự
- chậm nếu file lớn
- không có readLine()

BufferedReader.readLine()
- đọc từng dòng
- nhanh hơn
- phổ biến trong thực tế

========================================================
VI. TƯ DUY HỆ THỐNG ĐỂ NHỚ

Bước 1: File có phải TEXT không?
    Nếu KHÔNG -> dùng InputStream
    Nếu CÓ -> tiếp tục

Bước 2: Có cần đọc theo dòng không?
    Nếu CÓ -> dùng BufferedReader
    Nếu KHÔNG -> FileReader cũng được

Bước 3: Có cần kiểm soát encoding không?
    Nếu CÓ -> dùng InputStreamReader + UTF-8
    Nếu KHÔNG -> FileReader được

========================================================
VII. KẾT LUẬN CHUẨN

Dùng:

BufferedReader br = new BufferedReader(new FileReader(file));

Khi:

- File là file văn bản
- Muốn đọc theo từng dòng
- Không cần kiểm soát encoding cụ thể
- Muốn tăng hiệu suất đọc

KHÔNG dùng cho file nhị phân.
KHÔNG dùng khi cần chỉ định encoding rõ ràng.

========================================================

TÓM LẠI MỘT CÂU:

BufferedReader + FileReader
= Giải pháp chuẩn để đọc file TEXT theo từng dòng với hiệu suất tốt.

--- StringBuffer -> toString() -> getBytes()

GIẢI THÍCH CHI TIẾT:

StringBuffer -> toString() -> getBytes()

========================================================
I. STRINGBUFFER LÀ GÌ?

1) Khái niệm

StringBuffer là một class trong Java dùng để thao tác chuỗi
có thể thay đổi (mutable).

Khác với String:
- String là immutable (không thay đổi được)
- StringBuffer có thể append, insert, delete mà không tạo object mới

2) Khi nào dùng StringBuffer?

- Khi cần nối chuỗi nhiều lần
- Khi xử lý chuỗi trong vòng lặp
- Khi cần thread-safe

Lưu ý:
StringBuffer là thread-safe (có synchronized)
=> chậm hơn StringBuilder

========================================================
II. VÍ DỤ CƠ BẢN

StringBuffer sb = new StringBuffer();
sb.append("Hello");
sb.append(" ");
sb.append("World");

Lúc này sb chứa:
Hello World

Nhưng sb KHÔNG phải là String.

========================================================
III. toString() LÀ GÌ?

1) Mục đích

Chuyển nội dung của StringBuffer thành String.

Ví dụ:

String str = sb.toString();

Giờ str là một String độc lập.

2) Điều quan trọng

- toString() tạo ra một object String mới
- Sau khi chuyển, String không thay đổi được

========================================================
IV. getBytes() LÀ GÌ?

getBytes() là method của String, KHÔNG phải của StringBuffer.

Nó dùng để:

Chuyển String thành mảng byte.

Ví dụ:

byte[] data = str.getBytes();

========================================================
V. CHUỖI HOẠT ĐỘNG ĐẦY ĐỦ

StringBuffer sb = new StringBuffer();
sb.append("Xin chao");

String str = sb.toString();
byte[] bytes = str.getBytes();

Quá trình:

StringBuffer (mutable)
        ↓
toString()
        ↓
String (immutable)
        ↓
getBytes()
        ↓
byte[] (dữ liệu nhị phân)

========================================================
VI. TẠI SAO PHẢI QUA toString()?

Vì StringBuffer KHÔNG có method getBytes().

Sai:

sb.getBytes();   // lỗi compile

Đúng:

sb.toString().getBytes();

========================================================
VII. getBytes() HOẠT ĐỘNG NHƯ THẾ NÀO?

String trong Java lưu trữ dưới dạng Unicode (UTF-16).

Khi gọi:

str.getBytes();

Java sẽ:

- Dùng encoding mặc định của hệ điều hành
- Chuyển ký tự sang byte theo encoding đó

Ví dụ:

String str = "A";

Ký tự 'A' trong UTF-8 = 65
=> byte[] = {65}

========================================================
VIII. VẤN ĐỀ ENCODING RẤT QUAN TRỌNG

Nếu bạn viết:

str.getBytes();

Encoding phụ thuộc hệ thống.

Có thể gây lỗi tiếng Việt.

Cách chuẩn:

str.getBytes("UTF-8");

Hoặc:

str.getBytes(StandardCharsets.UTF_8);

========================================================
IX. KHI NÀO DÙNG CHUỖI NÀY?

1) Khi cần ghi file nhị phân

FileOutputStream fos = new FileOutputStream("file.txt");
fos.write(sb.toString().getBytes("UTF-8"));

2) Khi gửi dữ liệu qua socket

OutputStream.write(bytes);

3) Khi mã hóa dữ liệu

MessageDigest.digest(str.getBytes());

========================================================
X. TƯ DUY BỘ NHỚ

1) StringBuffer
   - lưu char[]
   - có thể thay đổi

2) toString()
   - tạo object String mới
   - copy dữ liệu

3) getBytes()
   - tạo mảng byte mới
   - chuyển encoding

=> Mỗi bước đều tạo object mới.

========================================================
XI. SO SÁNH VỚI StringBuilder

StringBuilder:
- giống StringBuffer
- KHÔNG thread-safe
- nhanh hơn
- dùng phổ biến hơn trong web app

========================================================
XII. TÓM TẮT NGẮN GỌN

StringBuffer:
- Dùng để build chuỗi động
- Có thể thay đổi
- Thread-safe

toString():
- Chuyển StringBuffer -> String

getBytes():
- Chuyển String -> byte[]
- Dùng encoding (nên chỉ định UTF-8)

========================================================
XIII. KẾT LUẬN MỘT CÂU

StringBuffer.toString().getBytes()

= Xây dựng chuỗi động
→ chuyển thành String
→ chuyển thành byte[] để ghi file hoặc gửi qua mạng.

Luôn chỉ định encoding khi dùng getBytes().

--- NAPAS

GIẢI THÍCH CHI TIẾT VỀ NAPAS
(Nhìn theo góc độ nghiệp vụ + kỹ thuật lập trình ngân hàng)

========================================================
I. NAPAS LÀ GÌ?

NAPAS là viết tắt của:

National Payment Services

Tên đầy đủ:
Công ty Cổ phần Thanh toán Quốc gia Việt Nam.

Vai trò chính:
Là đơn vị trung gian kết nối hệ thống thanh toán
giữa các ngân hàng và tổ chức tài chính tại Việt Nam.

Hiểu đơn giản:

NAPAS = “cầu nối” giúp ngân hàng A chuyển tiền
cho ngân hàng B một cách tự động và an toàn.

========================================================
II. NAPAS LÀM NHỮNG GÌ?

1) Kết nối ATM giữa các ngân hàng
2) Kết nối POS (máy quẹt thẻ)
3) Chuyển khoản liên ngân hàng 24/7
4) Thanh toán thẻ nội địa
5) Thanh toán QR
6) Kết nối ví điện tử

========================================================
III. LUỒNG CHUYỂN TIỀN QUA NAPAS

Ví dụ:

Bạn dùng app ngân hàng A
chuyển tiền sang ngân hàng B.

Luồng thực tế:

1) Ngân hàng A nhận yêu cầu
2) Gửi request sang NAPAS
3) NAPAS định tuyến sang ngân hàng B
4) Ngân hàng B xử lý
5) Trả kết quả về NAPAS
6) NAPAS trả kết quả về ngân hàng A

NAPAS không giữ tiền.
NAPAS chỉ làm trung gian xử lý và định tuyến.

========================================================
IV. CLEARING VÀ SETTLEMENT TRONG NAPAS

1) Clearing
- Tổng hợp giao dịch giữa các ngân hàng
- Tính toán ngân hàng nào nợ bao nhiêu

2) Settlement
- Thanh toán bù trừ thực tế
- Thường thực hiện qua Ngân hàng Nhà nước

========================================================
V. NAPAS 24/7 LÀ GÌ?

Là dịch vụ chuyển tiền liên ngân hàng tức thời.

Đặc điểm:
- Thời gian xử lý vài giây
- Hoạt động 24/7 kể cả ngày lễ
- Gần realtime

Khác với chuyển tiền thường:
- Chuyển tiền thường có thể T+1
- NAPAS 24/7 là realtime

========================================================
VI. VAI TRÒ NAPAS TRONG LẬP TRÌNH NGÂN HÀNG

Nếu bạn làm hệ thống ngân hàng,
NAPAS thường xuất hiện trong:

1) API chuyển tiền liên ngân hàng
2) Module xử lý thẻ nội địa
3) Module đối soát
4) Batch EOD

========================================================
VII. CÁC THÀNH PHẦN KỸ THUẬT LIÊN QUAN

1) Message format

NAPAS dùng format chuẩn riêng:
- ISO8583 (phổ biến với giao dịch thẻ)

2) Transaction code
3) Response code
4) STAN (System Trace Audit Number)
5) RRN (Retrieval Reference Number)

Các trường này dùng để:
- Theo dõi giao dịch
- Đối soát
- Tra soát

========================================================
VIII. ĐỐI SOÁT VỚI NAPAS

Cuối ngày:

- NAPAS gửi file đối soát
- Ngân hàng so sánh với dữ liệu nội bộ
- Phát hiện lệch
- Xử lý sai khác

Trong hệ thống thường có:

- bảng napas_transaction
- bảng napas_reconciliation
- batch job đối soát

========================================================
IX. TRƯỜNG HỢP LỖI

Có thể xảy ra:

1) Timeout
2) Ngân hàng đích không phản hồi
3) Mạng gián đoạn

Khi đó hệ thống phải:

- đảm bảo idempotent
- có cơ chế reversal
- có cơ chế tra soát

========================================================
X. BẢO MẬT

NAPAS yêu cầu:

- Mã hóa kênh truyền (TLS)
- Mã hóa dữ liệu nhạy cảm
- Ký điện tử
- HSM (Hardware Security Module)

========================================================
XI. KHÁC GÌ SO VỚI VISA / MASTERCARD?

NAPAS:
- Thanh toán nội địa Việt Nam

Visa / Mastercard:
- Thanh toán quốc tế

NAPAS xử lý thẻ nội địa,
Visa/Master xử lý thẻ quốc tế.

========================================================
XII. TƯ DUY HỆ THỐNG KHI CODE LIÊN QUAN NAPAS

1) Giao dịch phải atomic
2) Phải log đầy đủ
3) Phải lưu request/response
4) Phải có cơ chế retry
5) Phải chống xử lý trùng
6) Phải có đối soát cuối ngày

========================================================
XIII. TÓM TẮT NGẮN GỌN

NAPAS là:

- Hệ thống trung gian thanh toán quốc gia
- Kết nối các ngân hàng
- Xử lý chuyển tiền liên ngân hàng
- Thực hiện clearing và settlement
- Cung cấp dịch vụ chuyển tiền 24/7

Trong lập trình ngân hàng:

NAPAS = hệ thống tích hợp quan trọng
cần đảm bảo:
- chính xác
- bảo mật
- không xử lý trùng
- có cơ chế đối soát

========================================================

TÓM LẠI MỘT CÂU:

NAPAS là "cầu nối thanh toán quốc gia"
giúp các ngân hàng Việt Nam
chuyển tiền và thanh toán với nhau
một cách tự động và an toàn.

--- KHI THANH TOÁN BẰNG MOMO, TIỀN BỊ TRỪ VÀO TÀI KHOẢN NGÂN HÀNG THÌ CÓ LIÊN QUAN ĐẾN NAPAS KHÔNG?

KHI THANH TOÁN BẰNG MOMO, TIỀN BỊ TRỪ VÀO TÀI KHOẢN NGÂN HÀNG
THÌ CÓ LIÊN QUAN ĐẾN NAPAS KHÔNG?

========================================================
I. TRẢ LỜI NGẮN GỌN

CÓ THỂ CÓ, CÓ THỂ KHÔNG.

Phụ thuộc vào:
- Bạn thanh toán theo cách nào
- Tiền nằm ở đâu (ví hay tài khoản ngân hàng)
- Cách MoMo kết nối với ngân hàng

========================================================
II. PHÂN TÍCH THEO TỪNG TRƯỜNG HỢP

--------------------------------------------------------
TRƯỜNG HỢP 1:
Bạn thanh toán bằng SỐ DƯ VÍ MOMO

Ví dụ:
- Trong ví MoMo có sẵn 500.000
- Bạn thanh toán 100.000

Luồng xử lý:

1) MoMo trừ tiền trong ví nội bộ
2) Ghi nhận giao dịch
3) Không cần gọi ngân hàng ngay lập tức

=> KHÔNG liên quan trực tiếp đến NAPAS
ở thời điểm thanh toán.

Tuy nhiên:
Cuối ngày MoMo có thể phải đối soát
với ngân hàng qua NAPAS hoặc cơ chế khác.

--------------------------------------------------------
TRƯỜNG HỢP 2:
Bạn thanh toán bằng TÀI KHOẢN NGÂN HÀNG LIÊN KẾT

Ví dụ:
- Ví MoMo = 0 đồng
- Bạn thanh toán 100.000
- MoMo tự động trừ từ tài khoản ngân hàng

Lúc này có 2 khả năng:

========================================================
III. KHẢ NĂNG A: KẾT NỐI TRỰC TIẾP (HOST TO HOST)

MoMo và ngân hàng có kết nối trực tiếp:

Luồng:

1) MoMo gửi request sang ngân hàng
2) Ngân hàng trừ tiền
3) Trả kết quả về MoMo

=> Không đi qua NAPAS
=> Gọi là kết nối song phương (bilateral)

Nhiều ngân hàng lớn kết nối trực tiếp như vậy.

========================================================
IV. KHẢ NĂNG B: THÔNG QUA NAPAS

Nếu ngân hàng không có kết nối trực tiếp
hoặc sử dụng hạ tầng trung gian:

Luồng có thể là:

1) MoMo gửi yêu cầu
2) Gửi qua NAPAS
3) NAPAS định tuyến sang ngân hàng
4) Ngân hàng xử lý
5) Trả kết quả ngược lại

=> Lúc này CÓ liên quan đến NAPAS

========================================================
V. KHI NẠP TIỀN TỪ NGÂN HÀNG VÀO MOMO

Trường hợp bạn nạp tiền vào ví:

1) Nếu nạp qua chuyển khoản 24/7
   => Thường đi qua NAPAS

2) Nếu nạp qua liên kết trực tiếp
   => Có thể không qua NAPAS

========================================================
VI. TƯ DUY HỆ THỐNG

MoMo là ví điện tử.
Ví điện tử phải:

- Giữ tiền trong tài khoản đảm bảo tại ngân hàng
- Đối soát với ngân hàng
- Thanh toán bù trừ

NAPAS thường tham gia khi:

- Có chuyển tiền liên ngân hàng
- Có giao dịch thẻ nội địa
- Có thanh toán 24/7

========================================================
VII. KẾT LUẬN THEO TÌNH HUỐNG CỤ THỂ

1) Nếu bạn dùng tiền sẵn trong ví:
   => Không liên quan trực tiếp NAPAS lúc đó

2) Nếu ví trừ tiền từ tài khoản ngân hàng:
   => Có thể có NAPAS
   => Hoặc có thể kết nối trực tiếp

3) Nếu có chuyển tiền liên ngân hàng:
   => Gần như chắc chắn có NAPAS

========================================================
VIII. TÓM TẮT NGẮN GỌN

Thanh toán bằng MoMo
mà tiền bị trừ từ tài khoản ngân hàng

THÌ:

- Nếu ngân hàng và MoMo kết nối trực tiếp
  => Không cần NAPAS

- Nếu thông qua hạ tầng trung gian
  => Có NAPAS

Bạn không nhìn thấy NAPAS,
nhưng ở tầng hạ tầng thanh toán,
NAPAS thường đóng vai trò rất lớn.

========================================================

TÓM LẠI MỘT CÂU:

Việc có liên quan NAPAS hay không
phụ thuộc vào cách MoMo và ngân hàng
kết nối với nhau ở tầng hạ tầng thanh toán.

--- PROJECT FACET TRONG ECLIPSE

GIẢI THÍCH CHI TIẾT VỀ PROJECT FACET TRONG ECLIPSE

========================================================
I. PROJECT FACET LÀ GÌ?

Project Facet trong Eclipse là:

Cơ chế dùng để xác định loại dự án (project type)
và các công nghệ mà project đó sử dụng.

Hiểu đơn giản:

Facet = “tính năng” hoặc “vai trò” mà project hỗ trợ.

Ví dụ:
- Project Java
- Project Web
- Project Dynamic Web
- Project Enterprise (JPA, EJB…)

========================================================
II. FACET NẰM Ở ĐÂU?

Trong Eclipse:

Right click project
→ Properties
→ Project Facets

Ở đây bạn sẽ thấy danh sách các facet được bật.

========================================================
III. VÍ DỤ CÁC FACET PHỔ BIẾN

1) Java
   - Xác định version Java (1.8, 11, 17...)

2) Dynamic Web Module
   - Cho phép project chạy web (Servlet, JSP)
   - Xác định version Servlet (2.5, 3.0, 4.0...)

3) JavaScript
   - Hỗ trợ JavaScript trong project

4) JPA
   - Hỗ trợ Java Persistence API

5) EJB
   - Hỗ trợ Enterprise JavaBeans

6) WebSocket
   - Hỗ trợ WebSocket API

========================================================
IV. TẠI SAO FACET QUAN TRỌNG?

Facet quyết định:

1) Cấu trúc project
2) Thư viện được thêm vào
3) Cách deploy
4) Server runtime tương thích

Ví dụ:

Nếu không có Dynamic Web Module:
→ Không thể chạy project trên Tomcat

========================================================
V. FACET LIÊN QUAN ĐẾN SERVER NHƯ THẾ NÀO?

Ví dụ:

Bạn chọn:
Dynamic Web Module 3.1

Thì:

- Phải dùng server hỗ trợ Servlet 3.1
- Ví dụ Tomcat 8+

Nếu version không khớp:
→ Eclipse sẽ báo lỗi.

========================================================
VI. FACET KHÁC VỚI BUILD PATH NHƯ THẾ NÀO?

Build Path:
- Quản lý thư viện (jar)
- Quản lý classpath

Facet:
- Xác định loại project
- Xác định runtime môi trường

Build Path = thư viện
Facet = vai trò & môi trường

========================================================
VII. FILE CẤU HÌNH FACET NẰM Ở ĐÂU?

Trong project có thư mục:

.settings/

File:

org.eclipse.wst.common.project.facet.core.xml

File này lưu:

- danh sách facet
- version của từng facet

========================================================
VIII. LỖI THƯỜNG GẶP LIÊN QUAN FACET

1) Project facet Java version not supported
   → Version Java không khớp JDK đang dùng

2) Dynamic Web Module version mismatch
   → Server không hỗ trợ version đó

3) Cannot change project facet
   → Project đang gắn với server không tương thích

========================================================
IX. KHI NÀO CẦN CHỈNH FACET?

1) Nâng cấp Java version
2) Nâng cấp Servlet version
3) Chuyển project sang server mới
4) Import project từ máy khác

========================================================
X. TRONG LẬP TRÌNH WEB

Nếu làm project Servlet/JSP:

Cần ít nhất:

- Java facet
- Dynamic Web Module facet

Nếu dùng JPA:
- Thêm JPA facet

Nếu làm Spring Boot:
- Thường không cần cấu hình facet phức tạp
- Vì Maven/Gradle quản lý

========================================================
XI. TƯ DUY HỆ THỐNG

Project Facet giúp Eclipse hiểu:

“Project này thuộc loại gì
và sẽ chạy trong môi trường nào?”

Nhờ đó Eclipse:

- Validate đúng
- Thêm đúng cấu trúc
- Deploy đúng server

========================================================
XII. KẾT LUẬN

Project Facet trong Eclipse là:

Cơ chế xác định loại project
và các công nghệ mà project sử dụng,
bao gồm version tương ứng.

Nó quyết định:

- Project có phải web app không
- Dùng version Java nào
- Tương thích server nào
- Có hỗ trợ JPA, EJB hay không

========================================================

TÓM LẠI MỘT CÂU:

Project Facet là cách Eclipse định nghĩa
“project này là loại gì và chạy trên môi trường nào”.

--- LỆNH XÓA 1 ROW THEO ĐIỀU KIỆN BẰNG SQL

LỆNH XÓA 1 ROW THEO ĐIỀU KIỆN BẰNG SQL

========================================================
I. CÚ PHÁP CƠ BẢN

Cú pháp chuẩn của SQL:

DELETE FROM ten_bang
WHERE dieu_kien;

Trong đó:

- DELETE FROM  : lệnh xóa dữ liệu
- ten_bang     : tên bảng cần xóa
- WHERE        : điều kiện xác định row cần xóa

========================================================
II. VÍ DỤ CƠ BẢN

Giả sử có bảng:

users
---------------------
id | name | age
---------------------

Muốn xóa user có id = 10:

DELETE FROM users
WHERE id = 10;

Kết quả:
Row có id = 10 sẽ bị xóa.

========================================================
III. CỰC KỲ QUAN TRỌNG: LUÔN CÓ WHERE

Nếu viết:

DELETE FROM users;

=> Sẽ xóa TOÀN BỘ dữ liệu trong bảng.

Đây là lỗi rất nguy hiểm trong production.

========================================================
IV. XÓA THEO NHIỀU ĐIỀU KIỆN

DELETE FROM users
WHERE age > 30
AND name = 'Tuan';

Hoặc:

DELETE FROM users
WHERE id IN (1, 2, 3);

========================================================
V. XÓA 1 ROW DUY NHẤT

Thông thường:
Xóa theo khóa chính (PRIMARY KEY).

Ví dụ:

DELETE FROM orders
WHERE order_id = 1001;

Vì khóa chính là duy nhất,
chỉ có 1 row bị xóa.

========================================================
VI. KIỂM TRA TRƯỚC KHI XÓA (BEST PRACTICE)

Bước 1: Kiểm tra dữ liệu sẽ bị xóa

SELECT *
FROM users
WHERE id = 10;

Bước 2: Nếu đúng, mới chạy DELETE.

========================================================
VII. SỰ KHÁC NHAU GIỮA DELETE VÀ TRUNCATE

DELETE:
- Có WHERE
- Có thể rollback (trong transaction)
- Xóa từng row

TRUNCATE:
- Không có WHERE
- Xóa toàn bộ bảng
- Nhanh hơn
- Thường không rollback được

========================================================
VIII. DELETE TRONG TRANSACTION

BEGIN;

DELETE FROM users
WHERE id = 10;

ROLLBACK;  -- hủy xóa

Hoặc:

COMMIT;    -- xác nhận xóa

Rất quan trọng trong hệ thống ngân hàng hoặc hệ thống lớn.

========================================================
IX. DELETE KẾT HỢP JOIN (MYSQL)

Ví dụ xóa user không có đơn hàng:

DELETE u
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.user_id IS NULL;

========================================================
X. XÓA CÓ GIỚI HẠN SỐ LƯỢNG (MYSQL)

DELETE FROM users
WHERE age > 30
LIMIT 1;

Chỉ xóa 1 row thỏa điều kiện.

========================================================
XI. SOFT DELETE (XÓA MỀM)

Trong hệ thống thực tế,
thường không xóa thật.

Thay vào đó:

UPDATE users
SET deleted = 1
WHERE id = 10;

Hoặc:

UPDATE users
SET deleted_at = NOW()
WHERE id = 10;

=> Dữ liệu vẫn còn trong DB
=> Dễ audit, dễ khôi phục

========================================================
XII. TƯ DUY QUAN TRỌNG

1) Luôn có WHERE
2) Luôn kiểm tra bằng SELECT trước
3) Dùng transaction nếu hệ thống quan trọng
4) Cân nhắc soft delete thay vì delete thật

========================================================
XIII. KẾT LUẬN

Lệnh xóa 1 row theo điều kiện:

DELETE FROM ten_bang
WHERE dieu_kien;

Muốn đảm bảo chỉ xóa 1 row:
- Dùng khóa chính
- Hoặc LIMIT 1 (nếu DB hỗ trợ)

========================================================

TÓM LẠI MỘT CÂU:

Muốn xóa 1 row theo điều kiện trong SQL,
dùng DELETE FROM ... WHERE ...
và luôn cẩn thận với mệnh đề WHERE.

--- FTP FAIL VÀ OFS ERROR LÀ GÌ?

GIẢI THÍCH CHI TIẾT:

FTP FAIL VÀ OFS ERROR LÀ GÌ?

========================================================
I. FTP FAIL LÀ GÌ?

1) FTP là gì?

FTP = File Transfer Protocol
Là giao thức truyền file giữa 2 hệ thống qua mạng.

Thường dùng để:
- Gửi file batch
- Nhận file đối soát
- Truyền file báo cáo
- Tích hợp hệ thống ngân hàng

2) FTP FAIL nghĩa là gì?

FTP FAIL = quá trình truyền file qua FTP bị thất bại.

Nó không phải là một lỗi cụ thể,
mà là trạng thái tổng quát: "gửi file không thành công".

========================================================
II. NGUYÊN NHÂN FTP FAIL PHỔ BIẾN

1) Sai username/password
2) Sai IP hoặc port
3) Server FTP không hoạt động
4) Mất kết nối mạng
5) Không có quyền ghi file
6) Thư mục đích không tồn tại
7) Firewall chặn kết nối
8) Timeout do file quá lớn

========================================================
III. TRIỆU CHỨNG TRONG CODE

Ví dụ khi dùng SFTP:

- Session connect failed
- Auth fail
- No such file
- Permission denied
- Connection reset

Trong log có thể thấy:
- socket timeout
- connection refused

========================================================
IV. TRONG HỆ THỐNG NGÂN HÀNG

FTP FAIL rất nghiêm trọng nếu:

- Không gửi được file đối soát
- Không gửi được file thanh toán
- Không nhận được file phản hồi

Hệ thống thường cần:

- Retry mechanism
- Alert monitoring
- Log chi tiết
- Manual re-send

========================================================
V. OFS ERROR LÀ GÌ?

1) OFS là gì?

OFS thường viết tắt của:

Open Financial Services

Trong nhiều hệ thống ngân hàng (đặc biệt core banking),
OFS là giao thức giao tiếp giữa hệ thống ngoài
và core banking.

Ví dụ:
- Hệ thống thẻ gọi vào core
- Hệ thống internet banking gọi core

2) OFS ERROR là gì?

OFS ERROR = lỗi trả về từ core banking
khi xử lý một yêu cầu tài chính.

========================================================
VI. NGUYÊN NHÂN OFS ERROR

1) Sai format message
2) Sai tham số đầu vào
3) Tài khoản không tồn tại
4) Không đủ số dư
5) Sai trạng thái tài khoản
6) Lỗi nghiệp vụ
7) Lỗi validation

========================================================
VII. OFS ERROR KHÁC FTP FAIL NHƯ THẾ NÀO?

FTP FAIL:
- Lỗi ở tầng truyền file
- Lỗi hạ tầng mạng / kết nối
- File chưa được xử lý

OFS ERROR:
- Lỗi nghiệp vụ từ core banking
- Request đã đến core
- Core từ chối xử lý

========================================================
VIII. SO SÁNH DỄ HIỂU

FTP FAIL
= "Không gửi được thư"

OFS ERROR
= "Thư đã gửi tới nơi, nhưng nội dung bị từ chối"

========================================================
IX. TRONG LOG HỆ THỐNG

FTP FAIL thường thấy:

- connection refused
- timeout
- permission denied

OFS ERROR thường thấy:

- ACCOUNT NOT FOUND
- INSUFFICIENT FUND
- INVALID FIELD
- DUPLICATE TRANSACTION

========================================================
X. TƯ DUY XỬ LÝ

Nếu FTP FAIL:
- Kiểm tra network
- Kiểm tra server FTP
- Kiểm tra credential
- Retry

Nếu OFS ERROR:
- Kiểm tra dữ liệu gửi
- Kiểm tra logic nghiệp vụ
- Kiểm tra idempotent
- Tra soát giao dịch

========================================================
XI. TRONG DOMAIN NGÂN HÀNG

FTP FAIL thường liên quan:
- Batch
- Đối soát
- Gửi file Napas
- Gửi file thanh toán

OFS ERROR thường liên quan:
- Giao dịch realtime
- Hạch toán
- Ghi sổ
- Truy vấn tài khoản

========================================================
XII. KẾT LUẬN

FTP FAIL:
- Lỗi truyền file
- Lỗi kết nối hạ tầng

OFS ERROR:
- Lỗi xử lý nghiệp vụ từ core banking

========================================================

TÓM LẠI MỘT CÂU:

FTP FAIL là lỗi ở tầng truyền file,
còn OFS ERROR là lỗi nghiệp vụ khi hệ thống core
từ chối xử lý giao dịch tài chính.

--- WINSCP (WINDOWS SCP) LÀ GÌ?

GIẢI THÍCH CHI TIẾT: WINSCP (WINDOWS SCP) LÀ GÌ?

========================================================
I. WINSCP LÀ GÌ?

WinSCP là một phần mềm miễn phí trên Windows dùng để:

- Kết nối tới server Linux/Unix
- Truyền file giữa máy Windows và server
- Quản lý file từ xa

Tên gọi:

WinSCP = Windows Secure Copy

Nó là một client sử dụng các giao thức bảo mật như:
- SFTP (SSH File Transfer Protocol)
- SCP (Secure Copy Protocol)
- FTP
- FTPS
- WebDAV

========================================================
II. MỤC ĐÍCH SỬ DỤNG WINSCP

WinSCP thường được dùng để:

1) Upload file lên server
2) Download file từ server
3) Sửa file cấu hình trên server
4) Deploy code
5) Lấy log hệ thống
6) Gửi file đối soát trong hệ thống ngân hàng

========================================================
III. WINSCP HOẠT ĐỘNG NHƯ THẾ NÀO?

Luồng hoạt động cơ bản:

1) Bạn nhập:
   - Host (IP server)
   - Port (thường 22 cho SFTP)
   - Username
   - Password hoặc Private Key

2) WinSCP tạo kết nối SSH tới server

3) Sau khi xác thực thành công,
   bạn có thể kéo thả file giữa:
   - Máy local (Windows)
   - Máy remote (Linux server)

========================================================
IV. GIAO DIỆN WINSCP

WinSCP có 2 kiểu giao diện:

1) Commander Mode
   - Bên trái: máy local
   - Bên phải: server

2) Explorer Mode
   - Giống Windows Explorer

========================================================
V. PHÂN BIỆT SFTP, SCP, FTP

1) FTP
   - Không mã hóa
   - Kém an toàn

2) SCP
   - Truyền file qua SSH
   - Bảo mật

3) SFTP
   - Cũng dùng SSH
   - Linh hoạt hơn SCP
   - Phổ biến nhất

Trong thực tế:
Nên dùng SFTP thay vì FTP.

========================================================
VI. WINSCP KHÁC GÌ VỚI PUTTY?

PuTTY:
- Dùng để SSH vào server (terminal)

WinSCP:
- Dùng để truyền file

Hai công cụ này thường dùng chung trong môi trường DevOps.

========================================================
VII. ỨNG DỤNG TRONG LẬP TRÌNH

1) Deploy file .war lên Tomcat
2) Upload file batch lên server ngân hàng
3) Download file đối soát Napas
4) Chỉnh sửa file cấu hình application.properties
5) Lấy log lỗi từ server production

========================================================
VIII. PRIVATE KEY TRONG WINSCP

Có thể đăng nhập bằng:

- Password
- SSH private key (.ppk)

Quy trình thường thấy:

1) Dùng PuTTYgen tạo key
2) Lưu private key (.ppk)
3) Cấu hình trong WinSCP
4) Kết nối server không cần password

========================================================
IX. LỖI THƯỜNG GẶP

1) Connection refused
   → Sai IP hoặc server tắt

2) Authentication failed
   → Sai password hoặc key

3) Permission denied
   → Không có quyền ghi file

4) Timeout
   → Mạng chậm hoặc firewall chặn

========================================================
X. WINSCP TRONG HỆ THỐNG NGÂN HÀNG

Thường dùng để:

- Upload file thanh toán
- Upload file đối soát
- Lấy file phản hồi
- Backup dữ liệu

Rất quan trọng trong tích hợp batch.

========================================================
XI. TÍNH BẢO MẬT

Khi dùng SFTP hoặc SCP:

- Dữ liệu được mã hóa
- Truyền qua SSH
- An toàn hơn FTP

Luôn:
- Không chia sẻ private key
- Không để lộ password
- Phân quyền đúng trên server

========================================================
XII. KẾT LUẬN

WinSCP là:

Phần mềm trên Windows dùng để
truyền file an toàn giữa máy local và server
thông qua SSH (SFTP/SCP).

Nó rất phổ biến trong:

- Lập trình web
- DevOps
- Hệ thống ngân hàng
- Quản trị server Linux

========================================================

TÓM LẠI MỘT CÂU:

WinSCP là công cụ Windows giúp bạn kết nối
và truyền file an toàn với server Linux thông qua SSH.

--- SFTP KHÁC GÌ VỚI SSH?

GIẢI THÍCH CHI TIẾT: SFTP KHÁC GÌ VỚI SSH?

========================================================
I. TỔNG QUAN

Nhiều người nhầm lẫn giữa SSH và SFTP vì:

- Cùng dùng port 22
- Cùng liên quan đến bảo mật
- Cùng thường dùng chung trong hệ thống Linux

Nhưng thực tế:

SSH là giao thức kết nối bảo mật
SFTP là giao thức truyền file chạy trên SSH

========================================================
II. SSH LÀ GÌ?

SSH = Secure Shell

SSH là giao thức dùng để:

- Kết nối vào server từ xa
- Thực thi lệnh trên server
- Quản trị hệ thống

Ví dụ:

Bạn dùng:
ssh user@server_ip

Sau đó:
- Gõ lệnh Linux
- Restart service
- Xem log
- Chạy script

SSH giống như:
Bạn mở Terminal điều khiển server từ xa.

========================================================
III. SFTP LÀ GÌ?

SFTP = SSH File Transfer Protocol

SFTP là giao thức:

- Truyền file giữa client và server
- Chạy trên nền SSH
- Dùng kênh bảo mật của SSH

SFTP không dùng để gõ lệnh.
Nó dùng để:

- Upload file
- Download file
- Xóa file
- Đổi tên file
- Tạo thư mục

========================================================
IV. MỐI QUAN HỆ GIỮA SSH VÀ SFTP

Quan trọng:

SFTP KHÔNG tồn tại độc lập.
Nó chạy bên trong SSH.

Nói cách khác:

SSH là nền tảng bảo mật
SFTP là dịch vụ truyền file sử dụng nền tảng đó

Ví dụ:

Khi bạn dùng WinSCP chọn SFTP:

- Nó mở một kết nối SSH
- Sau đó sử dụng giao thức SFTP bên trong

========================================================
V. SO SÁNH CHI TIẾT

1) Mục đích

SSH:
- Điều khiển server
- Thực thi lệnh

SFTP:
- Truyền và quản lý file

--------------------------------------------------------

2) Giao diện

SSH:
- Terminal (command line)

SFTP:
- Có thể dùng GUI (WinSCP)
- Hoặc command line (sftp)

--------------------------------------------------------

3) Cổng mặc định

Cả hai đều dùng:
Port 22

--------------------------------------------------------

4) Mức độ bảo mật

Cả hai đều:
- Mã hóa dữ liệu
- Sử dụng cơ chế xác thực (password hoặc private key)

--------------------------------------------------------

5) Cấu trúc hoạt động

SSH:
- Tạo secure tunnel

SFTP:
- Chạy bên trong tunnel đó

========================================================
VI. VÍ DỤ THỰC TẾ

1) Bạn muốn:

- Restart Tomcat
- Chạy script deploy
- Kiểm tra log

→ Dùng SSH

--------------------------------------------------------

2) Bạn muốn:

- Upload file .war
- Download file log
- Gửi file đối soát ngân hàng

→ Dùng SFTP

========================================================
VII. SAI LẦM THƯỜNG GẶP

Sai lầm 1:
"SFTP là một dạng của FTP"

Sai.
SFTP không liên quan đến FTP truyền thống.
Nó hoàn toàn khác về cấu trúc.

--------------------------------------------------------

Sai lầm 2:
"Chỉ cần mở SFTP thì không cần SSH"

Sai.
SFTP cần SSH để hoạt động.

--------------------------------------------------------

Sai lầm 3:
"SCP và SFTP giống nhau"

Không hoàn toàn.
Cả hai đều chạy trên SSH nhưng:

SCP:
- Chỉ copy file

SFTP:
- Có thể quản lý file (xóa, đổi tên, duyệt thư mục)

========================================================
VIII. KIẾN TRÚC BÊN TRONG

Khi bạn kết nối SFTP:

Bước 1:
Client tạo kết nối SSH

Bước 2:
Xác thực thành công

Bước 3:
SSH mở một kênh SFTP

Bước 4:
Client bắt đầu truyền file qua kênh mã hóa

========================================================
IX. ỨNG DỤNG TRONG THỰC TẾ LẬP TRÌNH

Trong hệ thống ngân hàng:

- SSH: quản trị server core banking
- SFTP: gửi file thanh toán, file batch, file đối soát

Trong DevOps:

- SSH: điều khiển server production
- SFTP: deploy code

========================================================
X. KẾT LUẬN NGẮN GỌN

SSH là giao thức tạo kết nối bảo mật và điều khiển server.

SFTP là giao thức truyền file chạy trên nền SSH.

========================================================

TÓM LẠI MỘT CÂU:

SSH là đường hầm bảo mật.
SFTP là cách truyền file đi bên trong đường hầm đó.

--- SSLContext LÀ GÌ?

GIẢI THÍCH CHI TIẾT: SSLContext LÀ GÌ?

========================================================
I. SSLContext LÀ GÌ?

SSLContext là một class trong Java (thuộc package javax.net.ssl)
dùng để cấu hình và khởi tạo môi trường bảo mật SSL/TLS.

Nó là thành phần trung tâm khi bạn muốn:

- Tạo kết nối HTTPS
- Kết nối TLS tới server
- Cấu hình certificate
- Cấu hình TrustManager / KeyManager

Hiểu đơn giản:

SSLContext là "bộ cấu hình bảo mật" cho SSL/TLS trong Java.

========================================================
II. SSL/TLS LÀ GÌ?

SSL (Secure Sockets Layer) và TLS (Transport Layer Security)
là giao thức mã hóa dữ liệu khi truyền qua mạng.

Ví dụ:
- HTTPS
- FTPS
- SMTPS

Hiện nay:
TLS là phiên bản nâng cấp của SSL.
Nhưng trong Java vẫn dùng tên SSLContext.

========================================================
III. VAI TRÒ CỦA SSLContext

SSLContext dùng để:

1) Chọn phiên bản giao thức (TLSv1.2, TLSv1.3...)
2) Cấu hình certificate
3) Cấu hình xác thực client/server
4) Tạo SSLSocketFactory
5) Tạo SSLServerSocketFactory

Nó giống như:

Một nhà máy sản xuất socket bảo mật.

========================================================
IV. CẤU TRÚC CƠ BẢN

Quy trình tạo SSLContext:

Bước 1:
SSLContext context = SSLContext.getInstance("TLS");

Bước 2:
context.init(keyManagers, trustManagers, secureRandom);

Bước 3:
SSLSocketFactory factory = context.getSocketFactory();

========================================================
V. CÁC THÀNH PHẦN QUAN TRỌNG

1) KeyManager

Quản lý:
- Private key
- Certificate của client

Dùng khi:
Client cần xác thực với server.

--------------------------------------------------------

2) TrustManager

Quản lý:
- Danh sách certificate tin cậy

Dùng để:
Xác minh certificate của server.

--------------------------------------------------------

3) SecureRandom

Tạo số ngẫu nhiên an toàn cho mã hóa.

========================================================
VI. SSLContext HOẠT ĐỘNG NHƯ THẾ NÀO?

Khi bạn gọi:

SSLContext.getInstance("TLS")

Java tạo một đối tượng chưa được cấu hình.

Khi bạn gọi:

context.init(...)

Bạn đang cung cấp:

- Chứng chỉ
- Cơ chế xác thực
- Cơ chế tin cậy

Sau đó:

Từ SSLContext bạn tạo ra socket bảo mật.

========================================================
VII. ỨNG DỤNG THỰC TẾ

1) Gọi API HTTPS có certificate riêng
2) Kết nối tới ngân hàng yêu cầu mutual TLS
3) Kết nối hệ thống thanh toán
4) Bỏ qua validate certificate trong môi trường test

========================================================
VIII. MUTUAL TLS LÀ GÌ?

Thông thường:

Client xác thực server.

Nhưng trong ngân hàng:

Server cũng yêu cầu xác thực client.

Quy trình:

1) Client gửi certificate
2) Server xác minh certificate
3) Server gửi certificate
4) Client xác minh server

SSLContext cho phép cấu hình cả 2 phía.

========================================================
IX. VÍ DỤ LUỒNG HTTPS

Khi bạn truy cập:

https://example.com

Quá trình:

1) Client gửi request
2) Server gửi certificate
3) Client dùng TrustManager kiểm tra
4) Nếu hợp lệ → bắt đầu trao đổi dữ liệu mã hóa

SSLContext chính là nơi chứa cấu hình kiểm tra đó.

========================================================
X. TRUST ALL (KHÔNG KHUYẾN KHÍCH)

Trong môi trường test,
có thể cấu hình TrustManager bỏ qua kiểm tra certificate.

Điều này nguy hiểm vì:

- Dễ bị tấn công man-in-the-middle
- Không an toàn production

========================================================
XI. SỰ KHÁC NHAU GIỮA HTTP VÀ HTTPS

HTTP:
- Không mã hóa
- Dễ bị đọc trộm

HTTPS:
- Dùng SSL/TLS
- Mã hóa dữ liệu
- Sử dụng SSLContext trong Java

========================================================
XII. VÌ SAO CẦN SSLContext?

Nếu bạn chỉ dùng HttpURLConnection bình thường,
Java dùng SSLContext mặc định.

Nhưng khi:

- Cần custom certificate
- Cần mutual TLS
- Cần kiểm soát bảo mật

→ Bạn phải tạo SSLContext riêng.

========================================================
XIII. TÓM TẮT KIẾN TRÚC

Ứng dụng Java
    ↓
SSLContext (cấu hình bảo mật)
    ↓
SSLSocketFactory
    ↓
Kết nối TLS
    ↓
Server

========================================================
XIV. LỖI THƯỜNG GẶP

1) PKIX path building failed
→ Certificate server không nằm trong truststore

2) Handshake failure
→ Sai protocol TLS

3) Keystore not found
→ Sai đường dẫn file .jks

========================================================
XV. KẾT LUẬN

SSLContext là class trong Java
dùng để cấu hình và quản lý kết nối SSL/TLS.

Nó chịu trách nhiệm:

- Xác thực certificate
- Tạo socket bảo mật
- Quản lý trust và key

========================================================

TÓM LẠI MỘT CÂU:

SSLContext là bộ cấu hình trung tâm
giúp Java tạo kết nối HTTPS/TLS an toàn.

--- JSCH LÀ GÌ?

GIẢI THÍCH CHI TIẾT: JSCH LÀ GÌ?

========================================================
I. JSCH LÀ GÌ?

JSch là một thư viện Java dùng để:

- Kết nối SSH tới server
- Thực thi lệnh từ xa
- Truyền file qua SFTP
- Truyền file qua SCP
- Tạo tunnel (port forwarding)

Tên đầy đủ:
Java Secure Channel

Hiểu đơn giản:

JSch là thư viện giúp Java giao tiếp với server qua SSH.

========================================================
II. VÌ SAO CẦN JSCH?

Thông thường:

- SSH dùng cho terminal (PuTTY, Linux terminal)
- SFTP dùng cho truyền file (WinSCP)

Nhưng khi bạn viết ứng dụng Java mà muốn:

- Tự động upload file
- Tự động download file
- Tự động chạy lệnh Linux

→ Bạn cần JSch.

========================================================
III. JSCH HỖ TRỢ NHỮNG GIAO THỨC NÀO?

1) SSH
   - Thực thi lệnh

2) SFTP
   - Upload / download file

3) SCP
   - Copy file

4) Port forwarding
   - Tạo tunnel qua SSH

========================================================
IV. CẤU TRÚC HOẠT ĐỘNG

Luồng hoạt động cơ bản:

1) Tạo đối tượng JSch
2) Tạo Session
3) Cấu hình xác thực (password hoặc private key)
4) Kết nối
5) Mở Channel
6) Thực thi hành động

Sơ đồ:

Java App
   ↓
JSch
   ↓
SSH Session
   ↓
Channel (exec / sftp)
   ↓
Server Linux

========================================================
V. CÁC KHÁI NIỆM QUAN TRỌNG

1) Session

Session đại diện cho:

- Một kết nối SSH tới server

Ví dụ:
Session session = jsch.getSession(user, host, port);

--------------------------------------------------------

2) Channel

Sau khi có Session,
bạn mở Channel để làm việc.

Các loại Channel phổ biến:

- exec  → chạy lệnh
- sftp  → truyền file
- shell → mở terminal

========================================================
VI. VÍ DỤ TÌNH HUỐNG THỰC TẾ

1) Upload file đối soát ngân hàng
   → Dùng ChannelSftp

2) Chạy script xử lý batch
   → Dùng ChannelExec

3) Tự động deploy file .war
   → Upload + exec restart service

========================================================
VII. XÁC THỰC

JSch hỗ trợ:

1) Password
2) Private key (.pem, .ppk convert)

Trong production:
Nên dùng private key thay vì password.

========================================================
VIII. SFTP TRONG JSCH

ChannelSftp cho phép:

- put()      → upload
- get()      → download
- rm()       → xóa file
- mkdir()    → tạo thư mục
- cd()       → đổi thư mục
- ls()       → liệt kê file

========================================================
IX. JSCH TRONG HỆ THỐNG NGÂN HÀNG

Rất phổ biến khi:

- Gửi file thanh toán qua SFTP
- Nhận file phản hồi
- Tích hợp với Napas
- Gửi file batch định kỳ

Luồng thường thấy:

1) Tạo job scheduler
2) Kết nối SFTP
3) Upload file
4) Download file phản hồi
5) Đóng session

========================================================
X. LỖI THƯỜNG GẶP

1) Auth fail
   → Sai password hoặc private key

2) UnknownHostKey
   → Chưa thêm host vào known_hosts

3) Session is down
   → Kết nối bị timeout

4) Channel closed
   → Không mở channel đúng cách

========================================================
XI. BẢO MẬT

Cần chú ý:

- Không hard-code password
- Không commit private key lên Git
- Quản lý known_hosts đúng cách
- Đóng session sau khi dùng

========================================================
XII. ƯU ĐIỂM CỦA JSCH

- Nhẹ
- Dễ tích hợp
- Không cần cài đặt thêm service
- Hoạt động tốt với Linux server

========================================================
XIII. NHƯỢC ĐIỂM

- API hơi cũ
- Xử lý lỗi không thân thiện
- Không hỗ trợ một số thuật toán SSH mới nếu phiên bản cũ

========================================================
XIV. SO SÁNH VỚI CÔNG CỤ KHÁC

JSch:
- Dùng trong Java
- Tự động hóa

WinSCP:
- GUI cho người dùng

PuTTY:
- SSH thủ công

========================================================
XV. KẾT LUẬN

JSch là thư viện Java
giúp ứng dụng Java:

- Kết nối SSH
- Thực thi lệnh từ xa
- Truyền file SFTP/SCP

Nó rất quan trọng trong:

- DevOps
- Hệ thống ngân hàng
- Tự động hóa xử lý batch

========================================================

TÓM LẠI MỘT CÂU:

JSch là thư viện Java giúp bạn lập trình kết nối SSH và SFTP tới server Linux một cách tự động.

--- Class clazz; clazz.getDeclaredMethod(...) LÀ GÌ?

GIẢI THÍCH CHI TIẾT:

Class clazz;
clazz.getDeclaredMethod(...) LÀ GÌ?

========================================================
I. TỔNG QUAN

Trong Java, Class và phương thức getDeclaredMethod()
thuộc về cơ chế Reflection.

Reflection là cơ chế cho phép:

- Xem thông tin class khi runtime
- Lấy danh sách method
- Gọi method động
- Truy cập field private
- Tạo object động

========================================================
II. Class clazz LÀ GÌ?

Class là một class đặc biệt trong Java.

Nó đại diện cho:

- Metadata của một class

Ví dụ:

String.class
User.class
obj.getClass()

Khi bạn có:

Class clazz;

Điều đó có nghĩa:

Bạn đang giữ thông tin về một class tại runtime.

========================================================
III. getDeclaredMethod() LÀ GÌ?

Cú pháp:

Method method = clazz.getDeclaredMethod(
    "tenMethod",
    KieuThamSo.class
);

getDeclaredMethod() dùng để:

Lấy ra một method được khai báo trong class,
bao gồm cả method private.

Quan trọng:

Nó chỉ tìm trong class hiện tại,
không tìm trong class cha.

========================================================
IV. PHÂN BIỆT getMethod() VÀ getDeclaredMethod()

1) getMethod()

- Chỉ lấy method public
- Tìm cả trong class cha

--------------------------------------------------------

2) getDeclaredMethod()

- Lấy cả public, protected, private
- Chỉ tìm trong class hiện tại
- Không tìm trong superclass

========================================================
V. CÚ PHÁP ĐẦY ĐỦ

Method method = clazz.getDeclaredMethod(
    "tenMethod",
    Kieu1.class,
    Kieu2.class
);

Tham số:

1) Tên method (String)
2) Danh sách kiểu tham số

========================================================
VI. VÍ DỤ THỰC TẾ

Giả sử class:

class User {
    private String getSecret() {
        return "secret";
    }
}

Khi đó:

Class clazz = User.class;

Method m = clazz.getDeclaredMethod("getSecret");

========================================================
VII. GỌI METHOD SAU KHI LẤY ĐƯỢC

Sau khi lấy được Method,
bạn có thể gọi nó bằng:

m.invoke(object);

Nếu method là private,
bạn phải:

m.setAccessible(true);

Nếu không sẽ bị IllegalAccessException.

========================================================
VIII. KHI NÀO DÙNG getDeclaredMethod?

1) Khi cần truy cập method private
2) Khi làm framework
3) Khi làm dependency injection
4) Khi làm ORM
5) Khi viết library

========================================================
IX. LỖI THƯỜNG GẶP

1) NoSuchMethodException

→ Sai tên method
→ Sai kiểu tham số

--------------------------------------------------------

2) IllegalAccessException

→ Method private nhưng chưa setAccessible(true)

--------------------------------------------------------

3) InvocationTargetException

→ Method bên trong ném exception

========================================================
X. LƯU Ý QUAN TRỌNG

Tên method phải chính xác 100%.
Java phân biệt chữ hoa chữ thường.

Ví dụ:

"getName" ≠ "getname"

========================================================
XI. getDeclaredMethods() KHÁC GÌ?

getDeclaredMethod() 
→ Lấy một method cụ thể

getDeclaredMethods()
→ Lấy tất cả method trong class

========================================================
XII. VAI TRÒ TRONG FRAMEWORK

Nhiều framework sử dụng reflection:

- Spring
- Hibernate
- Jackson

Ví dụ:

Spring có thể tự động gọi method có annotation
nhờ dùng getDeclaredMethod().

========================================================
XIII. CẢNH BÁO

Reflection:

- Chậm hơn gọi trực tiếp
- Bỏ qua kiểm tra compile-time
- Có thể gây lỗi runtime

Chỉ nên dùng khi thực sự cần.

========================================================
XIV. TÓM TẮT NGẮN GỌN

Class clazz;

Là biến đại diện cho metadata của một class.

clazz.getDeclaredMethod("tenMethod", ...)

Là phương thức dùng để lấy một method
được khai báo trong class đó,
bao gồm cả method private,
để có thể thao tác hoặc gọi động bằng reflection.

========================================================

TÓM LẠI MỘT CÂU:

getDeclaredMethod() là cách dùng Reflection
để lấy một method (kể cả private) trong class
tại runtime trong Java.

--- HASHTABLE TRONG java.util

GIẢI THÍCH CHI TIẾT: HASHTABLE TRONG java.util

========================================================
I. HASHTABLE LÀ GÌ?

Hashtable là một class trong package java.util
dùng để lưu trữ dữ liệu theo dạng:

Key → Value

Nó là một cấu trúc dữ liệu ánh xạ (Map).

Ví dụ:

"username" → "admin"
"age" → 25

========================================================
II. VỊ TRÍ TRONG HỆ THỐNG COLLECTION

java.util.Hashtable:

- Kế thừa từ Dictionary (class cũ)
- Implement Map interface

Sơ đồ:

Object
  ↓
Dictionary (abstract)
  ↓
Hashtable

Nó là một trong những Map đầu tiên của Java.

========================================================
III. CÁCH HOẠT ĐỘNG BÊN TRONG

Hashtable sử dụng:

Hashing (băm)

Quy trình:

1) Nhận key
2) Gọi key.hashCode()
3) Tính vị trí lưu trong mảng
4) Lưu value tại vị trí đó

Nếu 2 key có cùng hash (collision),
nó dùng linked list để xử lý.

========================================================
IV. ĐẶC ĐIỂM QUAN TRỌNG

1) Không cho phép null key
2) Không cho phép null value
3) Thread-safe (đồng bộ hóa)
4) Hiệu năng chậm hơn HashMap

========================================================
V. CÚ PHÁP CƠ BẢN

Hashtable<K, V> table = new Hashtable<>();

Ví dụ:

Hashtable<String, Integer> map = new Hashtable<>();

========================================================
VI. CÁC PHƯƠNG THỨC QUAN TRỌNG

1) put(key, value)

Thêm phần tử

--------------------------------------------------------

2) get(key)

Lấy value theo key

--------------------------------------------------------

3) remove(key)

Xóa theo key

--------------------------------------------------------

4) containsKey(key)

Kiểm tra key tồn tại

--------------------------------------------------------

5) contains(value)

Kiểm tra value tồn tại

========================================================
VII. SO SÁNH VỚI HASHMAP

1) Thread-safe

Hashtable:
Có (mọi method đều synchronized)

HashMap:
Không

--------------------------------------------------------

2) Null

Hashtable:
Không cho phép null

HashMap:
Cho phép 1 null key và nhiều null value

--------------------------------------------------------

3) Hiệu năng

Hashtable:
Chậm hơn do synchronized

HashMap:
Nhanh hơn

--------------------------------------------------------

4) Tính hiện đại

Hashtable:
Cũ (Java 1.0)

HashMap:
Mới hơn (Java 1.2)

========================================================
VIII. THREAD-SAFE LÀ GÌ?

Thread-safe nghĩa là:

Nhiều thread cùng truy cập
không gây lỗi dữ liệu.

Hashtable dùng synchronized
trên mỗi method để đảm bảo điều này.

Nhưng điều này làm giảm hiệu năng.

========================================================
IX. KHI NÀO NÊN DÙNG HASHTABLE?

Ngày nay:

Hiếm khi dùng trực tiếp Hashtable.

Thay thế tốt hơn:

1) HashMap
2) ConcurrentHashMap (đa luồng hiệu quả hơn)

========================================================
X. HASHCODE VÀ EQUALS

Khi dùng key trong Hashtable:

Phải đảm bảo:

1) equals() được override đúng
2) hashCode() được override đúng

Nếu không:
Có thể không tìm thấy key.

========================================================
XI. CẤU TRÚC BÊN TRONG

Bên trong Hashtable gồm:

- Một mảng Entry[]
- Mỗi Entry chứa:
    key
    value
    hash
    next (để xử lý collision)

========================================================
XII. COLLISION LÀ GÌ?

Collision xảy ra khi:

2 key khác nhau
nhưng có cùng hashCode.

Hashtable xử lý bằng:

Chaining (dùng linked list).

========================================================
XIII. VÍ DỤ ỨNG DỤNG

1) Lưu cấu hình key-value
2) Lưu session đơn giản
3) Lưu dữ liệu tạm

Nhưng hiện nay thường dùng HashMap.

========================================================
XIV. VẤN ĐỀ HIỆU NĂNG

Do mọi method đều synchronized:

Trong môi trường nhiều thread,
Hashtable có thể gây bottleneck.

Giải pháp tốt hơn:

ConcurrentHashMap.

========================================================
XV. TỔNG KẾT SO SÁNH NHANH

Hashtable:

- Có synchronized
- Không cho null
- Cũ
- Chậm hơn

HashMap:

- Không synchronized
- Cho null
- Hiện đại hơn
- Nhanh hơn

========================================================
XVI. KẾT LUẬN

Hashtable là một cấu trúc dữ liệu dạng Map
lưu trữ dữ liệu theo key-value,
sử dụng cơ chế hashing,
có tính thread-safe nhưng hiệu năng thấp hơn HashMap.

========================================================

TÓM LẠI MỘT CÂU:

Hashtable là Map thread-safe cũ trong Java,
không cho phép null,
và ngày nay thường được thay bằng HashMap hoặc ConcurrentHashMap.

--- PREPROD LÀ GÌ?

GIẢI THÍCH CHI TIẾT: PREPROD LÀ GÌ?

========================================================
I. PREPROD LÀ GÌ?

Preprod (Pre-production) là môi trường
được sử dụng để kiểm thử cuối cùng
trước khi đưa hệ thống lên Production.

Nó mô phỏng môi trường Production gần giống nhất có thể.

Hiểu đơn giản:

Preprod = môi trường "tập dượt" cuối cùng
trước khi hệ thống chạy thật.

========================================================
II. CÁC MÔI TRƯỜNG TRONG DỰ ÁN PHẦN MỀM

Thông thường hệ thống có các môi trường:

1) DEV
   - Lập trình viên phát triển

2) TEST / SIT
   - Tester kiểm thử chức năng

3) UAT
   - Người dùng kiểm thử nghiệp vụ

4) PREPROD
   - Kiểm thử gần Production

5) PROD (Production)
   - Hệ thống chạy thật cho khách hàng

========================================================
III. VỊ TRÍ CỦA PREPROD

Sơ đồ luồng triển khai:

DEV → TEST → UAT → PREPROD → PROD

Preprod là bước cuối cùng
trước khi release chính thức.

========================================================
IV. MỤC ĐÍCH CỦA PREPROD

1) Kiểm thử tích hợp toàn hệ thống
2) Kiểm thử hiệu năng gần thực tế
3) Kiểm tra cấu hình server
4) Kiểm tra SSL, certificate
5) Kiểm tra kết nối SFTP, API ngân hàng
6) Kiểm tra batch job

========================================================
V. ĐẶC ĐIỂM CỦA PREPROD

1) Cấu hình giống Production
   - CPU
   - RAM
   - Database
   - Load balancer

2) Dữ liệu gần giống Production
   - Có thể dùng dữ liệu giả lập
   - Không dùng dữ liệu thật nhạy cảm

3) Kết nối đầy đủ hệ thống bên ngoài

========================================================
VI. KHÁC GÌ VỚI UAT?

UAT:
- Tập trung test nghiệp vụ
- Người dùng test

Preprod:
- Tập trung kiểm tra kỹ thuật
- Kiểm tra môi trường
- Kiểm tra deployment

========================================================
VII. KHÁC GÌ VỚI PRODUCTION?

Production:
- Người dùng thật sử dụng
- Dữ liệu thật
- Giao dịch thật

Preprod:
- Chỉ test
- Không phục vụ khách hàng
- Không xử lý tiền thật

========================================================
VIII. VÌ SAO CẦN PREPROD?

Nếu không có Preprod:

- Có thể lỗi khi deploy
- Sai cấu hình server
- Sai certificate
- Sai cấu hình database
- Sai biến môi trường

Preprod giúp phát hiện lỗi trước khi lên Production.

========================================================
IX. VÍ DỤ TRONG HỆ THỐNG NGÂN HÀNG

Trong hệ thống ngân hàng:

Preprod thường dùng để:

- Test kết nối Napas
- Test gửi file thanh toán
- Test SSLContext
- Test SFTP
- Test mutual TLS
- Test batch cuối ngày

========================================================
X. CÁC RỦI RO NẾU BỎ QUA PREPROD

1) Lỗi cấu hình khi deploy
2) Không tương thích môi trường
3) Lỗi certificate
4) Lỗi performance
5) Ứng dụng crash khi có traffic lớn

========================================================
XI. TRIỂN KHAI Ở PREPROD

Quy trình thường thấy:

1) Build bản release
2) Deploy lên Preprod
3) Smoke test
4) Test hiệu năng
5) Kiểm tra log
6) Nếu OK → lên Production

========================================================
XII. PREPROD CÓ PHẢI LUÔN LUÔN CẦN?

Với dự án nhỏ:
Có thể không có Preprod.

Với hệ thống lớn, đặc biệt ngân hàng:
Preprod gần như bắt buộc.

========================================================
XIII. NHỮNG LỖI THƯỜNG PHÁT HIỆN Ở PREPROD

1) Sai biến môi trường
2) Sai endpoint API
3) Sai cấu hình firewall
4) Sai port
5) Sai quyền thư mục
6) Lỗi memory

========================================================
XIV. TÓM TẮT NGẮN GỌN

Preprod là môi trường gần giống Production nhất,
được dùng để kiểm thử cuối cùng
trước khi đưa hệ thống vào hoạt động chính thức.

========================================================

TÓM LẠI MỘT CÂU:

Preprod là môi trường kiểm thử cuối cùng,
mô phỏng Production,
nhằm đảm bảo hệ thống ổn định trước khi release thật.

--- ĐIỆN TRA SOÁT TRONG NGÂN HÀNG LÀ GÌ?

GIẢI THÍCH CHI TIẾT: ĐIỆN TRA SOÁT TRONG NGÂN HÀNG LÀ GÌ?

========================================================
I. ĐIỆN TRA SOÁT LÀ GÌ?

Điện tra soát là một thông điệp nghiệp vụ
được ngân hàng gửi đến ngân hàng khác
hoặc tổ chức trung gian thanh toán
để yêu cầu kiểm tra, xác minh hoặc xử lý lại
một giao dịch có vấn đề.

Hiểu đơn giản:

Điện tra soát là yêu cầu kiểm tra giao dịch bị lỗi,
chưa rõ trạng thái, hoặc phát sinh khiếu nại.

========================================================
II. KHI NÀO PHÁT SINH ĐIỆN TRA SOÁT?

Điện tra soát thường phát sinh khi:

1) Chuyển tiền nhưng người nhận chưa nhận được
2) Tài khoản bị trừ tiền nhưng giao dịch báo lỗi
3) ATM nuốt tiền
4) Giao dịch treo (pending lâu)
5) Sai thông tin người nhận
6) Giao dịch thành công một bên nhưng thất bại bên kia

========================================================
III. MỤC ĐÍCH CỦA ĐIỆN TRA SOÁT

1) Xác minh trạng thái giao dịch
2) Làm rõ nguyên nhân lỗi
3) Yêu cầu hoàn tiền
4) Yêu cầu hạch toán lại
5) Giải quyết khiếu nại khách hàng

========================================================
IV. CHỦ THỂ THAM GIA

Tùy loại giao dịch, có thể gồm:

1) Ngân hàng gửi tiền
2) Ngân hàng nhận tiền
3) Trung gian thanh toán (ví dụ Napas)
4) Tổ chức thẻ quốc tế (Visa, Mastercard)

========================================================
V. LUỒNG XỬ LÝ ĐIỆN TRA SOÁT (VÍ DỤ CHUYỂN TIỀN LIÊN NGÂN HÀNG)

Bước 1:
Khách hàng khiếu nại chưa nhận được tiền.

Bước 2:
Ngân hàng gửi tiền kiểm tra hệ thống nội bộ.

Bước 3:
Nếu không rõ trạng thái,
ngân hàng gửi điện tra soát qua hệ thống liên ngân hàng.

Bước 4:
Ngân hàng nhận tiền kiểm tra giao dịch.

Bước 5:
Trả lời điện tra soát:
- Đã ghi có
- Chưa ghi có
- Sai thông tin
- Hoàn trả tiền

========================================================
VI. HÌNH THỨC ĐIỆN TRA SOÁT

Tùy hệ thống có thể:

1) Gửi điện qua hệ thống thanh toán liên ngân hàng
2) Gửi file batch
3) Gửi thông điệp online (API)
4) Gửi điện SWIFT (quốc tế)

========================================================
VII. PHÂN BIỆT ĐIỆN TRA SOÁT VÀ ĐỐI SOÁT

Đối soát:
- So khớp dữ liệu giữa 2 bên
- Thường theo ngày

Điện tra soát:
- Xử lý từng giao dịch cụ thể
- Khi có vấn đề phát sinh

========================================================
VIII. THỜI HẠN XỬ LÝ

Tùy quy định hệ thống:

- 1 ngày
- 3 ngày
- 5 ngày làm việc
- Có thể lâu hơn với giao dịch quốc tế

Nếu quá thời hạn:
Có thể phát sinh bồi hoàn.

========================================================
IX. CÁC TRẠNG THÁI THƯỜNG GẶP

1) Giao dịch thành công
2) Giao dịch thất bại
3) Giao dịch đang xử lý
4) Đã hoàn tiền
5) Sai thông tin người nhận

========================================================
X. TRONG HỆ THỐNG THẺ

Ví dụ:

Khách rút tiền ATM ngân hàng A
nhưng máy thuộc ngân hàng B.

Nếu:

- Tài khoản bị trừ tiền
- Máy ATM không nhả tiền

→ Phát sinh điện tra soát giữa 2 ngân hàng.

========================================================
XI. ĐIỆN TRA SOÁT TRONG HỆ THỐNG THANH TOÁN NỘI ĐỊA

Khi giao dịch qua trung gian:

Ngân hàng A
   ↓
Hệ thống chuyển mạch
   ↓
Ngân hàng B

Nếu có lỗi,
điện tra soát sẽ đi qua trung gian đó.

========================================================
XII. RỦI RO NẾU KHÔNG XỬ LÝ ĐIỆN TRA SOÁT

1) Mất tiền khách hàng
2) Ảnh hưởng uy tín ngân hàng
3) Sai lệch sổ sách
4) Tranh chấp pháp lý

========================================================
XIII. LIÊN QUAN ĐẾN HẠCH TOÁN

Khi có điện tra soát:

Có thể phải:

- Hạch toán tạm giữ
- Hạch toán hoàn tiền
- Điều chỉnh bút toán

========================================================
XIV. TRONG LẬP TRÌNH HỆ THỐNG NGÂN HÀNG

Hệ thống cần:

1) Lưu trạng thái giao dịch chi tiết
2) Có mã tra soát (reference)
3) Có log đầy đủ
4) Có cơ chế gửi/nhận điện tự động
5) Có SLA xử lý

========================================================
XV. TÓM TẮT NGẮN GỌN

Điện tra soát là thông điệp nghiệp vụ
giữa các ngân hàng
để kiểm tra và xử lý một giao dịch có vấn đề,
đảm bảo quyền lợi khách hàng
và tính chính xác sổ sách.

========================================================

TÓM LẠI MỘT CÂU:

Điện tra soát là yêu cầu chính thức giữa các ngân hàng
để xác minh và xử lý giao dịch lỗi hoặc khiếu nại.

--- SỰ KHÁC NHAU GIỮA CÓ TRY-CATCH VÀ KHÔNG CÓ TRY-CATCH TRONG JAVA

GIẢI THÍCH CHI TIẾT: SỰ KHÁC NHAU GIỮA CÓ TRY-CATCH VÀ KHÔNG CÓ TRY-CATCH TRONG JAVA

========================================================
I. TRY-CATCH LÀ GÌ?

try-catch là cơ chế xử lý ngoại lệ (Exception Handling) trong Java.

Cấu trúc:

try {
    // đoạn code có thể gây lỗi
} catch (Exception e) {
    // xử lý lỗi
}

Mục đích:
Giúp chương trình không bị dừng đột ngột khi xảy ra lỗi.

========================================================
II. EXCEPTION LÀ GÌ?

Exception là lỗi xảy ra trong runtime.

Ví dụ:

- Chia cho 0
- NullPointerException
- File không tồn tại
- Lỗi kết nối database

========================================================
III. KHÔNG CÓ TRY-CATCH THÌ ĐIỀU GÌ XẢY RA?

Nếu không có try-catch:

1) Khi exception xảy ra
2) Java sẽ ném lỗi ra ngoài
3) Nếu không ai bắt lỗi
4) Chương trình sẽ dừng ngay lập tức

Ví dụ:

int a = 10 / 0;

Kết quả:
ArithmeticException
Chương trình crash.

========================================================
IV. CÓ TRY-CATCH THÌ ĐIỀU GÌ XẢY RA?

Nếu có try-catch:

1) Khi exception xảy ra
2) Java chuyển luồng sang catch
3) Thực hiện xử lý lỗi
4) Chương trình tiếp tục chạy

Ví dụ:

try {
    int a = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Loi chia cho 0");
}

Chương trình không crash.

========================================================
V. SO SÁNH TRỰC TIẾP

1) Không có try-catch

- Lỗi xảy ra → chương trình dừng
- Không kiểm soát được lỗi
- Người dùng thấy stacktrace

--------------------------------------------------------

2) Có try-catch

- Lỗi xảy ra → được bắt
- Có thể xử lý
- Có thể log
- Có thể thông báo thân thiện

========================================================
VI. LUỒNG CHẠY

Không try-catch:

Code → Lỗi → Dừng chương trình

Có try-catch:

Code → Lỗi → Catch → Tiếp tục

========================================================
VII. CHECKED EXCEPTION VS UNCHECKED EXCEPTION

1) Checked Exception

Ví dụ:
IOException
SQLException

BẮT BUỘC phải:
- try-catch
HOẶC
- throws

Nếu không sẽ không compile.

--------------------------------------------------------

2) Unchecked Exception

Ví dụ:
NullPointerException
ArithmeticException

Không bắt buộc phải try-catch.
Nhưng nếu không bắt → có thể crash runtime.

========================================================
VIII. LỢI ÍCH CỦA TRY-CATCH

1) Tránh crash hệ thống
2) Ghi log chi tiết
3) Trả thông báo rõ ràng
4) Giữ hệ thống ổn định
5) Tách logic xử lý lỗi

========================================================
IX. RỦI RO KHI KHÔNG DÙNG TRY-CATCH

1) Ứng dụng dừng đột ngột
2) Mất dữ liệu
3) Giao dịch bị treo
4) Không biết nguyên nhân lỗi

========================================================
X. RỦI RO KHI DÙNG TRY-CATCH SAI CÁCH

Ví dụ:

catch (Exception e) {
}

Không log gì cả.

Điều này nguy hiểm vì:
- Lỗi bị nuốt
- Không biết nguyên nhân
- Khó debug

========================================================
XI. FINALLY LÀ GÌ?

finally luôn được chạy dù có lỗi hay không.

Dùng để:
- Đóng file
- Đóng connection
- Giải phóng tài nguyên

========================================================
XII. TRONG HỆ THỐNG NGÂN HÀNG

Nếu không có try-catch:

- Giao dịch lỗi → hệ thống dừng
- Không rollback
- Không log

Nếu có try-catch đúng cách:

- Log lỗi
- Rollback transaction
- Trả thông báo chuẩn

========================================================
XIII. TỔNG KẾT SO SÁNH

Không try-catch:

- Chương trình có thể crash
- Không kiểm soát được lỗi

Có try-catch:

- Bắt được lỗi
- Xử lý lỗi
- Ổn định hệ thống hơn

========================================================
XIV. KẾT LUẬN

Try-catch là cơ chế giúp chương trình
xử lý lỗi một cách có kiểm soát.

Không có try-catch:
Exception có thể làm dừng toàn bộ chương trình.

Có try-catch:
Bạn có thể bắt, xử lý và tiếp tục chương trình.

========================================================

TÓM LẠI MỘT CÂU:

Có try-catch giúp chương trình kiểm soát và xử lý lỗi,
không có try-catch thì khi xảy ra exception,
chương trình có thể bị dừng đột ngột.

--- ĐỂ FRONTEND UPLOAD FILE, BACKEND BẮT ĐƯỢC FILE CẦN SETTING NHỮNG GÌ?

GIẢI THÍCH CHI TIẾT:
ĐỂ FRONTEND UPLOAD FILE, BACKEND BẮT ĐƯỢC FILE CẦN SETTING NHỮNG GÌ?

========================================================
I. TỔNG QUAN

Để frontend upload file lên server và backend nhận được file,
cần cấu hình đúng ở cả 2 phía:

1) Frontend
2) HTTP request
3) Backend
4) Server (Tomcat/Nginx/...)
5) Cấu hình kích thước file

Nếu thiếu một trong các phần này,
file có thể không gửi được hoặc backend không nhận được.

========================================================
II. PHÍA FRONTEND CẦN GÌ?

1) Input type file

HTML phải có:

<input type="file" name="file" />

Quan trọng:
Phải có thuộc tính name
→ Backend sẽ dùng name này để lấy file.

--------------------------------------------------------

2) Form phải có enctype đúng

<form method="post" enctype="multipart/form-data">

Nếu không có:
File sẽ không được gửi đúng cách.

--------------------------------------------------------

3) Nếu dùng JavaScript (Axios / Fetch)

Phải dùng FormData:

- Tạo FormData
- Append file
- Gửi request dạng multipart/form-data

========================================================
III. HTTP REQUEST PHẢI LÀ MULTIPART

Content-Type phải là:

multipart/form-data

Đây là chuẩn để gửi file qua HTTP.

Nếu dùng:
application/json
→ File sẽ không gửi được.

========================================================
IV. PHÍA BACKEND CẦN GÌ?

Phụ thuộc framework (ví dụ Spring Boot):

1) Endpoint phải nhận multipart

Ví dụ concept:

@PostMapping("/upload")
public Response upload(@RequestParam("file") MultipartFile file)

Tên "file" phải trùng với name bên frontend.

--------------------------------------------------------

2) Phải enable multipart

Trong Spring Boot thường có:

spring.servlet.multipart.enabled=true

--------------------------------------------------------

3) Cấu hình kích thước file

Ví dụ:

spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

Nếu không:
Upload file lớn sẽ bị lỗi 413.

========================================================
V. CẤU HÌNH SERVER

1) Tomcat

Nếu dùng Tomcat embedded:
Phải cấu hình maxPostSize.

Nếu không:
File lớn sẽ bị reject.

--------------------------------------------------------

2) Nginx

Nếu có Nginx phía trước:

Cần set:

client_max_body_size 20M;

Nếu không:
Nginx sẽ chặn trước khi tới backend.

========================================================
VI. CORS (NẾU FRONTEND KHÁC DOMAIN)

Nếu frontend và backend khác domain:

Cần enable CORS:

- Cho phép method POST
- Cho phép Content-Type multipart/form-data

Nếu không:
Trình duyệt sẽ chặn request.

========================================================
VII. QUY TRÌNH HOẠT ĐỘNG

Bước 1:
Người dùng chọn file.

Bước 2:
Frontend gửi request multipart/form-data.

Bước 3:
Server nhận HTTP request.

Bước 4:
Framework parse multipart thành MultipartFile.

Bước 5:
Backend xử lý file:
- Lưu vào ổ đĩa
- Lưu database
- Gửi sang hệ thống khác

========================================================
VIII. NHỮNG LỖI THƯỜNG GẶP

1) 415 Unsupported Media Type
→ Sai Content-Type

2) 400 Bad Request
→ Sai tên tham số

3) 413 Payload Too Large
→ File vượt quá kích thước cho phép

4) file = null
→ Sai name giữa frontend và backend

========================================================
IX. CÁC YẾU TỐ BẢO MẬT CẦN SETTING

1) Giới hạn kích thước file
2) Kiểm tra loại file (MIME type)
3) Không tin tưởng tên file từ client
4) Quét virus (nếu cần)
5) Không cho upload file thực thi (.exe, .jsp)

========================================================
X. LƯU FILE Ở ĐÂU?

Backend có thể:

1) Lưu local disk
2) Lưu database (BLOB)
3) Lưu object storage (S3, MinIO)
4) Lưu qua SFTP sang server khác

========================================================
XI. CHECKLIST CẤU HÌNH ĐẦY ĐỦ

PHÍA FRONTEND:
- input type="file"
- name đúng
- enctype="multipart/form-data"
- Dùng FormData nếu dùng JS

PHÍA BACKEND:
- Endpoint nhận MultipartFile
- Enable multipart
- Cấu hình max file size

PHÍA SERVER:
- Tăng giới hạn body size (Tomcat/Nginx)

BẢO MẬT:
- Validate file type
- Validate size
- Không tin client

========================================================
XII. TÓM TẮT NGẮN GỌN

Để frontend upload file và backend nhận được file,
cần:

1) Gửi request dạng multipart/form-data
2) Backend có endpoint nhận MultipartFile
3) Cấu hình giới hạn kích thước
4) Server không chặn request lớn
5) Kiểm tra bảo mật file

========================================================

TÓM LẠI MỘT CÂU:

Muốn upload file thành công,
frontend phải gửi multipart/form-data,
backend phải enable multipart và cấu hình kích thước file phù hợp,
đồng thời server không được chặn request.

--- Hibernate.createBlob LÀ GÌ?

GIẢI THÍCH CHI TIẾT: Hibernate.createBlob LÀ GÌ?

========================================================
I. TỔNG QUAN

Hibernate.createBlob (hoặc session.getLobHelper().createBlob())
là cách trong Hibernate dùng để tạo đối tượng BLOB
(Binary Large Object) từ dữ liệu nhị phân (byte[] hoặc InputStream)
để lưu vào database.

Hiểu đơn giản:

createBlob giúp bạn lưu file hoặc dữ liệu nhị phân vào cột BLOB trong database.

========================================================
II. BLOB LÀ GÌ?

BLOB = Binary Large Object

Là kiểu dữ liệu trong database dùng để lưu:

- File PDF
- Ảnh
- File Excel
- File XML
- Dữ liệu nhị phân lớn

Ví dụ trong database:

MySQL:
BLOB, MEDIUMBLOB, LONGBLOB

Oracle:
BLOB

========================================================
III. VÌ SAO CẦN createBlob?

Database yêu cầu kiểu BLOB.
Hibernate không thể tự động convert byte[] sang BLOB
trong một số trường hợp (đặc biệt Oracle).

Vì vậy cần dùng:

createBlob(byte[] data)

để Hibernate tạo đúng đối tượng BLOB theo JDBC driver.

========================================================
IV. CÁCH SỬ DỤNG PHỔ BIẾN

Trong Hibernate hiện đại:

Blob blob = session.getLobHelper().createBlob(byteArray);

Hoặc:

Blob blob = Hibernate.getLobCreator(session).createBlob(byteArray);

========================================================
V. QUY TRÌNH LƯU FILE VÀO DATABASE

Bước 1:
Nhận file upload (MultipartFile)

Bước 2:
Chuyển file thành byte[]

Bước 3:
Gọi createBlob(byte[])

Bước 4:
Set vào entity

Bước 5:
Save entity

========================================================
VI. ENTITY MAPPING

Ví dụ concept:

@Column(name="file_data")
@Lob
private Blob fileData;

@Lob cho Hibernate biết:
Đây là Large Object.

========================================================
VII. KHÁC GÌ VỚI LƯU byte[] TRỰC TIẾP?

Bạn có thể khai báo:

@Lob
private byte[] fileData;

Hibernate sẽ tự xử lý trong nhiều trường hợp.

Nhưng:

Với một số database (Oracle),
việc dùng createBlob an toàn hơn.

========================================================
VIII. createBlob HỖ TRỢ NHỮNG GÌ?

1) createBlob(byte[])
2) createBlob(InputStream, length)

Trường hợp file lớn:
Nên dùng InputStream
để tránh load toàn bộ vào RAM.

========================================================
IX. LUỒNG HOẠT ĐỘNG BÊN TRONG

1) Hibernate gọi JDBC driver
2) JDBC driver tạo java.sql.Blob
3) Hibernate gán Blob vào PreparedStatement
4) Database lưu dữ liệu

========================================================
X. LỖI THƯỜNG GẶP

1) java.sql.SQLException: invalid column type
→ Mapping sai kiểu

2) ORA-22275 (Oracle)
→ Xử lý BLOB sai cách

3) OutOfMemoryError
→ File quá lớn, load hết vào RAM

========================================================
XI. KHI NÀO NÊN DÙNG BLOB?

Nên dùng khi:

- File nhỏ
- Cần transactional consistency
- File gắn chặt với record

Không nên dùng khi:

- File lớn (video, file > 100MB)
- Cần truy cập thường xuyên

Thay vào đó:
Lưu file vào filesystem hoặc object storage,
chỉ lưu đường dẫn trong DB.

========================================================
XII. HIỆU NĂNG

Lưu BLOB trong DB:

Ưu điểm:
- Backup đồng bộ
- Transaction đảm bảo

Nhược điểm:
- Tăng kích thước DB
- Giảm hiệu năng query
- Backup chậm

========================================================
XIII. TRONG HỆ THỐNG NGÂN HÀNG

createBlob thường dùng để lưu:

- File đối soát
- File chứng từ
- File XML giao dịch
- Ảnh CMND

========================================================
XIV. TÓM TẮT NGẮN GỌN

Hibernate.createBlob là phương thức
tạo đối tượng BLOB từ byte[] hoặc InputStream
để lưu dữ liệu nhị phân vào database thông qua Hibernate.

========================================================

TÓM LẠI MỘT CÂU:

createBlob giúp Hibernate chuyển dữ liệu nhị phân
thành đối tượng BLOB chuẩn JDBC
để lưu file hoặc dữ liệu binary vào database.

--- CÁC BƯỚC ĐỂ BẮT ĐẦU GỬI FILE BẰNG JSCH (SFTP) TRONG JAVA

GIẢI THÍCH CHI TIẾT:
CÁC BƯỚC ĐỂ BẮT ĐẦU GỬI FILE BẰNG JSCH (SFTP) TRONG JAVA

========================================================
I. JSCH LÀ GÌ?

JSch là thư viện Java dùng để:

- Kết nối SSH
- Thực hiện SFTP
- Upload / Download file an toàn

JSch hoạt động dựa trên giao thức SSH (Secure Shell).

SFTP = SSH File Transfer Protocol
→ Truyền file an toàn, có mã hóa.

========================================================
II. KHÁC NHAU GIỮA FTP VÀ SFTP (JSCH)

FTP:
- Không mã hóa
- Dùng port 21

SFTP (JSch):
- Chạy trên SSH
- Mã hóa toàn bộ dữ liệu
- Dùng port 22
- An toàn cho production và ngân hàng

========================================================
III. TỔNG QUAN LUỒNG GỬI FILE BẰNG JSCH

Luồng chuẩn gồm 9 bước:

1) Thêm dependency JSch
2) Tạo đối tượng JSch
3) Tạo Session
4) Set cấu hình Session
5) Kết nối Session
6) Mở Channel SFTP
7) Kết nối Channel
8) Upload file
9) Đóng channel và session

========================================================
IV. BƯỚC 1: THÊM THƯ VIỆN JSCH

Nếu dùng Maven:
Thêm dependency JSch vào pom.xml

Nếu không:
Tải file jar và add vào project.

========================================================
V. BƯỚC 2: TẠO ĐỐI TƯỢNG JSCH

Tạo instance:

JSch jsch = new JSch();

Đây là điểm bắt đầu cho mọi thao tác SSH.

========================================================
VI. BƯỚC 3: TẠO SESSION

Session đại diện cho:

Kết nối SSH tới server.

Cần 4 thông tin:

- username
- host
- port (thường là 22)
- password hoặc private key

Ví dụ logic:

Session session = jsch.getSession(username, host, port);

========================================================
VII. BƯỚC 4: SET CẤU HÌNH SESSION

Thông thường phải tắt kiểm tra host key khi test:

session.setConfig("StrictHostKeyChecking", "no");

Trong production:
NÊN cấu hình known_hosts thay vì tắt.

========================================================
VIII. BƯỚC 5: SET PASSWORD HOẶC PRIVATE KEY

Cách 1: Dùng password

session.setPassword(password);

Cách 2: Dùng private key (an toàn hơn)

jsch.addIdentity(pathToPrivateKey);

========================================================
IX. BƯỚC 6: CONNECT SESSION

session.connect();

Sau bước này:
SSH connection đã được thiết lập.

========================================================
X. BƯỚC 7: MỞ CHANNEL SFTP

Channel là kênh làm việc bên trong SSH.

Channel channel = session.openChannel("sftp");

Sau đó:

channel.connect();

Ép kiểu:

ChannelSftp sftp = (ChannelSftp) channel;

========================================================
XI. BƯỚC 8: UPLOAD FILE

Upload file bằng:

sftp.put(localPath, remotePath);

Hoặc dùng InputStream:

sftp.put(inputStream, remoteFileName);

Nếu không có exception:
Upload thành công.

========================================================
XII. BƯỚC 9: ĐÓNG KẾT NỐI

Luôn đóng theo thứ tự:

1) sftp.exit();
2) channel.disconnect();
3) session.disconnect();

Nếu không:
Sẽ gây rò rỉ kết nối.

========================================================
XIII. TÓM TẮT LUỒNG CHUẨN

JSch
  ↓
Session
  ↓
Connect SSH
  ↓
Open SFTP Channel
  ↓
Upload file
  ↓
Close everything

========================================================
XIV. CÁC LỖI THƯỜNG GẶP

1) Auth fail
→ Sai username/password hoặc private key

2) UnknownHostKey
→ Chưa cấu hình known_hosts

3) Connection refused
→ Sai IP hoặc port

4) Permission denied
→ Không có quyền ghi file trên server

5) No such file
→ Sai đường dẫn remote

========================================================
XV. NHỮNG ĐIỂM QUAN TRỌNG

1) Không hardcode password trong code
2) Nên dùng private key thay vì password
3) Luôn đóng session trong finally
4) Nên set timeout
5) Nên kiểm tra file tồn tại trước khi upload

========================================================
XVI. VÍ DỤ LUỒNG THỰC TẾ TRONG HỆ THỐNG

Trong ngân hàng:

- Ứng dụng tạo file batch
- Kết nối SFTP bằng JSch
- Upload file thanh toán
- Ghi log kết quả
- Đóng kết nối

========================================================
XVII. KHI NÀO DÙNG JSCH?

Dùng khi:

- Cần truyền file an toàn
- Làm việc với server Linux
- Tích hợp hệ thống ngân hàng
- Trao đổi file batch
- Đồng bộ dữ liệu qua SSH

========================================================
XVIII. SO SÁNH NHANH

JSch (SFTP):
+ An toàn
+ Mã hóa
+ Phù hợp production

FTPClient:
+ Đơn giản
- Không an toàn nếu không dùng FTPS

========================================================
XIX. KẾT LUẬN

Các bước gửi file bằng JSch gồm:

1) Tạo JSch
2) Tạo Session
3) Cấu hình
4) Connect
5) Mở SFTP channel
6) Upload file
7) Đóng kết nối

========================================================

TÓM LẠI MỘT CÂU:

Gửi file bằng JSch là quá trình thiết lập SSH session,
mở kênh SFTP và dùng phương thức put()
để truyền file an toàn lên server.

--- 1 CLASS IMPLEMENT SERIALIZABLE MANG Ý NGHĨA LÀ GÌ?

GIẢI THÍCH CHI TIẾT:
TRONG JAVA, 1 CLASS IMPLEMENT SERIALIZABLE MANG Ý NGHĨA LÀ GÌ?

========================================================
I. SERIALIZABLE LÀ GÌ?

Serializable là một interface trong Java.

Khi một class implement Serializable,
nó có nghĩa là:

Đối tượng của class đó có thể được chuyển thành dạng byte stream
để lưu trữ hoặc truyền đi.

Quá trình này gọi là:
Serialization.

Ngược lại:
Chuyển byte stream trở lại object gọi là:
Deserialization.

========================================================
II. SERIALIZATION LÀ GÌ?

Serialization là quá trình:

Object → Byte stream

Mục đích:

1) Lưu object xuống file
2) Gửi object qua mạng
3) Lưu vào cache
4) Lưu vào session
5) Truyền giữa các JVM

========================================================
III. TẠI SAO PHẢI IMPLEMENT SERIALIZABLE?

Trong Java:

Không phải object nào cũng tự động serialize được.

Chỉ khi class implement Serializable,
Java mới cho phép chuyển object đó thành byte stream.

Serializable là một marker interface
(tức là không có method nào).

Nó chỉ đánh dấu rằng:

"Tôi cho phép object này được serialize"

========================================================
IV. CÁCH HOẠT ĐỘNG

Ví dụ:

class Person implements Serializable

Khi đó:

Person object có thể:

- Ghi vào file bằng ObjectOutputStream
- Đọc lại bằng ObjectInputStream
- Gửi qua socket
- Lưu trong HttpSession

Nếu class không implement Serializable,
Java sẽ ném lỗi:

NotSerializableException

========================================================
V. SERIALVERSIONUID LÀ GÌ?

Khi serialize object,
Java sẽ ghi kèm một mã version gọi là:

serialVersionUID

Mục đích:

- Kiểm tra tính tương thích giữa class khi deserialize.

Nếu version khác nhau:
→ InvalidClassException

Cách khai báo:

private static final long serialVersionUID = 1L;

Nên luôn khai báo rõ ràng.

========================================================
VI. QUÁ TRÌNH SERIALIZATION DIỄN RA NHƯ SAU

Bước 1:
ObjectOutputStream ghi object

Bước 2:
JVM:
- Ghi class metadata
- Ghi giá trị field
- Ghi serialVersionUID

Bước 3:
Sinh ra byte stream

========================================================
VII. QUÁ TRÌNH DESERIALIZATION

Bước 1:
Đọc byte stream

Bước 2:
Kiểm tra serialVersionUID

Bước 3:
Tạo object mới

Bước 4:
Gán giá trị field từ stream

========================================================
VIII. FIELD NÀO ĐƯỢC SERIALIZE?

Mặc định:

- Tất cả field non-static
- Không phải transient

Không được serialize:

1) static field
2) transient field

========================================================
IX. TRANSIENT LÀ GÌ?

Transient dùng để:

Loại trừ field khỏi quá trình serialize.

Ví dụ:

transient String password;

Mục đích:

- Không lưu thông tin nhạy cảm
- Không lưu field tạm thời

========================================================
X. LƯU Ý KHI CLASS CÓ OBJECT BÊN TRONG

Nếu class A implement Serializable
nhưng có field là class B

Thì:

Class B cũng phải implement Serializable.

Nếu không:
Sẽ lỗi NotSerializableException.

========================================================
XI. ỨNG DỤNG THỰC TẾ

1) HttpSession trong Web
   → Object lưu trong session phải Serializable

2) Distributed cache (Redis, Hazelcast)

3) RMI (Remote Method Invocation)

4) Gửi object qua socket

5) Lưu object xuống file

========================================================
XII. RỦI RO KHI DÙNG SERIALIZABLE

1) Thay đổi cấu trúc class
2) Xóa field
3) Đổi kiểu dữ liệu
4) Không quản lý serialVersionUID

Có thể gây lỗi khi deserialize.

========================================================
XIII. CUSTOM SERIALIZATION

Có thể override:

private void writeObject(...)
private void readObject(...)

Để kiểm soát cách serialize/deserialze.

========================================================
XIV. SERIALIZABLE KHÔNG PHẢI LÀ BẢO MẬT

Serializable:

KHÔNG mã hóa dữ liệu.

Nếu lưu password:
Phải tự mã hóa trước.

========================================================
XV. SO SÁNH VỚI JSON SERIALIZATION

Java Serializable:
- Chuyển thành binary
- Dùng trong JVM
- Không đọc được bằng mắt

JSON:
- Dạng text
- Dễ debug
- Dùng khi giao tiếp API

========================================================
XVI. KHI NÀO NÊN DÙNG SERIALIZABLE?

Nên dùng khi:

- Cần lưu object nội bộ JVM
- Cần lưu session
- Cần truyền object Java thuần

Không nên dùng khi:

- Giao tiếp REST API
- Truyền giữa hệ thống khác ngôn ngữ

========================================================
XVII. TÓM TẮT Ý NGHĨA

Khi một class implement Serializable:

→ Bạn cho phép object của class đó
   được chuyển thành byte stream
   để lưu trữ hoặc truyền đi.

========================================================

TÓM LẠI MỘT CÂU:

Implement Serializable nghĩa là
object của class đó có thể được
serialize (chuyển thành byte stream)
và deserialize (khôi phục lại thành object).

--- GREGORIANCALENDAR TRONG JAVA

GREGORIANCALENDAR TRONG JAVA – GIẢI THÍCH CHI TIẾT NHẤT

1. GregorianCalendar là gì?

GregorianCalendar là một class trong Java thuộc package:

    java.util.GregorianCalendar

Nó là một lớp con (subclass) của:

    java.util.Calendar

GregorianCalendar dùng để biểu diễn và xử lý ngày tháng theo hệ lịch Gregory (Gregorian calendar) – đây là hệ lịch đang được sử dụng phổ biến trên toàn thế giới hiện nay.

Nói đơn giản:
- Calendar là lớp trừu tượng (abstract class)
- GregorianCalendar là một triển khai (implementation) cụ thể của Calendar


=====================================================================
2. Vị trí của GregorianCalendar trong hệ thống class

Object
   └── Calendar (abstract class)
         └── GregorianCalendar

Calendar định nghĩa:
- Các trường thời gian (YEAR, MONTH, DAY_OF_MONTH, HOUR, ...)
- Các phương thức chung để xử lý ngày giờ

GregorianCalendar:
- Cung cấp cách tính toán cụ thể dựa trên lịch Gregory
- Hỗ trợ chuyển đổi giữa lịch Julian và Gregorian


=====================================================================
3. Lịch Gregory là gì?

Lịch Gregory được Giáo hoàng Gregory XIII ban hành năm 1582 để sửa sai lệch của lịch Julian.

Điểm quan trọng:
- 1 năm thường có 365 ngày
- Năm nhuận có 366 ngày
- Quy tắc năm nhuận:
    + Chia hết cho 4 → năm nhuận
    + Nhưng nếu chia hết cho 100 → không phải năm nhuận
    + Nhưng nếu chia hết cho 400 → vẫn là năm nhuận

Ví dụ:
- 2000 → chia hết cho 400 → năm nhuận
- 1900 → chia hết cho 100 nhưng không chia hết cho 400 → không nhuận
- 2024 → chia hết cho 4 → năm nhuận


=====================================================================
4. Constructor của GregorianCalendar

Một số constructor thường dùng:

1)
GregorianCalendar()

→ Tạo đối tượng với:
- Thời điểm hiện tại
- TimeZone mặc định của hệ thống
- Locale mặc định

2)
GregorianCalendar(int year, int month, int dayOfMonth)

Lưu ý cực kỳ quan trọng:
- month trong Java bắt đầu từ 0

Ví dụ:
    0  → January
    1  → February
    ...
    11 → December

Ví dụ:
    new GregorianCalendar(2026, 1, 19)

KHÔNG phải tháng 1 mà là tháng 2 (February)


3)
GregorianCalendar(int year, int month, int dayOfMonth,
                  int hourOfDay, int minute, int second)

→ Tạo đầy đủ ngày giờ


=====================================================================
5. Các field quan trọng trong Calendar

Calendar.YEAR
Calendar.MONTH
Calendar.DAY_OF_MONTH
Calendar.DAY_OF_WEEK
Calendar.HOUR
Calendar.HOUR_OF_DAY
Calendar.MINUTE
Calendar.SECOND
Calendar.MILLISECOND

Lưu ý:
MONTH bắt đầu từ 0


=====================================================================
6. Cách lấy giá trị ngày tháng

Ví dụ:

GregorianCalendar cal = new GregorianCalendar();

int year = cal.get(Calendar.YEAR);
int month = cal.get(Calendar.MONTH);
int day = cal.get(Calendar.DAY_OF_MONTH);

Phương thức:

cal.get(field)

→ Trả về giá trị của trường tương ứng


=====================================================================
7. Cách thay đổi giá trị ngày tháng

7.1 set()

cal.set(Calendar.YEAR, 2030);

→ Đặt lại năm thành 2030

7.2 add()

cal.add(Calendar.DAY_OF_MONTH, 5);

→ Cộng thêm 5 ngày

Nếu đang là 28/02/2026
Sau add 5 ngày → tự động chuyển sang tháng 3

add() sẽ xử lý tràn tháng, tràn năm tự động.


7.3 roll()

cal.roll(Calendar.DAY_OF_MONTH, 5);

Khác với add():
- roll không làm thay đổi trường lớn hơn

Ví dụ:
31/01/2026 roll 1 ngày
→ có thể quay lại trong cùng tháng mà không sang tháng 2


=====================================================================
8. Cách kiểm tra năm nhuận

GregorianCalendar có method:

boolean isLeapYear(int year)

Ví dụ:

GregorianCalendar cal = new GregorianCalendar();
boolean leap = cal.isLeapYear(2024);

→ true


=====================================================================
9. TimeZone trong GregorianCalendar

GregorianCalendar hoạt động cùng TimeZone.

Ví dụ:

TimeZone tz = TimeZone.getTimeZone("Asia/Ho_Chi_Minh");
GregorianCalendar cal = new GregorianCalendar(tz);

Nếu không truyền vào:
→ dùng timezone mặc định hệ thống


=====================================================================
10. Chuyển đổi sang Date

GregorianCalendar cal = new GregorianCalendar();
Date date = cal.getTime();

getTime() trả về java.util.Date


=====================================================================
11. Cơ chế hoạt động bên trong

GregorianCalendar lưu trữ thời gian dưới dạng:

milliseconds tính từ mốc 1/1/1970 00:00:00 GMT (Unix Epoch)

Khi bạn gọi:
- get()
- set()
- add()

Nó sẽ:
1. Chuyển đổi millisecond → các field (YEAR, MONTH, DAY...)
2. Hoặc ngược lại


=====================================================================
12. Vấn đề hiệu năng

GregorianCalendar:
- Nặng
- Phức tạp
- Không thread-safe

Không nên dùng trong ứng dụng hiện đại nếu không bắt buộc.


=====================================================================
13. Hạn chế lớn

1) Không thread-safe
→ Không dùng chung giữa nhiều thread

2) API khó dùng
→ month bắt đầu từ 0 gây lỗi phổ biến

3) Thiết kế cũ (legacy)


=====================================================================
14. Thay thế hiện đại

Từ Java 8 trở đi nên dùng:

java.time package

Ví dụ:

- LocalDate
- LocalDateTime
- ZonedDateTime
- Instant

Các class này:
- Immutable
- Thread-safe
- Dễ đọc
- Không bị month bắt đầu từ 0


=====================================================================
15. Khi nào vẫn dùng GregorianCalendar?

- Làm việc với code cũ (legacy)
- API cũ yêu cầu java.util.Calendar
- Hệ thống chưa nâng cấp lên Java 8+


=====================================================================
16. Tóm tắt ngắn gọn

GregorianCalendar là:
- Triển khai cụ thể của Calendar
- Dùng hệ lịch Gregory
- Xử lý ngày tháng dựa trên millisecond từ epoch
- Hỗ trợ timezone
- Không thread-safe
- Đã lỗi thời so với java.time


=====================================================================
KẾT LUẬN

Nếu bạn đang học Java core để hiểu hệ thống cũ → nên hiểu rõ GregorianCalendar.

Nếu bạn đang viết hệ thống mới → nên dùng java.time thay vì GregorianCalendar.

Hiểu GregorianCalendar giúp bạn:
- Debug hệ thống cũ
- Hiểu cách Java xử lý thời gian nội bộ
- Tránh lỗi month bắt đầu từ 0
- Hiểu rõ add() và roll() khác nhau thế nào

Đây là toàn bộ kiến thức nền tảng và chuyên sâu về GregorianCalendar trong Java.

--- new ByteArrayInputStream(content.getBytes())

GIẢI THÍCH CHI TIẾT NHẤT CHO:

new ByteArrayInputStream(content.getBytes())

(Lưu ý: Trong Java đúng là getBytes(), không phải getByte())


=====================================================================
1. Tổng quan câu lệnh

new ByteArrayInputStream(content.getBytes())

Câu lệnh này làm 2 việc:

Bước 1:
content.getBytes()
→ chuyển một chuỗi String thành mảng byte[]

Bước 2:
new ByteArrayInputStream(byte[])
→ tạo một InputStream đọc dữ liệu từ mảng byte đó

Nói đơn giản:
Bạn biến một String trong bộ nhớ thành một InputStream giả lập như đang đọc từ file.


=====================================================================
2. ByteArrayInputStream là gì?

ByteArrayInputStream là class thuộc package:

    java.io.ByteArrayInputStream

Nó kế thừa:

    InputStream

Dùng để đọc dữ liệu từ một mảng byte[] thay vì đọc từ file hoặc network.


=====================================================================
3. content.getBytes() là gì?

Giả sử:

String content = "Hello";

content.getBytes()

→ Java sẽ mã hóa chuỗi thành mảng byte dựa trên charset mặc định của hệ thống.

Ví dụ:
"Hello" → [72, 101, 108, 108, 111]

Mỗi ký tự sẽ được chuyển thành giá trị byte tương ứng theo bảng mã (ví dụ UTF-8).


=====================================================================
4. Luồng xử lý chi tiết từng bước

Giả sử:

String content = "ABC";

Bước 1:
byte[] data = content.getBytes();

Bên trong Java:
- Lấy từng ký tự 'A', 'B', 'C'
- Mã hóa theo charset (ví dụ UTF-8)
- Tạo mảng byte[]

Kết quả:
data = {65, 66, 67}

Bước 2:
ByteArrayInputStream bis = new ByteArrayInputStream(data);

Bên trong ByteArrayInputStream:

- Lưu reference đến mảng data
- Tạo con trỏ nội bộ pos = 0
- Khi gọi read():
    → trả về data[pos]
    → pos++


=====================================================================
5. Cấu trúc nội bộ của ByteArrayInputStream

Bên trong class có các biến quan trọng:

protected byte[] buf;
protected int pos;
protected int mark;
protected int count;

Giải thích:

buf   → mảng byte nguồn
pos   → vị trí đang đọc
count → tổng số byte
mark  → vị trí đánh dấu


=====================================================================
6. Khi gọi read()

Ví dụ:

ByteArrayInputStream bis = new ByteArrayInputStream(data);

bis.read();

Quy trình:

1. Kiểm tra pos < count ?
2. Nếu còn dữ liệu:
      trả về buf[pos]
      tăng pos lên 1
3. Nếu hết dữ liệu:
      trả về -1


=====================================================================
7. Vì sao cần tạo InputStream từ String?

Rất nhiều API trong Java yêu cầu InputStream, ví dụ:

- Servlet upload
- XML parser
- PDF generator
- SFTP upload
- SAXReader
- API đọc file

Nhưng bạn không có file thật, chỉ có String.

Lúc này:
→ Chuyển String thành InputStream bằng ByteArrayInputStream


=====================================================================
8. Ví dụ thực tế

Ví dụ đọc như file:

String content = "Xin chao";
ByteArrayInputStream bis =
    new ByteArrayInputStream(content.getBytes());

int ch;
while ((ch = bis.read()) != -1) {
    System.out.print((char) ch);
}

Kết quả:
Xin chao


=====================================================================
9. Quan trọng: Charset

getBytes() nếu không truyền charset:

content.getBytes()

→ dùng charset mặc định của hệ thống

Điều này có thể gây lỗi nếu hệ thống khác nhau.

An toàn hơn:

content.getBytes(StandardCharsets.UTF_8)

Ví dụ:

new ByteArrayInputStream(
    content.getBytes(StandardCharsets.UTF_8)
);


=====================================================================
10. So sánh với FileInputStream

FileInputStream:
- Đọc từ file thật trên disk
- Có I/O vật lý
- Chậm hơn

ByteArrayInputStream:
- Đọc từ RAM
- Không I/O vật lý
- Rất nhanh


=====================================================================
11. Bộ nhớ hoạt động như thế nào?

Khi dùng:

new ByteArrayInputStream(content.getBytes())

Memory sẽ chứa:

[String content]
      ↓
[byte[]]
      ↓
[ByteArrayInputStream reference đến byte[]]

Không có sao chép dữ liệu thêm lần nữa.

ByteArrayInputStream chỉ giữ reference tới mảng byte.


=====================================================================
12. Có cần close() không?

Về mặt kỹ thuật:
ByteArrayInputStream.close() không làm gì cả.

Vì nó không mở tài nguyên hệ thống như file hoặc socket.

Nhưng vẫn nên gọi close() nếu dùng trong cấu trúc chung để code sạch.


=====================================================================
13. Tại sao dùng trong upload SFTP?

Ví dụ:

channelSftp.put(
    new ByteArrayInputStream(content.getBytes()),
    "file.txt"
);

Ở đây:
- Không cần tạo file tạm
- Upload trực tiếp dữ liệu từ memory
- Nhanh và gọn


=====================================================================
14. Lỗi thường gặp

1) Dùng getBytes() không chỉ định charset
→ Sai encoding

2) Hiểu nhầm getByte()
→ Không tồn tại

3) Nghĩ rằng ByteArrayInputStream tạo bản sao dữ liệu
→ Thực tế chỉ giữ reference


=====================================================================
15. Tổng kết

new ByteArrayInputStream(content.getBytes())

Là thao tác:

1) Chuyển String → byte[]
2) Bọc byte[] thành InputStream
3) Cho phép API khác đọc như đang đọc file

Nó là cách chuẩn để:
- Giả lập file
- Truyền dữ liệu vào API yêu cầu InputStream
- Tránh tạo file tạm trên disk


=====================================================================
CÔNG THỨC TƯ DUY HỆ THỐNG

String
  ↓ encode
byte[]
  ↓ wrap
ByteArrayInputStream
  ↓ read()
API tiêu thụ InputStream


Hiểu câu lệnh này giúp bạn:
- Làm việc với SFTP
- Upload file
- Tạo XML từ chuỗi
- Gửi dữ liệu HTTP
- Làm việc với stream trong Java core

Đây là toàn bộ phân tích từ cơ bản đến nội bộ của:

new ByteArrayInputStream(content.getBytes())

--- clazz.getDeclaredMethod(...) VÀ method.invoke(...)

GIẢI THÍCH CHI TIẾT NHẤT CHO:

clazz.getDeclaredMethod(...) VÀ method.invoke(...)

(Thuộc cơ chế Reflection trong Java)


=====================================================================
1. Reflection là gì?

Reflection là cơ chế cho phép chương trình:
- Phân tích cấu trúc class tại runtime
- Truy cập method, field, constructor
- Gọi method động (dynamic invocation)

Reflection nằm trong package:

    java.lang.reflect


=====================================================================
2. clazz là gì?

clazz là một đối tượng thuộc kiểu:

    java.lang.Class

Ví dụ:

Class<?> clazz = MyClass.class;

Hoặc:

Class<?> clazz = obj.getClass();

Class đại diện cho cấu trúc metadata của một class trong JVM:
- Tên class
- Danh sách method
- Field
- Constructor
- Annotation


=====================================================================
3. getDeclaredMethod là gì?

Cú pháp:

Method method = clazz.getDeclaredMethod(String name,
                                         Class<?>... parameterTypes);

Ý nghĩa:

- Tìm method theo tên
- Trong chính class đó
- Không quan tâm public hay private
- Không tìm trong class cha


=====================================================================
4. Sự khác nhau giữa getMethod và getDeclaredMethod

getMethod():
- Chỉ lấy method public
- Bao gồm cả method từ class cha

getDeclaredMethod():
- Lấy mọi method (private, protected, default, public)
- Chỉ trong class hiện tại
- Không lấy từ class cha


=====================================================================
5. Ví dụ minh họa

Giả sử:

class Person {
    private String sayHello(String name) {
        return "Hello " + name;
    }
}

Ta muốn gọi method private này bằng Reflection.


=====================================================================
6. Cách dùng getDeclaredMethod

Class<?> clazz = Person.class;

Method method = clazz.getDeclaredMethod(
    "sayHello",
    String.class
);

Giải thích:

"sayHello"  → tên method
String.class → kiểu tham số

Nếu method có nhiều tham số:

methodName(int.class, String.class, ...)


=====================================================================
7. Vấn đề với private method

Nếu method là private:

method.setAccessible(true);

Nếu không:
→ IllegalAccessException


=====================================================================
8. invoke là gì?

Cú pháp:

Object result = method.invoke(Object obj,
                              Object... args);

Ý nghĩa:

- Gọi method tại runtime
- Truyền vào object cần gọi
- Truyền tham số
- Trả về kết quả dạng Object


=====================================================================
9. Cách invoke hoạt động bên trong

Khi gọi:

method.invoke(obj, "Tuan");

JVM sẽ:

1. Kiểm tra quyền truy cập
2. Kiểm tra số lượng tham số
3. Kiểm tra kiểu dữ liệu
4. Gọi method thật sự
5. Trả về kết quả


=====================================================================
10. Ví dụ đầy đủ

Person p = new Person();

Class<?> clazz = p.getClass();

Method method = clazz.getDeclaredMethod(
    "sayHello",
    String.class
);

method.setAccessible(true);

Object result = method.invoke(p, "Tuan");

System.out.println(result);

Kết quả:
Hello Tuan


=====================================================================
11. Phân tích sâu từng bước

Bước 1:
clazz.getDeclaredMethod()

→ JVM tra cứu method trong metadata của class

Bước 2:
method.setAccessible(true)

→ Bỏ qua kiểm tra access modifier

Bước 3:
method.invoke()

→ Tạo frame thực thi mới trong JVM
→ Đẩy tham số vào stack
→ Gọi method thật
→ Nhận kết quả


=====================================================================
12. Trường hợp method static

Nếu method là static:

method.invoke(null, args);

Vì static không cần object instance


=====================================================================
13. Kiểu trả về

invoke luôn trả về Object

Nếu method trả về int:

int value = (int) method.invoke(obj);

Nếu void:

method.invoke(obj);
→ trả về null


=====================================================================
14. Các Exception thường gặp

1) NoSuchMethodException
→ Không tìm thấy method

2) IllegalAccessException
→ Không có quyền truy cập

3) InvocationTargetException
→ Method bên trong ném exception
→ Exception thật nằm trong:

e.getCause()

4) IllegalArgumentException
→ Sai kiểu tham số


=====================================================================
15. Cơ chế nội bộ trong JVM

Reflection chậm hơn gọi trực tiếp vì:

- Không resolve tại compile time
- Phải lookup metadata
- Phải kiểm tra bảo mật
- Không inline optimization

Do đó:
Reflection thường chậm hơn 5-20 lần


=====================================================================
16. Tại sao vẫn dùng Reflection?

Vì:

- Framework cần gọi method không biết trước
- Dependency Injection (Spring)
- Hibernate mapping
- JSON mapping (Jackson)
- JUnit gọi test method


=====================================================================
17. Ví dụ trong Spring

Spring dùng Reflection để:

- Tìm annotation
- Inject dependency
- Gọi method có @PostConstruct
- Gọi controller method


=====================================================================
18. Lưu ý quan trọng

1) Không lạm dụng Reflection
→ Khó debug
→ Chậm
→ Mất type safety

2) Ưu tiên interface hoặc lambda nếu có thể

3) Chỉ dùng Reflection khi:
   - Làm framework
   - Viết tool generic
   - Không biết method tại compile time


=====================================================================
19. Tóm tắt tư duy hệ thống

clazz
   ↓
getDeclaredMethod
   ↓
Method object (metadata)
   ↓
setAccessible(true) nếu cần
   ↓
invoke()
   ↓
Method thực thi trong JVM


=====================================================================
20. Kết luận

clazz.getDeclaredMethod(...):
→ Lấy method từ class, kể cả private

method.invoke(...):
→ Gọi method tại runtime

Hai cái này là lõi của Reflection trong Java.

Hiểu rõ chúng giúp bạn:
- Hiểu Spring hoạt động thế nào
- Hiểu Dependency Injection
- Debug framework
- Viết code dynamic

Đây là toàn bộ phân tích chi tiết về:

clazz.getDeclaredMethod và method.invoke trong Java.

--- UUID

GIẢI THÍCH CHI TIẾT NHẤT VỀ UUID – NÓ GIẢI QUYẾT VẤN ĐỀ GÌ?


=====================================================================
1. UUID LÀ GÌ?

UUID là viết tắt của:

    Universally Unique Identifier

Dịch ra:
    Định danh duy nhất toàn cầu

UUID là một chuỗi 128-bit được thiết kế để đảm bảo:
    Gần như không bao giờ trùng nhau trên toàn thế giới.

Trong Java, UUID nằm trong package:

    java.util.UUID


=====================================================================
2. UUID GIẢI QUYẾT VẤN ĐỀ GÌ?

Vấn đề cốt lõi trong hệ thống phần mềm:

Làm sao tạo ID duy nhất mà:
- Không cần hỏi server trung tâm
- Không cần auto increment
- Không bị trùng khi chạy nhiều máy
- Không bị trùng khi chạy phân tán
- Không cần lock database

UUID sinh ra để giải quyết bài toán này.


=====================================================================
3. TẠI SAO AUTO INCREMENT KHÔNG ĐỦ?

Ví dụ database:

id = 1, 2, 3, 4...

Vấn đề:

1) Hệ thống phân tán
   - Server A sinh ID 1
   - Server B sinh ID 1
   → Trùng

2) Microservices độc lập
   - Không có DB chung

3) Merge dữ liệu giữa nhiều database
   → Xung đột ID

4) Bị lộ thông tin
   - Nhìn ID biết có bao nhiêu record


=====================================================================
4. UUID GIẢI QUYẾT NHƯ THẾ NÀO?

UUID có 128 bit = 2^128 khả năng

Số lượng khả năng:
    340,282,366,920,938,463,463,374,607,431,768,211,456

Khả năng trùng gần như bằng 0 trong thực tế.

Do đó:
Mỗi server có thể tự sinh UUID mà không cần phối hợp với server khác.


=====================================================================
5. CẤU TRÚC UUID

UUID thường có dạng:

    550e8400-e29b-41d4-a716-446655440000

Gồm 5 nhóm:

8-4-4-4-12 ký tự hex

Tổng cộng 36 ký tự (bao gồm dấu -)

Thực chất bên trong là 128 bit nhị phân.


=====================================================================
6. CÁC PHIÊN BẢN UUID

UUID có nhiều version:

Version 1:
- Dựa trên timestamp + MAC address
- Có thể đoán được thời gian tạo

Version 2:
- DCE Security (ít dùng)

Version 3:
- Dựa trên hash MD5

Version 4:
- Random (phổ biến nhất)

Version 5:
- Dựa trên hash SHA-1

Trong Java:

UUID.randomUUID()

→ Tạo UUID version 4 (random)


=====================================================================
7. CÁCH TẠO UUID TRONG JAVA

UUID id = UUID.randomUUID();

System.out.println(id);

Ví dụ kết quả:
    c0a8012e-7b89-4b23-a1b2-9f1d12345678

Mỗi lần chạy sẽ khác nhau.


=====================================================================
8. UUID HOẠT ĐỘNG NHƯ THẾ NÀO (Version 4)?

Version 4:

- 122 bit là random
- 6 bit dành cho version + variant

Java dùng SecureRandom hoặc PRNG để sinh số ngẫu nhiên.

Do đó:
Xác suất trùng là cực kỳ thấp.


=====================================================================
9. UUID GIẢI QUYẾT BÀI TOÁN PHÂN TÁN

Trong hệ thống microservices:

Service A tạo user
Service B tạo order
Service C tạo invoice

Mỗi service có thể tự sinh UUID mà:
- Không cần DB chung
- Không cần coordination
- Không cần central ID server


=====================================================================
10. SO SÁNH UUID VỚI AUTO INCREMENT

AUTO INCREMENT:

Ưu điểm:
- Nhỏ gọn
- Index nhanh

Nhược điểm:
- Phải phụ thuộc DB
- Không phù hợp hệ phân tán
- Dễ đoán


UUID:

Ưu điểm:
- Không cần DB
- Phù hợp hệ phân tán
- Không đoán được
- Gần như không trùng

Nhược điểm:
- Dài
- Tốn bộ nhớ hơn
- Index chậm hơn nếu không tối ưu


=====================================================================
11. VẤN ĐỀ HIỆU NĂNG

UUID dạng String (36 ký tự):
→ Tốn 36 bytes (thực tế nhiều hơn vì encoding)

UUID dạng binary:
→ 16 bytes

Trong database lớn:
→ Nên lưu dạng BINARY(16) thay vì VARCHAR(36)


=====================================================================
12. UUID TRONG DATABASE

Ví dụ MySQL:

CHAR(36)      → lưu dạng text
BINARY(16)    → lưu dạng nhị phân (tốt hơn)

Vì 128 bit = 16 byte


=====================================================================
13. UUID CÓ THẬT SỰ KHÔNG BAO GIỜ TRÙNG?

Toán học:

Nếu sinh 1 tỷ UUID mỗi giây
Trong 100 năm

Xác suất trùng vẫn gần như bằng 0.

Theo lý thuyết Birthday Paradox:
Phải sinh khoảng 2^64 UUID mới có xác suất trùng đáng kể.


=====================================================================
14. KHI NÀO NÊN DÙNG UUID?

Nên dùng khi:

- Hệ thống phân tán
- Microservices
- Offline sync
- Public API (không muốn lộ số lượng record)
- Import/export dữ liệu giữa nhiều hệ thống


=====================================================================
15. KHI NÀO KHÔNG NÊN DÙNG UUID?

Không nên dùng khi:

- Hệ thống nhỏ, đơn giản
- Chỉ có 1 database
- Cần index cực nhanh
- Không có yêu cầu phân tán


=====================================================================
16. UUID KHÔNG PHẢI GIẢI PHÁP DUY NHẤT

Hiện nay còn có:

- Snowflake ID
- ULID
- KSUID

Các giải pháp này:
- Có tính sắp xếp theo thời gian
- Index tốt hơn UUID random


=====================================================================
17. TÓM TẮT TƯ DUY HỆ THỐNG

Vấn đề:
Làm sao tạo ID duy nhất trong hệ phân tán?

Giải pháp:
UUID

Cơ chế:
128-bit random

Kết quả:
Không cần coordination
Không trùng thực tế
An toàn khi merge dữ liệu


=====================================================================
18. KẾT LUẬN

UUID là:

- Một định danh 128-bit
- Gần như không trùng
- Giải quyết bài toán ID trong hệ thống phân tán
- Phù hợp microservices
- Không phụ thuộc database

Nếu bạn đang xây hệ thống hiện đại, phân tán:
UUID là giải pháp rất phổ biến.

Nếu bạn đang làm hệ thống nhỏ, monolith đơn giản:
Auto increment vẫn đủ dùng.

Đây là toàn bộ phân tích chi tiết nhất về UUID và vấn đề mà nó giải quyết.

--- PostMethod trong org.apache.commons.httpclient.methods.PostMethod

GIẢI THÍCH CHI TIẾT NHẤT VỀ:

PostMethod trong org.apache.commons.httpclient.methods.PostMethod


=====================================================================
1. PostMethod LÀ GÌ?

PostMethod là một class thuộc thư viện:

    org.apache.commons.httpclient

Cụ thể nằm trong package:

    org.apache.commons.httpclient.methods.PostMethod

Đây là thư viện Apache HttpClient phiên bản cũ (3.x),
không phải Apache HttpClient 4.x hoặc 5.x hiện đại.

PostMethod đại diện cho một HTTP request sử dụng phương thức POST.


=====================================================================
2. POST LÀ GÌ TRONG HTTP?

HTTP có nhiều method:

- GET
- POST
- PUT
- DELETE
- PATCH

POST được dùng để:
- Gửi dữ liệu lên server
- Submit form
- Upload dữ liệu
- Gọi API cần body request

PostMethod là lớp Java dùng để gửi HTTP POST request.


=====================================================================
3. VỊ TRÍ TRONG HỆ THỐNG CLASS

Object
   └── HttpMethodBase
         └── EntityEnclosingMethod
               └── PostMethod

Giải thích:

HttpMethodBase:
- Lớp nền tảng cho tất cả HTTP method

EntityEnclosingMethod:
- Cho phép request có body (entity)

PostMethod:
- Cụ thể hóa thành HTTP POST


=====================================================================
4. CÁCH SỬ DỤNG CƠ BẢN

Ví dụ:

HttpClient client = new HttpClient();

PostMethod post = new PostMethod("http://example.com/api");

post.addParameter("name", "Tuan");
post.addParameter("age", "25");

int status = client.executeMethod(post);

String response = post.getResponseBodyAsString();

post.releaseConnection();

Giải thích từng bước:

1) Tạo HttpClient
2) Tạo PostMethod với URL
3) Thêm tham số
4) Gửi request
5) Lấy response
6) Giải phóng connection


=====================================================================
5. CÁCH GỬI DỮ LIỆU TRONG PostMethod

Có 3 cách chính:

-----------------------------------------------------
A) addParameter()

post.addParameter("key", "value");

→ Tự động encode thành:
   application/x-www-form-urlencoded

Ví dụ body gửi đi:

key=value&key2=value2

-----------------------------------------------------
B) setRequestBody(NameValuePair[])

NameValuePair[] data = {
    new NameValuePair("username", "admin"),
    new NameValuePair("password", "123")
};

post.setRequestBody(data);

-----------------------------------------------------
C) setRequestEntity()

Dùng khi gửi JSON, XML hoặc binary

Ví dụ JSON:

String json = "{\"name\":\"Tuan\"}";

post.setRequestEntity(
    new StringRequestEntity(
        json,
        "application/json",
        "UTF-8"
    )
);

Cách này linh hoạt nhất.


=====================================================================
6. CÁCH HOẠT ĐỘNG BÊN TRONG

Khi gọi:

client.executeMethod(post);

Quy trình:

1) Mở TCP connection
2) Tạo HTTP request text
3) Gửi header
4) Gửi body
5) Nhận response
6) Parse response header
7) Lưu response body vào buffer


=====================================================================
7. LẤY RESPONSE

post.getResponseBodyAsString();

→ Trả về response dưới dạng String

Hoặc:

post.getResponseBody();

→ byte[]

Hoặc:

post.getResponseBodyAsStream();

→ InputStream


=====================================================================
8. HEADER TRONG PostMethod

Thêm header:

post.setRequestHeader("Authorization", "Bearer token");

Lấy header response:

post.getResponseHeader("Content-Type");


=====================================================================
9. STATUS CODE

int status = client.executeMethod(post);

Kiểm tra:

if (status == 200) {
    // OK
}

Hoặc:

if (status == HttpStatus.SC_OK)


=====================================================================
10. TẠI SAO PHẢI releaseConnection()?

Rất quan trọng.

Sau khi xong:

post.releaseConnection();

Nếu không:
- Connection không được trả về pool
- Có thể gây memory leak
- Hết connection


=====================================================================
11. HẠN CHẾ CỦA PostMethod (HttpClient 3.x)

1) API cũ, verbose
2) Không thread-safe nếu dùng sai
3) Khó cấu hình hơn phiên bản mới
4) Đã deprecated trong hệ thống hiện đại

Hiện nay nên dùng:

org.apache.http.client.methods.HttpPost (HttpClient 4.x)


=====================================================================
12. SO SÁNH HttpClient 3.x VÀ 4.x

3.x:
- PostMethod
- HttpClient

4.x:
- HttpPost
- CloseableHttpClient
- HttpEntity
- ResponseHandler

4.x mạnh hơn và dễ dùng hơn.


=====================================================================
13. KHI NÀO BẠN VẪN GẶP PostMethod?

- Dự án legacy cũ
- Hệ thống Java 6 / Java 7
- Ứng dụng không nâng cấp thư viện
- Code bảo trì


=====================================================================
14. TƯ DUY HỆ THỐNG

PostMethod đại diện cho:

HTTP POST request trong Java.

Luồng hoạt động:

Application
   ↓
PostMethod (build request)
   ↓
HttpClient
   ↓
TCP connection
   ↓
Server
   ↓
Response
   ↓
PostMethod giữ response


=====================================================================
15. VÍ DỤ THỰC TẾ GỬI JSON

HttpClient client = new HttpClient();

PostMethod post = new PostMethod("http://api.test.com/user");

String json = "{\"name\":\"Tuan\"}";

post.setRequestEntity(
    new StringRequestEntity(
        json,
        "application/json",
        "UTF-8"
    )
);

int status = client.executeMethod(post);

String response = post.getResponseBodyAsString();

post.releaseConnection();


=====================================================================
16. TỔNG KẾT

PostMethod là:

- Class đại diện HTTP POST
- Thuộc Apache Commons HttpClient 3.x
- Cho phép gửi form, JSON, XML
- Cần releaseConnection()
- Hiện tại là thư viện legacy

Nếu bạn đang làm dự án mới:
→ Nên dùng HttpClient 4.x hoặc 5.x
→ Hoặc dùng RestTemplate / WebClient / OkHttp

Nếu bạn đang bảo trì hệ thống cũ:
→ Phải hiểu rõ PostMethod để debug và sửa lỗi.


=====================================================================
KẾT LUẬN

PostMethod giúp Java gửi HTTP POST request theo chuẩn HTTP/1.1.
Nó từng rất phổ biến trước khi HttpClient 4.x ra đời.

Hiểu PostMethod giúp bạn:
- Debug hệ thống cũ
- Hiểu cơ chế HTTP trong Java
- Nắm rõ cách client-server giao tiếp

Đây là toàn bộ phân tích chi tiết nhất về PostMethod trong
org.apache.commons.httpclient.methods.PostMethod.

--- KHI FRONTEND GỬI FILE QUA BACKEND VỚI MULTIPART CÓ CẦN THIẾT LẬP REQUEST HEADER KHÔNG?

GIẢI THÍCH CHI TIẾT NHẤT CHO:

KHI FRONTEND GỬI FILE QUA BACKEND VỚI MULTIPART
CÓ CẦN THIẾT LẬP REQUEST HEADER KHÔNG?


=====================================================================
1. CÂU TRẢ LỜI NGẮN GỌN

CÓ.

BẮT BUỘC phải có header:

Content-Type: multipart/form-data; boundary=...

Nhưng:
Trong hầu hết trường hợp,
frontend (trình duyệt hoặc thư viện HTTP) sẽ tự động thiết lập cho bạn.


=====================================================================
2. MULTIPART LÀ GÌ?

multipart/form-data là chuẩn HTTP dùng để:

- Upload file
- Gửi form có file
- Gửi nhiều phần dữ liệu (text + file)

Nó cho phép chia body thành nhiều phần (part),
mỗi part có header riêng.


=====================================================================
3. CẤU TRÚC REQUEST MULTIPART

Ví dụ request thực tế:

POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXYZ

------WebKitFormBoundaryXYZ
Content-Disposition: form-data; name="username"

tuan
------WebKitFormBoundaryXYZ
Content-Disposition: form-data; name="file"; filename="a.txt"
Content-Type: text/plain

hello world
------WebKitFormBoundaryXYZ--


Ở đây có 2 header quan trọng:

1) Content-Type
2) boundary


=====================================================================
4. BOUNDARY LÀ GÌ?

Boundary là chuỗi phân cách giữa các phần dữ liệu.

Ví dụ:

boundary=----WebKitFormBoundaryXYZ

Server dùng boundary để biết:
- Phần nào bắt đầu
- Phần nào kết thúc

Nếu không có boundary → backend không thể parse file.


=====================================================================
5. FRONTEND CÓ CẦN TỰ SET HEADER KHÔNG?

TRƯỜNG HỢP 1: DÙNG HTML FORM

<form method="POST" enctype="multipart/form-data">

Trình duyệt tự động:
- Set Content-Type
- Tạo boundary
- Encode dữ liệu

→ Không cần set header thủ công


----------------------------------------------------------
TRƯỜNG HỢP 2: DÙNG fetch + FormData

Ví dụ:

const formData = new FormData();
formData.append("file", file);

fetch("/upload", {
  method: "POST",
  body: formData
});

KHÔNG được set:

headers: {
   "Content-Type": "multipart/form-data"
}

Vì:
Nếu bạn set thủ công,
trình duyệt sẽ KHÔNG thêm boundary.

→ Server sẽ lỗi parse.


=====================================================================
6. QUY TẮC QUAN TRỌNG NHẤT

Nếu dùng FormData:

KHÔNG BAO GIỜ tự set Content-Type.

Để trình duyệt tự làm.


=====================================================================
7. TRƯỜNG HỢP DÙNG AXIOS

axios tự động xử lý nếu bạn truyền FormData:

const formData = new FormData();
formData.append("file", file);

axios.post("/upload", formData);

→ axios tự set Content-Type + boundary

Không cần set thủ công.


=====================================================================
8. TRƯỜNG HỢP PHẢI TỰ SET HEADER

Chỉ khi:

- Bạn không dùng FormData
- Bạn tự build raw multipart body
- Hoặc gửi từ tool đặc biệt (ví dụ server-to-server)

Lúc đó bạn phải tự set:

Content-Type: multipart/form-data; boundary=abc123


=====================================================================
9. BACKEND XỬ LÝ NHƯ THẾ NÀO?

Ví dụ trong Spring:

@PostMapping("/upload")
public void upload(@RequestParam("file") MultipartFile file)

Spring kiểm tra:

Content-Type có phải multipart/form-data không?

Nếu không:
→ isMultipartContent(request) trả về false
→ Không parse file được


=====================================================================
10. LỖI THƯỜNG GẶP

1) Tự set Content-Type nhưng không có boundary
→ Server báo lỗi

2) Gửi JSON thay vì multipart
→ Backend không nhận file

3) Thiếu enctype="multipart/form-data" trong HTML form
→ File không được gửi


=====================================================================
11. TƯ DUY HỆ THỐNG

Frontend
   ↓
Tạo FormData
   ↓
Browser encode multipart
   ↓
Tự set Content-Type + boundary
   ↓
Backend parse multipart
   ↓
Tách từng part
   ↓
Trả về file


=====================================================================
12. TÓM TẮT QUAN TRỌNG

CÓ cần header không?
→ Có.

CÓ cần tự set không?
→ KHÔNG nếu dùng FormData hoặc HTML form.

Chỉ tự set khi bạn tự xây dựng multipart body.


=====================================================================
13. KẾT LUẬN

- multipart/form-data bắt buộc phải có Content-Type + boundary
- Nhưng frontend hiện đại sẽ tự làm cho bạn
- Không nên tự set Content-Type khi dùng FormData
- Nếu set sai → backend không parse được file

Đây là nguyên tắc quan trọng khi upload file từ frontend lên backend.

--- TRONG NGÂN HÀNG, "LỆNH" MANG Ý NGHĨA LÀ GÌ?

TRONG NGÂN HÀNG, "LỆNH" MANG Ý NGHĨA LÀ GÌ?

1. KHÁI NIỆM CHUNG

Trong lĩnh vực ngân hàng, “lệnh” là một chỉ thị (instruction) do khách hàng, hệ thống hoặc bộ phận nghiệp vụ phát ra nhằm yêu cầu ngân hàng thực hiện một hành động tài chính cụ thể.

Nói đơn giản:
Lệnh = Yêu cầu chính thức để thực hiện một giao dịch hoặc thao tác nghiệp vụ.

Lệnh có thể ở dạng:
- Văn bản giấy (phiếu, ủy nhiệm chi, séc…)
- Dữ liệu điện tử (Internet Banking, Mobile Banking, API)
- Thông điệp hệ thống (core banking, hệ thống thanh toán liên ngân hàng)

----------------------------------------
2. BẢN CHẤT CỦA LỆNH TRONG NGÂN HÀNG

Về bản chất, lệnh trong ngân hàng có 3 đặc điểm chính:

(1) Là yêu cầu mang tính pháp lý
Khi khách hàng phát hành lệnh, đó là một hành vi pháp lý yêu cầu ngân hàng thực hiện giao dịch theo thỏa thuận giữa hai bên.

(2) Là dữ liệu đầu vào của hệ thống ngân hàng
Hệ thống core banking tiếp nhận lệnh, kiểm tra điều kiện (số dư, hạn mức, quyền truy cập…) và xử lý.

(3) Là cơ sở ghi nhận kế toán
Sau khi lệnh được thực hiện, hệ thống sẽ:
- Ghi Nợ tài khoản này
- Ghi Có tài khoản kia
Từ đó tạo ra bút toán kế toán trong hệ thống.

----------------------------------------
3. CÁC LOẠI LỆNH PHỔ BIẾN TRONG NGÂN HÀNG

3.1. Lệnh chuyển tiền
Ví dụ:
- Chuyển khoản trong cùng ngân hàng
- Chuyển khoản liên ngân hàng
- Chuyển tiền quốc tế (SWIFT)

Ý nghĩa:
Yêu cầu ngân hàng trích tiền từ tài khoản A và chuyển sang tài khoản B.

3.2. Lệnh thanh toán
Ví dụ:
- Thanh toán hóa đơn
- Thanh toán thẻ tín dụng
- Thanh toán lương

Ý nghĩa:
Yêu cầu ngân hàng thực hiện nghĩa vụ chi trả thay mặt khách hàng.

3.3. Lệnh ghi nợ (Debit Order)
Ngân hàng được phép tự động trích tiền từ tài khoản khách hàng theo thỏa thuận trước (ví dụ: trả góp, bảo hiểm).

3.4. Lệnh ghi có (Credit Order)
Yêu cầu ghi tăng số dư vào tài khoản.

3.5. Lệnh phong tỏa / giải tỏa
- Phong tỏa: khóa một phần hoặc toàn bộ số tiền.
- Giải tỏa: mở khóa số tiền đã bị phong tỏa.

----------------------------------------
4. VÒNG ĐỜI CỦA MỘT LỆNH TRONG NGÂN HÀNG

Một lệnh thường trải qua các bước:

Bước 1: Khởi tạo (Initiation)
Khách hàng hoặc hệ thống tạo lệnh.

Bước 2: Xác thực (Authentication)
- Kiểm tra chữ ký
- Kiểm tra OTP
- Kiểm tra quyền truy cập

Bước 3: Kiểm tra điều kiện (Validation)
- Kiểm tra số dư
- Kiểm tra hạn mức
- Kiểm tra trạng thái tài khoản

Bước 4: Phê duyệt (Approval)
Tùy mức tiền, có thể cần 1 hoặc nhiều cấp duyệt.

Bước 5: Thực thi (Execution)
Hệ thống thực hiện bút toán:
- Ghi Nợ
- Ghi Có

Bước 6: Hoàn tất (Settlement/Completion)
Giao dịch hoàn tất và cập nhật số dư.

----------------------------------------
5. SỰ KHÁC NHAU GIỮA "LỆNH" VÀ "GIAO DỊCH"

Nhiều người nhầm lẫn hai khái niệm này.

Lệnh = yêu cầu thực hiện.
Giao dịch = kết quả đã được xử lý thành công.

Ví dụ:
- Bạn gửi lệnh chuyển tiền.
- Hệ thống kiểm tra và xử lý.
- Khi thành công → tạo ra một giao dịch.

Nếu lệnh bị từ chối → không tạo giao dịch.

----------------------------------------
6. LỆNH TRONG HỆ THỐNG CORE BANKING

Trong hệ thống core banking:

Lệnh thường là một record dữ liệu chứa:
- Mã lệnh
- Loại lệnh
- Tài khoản nguồn
- Tài khoản đích
- Số tiền
- Thời gian tạo
- Trạng thái (Pending / Approved / Rejected / Completed)

Trạng thái lệnh có thể thay đổi theo quá trình xử lý.

----------------------------------------
7. Ý NGHĨA KIỂM SOÁT RỦI RO CỦA LỆNH

Lệnh giúp ngân hàng:
- Kiểm soát luồng tiền
- Theo dõi trách nhiệm
- Truy vết giao dịch khi có sai sót
- Ngăn gian lận (fraud detection)

Mỗi lệnh đều có:
- Log hệ thống
- Người tạo
- Người duyệt
- Thời điểm xử lý

----------------------------------------
8. TÓM TẮT NGẮN GỌN

Trong ngân hàng, "lệnh" là:

→ Một yêu cầu chính thức để thực hiện một nghiệp vụ tài chính.
→ Là đầu vào của hệ thống xử lý tiền.
→ Là cơ sở tạo ra bút toán kế toán.
→ Có trạng thái và vò

--- NGUYÊN LÝ AUTHORIZATION TRONG BASIC HEADER (HTTP BASIC AUTHENTICATION)

NGUYÊN LÝ AUTHORIZATION TRONG BASIC HEADER (HTTP BASIC AUTHENTICATION)

1. TỔNG QUAN

Trong HTTP, "Authorization header" là một header được client gửi lên server để chứng minh rằng
mình có quyền truy cập tài nguyên.

Với cơ chế "Basic Authentication", Authorization header có dạng:

Authorization: Basic <credentials>

Trong đó:
- "Basic" là scheme (cơ chế xác thực).
- <credentials> là chuỗi username:password đã được mã hóa Base64.

Lưu ý:
Basic Authentication thực chất là cơ chế AUTHENTICATION (xác thực danh tính),
nhưng sau khi xác thực thành công, server mới thực hiện AUTHORIZATION (phân quyền).

----------------------------------------
2. PHÂN BIỆT AUTHENTICATION VÀ AUTHORIZATION

Authentication = Bạn là ai?
Authorization = Bạn được phép làm gì?

Trong Basic Auth:

Bước 1: Server xác thực (authentication)
→ Kiểm tra username/password có đúng không.

Bước 2: Server phân quyền (authorization)
→ Nếu đúng, kiểm tra user đó có quyền truy cập resource không.

Vì vậy:
Authorization header chứa thông tin phục vụ authentication,
còn authorization (phân quyền) diễn ra phía server sau đó.

----------------------------------------
3. CẤU TRÚC BASIC AUTH HEADER

Giả sử:
username = admin
password = 123456

Bước 1: Ghép lại thành chuỗi:
admin:123456

Bước 2: Encode Base64:
YWRtaW46MTIzNDU2

Bước 3: Gửi trong header:
Authorization: Basic YWRtaW46MTIzNDU2

----------------------------------------
4. QUY TRÌNH HOẠT ĐỘNG CỦA BASIC AUTH

4.1. Client gửi request không có Authorization

GET /api/data HTTP/1.1

Server trả về:
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Basic realm="MyApp"

Ý nghĩa:
Server yêu cầu client cung cấp Basic credentials.

----------------------------------------
4.2. Client gửi lại request kèm Authorization

GET /api/data HTTP/1.1
Authorization: Basic YWRtaW46MTIzNDU2

----------------------------------------
4.3. Server xử lý

Bước 1: Server đọc header Authorization.
Bước 2: Kiểm tra scheme có phải "Basic" không.
Bước 3: Decode Base64.
Bước 4: Tách thành username và password.
Bước 5: So sánh với database.

Nếu hợp lệ:
→ Authentication thành công.
→ Tiến hành Authorization (kiểm tra quyền).

Nếu không hợp lệ:
→ Trả về 401 Unauthorized.

----------------------------------------
5. NGUYÊN LÝ AUTHORIZATION SAU KHI BASIC AUTH THÀNH CÔNG

Sau khi xác thực thành công, server thường:

- Load user từ database.
- Load role (ví dụ: ADMIN, USER).
- Kiểm tra quyền truy cập endpoint.

Ví dụ:

User A:
- Role: USER
- Chỉ được GET /profile

User B:
- Role: ADMIN
- Được DELETE /users

Nếu user USER cố gọi DELETE:
→ Server trả 403 Forbidden.

401 = chưa xác thực hoặc sai mật khẩu.
403 = đã xác thực nhưng không có quyền.

----------------------------------------
6. ĐẶC ĐIỂM BẢN CHẤT CỦA BASIC AUTH

6.1. Stateless

Mỗi request đều phải gửi lại Authorization header.
Server không lưu session (trong mô hình thuần REST).

6.2. Không mã hóa thật sự

Base64 KHÔNG phải là encryption.
Nó chỉ là encoding.

Nếu không dùng HTTPS:
→ Dữ liệu có thể bị đọc trộm.

Vì vậy:
Basic Auth bắt buộc phải đi kèm HTTPS trong môi trường thực tế.

----------------------------------------
7. VẤN ĐỀ BẢO MẬT

Nhược điểm:

1. Password gửi mỗi request.
2. Nếu bị lộ header → lộ tài khoản.
3. Không có token hết hạn.
4. Không có cơ chế revoke linh hoạt.

Vì vậy:
Basic Auth thường dùng cho:
- API nội bộ
- Dev/test
- Microservice internal communication
- Hệ thống đơn giản

Không phù hợp cho:
- Ứng dụng public lớn
- Hệ thống yêu cầu bảo mật cao

----------------------------------------
8. SO SÁNH VỚI BEARER TOKEN

Basic:
- Gửi username:password
- Server kiểm tra mỗi lần
- Không có token trung gian

Bearer:
- Gửi access token
- Token có thời hạn
- Có thể revoke
- Không gửi password mỗi request

----------------------------------------
9. VÍ DỤ TRIỂN KHAI TRONG BACKEND (MÔ HÌNH CHUNG)

Pseudo flow:

if Authorization header tồn tại:
    tách scheme
    nếu scheme != Basic:
        reject
    decode Base64
    lấy username, password
    user = findUser(username)
    nếu user == null:
        reject
    nếu password không khớp:
        reject
    nếu không có quyền:
        return 403
    else:
        cho phép truy cập

----------------------------------------
10. TÓM TẮT CỐT LÕI

Authorization: Basic <base64(username:password)>

Nguyên lý:

1. Client gửi credentials qua header.
2. Server decode và xác thực.
3. Nếu hợp lệ → thực hiện phân quyền.
4. Nếu không hợp lệ → 401.
5. Nếu không đủ quyền → 403.

Basic Auth:
- Đơn giản.
- Stateless.
- Không mã hóa thật sự.
- Phải dùng HTTPS.
- Phù hợp hệ thống nhỏ hoặc nội bộ.

KẾT LUẬN:

Authorization trong Basic header là cơ chế truyền thông tin xác thực
(username và password đã encode Base64) để server xác minh danh tính,
sau đó thực hiện phân quyền truy cập tài nguyên.

Hiểu đúng nguyên lý này rất quan trọng khi:
- Xây dựng REST API
- Làm việc với Spring Security
- Làm việc với Web Service
- Thiết kế hệ thống xác thực và phân quyền

--- TẠI SAO PHẢI GỬI DẠNG BASE64

GIẢI THÍCH CHI TIẾT: TẠI SAO PHẢI GỬI DẠNG BASE64

1. BASE64 LÀ GÌ?

Base64 là một cơ chế mã hóa dữ liệu nhị phân (binary data) sang dạng văn bản (text) sử dụng 64 ký tự ASCII an toàn:
A–Z, a–z, 0–9, +, /

Mục đích của Base64 KHÔNG phải để bảo mật, mà để chuyển đổi dữ liệu nhị phân thành dạng text an toàn để truyền qua các hệ thống chỉ hỗ trợ text.

----------------------------------------
2. VẤN ĐỀ GỐC: DỮ LIỆU NHỊ PHÂN KHÔNG PHẢI LÚC NÀO CŨNG TRUYỀN ĐƯỢC

Trong lập trình, có 2 loại dữ liệu:

- Dữ liệu text (chuỗi ký tự)
- Dữ liệu nhị phân (file ảnh, file pdf, file zip, video, byte[]...)

Nhiều hệ thống truyền thông (đặc biệt là các hệ thống cũ hoặc một số giao thức) chỉ được thiết kế để xử lý TEXT, ví dụ:

- JSON
- XML
- HTTP body dạng text
- Email (SMTP đời cũ)
- Một số message queue
- Một số hệ thống log

Nếu bạn gửi trực tiếp dữ liệu nhị phân vào các hệ thống này thì có thể xảy ra:

- Mất dữ liệu
- Lỗi encoding
- Bị cắt byte
- Hỏng file
- Không parse được JSON/XML

----------------------------------------
3. VÌ SAO DỮ LIỆU NHỊ PHÂN GÂY LỖI?

Dữ liệu nhị phân chứa các byte từ 0–255.

Trong đó có:
- Byte điều khiển (control characters)
- Byte không in được
- Byte có ý nghĩa đặc biệt trong giao thức

Ví dụ:
- Ký tự xuống dòng
- Ký tự null (0x00)
- Ký tự escape
- Ký tự kết thúc chuỗi

Các byte này có thể:
- Làm vỡ cấu trúc JSON
- Làm sai XML
- Làm hệ thống hiểu nhầm là kết thúc dữ liệu

----------------------------------------
4. BASE64 GIẢI QUYẾT VẤN ĐỀ NHƯ THẾ NÀO?

Base64 biến toàn bộ dữ liệu nhị phân thành chuỗi chỉ gồm:

A-Z
a-z
0-9
+
/

Tức là chỉ dùng các ký tự an toàn trong bảng ASCII chuẩn.

Sau khi encode Base64:
- Không còn byte control
- Không còn byte null
- Không còn ký tự phá cấu trúc JSON/XML

=> Có thể truyền qua hệ thống text một cách an toàn.

----------------------------------------
5. CÁC TRƯỜNG HỢP BẮT BUỘC PHẢI DÙNG BASE64

(1) Gửi file qua JSON API

Ví dụ:
{
  "fileName": "image.png",
  "data": "iVBORw0KGgoAAAANSUhEUgAA..."
}

JSON chỉ chấp nhận text.
Không thể nhét trực tiếp byte[] vào JSON.

------------------------------------------------

(2) Gửi file qua SOAP (XML)

XML không cho phép byte nhị phân tùy ý.
Phải encode thành Base64 rồi đặt trong thẻ.

------------------------------------------------

(3) Gửi file qua email (MIME)

Email truyền thống chỉ hỗ trợ ASCII 7-bit.
File đính kèm phải encode Base64.

------------------------------------------------

(4) Lưu file vào database dạng TEXT

Nếu cột là VARCHAR hoặc TEXT
=> phải encode Base64

------------------------------------------------

(5) Nhúng ảnh trực tiếp vào HTML

<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA..." />

------------------------------------------------

(6) Truyền file qua message queue chỉ hỗ trợ string

------------------------------------------------

6. VÌ SAO KHÔNG GỬI TRỰC TIẾP FILE BINARY?

Trong HTTP hiện đại (multipart/form-data) có thể gửi binary trực tiếp.

Nhưng nếu:

- API thiết kế nhận JSON
- Hệ thống trung gian chỉ xử lý text
- Cần log lại nội dung
- Cần ký số nội dung dạng text
- Cần nhúng file vào chuỗi

=> Bắt buộc phải encode Base64.

----------------------------------------
7. BASE64 HOẠT ĐỘNG NHƯ THẾ NÀO (Ở MỨC BYTE)?

Base64 lấy 3 byte (24 bit)
Chia thành 4 nhóm mỗi nhóm 6 bit
Mỗi nhóm 6 bit sẽ map sang 1 ký tự trong bảng 64 ký tự.

Ví dụ:
3 byte -> 4 ký tự Base64

Nhược điểm:
Dung lượng tăng khoảng 33%.

----------------------------------------
8. NHƯỢC ĐIỂM CỦA BASE64

(1) Tăng dung lượng 33%
File 1MB -> ~1.33MB

(2) Tốn CPU để encode/decode

(3) Không phải mã hóa bảo mật
Ai cũng decode được

----------------------------------------
9. BASE64 KHÔNG PHẢI LÀ BẢO MẬT

Nhiều người hiểu nhầm Base64 là mã hóa bảo mật.

Sai.

Base64 chỉ là chuyển đổi định dạng.
Ai cũng có thể decode ngược lại.

Nếu cần bảo mật:
- Phải dùng AES
- Hoặc RSA
- Hoặc HTTPS

----------------------------------------
10. KẾT LUẬN BẢN CHẤT

Ta phải gửi dạng Base64 vì:

Hệ thống truyền thông (JSON, XML, email, text protocol)
KHÔNG đảm bảo truyền an toàn dữ liệu nhị phân.

Base64 biến dữ liệu nhị phân thành chuỗi ASCII an toàn,
để:

- Không làm hỏng cấu trúc dữ liệu
- Không gây lỗi encoding
- Không bị cắt byte
- Không bị hệ thống hiểu sai

=> Đây là giải pháp tương thích (compatibility solution),
không phải giải pháp bảo mật.

----------------------------------------
11. TƯ DUY HỆ THỐNG

Binary = dữ liệu gốc của máy
Text = dữ liệu thân thiện với giao thức

Khi hệ thống trung gian chỉ hiểu TEXT,
ta phải chuyển binary -> text.

Base64 chính là cầu nối giữa hai thế giới đó.

----------------------------------------

TÓM LẠI MỘT CÂU:

Phải gửi dạng Base64 vì nhiều giao thức và hệ thống chỉ truyền được TEXT,
trong khi file và dữ liệu thực tế là dạng nhị phân (binary).
Base64 giúp chuyển binary thành text an toàn để truyền đi mà không bị lỗi.

--- gRPC LÀ GÌ, MỤC ĐÍCH ĐỂ LÀM GÌ

GIẢI THÍCH CHI TIẾT: gRPC LÀ GÌ, MỤC ĐÍCH ĐỂ LÀM GÌ

========================================================
1. gRPC LÀ GÌ?
========================================================

gRPC (Google Remote Procedure Call) là một framework giao tiếp giữa các hệ thống
phân tán do Google phát triển.

Nó cho phép một chương trình có thể gọi hàm (function/method)
ở một chương trình khác đang chạy trên máy khác
như thể nó là hàm cục bộ (local function).

Hiểu đơn giản:

Thay vì:
- Gửi HTTP request thủ công
- Tự build JSON
- Tự parse response

Thì với gRPC:
Bạn chỉ cần gọi hàm như bình thường.
Phần network đã được framework xử lý.

========================================================
2. REMOTE PROCEDURE CALL (RPC) LÀ GÌ?
========================================================

RPC = Gọi hàm từ xa.

Ví dụ:

Service A muốn lấy thông tin user từ Service B.

Thay vì:
- Gửi HTTP POST
- Đính kèm JSON
- Parse JSON response

Thì chỉ cần:

user = userService.getUserById(1)

Tuy thực tế đang gọi qua network,
nhưng lập trình viên thấy giống như gọi hàm nội bộ.

========================================================
3. gRPC HOẠT ĐỘNG DỰA TRÊN NHỮNG GÌ?
========================================================

gRPC sử dụng:

- HTTP/2 làm giao thức truyền tải
- Protocol Buffers (Protobuf) làm cơ chế định nghĩa dữ liệu

----------------------------------------
3.1 HTTP/2

HTTP/2 cho phép:

- Multiplexing (nhiều request trên 1 kết nối)
- Streaming hai chiều
- Header nén
- Hiệu năng cao hơn HTTP/1.1

----------------------------------------
3.2 Protocol Buffers

Protobuf là cơ chế serialize dữ liệu nhị phân.

Bạn định nghĩa contract trong file .proto:

service UserService {
  rpc GetUser (UserRequest) returns (UserResponse);
}

message UserRequest {
  int32 id = 1;
}

message UserResponse {
  string name = 1;
}

Sau đó compile file .proto
=> sinh ra code client và server tự động.

========================================================
4. MỤC ĐÍCH CỦA gRPC LÀ GÌ?
========================================================

gRPC được tạo ra để:

1) Giao tiếp giữa các microservices
2) Tăng hiệu năng so với REST
3) Chuẩn hóa contract giữa client và server
4) Hỗ trợ streaming real-time
5) Giảm kích thước dữ liệu truyền

========================================================
5. TẠI SAO KHÔNG DÙNG REST?
========================================================

REST sử dụng:
- HTTP/1.1
- JSON (text-based)

JSON:
- Dễ đọc
- Nhưng nặng hơn
- Parse chậm hơn

gRPC:
- Dùng binary (Protobuf)
- Nhẹ hơn
- Nhanh hơn
- Ít tốn băng thông

Trong hệ thống lớn (microservices),
hiệu năng rất quan trọng.

========================================================
6. SO SÁNH gRPC VÀ REST
========================================================

REST:
- Dựa trên HTTP/1.1
- Dữ liệu dạng JSON
- Phổ biến, dễ debug
- Tốt cho public API

gRPC:
- Dựa trên HTTP/2
- Dữ liệu dạng binary (Protobuf)
- Nhanh hơn
- Tốt cho internal microservices

========================================================
7. CÁC LOẠI GIAO TIẾP TRONG gRPC
========================================================

1) Unary RPC
Client gửi 1 request -> nhận 1 response
Giống REST thông thường.

2) Server Streaming
Client gửi 1 request
Server trả về nhiều response liên tục.

3) Client Streaming
Client gửi nhiều request
Server trả về 1 response cuối.

4) Bidirectional Streaming
Client và server gửi dữ liệu hai chiều liên tục.

Đây là điểm mạnh lớn của gRPC so với REST.

========================================================
8. KIẾN TRÚC HOẠT ĐỘNG
========================================================

Client:
- Gọi hàm (stub)
- Stub serialize dữ liệu thành binary
- Gửi qua HTTP/2

Server:
- Nhận request
- Deserialize
- Gọi implementation thật
- Serialize response
- Trả về client

Tất cả được tự động hóa.

========================================================
9. ƯU ĐIỂM CỦA gRPC
========================================================

1) Hiệu năng cao
2) Dữ liệu nhỏ gọn
3) Contract rõ ràng (file .proto)
4) Tự sinh code
5) Hỗ trợ nhiều ngôn ngữ
6) Streaming mạnh
7) Tối ưu cho microservices

========================================================
10. NHƯỢC ĐIỂM CỦA gRPC
========================================================

1) Khó debug hơn JSON
2) Không thân thiện với trình duyệt (browser)
3) Phải compile .proto
4) Khó test bằng Postman truyền thống

========================================================
11. KHI NÀO NÊN DÙNG gRPC?
========================================================

- Hệ thống microservices nội bộ
- Cần hiệu năng cao
- Cần streaming
- Giao tiếp service-to-service
- Hệ thống realtime (chat, game, IoT)

========================================================
12. KHI NÀO KHÔNG NÊN DÙNG?
========================================================

- Public API cho frontend web
- Khi cần debug dễ dàng bằng curl/Postman
- Hệ thống nhỏ, không cần hiệu năng cao

========================================================
13. BẢN CHẤT SÂU HƠN

gRPC giải quyết bài toán:

Làm sao để các service nói chuyện với nhau
nhanh nhất, rõ ràng nhất, ít lỗi nhất.

Nó biến việc giao tiếp network
thành việc gọi hàm.

Tức là:
Che giấu sự phức tạp của network
để lập trình viên tập trung vào business logic.

========================================================
14. TÓM LẠI MỘT CÂU

gRPC là framework RPC hiện đại sử dụng HTTP/2 và Protocol Buffers,
giúp các hệ thống (đặc biệt là microservices)
giao tiếp nhanh, nhẹ, hiệu năng cao và có contract rõ ràng.

--- ResourceBundle TRONG java.util

GIẢI THÍCH CHI TIẾT: ResourceBundle TRONG java.util

========================================================
1. ResourceBundle LÀ GÌ?
========================================================

ResourceBundle là một lớp trong package java.util
dùng để quản lý tài nguyên (resource) theo ngôn ngữ (locale).

Nó thường được sử dụng để:
- Quốc tế hóa (Internationalization - i18n)
- Đa ngôn ngữ (Multi-language support)
- Tách text ra khỏi source code

Nói đơn giản:

ResourceBundle giúp bạn hiển thị nội dung
khác nhau tùy theo ngôn ngữ người dùng.

========================================================
2. TẠI SAO PHẢI DÙNG ResourceBundle?
========================================================

Nếu bạn viết trực tiếp:

System.out.println("Xin chào");

Thì:
- Không thể đổi sang tiếng Anh
- Không thể đổi sang tiếng Nhật
- Không linh hoạt

Thay vào đó, ta viết:

System.out.println(bundle.getString("hello"));

Và để nội dung trong file riêng theo từng ngôn ngữ.

=> Code không đổi, chỉ đổi file ngôn ngữ.

========================================================
3. BẢN CHẤT CỦA ResourceBundle
========================================================

ResourceBundle là một cơ chế ánh xạ:

KEY -> VALUE

Ví dụ:
hello = Xin chào
bye = Tạm biệt

KEY là cố định trong code.
VALUE thay đổi theo locale.

========================================================
4. CẤU TRÚC FILE ResourceBundle
========================================================

ResourceBundle thường dùng file .properties

Ví dụ:

messages.properties              (mặc định)
messages_vi.properties           (tiếng Việt)
messages_en.properties           (tiếng Anh)
messages_ja.properties           (tiếng Nhật)

----------------------------------------
Ví dụ nội dung:

messages_en.properties
hello=Hello
bye=Goodbye

messages_vi.properties
hello=Xin chào
bye=Tạm biệt

========================================================
5. CÁCH ResourceBundle HOẠT ĐỘNG
========================================================

Khi gọi:

ResourceBundle bundle =
    ResourceBundle.getBundle("messages", locale);

Java sẽ:

1) Tìm file phù hợp nhất với locale
2) Nếu không có -> fallback về file mặc định

Ví dụ:

Locale vi_VN
Java sẽ tìm theo thứ tự:

messages_vi_VN.properties
messages_vi.properties
messages.properties

========================================================
6. CÁC THÀNH PHẦN CHÍNH
========================================================

6.1 getBundle()

Dùng để load resource theo tên và locale.

6.2 getString(key)

Lấy giá trị theo key.

6.3 Locale

Đại diện cho ngôn ngữ và quốc gia.

Ví dụ:
new Locale("vi", "VN")
new Locale("en", "US")

========================================================
7. LỢI ÍCH CỦA ResourceBundle
========================================================

1) Tách text khỏi code
2) Hỗ trợ đa ngôn ngữ
3) Dễ bảo trì
4) Không cần sửa source code khi đổi ngôn ngữ
5) Hỗ trợ fallback tự động

========================================================
8. ỨNG DỤNG THỰC TẾ
========================================================

- Website đa ngôn ngữ
- Ứng dụng desktop Java
- Ứng dụng Spring Boot
- Hệ thống ERP quốc tế
- Ứng dụng mobile backend

========================================================
9. ResourceBundle KHÔNG CHỈ LÀ TEXT
========================================================

Ngoài .properties,
ResourceBundle còn hỗ trợ:

- Class-based bundle (extends ListResourceBundle)
- Custom bundle

Ví dụ:

public class MyBundle extends ListResourceBundle {
    protected Object[][] getContents() {
        return new Object[][] {
            {"hello", "Xin chào"},
            {"bye", "Tạm biệt"}
        };
    }
}

========================================================
10. VẤN ĐỀ THƯỜNG GẶP
========================================================

1) File không nằm đúng classpath
2) Encoding sai (mặc định ISO-8859-1)
3) Key không tồn tại -> MissingResourceException
4) Không hiểu cơ chế fallback

========================================================
11. VẤN ĐỀ ENCODING

File .properties mặc định dùng ISO-8859-1.

Nếu muốn dùng Unicode,
cần:

- Dùng escape Unicode
hoặc
- Java 9+ có hỗ trợ UTF-8 nếu cấu hình đúng

========================================================
12. TƯ DUY HỆ THỐNG

ResourceBundle giúp giải quyết bài toán:

Làm sao để một hệ thống phục vụ nhiều quốc gia
mà không phải viết lại code?

Giải pháp:

Tách phần thay đổi (ngôn ngữ)
ra khỏi phần logic (business logic).

========================================================
13. QUỐC TẾ HÓA (I18N) VS ĐỊA PHƯƠNG HÓA (L10N)

I18N:
Thiết kế hệ thống để hỗ trợ nhiều ngôn ngữ.

L10N:
Cung cấp nội dung cụ thể cho từng quốc gia.

ResourceBundle là công cụ hỗ trợ I18N.

========================================================
14. TÓM LẠI MỘT CÂU

ResourceBundle trong java.util là cơ chế quản lý tài nguyên
theo locale, giúp ứng dụng Java hỗ trợ đa ngôn ngữ
bằng cách tách nội dung (text) ra khỏi source code
và tự động chọn file phù hợp theo ngôn ngữ người dùng.

--- HÀM getResponseBodyAsStream() TRONG PostMethod

GIẢI THÍCH CHI TIẾT: HÀM getResponseBodyAsStream() TRONG PostMethod

========================================================
1. PostMethod LÀ GÌ?
========================================================

PostMethod là một class trong thư viện Apache Commons HttpClient (phiên bản 3.x),
được dùng để gửi HTTP POST request đến server.

Ví dụ:
- Gửi form
- Gửi JSON
- Upload dữ liệu
- Gọi API

Sau khi thực hiện request, server sẽ trả về response.
PostMethod cung cấp nhiều cách để đọc response này.

Một trong những cách đó là:

getResponseBodyAsStream()

========================================================
2. getResponseBodyAsStream() LÀ GÌ?
========================================================

getResponseBodyAsStream() là một phương thức dùng để
lấy phần body của HTTP response dưới dạng InputStream.

Khai báo:

public InputStream getResponseBodyAsStream()

Nó trả về:
- Một InputStream
- Đại diện cho dữ liệu response từ server

========================================================
3. VÌ SAO PHẢI DÙNG STREAM?
========================================================

Response từ server có thể:

- Nhỏ (vài KB)
- Rất lớn (file vài MB, vài GB)

Nếu dùng:
getResponseBody()

Thì toàn bộ dữ liệu sẽ được load vào bộ nhớ (RAM) dưới dạng byte[].

Điều này có thể:
- Tốn RAM
- Gây OutOfMemoryError
- Không hiệu quả với file lớn

Trong khi đó:

getResponseBodyAsStream()

Cho phép:
- Đọc từng phần nhỏ (chunk)
- Không cần load toàn bộ vào RAM
- Phù hợp khi download file lớn

========================================================
4. SỰ KHÁC BIỆT GIỮA CÁC CÁCH ĐỌC RESPONSE
========================================================

(1) getResponseBody()
- Trả về byte[]
- Load toàn bộ dữ liệu vào RAM
- Phù hợp dữ liệu nhỏ

(2) getResponseBodyAsString()
- Trả về String
- Phù hợp JSON nhỏ
- Không tốt cho file lớn

(3) getResponseBodyAsStream()
- Trả về InputStream
- Đọc tuần tự
- Phù hợp file lớn hoặc streaming

========================================================
5. CƠ CHẾ HOẠT ĐỘNG BÊN TRONG
========================================================

Khi gọi:

InputStream is = postMethod.getResponseBodyAsStream();

Thực tế:

1) HttpClient đã mở socket đến server
2) Server gửi response
3) Dữ liệu response nằm trong luồng network
4) InputStream đọc trực tiếp từ luồng này

Nghĩa là:

InputStream không phải dữ liệu có sẵn trong RAM,
mà là luồng đọc trực tiếp từ kết nối HTTP.

========================================================
6. LUỒNG XỬ LÝ THỰC TẾ
========================================================

1) Tạo HttpClient
2) Tạo PostMethod
3) executeMethod()
4) Gọi getResponseBodyAsStream()
5) Đọc từng byte hoặc từng buffer
6) Đóng stream
7) releaseConnection()

========================================================
7. KHI NÀO NÊN DÙNG getResponseBodyAsStream()?
========================================================

- Download file lớn
- Xử lý streaming
- Xử lý file ảnh, PDF
- Proxy dữ liệu sang nơi khác
- Không muốn tốn nhiều RAM

========================================================
8. CÁC LƯU Ý QUAN TRỌNG
========================================================

(1) Phải đóng InputStream sau khi dùng xong

Nếu không:
- Có thể rò rỉ tài nguyên
- Giữ kết nối HTTP mở

(2) Phải gọi releaseConnection()

Sau khi đọc xong,
nên gọi:

postMethod.releaseConnection();

Để trả connection về connection pool.

(3) Không nên đọc stream sau khi releaseConnection()

Vì connection đã đóng.

========================================================
9. VẤN ĐỀ MEMORY
========================================================

Sai cách:

byte[] data = postMethod.getResponseBody();

Nếu file 500MB:
=> 500MB vào RAM

Đúng cách:

InputStream is = postMethod.getResponseBodyAsStream();
Đọc từng 8KB buffer.

=> RAM chỉ dùng khoảng vài KB

========================================================
10. TƯ DUY HỆ THỐNG

Network response bản chất là một stream (luồng dữ liệu).

HTTP không gửi tất cả một lần,
mà gửi từng gói (packet).

getResponseBodyAsStream()
cho phép bạn xử lý đúng theo bản chất đó:
- Đọc dần
- Không cần chờ toàn bộ tải xong

========================================================
11. SO SÁNH VỚI JAVA CORE

Giống như:

FileInputStream đọc file lớn.
Không ai load toàn bộ file lớn vào RAM.

getResponseBodyAsStream()
cũng tương tự,
chỉ khác là nguồn dữ liệu đến từ network.

========================================================
12. NHƯỢC ĐIỂM

- Phải tự xử lý stream
- Phải tự đóng tài nguyên
- Code phức tạp hơn so với getResponseBodyAsString()

========================================================
13. KẾT LUẬN BẢN CHẤT

getResponseBodyAsStream() là phương thức giúp lấy
phần body của HTTP response dưới dạng InputStream,
cho phép đọc dữ liệu theo kiểu streaming,
giảm tiêu tốn bộ nhớ,
và phù hợp khi xử lý dữ liệu lớn hoặc file download.

Nó phản ánh đúng bản chất của giao tiếp mạng:
dữ liệu luôn là một luồng (stream), không phải một khối có sẵn.

--- getStatusLine

GIẢI THÍCH CHI TIẾT: HÀM getStatusLine

========================================================
1. getStatusLine LÀ GÌ?
========================================================

getStatusLine() là một phương thức thường xuất hiện
trong các thư viện HTTP client của Java
(ví dụ Apache HttpClient).

Nó dùng để lấy thông tin dòng trạng thái (Status Line)
của HTTP response mà server trả về.

Nói đơn giản:

Sau khi gửi HTTP request,
server sẽ trả về một response.
Dòng đầu tiên của response đó gọi là Status Line.

getStatusLine() dùng để lấy dòng này.

========================================================
2. STATUS LINE TRONG HTTP LÀ GÌ?
========================================================

Theo chuẩn HTTP, một HTTP response có cấu trúc:

Status-Line
Headers
Blank line
Body

Ví dụ:

HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 123

{ "name": "Tuan" }

Trong đó:

HTTP/1.1 200 OK

chính là Status Line.

========================================================
3. CẤU TRÚC CỦA STATUS LINE
========================================================

Status Line gồm 3 phần:

1) HTTP Version
2) Status Code
3) Reason Phrase

Ví dụ:

HTTP/1.1 404 Not Found

- HTTP/1.1      -> phiên bản giao thức
- 404           -> mã trạng thái
- Not Found     -> thông điệp mô tả

========================================================
4. getStatusLine() TRẢ VỀ GÌ?
========================================================

Thông thường nó trả về một object kiểu StatusLine.

Ví dụ:

StatusLine statusLine = method.getStatusLine();

Từ object này, ta có thể lấy:

- statusLine.getStatusCode()
- statusLine.getReasonPhrase()
- statusLine.getProtocolVersion()

========================================================
5. MỤC ĐÍCH CỦA getStatusLine()
========================================================

Mục đích chính:

1) Kiểm tra request có thành công không
2) Phân nhánh xử lý theo mã lỗi
3) Ghi log
4) Debug
5) Xử lý retry

Ví dụ:

Nếu statusCode = 200
-> Thành công

Nếu 404
-> Không tìm thấy

Nếu 500
-> Lỗi server

========================================================
6. TẠI SAO PHẢI KIỂM TRA STATUS LINE?
========================================================

Vì:

HTTP response có thể trả về body,
nhưng nếu statusCode là lỗi,
body có thể không hợp lệ.

Ví dụ:

Bạn gọi API lấy user.
Server trả:

404 Not Found

Nếu không kiểm tra status,
bạn có thể cố parse body
và gây lỗi.

========================================================
7. SỰ KHÁC BIỆT GIỮA getStatusLine() VÀ getStatusCode()

getStatusLine()
-> Lấy toàn bộ dòng trạng thái.

getStatusCode()
-> Chỉ lấy số 200, 404, 500...

Thông thường:
Chỉ cần getStatusCode().
Nhưng nếu cần log đầy đủ,
thì dùng getStatusLine().

========================================================
8. LUỒNG XỬ LÝ THỰC TẾ

1) Tạo HTTP request
2) Gửi request
3) Nhận response
4) Gọi getStatusLine()
5) Kiểm tra statusCode
6) Nếu OK -> đọc body
7) Nếu lỗi -> xử lý lỗi

========================================================
9. VÍ DỤ LOGGING

Thay vì chỉ log:

200

Ta có thể log:

HTTP/1.1 200 OK

Giúp debug rõ ràng hơn.

========================================================
10. BẢN CHẤT HỆ THỐNG

Trong giao tiếp HTTP:

Status Line là tín hiệu điều khiển.
Body là dữ liệu.

Tức là:

Status Line quyết định cách bạn xử lý Body.

Nếu Status báo lỗi,
body có thể không đáng tin.

========================================================
11. LIÊN HỆ THỰC TẾ

Khi bạn mở trình duyệt
và thấy:

- 404 Not Found
- 500 Internal Server Error
- 403 Forbidden

Đó chính là Status Line.

========================================================
12. KẾT LUẬN BẢN CHẤT

getStatusLine() là phương thức dùng để lấy
dòng trạng thái của HTTP response,
giúp lập trình viên biết:

- Request có thành công không
- Server trả về mã gì
- Có cần xử lý lỗi hay không

Nó là bước kiểm tra đầu tiên
trước khi xử lý nội dung response.

--- AML TRONG NGÂN HÀNG LÀ GÌ?

GIẢI THÍCH CHI TIẾT: AML TRONG NGÂN HÀNG LÀ GÌ?

========================================================
1. AML LÀ GÌ?
========================================================

AML là viết tắt của:

Anti-Money Laundering
(Tiếng Việt: Phòng chống rửa tiền)

AML là hệ thống quy định, quy trình, công cụ và kiểm soát
được các ngân hàng và tổ chức tài chính áp dụng
nhằm ngăn chặn, phát hiện và báo cáo các hành vi rửa tiền.

========================================================
2. RỬA TIỀN LÀ GÌ?
========================================================

Rửa tiền là hành vi:

Biến tiền có nguồn gốc bất hợp pháp
(tham nhũng, buôn lậu, ma túy, lừa đảo, khủng bố...)
thành tiền có vẻ hợp pháp.

Quy trình rửa tiền thường gồm 3 giai đoạn:

1) Placement (Đưa tiền bẩn vào hệ thống tài chính)
2) Layering (Che giấu nguồn gốc bằng nhiều giao dịch phức tạp)
3) Integration (Đưa tiền trở lại nền kinh tế như tiền hợp pháp)

========================================================
3. VÌ SAO NGÂN HÀNG PHẢI LÀM AML?
========================================================

Vì:

Ngân hàng là nơi tiền được gửi, chuyển, đầu tư.

Nếu không có AML:

- Tội phạm dễ dàng hợp pháp hóa tiền bẩn
- Ngân hàng có thể bị phạt rất nặng
- Mất uy tín nghiêm trọng
- Có thể bị rút giấy phép hoạt động

========================================================
4. MỤC TIÊU CỦA AML
========================================================

1) Phát hiện giao dịch đáng ngờ
2) Ngăn chặn tài trợ khủng bố
3) Bảo vệ hệ thống tài chính
4) Tuân thủ pháp luật
5) Giảm rủi ro pháp lý cho ngân hàng

========================================================
5. AML BAO GỒM NHỮNG GÌ?
========================================================

5.1 KYC (Know Your Customer)

Xác minh khách hàng:

- CMND/CCCD
- Hộ chiếu
- Địa chỉ
- Nghề nghiệp
- Nguồn thu nhập

Mục đích:
Biết khách hàng là ai.

----------------------------------------

5.2 CDD (Customer Due Diligence)

Đánh giá mức độ rủi ro của khách hàng:

- Khách hàng bình thường
- Khách hàng rủi ro cao
- Khách hàng PEP (Politically Exposed Person)

----------------------------------------

5.3 Monitoring (Giám sát giao dịch)

Hệ thống theo dõi:

- Giao dịch lớn bất thường
- Chuyển tiền nhiều lần chia nhỏ
- Chuyển tiền quốc tế đáng ngờ
- Giao dịch không phù hợp với hồ sơ khách hàng

----------------------------------------

5.4 STR (Suspicious Transaction Report)

Báo cáo giao dịch đáng ngờ cho cơ quan nhà nước.

========================================================
6. AML HOẠT ĐỘNG NHƯ THẾ NÀO TRONG HỆ THỐNG NGÂN HÀNG?
========================================================

Bước 1:
Khách hàng mở tài khoản -> KYC

Bước 2:
Khách hàng giao dịch

Bước 3:
Hệ thống AML tự động kiểm tra:
- Số tiền
- Tần suất
- Mẫu hành vi

Bước 4:
Nếu phát hiện bất thường:
- Đánh cờ (flag)
- Chuyển cho bộ phận kiểm soát

Bước 5:
Có thể:
- Tạm khóa tài khoản
- Yêu cầu giải trình
- Báo cáo cơ quan chức năng

========================================================
7. HỆ THỐNG AML TRONG CÔNG NGHỆ
========================================================

Trong IT ngân hàng, AML là:

Một hệ thống phần mềm
phân tích dữ liệu giao dịch
để phát hiện hành vi bất thường.

Công nghệ thường dùng:

- Rule-based system (luật cố định)
- Machine Learning
- Phân tích hành vi
- Phân tích mạng lưới giao dịch

========================================================
8. VÍ DỤ GIAO DỊCH BỊ NGHI NGỜ
========================================================

- Một sinh viên thu nhập thấp
  nhưng chuyển hàng tỷ đồng mỗi tháng.

- Một tài khoản nhận tiền từ nhiều nguồn khác nhau
  rồi chuyển ngay ra nước ngoài.

- Giao dịch chia nhỏ nhiều lần để né ngưỡng báo cáo.

========================================================
9. HẬU QUẢ NẾU KHÔNG TUÂN THỦ AML
========================================================

- Phạt hàng triệu USD
- Mất giấy phép
- Bị đưa vào danh sách đen quốc tế
- Mất niềm tin khách hàng

========================================================
10. AML KHÔNG CHỈ ÁP DỤNG CHO NGÂN HÀNG
========================================================

Ngoài ngân hàng, AML còn áp dụng cho:

- Công ty chứng khoán
- Bảo hiểm
- Fintech
- Ví điện tử
- Công ty chuyển tiền

========================================================
11. LIÊN HỆ THỰC TẾ TẠI VIỆT NAM
========================================================

Ngân hàng phải:

- Báo cáo giao dịch trên ngưỡng quy định
- Báo cáo giao dịch đáng ngờ
- Tuân thủ luật phòng chống rửa tiền

========================================================
12. TƯ DUY HỆ THỐNG

AML không chỉ là quy định pháp lý.

Nó là một lớp bảo vệ hệ thống tài chính quốc gia.

Nếu tiền bẩn tràn vào nền kinh tế:
- Làm méo mó thị trường
- Gây bất ổn tài chính
- Tăng tội phạm

========================================================
13. KẾT LUẬN BẢN CHẤT

AML trong ngân hàng là hệ thống kiểm soát,
giám sát và báo cáo
nhằm phát hiện và ngăn chặn hành vi rửa tiền,
giúp bảo vệ ngân hàng và hệ thống tài chính khỏi tiền bất hợp pháp.

--- @XmlElement VÀ @XmlRootElement

GIẢI THÍCH CHI TIẾT: @XmlElement VÀ @XmlRootElement

========================================================
1. BỐI CẢNH: JAXB LÀ GÌ?
========================================================

@XmlElement và @XmlRootElement là các annotation
thuộc JAXB (Java Architecture for XML Binding).

JAXB dùng để:

- Chuyển object Java -> XML (marshalling)
- Chuyển XML -> object Java (unmarshalling)

Tức là ánh xạ giữa Java object và cấu trúc XML.

========================================================
2. @XmlRootElement LÀ GÌ?
========================================================

@XmlRootElement dùng để đánh dấu một class
là phần tử gốc (root element) của XML.

Nó xác định:

- Tên thẻ XML ngoài cùng
- Namespace (nếu có)

Ví dụ:

@XmlRootElement(name = "user")
public class User {
    private String name;
    private int age;
}

Khi marshalling ra XML:

<user>
    <name>...</name>
    <age>...</age>
</user>

"User" là class,
"user" là root element của XML.

--------------------------------------------------------
2.1 Nếu KHÔNG có @XmlRootElement?

Khi marshal:

Marshaller.marshal(object, output);

Sẽ lỗi:

unable to marshal type ... as an element
because it is missing an @XmlRootElement annotation

Vì JAXB không biết thẻ gốc phải đặt tên gì.

========================================================
3. @XmlElement LÀ GÌ?
========================================================

@XmlElement dùng để ánh xạ một field
thành một thẻ XML con.

Ví dụ:

public class User {

    @XmlElement(name = "fullName")
    private String name;

    @XmlElement
    private int age;
}

XML sinh ra:

<user>
    <fullName>...</fullName>
    <age>...</age>
</user>

Nếu không ghi name,
JAXB sẽ dùng tên field làm tên thẻ.

========================================================
4. SỰ KHÁC BIỆT CỐT LÕI
========================================================

@XmlRootElement
- Áp dụng cho CLASS
- Xác định thẻ XML ngoài cùng

@XmlElement
- Áp dụng cho FIELD hoặc METHOD
- Xác định thẻ XML con bên trong

========================================================
5. CẤU TRÚC XML TƯƠNG ỨNG

Ví dụ:

@XmlRootElement(name = "order")
public class Order {

    @XmlElement
    private String id;

    @XmlElement
    private double amount;
}

XML:

<order>
    <id>123</id>
    <amount>1000.0</amount>
</order>

========================================================
6. CÁC THUỘC TÍNH QUAN TRỌNG

6.1 @XmlRootElement

- name: tên thẻ gốc
- namespace: namespace XML

Ví dụ:
@XmlRootElement(name = "customer", namespace = "http://example.com")

--------------------------------------------------------

6.2 @XmlElement

- name: đổi tên thẻ
- required: bắt buộc hay không
- nillable: cho phép null
- defaultValue: giá trị mặc định

Ví dụ:
@XmlElement(name = "email", required = true)

========================================================
7. MARSHALLING VÀ UNMARSHALLING

Marshalling:
Java object -> XML

Unmarshalling:
XML -> Java object

@XmlElement giúp JAXB biết:
- Lấy giá trị từ thẻ nào
- Gán vào field nào

@XmlRootElement giúp JAXB biết:
- Thẻ ngoài cùng tương ứng class nào

========================================================
8. CƠ CHẾ ÁNH XẠ BÊN TRONG

JAXB dùng reflection để:

1) Quét annotation
2) Đọc metadata
3) Tạo mapping giữa:
   XML element <-> Java field

Nó xây dựng một cấu trúc ánh xạ
trước khi thực hiện chuyển đổi.

========================================================
9. SO SÁNH VỚI JSON

Tương tự như:

@JsonProperty trong Jackson
để ánh xạ field với JSON.

@XmlElement là bản XML tương đương.

========================================================
10. VẤN ĐỀ THƯỜNG GẶP

1) Thiếu @XmlRootElement -> không marshal được
2) Không có constructor mặc định -> lỗi khi unmarshal
3) Field private nhưng không có getter/setter
4) Sai namespace

========================================================
11. KHI NÀO CẦN DÙNG?

- Làm việc với SOAP
- Làm việc với hệ thống XML
- Tích hợp hệ thống cũ
- Giao tiếp theo chuẩn XML

========================================================
12. TƯ DUY HỆ THỐNG

XML có cấu trúc cây:

Root
 ├── Child
 ├── Child
 └── Child

@XmlRootElement xác định nút gốc.
@XmlElement xác định các nút con.

Hai annotation này định nghĩa
cấu trúc cây XML tương ứng với object Java.

========================================================
13. KẾT LUẬN BẢN CHẤT

@XmlRootElement:
Định nghĩa class là phần tử gốc của XML.

@XmlElement:
Định nghĩa cách các field bên trong class
được biểu diễn thành các thẻ XML con.

Chúng là cơ chế ánh xạ giữa mô hình dữ liệu Java
và cấu trúc XML.

--- new String(data, encoding)

GIẢI THÍCH CHI TIẾT: new String(data, encoding)

========================================================
1. CÚ PHÁP
========================================================

new String(byte[] data, String encoding)

Hoặc:

new String(byte[] data, Charset charset)

Đây là constructor của lớp String trong Java,
dùng để tạo một chuỗi (String)
từ một mảng byte (byte[]),
dựa trên một bảng mã (character encoding) cụ thể.

========================================================
2. VẤN ĐỀ CỐT LÕI: BYTE KHÔNG PHẢI LÀ CHỮ
========================================================

Máy tính lưu dữ liệu dưới dạng byte (số).
Nhưng con người đọc chữ (ký tự).

Để biến byte thành chữ,
cần một quy tắc chuyển đổi gọi là encoding.

Ví dụ:

Byte:
[72, 101, 108, 108, 111]

Nếu dùng ASCII hoặc UTF-8:
=> "Hello"

Nếu dùng encoding khác sai:
=> Có thể thành ký tự rác.

========================================================
3. encoding LÀ GÌ?
========================================================

Encoding là bảng quy tắc:

Byte -> Ký tự

Ví dụ:

UTF-8
UTF-16
ISO-8859-1
Windows-1252

Mỗi encoding sẽ diễn giải byte khác nhau.

========================================================
4. new String(data, encoding) HOẠT ĐỘNG NHƯ THẾ NÀO?
========================================================

Bước 1:
Nhận byte[] data

Bước 2:
Dựa vào encoding được truyền vào

Bước 3:
Giải mã (decode) từng byte theo quy tắc encoding đó

Bước 4:
Tạo ra một chuỗi String trong bộ nhớ Java (Unicode nội bộ)

========================================================
5. VÍ DỤ THỰC TẾ

Giả sử nhận dữ liệu từ HTTP response:

byte[] data = ...

Nếu server trả về UTF-8
nhưng bạn không chỉ định encoding:

new String(data)

Java sẽ dùng default charset của hệ điều hành.

Nếu default charset ≠ UTF-8
=> Ký tự tiếng Việt có thể bị lỗi.

Đúng cách:

new String(data, "UTF-8")

========================================================
6. TẠI SAO PHẢI CHỈ ĐỊNH encoding?
========================================================

Vì:

- Default charset phụ thuộc OS
- Windows có thể là Windows-1258
- Linux thường là UTF-8
- Server có thể khác client

Nếu không chỉ định rõ,
kết quả có thể không nhất quán.

========================================================
7. LỖI PHỔ BIẾN

Lỗi thường gặp:

- Tiếng Việt bị thành ????
- Ký tự lạ như Ã¡, Ã©

Nguyên nhân:
Encode một kiểu
Decode một kiểu khác

Ví dụ:

String s = "Xin chào";
byte[] bytes = s.getBytes("UTF-8");

Nhưng decode bằng:

new String(bytes, "ISO-8859-1");

=> Sai ký tự.

========================================================
8. MỐI QUAN HỆ VỚI getBytes()

Hai quá trình ngược nhau:

String -> byte[]
s.getBytes("UTF-8")

byte[] -> String
new String(bytes, "UTF-8")

Phải dùng cùng encoding
để không mất dữ liệu.

========================================================
9. BẢN CHẤT TRONG JAVA

Trong Java:

String nội bộ lưu dưới dạng Unicode.

Khi dùng:

new String(data, encoding)

Java sẽ:
- Decode từ encoding cụ thể
- Chuyển sang Unicode nội bộ

========================================================
10. SO SÁNH CÁC CÁCH DÙNG

new String(data)
-> Dùng default charset
-> Không an toàn

new String(data, "UTF-8")
-> An toàn hơn
-> Kiểm soát rõ ràng

new String(data, StandardCharsets.UTF_8)
-> Tốt nhất (type-safe, không lỗi typo)

========================================================
11. TÌNH HUỐNG THỰC TẾ

(1) Đọc file

byte[] data = Files.readAllBytes(path);
String content = new String(data, "UTF-8");

(2) Nhận dữ liệu từ network

(3) Nhận dữ liệu từ message queue

(4) Nhận dữ liệu từ database dạng BLOB

========================================================
12. NGUYÊN TẮC VÀNG

Luôn luôn:

- Biết dữ liệu gốc được encode bằng gì
- Decode bằng đúng encoding đó

Nếu không:
Dữ liệu sẽ hỏng vĩnh viễn.

========================================================
13. TƯ DUY HỆ THỐNG

Byte chỉ là số.
Ý nghĩa của nó phụ thuộc vào cách bạn diễn giải.

Encoding chính là quy tắc diễn giải.

new String(data, encoding)
là hành động nói với Java:

"Hãy hiểu các byte này theo quy tắc này."

========================================================
14. KẾT LUẬN BẢN CHẤT

new String(data, encoding)
dùng để chuyển mảng byte thành chuỗi String
bằng cách giải mã theo một bảng mã cụ thể.

Nếu dùng sai encoding,
chuỗi kết quả sẽ sai hoặc hỏng ký tự.

Vì vậy,
việc chỉ định đúng encoding là cực kỳ quan trọng
khi làm việc với file, network hoặc dữ liệu nhị phân.

--- BufferedReader.readLine()

GIẢI THÍCH CHI TIẾT: BufferedReader.readLine()

========================================================
1. BufferedReader LÀ GÌ?
========================================================

BufferedReader là một lớp trong java.io
dùng để đọc dữ liệu dạng ký tự (character stream)
một cách hiệu quả nhờ cơ chế buffer (bộ đệm).

Nó thường được dùng để:

- Đọc file text
- Đọc dữ liệu từ console
- Đọc dữ liệu từ network
- Đọc InputStream đã chuyển thành Reader

========================================================
2. readLine() LÀ GÌ?
========================================================

readLine() là một phương thức của BufferedReader
dùng để đọc một dòng văn bản từ nguồn dữ liệu.

Khai báo:

public String readLine() throws IOException

Nó trả về:

- Một String chứa nội dung của dòng
- Hoặc null nếu đã đến cuối stream (EOF)

========================================================
3. readLine() HOẠT ĐỘNG NHƯ THẾ NÀO?
========================================================

Khi gọi readLine():

1) Nó đọc từng ký tự từ buffer
2) Ghép các ký tự lại thành chuỗi
3) Dừng khi gặp ký tự kết thúc dòng
4) Trả về chuỗi (không bao gồm ký tự xuống dòng)

========================================================
4. KÝ TỰ KẾT THÚC DÒNG LÀ GÌ?
========================================================

Tùy hệ điều hành:

Windows:
\r\n

Linux / Unix:
\n

Mac cũ:
\r

readLine() tự động xử lý tất cả các loại này.

========================================================
5. LƯU Ý QUAN TRỌNG

Chuỗi trả về KHÔNG bao gồm ký tự xuống dòng.

Ví dụ:

File:
Hello
World

Lần gọi thứ nhất:
readLine() -> "Hello"

Lần gọi thứ hai:
readLine() -> "World"

Lần gọi thứ ba:
readLine() -> null

========================================================
6. GIÁ TRỊ null CÓ NGHĨA GÌ?
========================================================

Khi readLine() trả về null,
nghĩa là:

- Đã đọc hết dữ liệu
- Không còn dòng nào nữa

Đây là cách xác định kết thúc vòng lặp.

========================================================
7. CÁCH DÙNG PHỔ BIẾN

while ((line = reader.readLine()) != null) {
    // xử lý line
}

Đây là pattern chuẩn khi đọc file text.

========================================================
8. BUFFER LÀ GÌ?
========================================================

BufferedReader có một bộ đệm (buffer) nội bộ.

Thay vì:
Đọc từng ký tự trực tiếp từ file (rất chậm)

Nó sẽ:
- Đọc một khối lớn vào RAM
- Sau đó đọc từ RAM (nhanh hơn nhiều)

Điều này giúp tăng hiệu năng đáng kể.

========================================================
9. SỰ KHÁC BIỆT VỚI read()
========================================================

read()
- Đọc từng ký tự hoặc từng mảng ký tự
- Không tự động xử lý dòng

readLine()
- Đọc đến hết một dòng
- Dễ xử lý file text hơn

========================================================
10. LUỒNG HOẠT ĐỘNG THỰC TẾ

File (byte)
↓
InputStream
↓
InputStreamReader (chuyển byte -> char)
↓
BufferedReader (thêm buffer)
↓
readLine() (đọc từng dòng)

========================================================
11. VẤN ĐỀ ENCODING

BufferedReader thường được kết hợp với:

InputStreamReader(inputStream, "UTF-8")

Vì:

Byte phải được decode thành ký tự đúng encoding.

Nếu không chỉ định encoding đúng:
- Có thể lỗi tiếng Việt
- Ký tự bị sai

========================================================
12. TÌNH HUỐNG THỰC TẾ

(1) Đọc file .txt
(2) Đọc file cấu hình
(3) Đọc CSV
(4) Đọc log
(5) Đọc response từ server

========================================================
13. NHƯỢC ĐIỂM

- Chỉ đọc text (không dùng cho file nhị phân)
- Không giữ lại ký tự xuống dòng
- Không phù hợp cho file cực lớn nếu xử lý sai cách

========================================================
14. TƯ DUY HỆ THỐNG

File text bản chất là chuỗi ký tự
được chia thành các dòng.

readLine() giúp:

- Tách logic theo từng dòng
- Xử lý từng đơn vị dữ liệu nhỏ
- Tiết kiệm bộ nhớ vì không load toàn bộ file

========================================================
15. KẾT LUẬN BẢN CHẤT

BufferedReader.readLine() là phương thức
dùng để đọc từng dòng văn bản từ một nguồn dữ liệu,
tự động xử lý ký tự xuống dòng,
trả về null khi hết dữ liệu,
và tối ưu hiệu năng nhờ cơ chế buffer.

Nó là công cụ chuẩn để đọc file text trong Java.

--- ĐIỆN CHUYỂN TIỀN LÀ GÌ?

GIẢI THÍCH CHI TIẾT: ĐIỆN CHUYỂN TIỀN LÀ GÌ?

========================================================
1. ĐIỆN CHUYỂN TIỀN LÀ GÌ?
========================================================

Điện chuyển tiền là một thông điệp (message)
được gửi giữa các ngân hàng
để yêu cầu thực hiện một giao dịch chuyển tiền.

Nó không phải là “tiền”,
mà là lệnh điện tử
yêu cầu ngân hàng trích tiền từ tài khoản A
và ghi có vào tài khoản B.

Hiểu đơn giản:

Điện chuyển tiền = Lệnh yêu cầu chuyển tiền
giữa các ngân hàng thông qua hệ thống thanh toán.

========================================================
2. TẠI SAO GỌI LÀ “ĐIỆN”?
========================================================

Ngày xưa, ngân hàng gửi lệnh chuyển tiền
qua hệ thống điện báo (telegraph).

Từ đó hình thành thuật ngữ:

“Điện chuyển tiền”

Ngày nay không còn gửi bằng điện báo,
nhưng thuật ngữ vẫn được giữ lại.

========================================================
3. ĐIỆN CHUYỂN TIỀN CHỨA NHỮNG GÌ?
========================================================

Một điện chuyển tiền thường bao gồm:

- Tên ngân hàng gửi
- Tên ngân hàng nhận
- Số tiền
- Loại tiền (VND, USD...)
- Tài khoản người gửi
- Tài khoản người nhận
- Nội dung chuyển tiền
- Ngày giờ giao dịch
- Mã tham chiếu giao dịch

Nó là một thông điệp có cấu trúc.

========================================================
4. QUY TRÌNH HOẠT ĐỘNG

Bước 1:
Khách hàng yêu cầu chuyển tiền tại ngân hàng A.

Bước 2:
Ngân hàng A tạo điện chuyển tiền.

Bước 3:
Điện được gửi qua hệ thống thanh toán liên ngân hàng.

Bước 4:
Ngân hàng B nhận điện.

Bước 5:
Ngân hàng B ghi có vào tài khoản người nhận.

========================================================
5. CÁC HỆ THỐNG GỬI ĐIỆN CHUYỂN TIỀN

Tùy loại giao dịch:

(1) Trong nước:
- Hệ thống thanh toán liên ngân hàng
- Hệ thống bù trừ điện tử

(2) Quốc tế:
- SWIFT
- Hệ thống thanh toán quốc tế khác

========================================================
6. PHÂN LOẠI ĐIỆN CHUYỂN TIỀN

6.1 Điện chuyển tiền trong nước
- Cùng quốc gia
- Thường xử lý nhanh
- Phí thấp

6.2 Điện chuyển tiền quốc tế
- Khác quốc gia
- Phải qua hệ thống trung gian
- Có phí và tỷ giá

========================================================
7. ĐIỆN CHUYỂN TIỀN KHÁC GÌ VỚI GIAO DỊCH CHUYỂN TIỀN?

Giao dịch chuyển tiền:
Là hành động chuyển tiền.

Điện chuyển tiền:
Là thông điệp chứa yêu cầu chuyển tiền.

Tiền không “bay” qua dây mạng.
Chỉ có thông điệp được gửi đi.
Việc thanh toán thực tế được xử lý qua hệ thống bù trừ.

========================================================
8. VAI TRÒ TRONG NGÂN HÀNG

Điện chuyển tiền giúp:

- Ghi nhận yêu cầu chính thức
- Làm căn cứ đối soát
- Làm bằng chứng pháp lý
- Theo dõi lịch sử giao dịch

========================================================
9. ĐẶC ĐIỂM QUAN TRỌNG

- Có mã tham chiếu duy nhất
- Có thể truy vết
- Được lưu trữ trong hệ thống core banking
- Phải tuân thủ quy định pháp luật

========================================================
10. RỦI RO LIÊN QUAN

Nếu điện chuyển tiền sai:

- Nhập sai số tài khoản
- Sai số tiền
- Sai ngân hàng

Có thể gây:

- Chuyển nhầm tiền
- Tranh chấp
- Khiếu nại

========================================================
11. TRONG HỆ THỐNG CÔNG NGHỆ NGÂN HÀNG

Điện chuyển tiền thường được:

- Tạo dưới dạng message chuẩn
- Gửi qua message queue hoặc network bảo mật
- Ghi log đầy đủ
- Có cơ chế kiểm tra trùng lặp

========================================================
12. LIÊN HỆ THỰC TẾ

Khi bạn chuyển khoản khác ngân hàng:

Bạn chỉ thấy:
“Chuyển tiền thành công”

Nhưng phía sau là:

- Hệ thống tạo điện chuyển tiền
- Gửi qua hệ thống thanh toán
- Ngân hàng nhận xử lý

========================================================
13. TƯ DUY HỆ THỐNG

Ngân hàng không gửi tiền vật lý cho nhau.
Họ gửi thông điệp xác nhận nghĩa vụ thanh toán.

Điện chuyển tiền chính là:

Công cụ truyền thông tin
để thực hiện nghĩa vụ tài chính đó.

========================================================
14. KẾT LUẬN BẢN CHẤT

Điện chuyển tiền là một thông điệp điện tử
giữa các ngân hàng,
chứa lệnh yêu cầu chuyển tiền từ tài khoản này sang tài khoản khác,
được gửi qua hệ thống thanh toán,
và là cơ sở để thực hiện giao dịch chuyển tiền.

--- NAPAS KHÁC GÌ CITAD?

GIẢI THÍCH CHI TIẾT: NAPAS KHÁC GÌ CITAD?

========================================================
1. TỔNG QUAN
========================================================

NAPAS và CITAD đều là hệ thống thanh toán
giữa các ngân hàng tại Việt Nam.

Nhưng:

- NAPAS chủ yếu phục vụ thanh toán bán lẻ (retail payment).
- CITAD là hệ thống thanh toán liên ngân hàng do Ngân hàng Nhà nước vận hành.

Hiểu đơn giản:

NAPAS = Hệ thống chuyển tiền và thanh toán bán lẻ nhanh.
CITAD = Hệ thống thanh toán bù trừ liên ngân hàng truyền thống.

========================================================
2. NAPAS LÀ GÌ?
========================================================

NAPAS là viết tắt của:
National Payment Services

Là công ty cổ phần thanh toán quốc gia Việt Nam.

Chức năng chính:

- Kết nối ATM, POS giữa các ngân hàng
- Chuyển tiền nhanh 24/7
- Thanh toán thẻ nội địa
- Thanh toán QR

Đặc điểm:

- Hoạt động 24/7
- Xử lý gần như real-time
- Phục vụ giao dịch nhỏ và vừa

========================================================
3. CITAD LÀ GÌ?
========================================================

CITAD là hệ thống thanh toán điện tử liên ngân hàng
do Ngân hàng Nhà nước Việt Nam quản lý.

Mục đích:

- Thanh toán giữa các ngân hàng
- Chuyển tiền liên ngân hàng
- Xử lý giao dịch giá trị lớn

Đặc điểm:

- Thường hoạt động theo phiên
- Không phải 24/7 (truyền thống)
- Có cơ chế bù trừ

========================================================
4. SỰ KHÁC BIỆT CỐT LÕI

4.1 Về bản chất

NAPAS:
Là công ty trung gian thanh toán.

CITAD:
Là hệ thống thanh toán do Ngân hàng Nhà nước vận hành.

--------------------------------------------------------

4.2 Về loại giao dịch

NAPAS:
- Chuyển tiền nhanh 24/7
- Thanh toán thẻ
- Thanh toán QR
- Giao dịch bán lẻ

CITAD:
- Chuyển tiền liên ngân hàng truyền thống
- Giao dịch giá trị lớn
- Thanh toán giữa ngân hàng với nhau

--------------------------------------------------------

4.3 Về tốc độ xử lý

NAPAS:
- Gần như ngay lập tức (real-time)
- 24/7 kể cả cuối tuần

CITAD:
- Theo phiên xử lý
- Giờ hành chính (truyền thống)

--------------------------------------------------------

4.4 Về mục đích sử dụng

NAPAS:
Phục vụ khách hàng cá nhân là chính.

CITAD:
Phục vụ thanh toán cấp ngân hàng.

========================================================
5. VÍ DỤ THỰC TẾ

Khi bạn:

- Chuyển tiền 200.000 VNĐ lúc 23h đêm
=> Thường qua NAPAS (chuyển nhanh 24/7).

Khi doanh nghiệp:

- Chuyển 50 tỷ VNĐ cho đối tác
=> Có thể qua CITAD.

========================================================
6. CƠ CHẾ XỬ LÝ

NAPAS:
- Gửi message tức thời
- Kiểm tra số dư
- Ghi nợ và ghi có gần như ngay lập tức

CITAD:
- Các ngân hàng gửi điện thanh toán
- Hệ thống bù trừ
- Cuối phiên quyết toán

========================================================
7. TÍNH CHẤT KỸ THUẬT

NAPAS:
- Hệ thống retail payment switch
- Tối ưu giao dịch nhỏ, số lượng lớn

CITAD:
- Hệ thống thanh toán liên ngân hàng
- Tập trung an toàn hệ thống tài chính

========================================================
8. TẠI SAO CẦN CẢ HAI?

Vì:

Hệ thống tài chính có hai nhu cầu:

1) Giao dịch nhỏ, nhanh, nhiều lần (bán lẻ)
2) Giao dịch lớn, an toàn, quyết toán giữa ngân hàng

NAPAS giải quyết (1).
CITAD giải quyết (2).

========================================================
9. TƯ DUY HỆ THỐNG

NAPAS giống như:
Hệ thống thanh toán tiêu dùng hàng ngày.

CITAD giống như:
Hệ thống quyết toán giữa các ngân hàng
ở cấp độ nền tảng tài chính quốc gia.

========================================================
10. KẾT LUẬN BẢN CHẤT

NAPAS và CITAD đều là hệ thống thanh toán liên ngân hàng,
nhưng khác nhau về:

- Cơ quan vận hành
- Mục đích sử dụng
- Tốc độ xử lý
- Loại giao dịch phục vụ

NAPAS:
Tập trung vào chuyển tiền nhanh 24/7 và thanh toán bán lẻ.

CITAD:
Là hệ thống thanh toán điện tử liên ngân hàng
do Ngân hàng Nhà nước quản lý,
phục vụ thanh toán và quyết toán giữa các ngân hàng.

--- IBPS LÀ GÌ?

GIẢI THÍCH CHI TIẾT: IBPS LÀ GÌ?

========================================================
1. IBPS LÀ GÌ?
========================================================

IBPS là viết tắt của:

Inter-Bank Payment System
(Hệ thống thanh toán liên ngân hàng)

Tại Việt Nam, IBPS là tên gọi mới
của hệ thống CITAD trước đây.

Nói cách khác:

IBPS = Hệ thống thanh toán điện tử liên ngân hàng
do Ngân hàng Nhà nước Việt Nam vận hành.

========================================================
2. MỤC ĐÍCH CỦA IBPS
========================================================

IBPS được xây dựng để:

- Thực hiện thanh toán giữa các ngân hàng
- Quyết toán nghĩa vụ thanh toán
- Đảm bảo an toàn hệ thống tài chính quốc gia
- Xử lý giao dịch giá trị lớn và bán lẻ

Đây là hệ thống thanh toán ở cấp độ quốc gia.

========================================================
3. IBPS HOẠT ĐỘNG NHƯ THẾ NÀO?
========================================================

Bước 1:
Ngân hàng A gửi lệnh thanh toán
tới IBPS.

Bước 2:
IBPS kiểm tra và xử lý bù trừ.

Bước 3:
Ngân hàng Nhà nước thực hiện quyết toán
trên tài khoản dự trữ của các ngân hàng.

Bước 4:
Ngân hàng B nhận tiền.

========================================================
4. IBPS KHÁC GÌ NAPAS?
========================================================

IBPS:
- Do Ngân hàng Nhà nước vận hành
- Thanh toán cấp ngân hàng
- Dùng để quyết toán giữa các ngân hàng

NAPAS:
- Do công ty trung gian vận hành
- Chuyển tiền nhanh 24/7
- Phục vụ khách hàng cá nhân là chính

Hiểu đơn giản:

NAPAS = lớp thanh toán bán lẻ.
IBPS = lớp quyết toán nền tảng quốc gia.

========================================================
5. CÁC LOẠI THANH TOÁN TRONG IBPS
========================================================

IBPS gồm 2 nhóm chính:

1) Thanh toán giá trị cao (High Value)
   - Giao dịch lớn
   - Xử lý tức thời hoặc ưu tiên cao

2) Thanh toán giá trị thấp (Low Value)
   - Giao dịch bán lẻ
   - Xử lý theo lô hoặc bù trừ

========================================================
6. VAI TRÒ CỦA IBPS TRONG HỆ THỐNG TÀI CHÍNH
========================================================

IBPS đóng vai trò:

- Trục thanh toán quốc gia
- Trung tâm quyết toán liên ngân hàng
- Đảm bảo tính thanh khoản hệ thống
- Giảm rủi ro thanh toán dây chuyền

Nếu IBPS gặp sự cố,
toàn bộ hệ thống ngân hàng có thể bị ảnh hưởng.

========================================================
7. TẠI SAO CẦN IBPS?
========================================================

Vì:

- Các ngân hàng phải thanh toán cho nhau hàng ngày
- Cần một hệ thống trung tâm để quản lý
- Cần đảm bảo minh bạch và an toàn

IBPS chính là "hệ thần kinh trung ương"
của hệ thống thanh toán quốc gia.

========================================================
8. SỰ CHUYỂN ĐỔI TỪ CITAD SANG IBPS
========================================================

Trước đây:
Hệ thống thanh toán điện tử liên ngân hàng
được gọi là CITAD.

Sau này:
Hệ thống được nâng cấp và đổi tên thành IBPS
với công nghệ hiện đại hơn,
tăng tốc độ xử lý và khả năng mở rộng.

========================================================
9. SO SÁNH TỔNG HỢP

IBPS:
- Hệ thống thanh toán liên ngân hàng
- Do Ngân hàng Nhà nước vận hành
- Phục vụ quyết toán cấp ngân hàng
- Cốt lõi của hạ tầng tài chính quốc gia

NAPAS:
- Hệ thống chuyển tiền nhanh
- Hoạt động 24/7
- Tập trung giao dịch bán lẻ

========================================================
10. KẾT LUẬN BẢN CHẤT
========================================================

IBPS là:

Hệ thống thanh toán điện tử liên ngân hàng
ở cấp độ quốc gia,
được vận hành bởi Ngân hàng Nhà nước,
đóng vai trò trung tâm trong việc
quyết toán và thanh toán giữa các ngân hàng.

Nói ngắn gọn:

IBPS = hạ tầng thanh toán nền tảng quốc gia.

--- DBLINK LÀ GÌ?

GIẢI THÍCH CHI TIẾT: DBLINK LÀ GÌ?

========================================================
1. DBLINK LÀ GÌ?
========================================================

DBLINK (Database Link) là một cơ chế trong hệ quản trị cơ sở dữ liệu
cho phép một database này truy cập dữ liệu của database khác
như thể dữ liệu đó nằm trong chính database của mình.

Hiểu đơn giản:

DBLINK = Cầu nối giữa 2 database.

========================================================
2. MỤC ĐÍCH CỦA DBLINK
========================================================

DBLINK được sử dụng để:

- Truy vấn dữ liệu từ database khác
- Join dữ liệu giữa 2 database
- Thực hiện insert/update/delete từ xa
- Đồng bộ dữ liệu
- Chia sẻ dữ liệu giữa các hệ thống

========================================================
3. CÁCH HOẠT ĐỘNG CỦA DBLINK
========================================================

Giả sử:

Database A cần lấy dữ liệu từ Database B.

Thay vì:
- Export/Import dữ liệu
- Viết API trung gian

Ta tạo DBLINK từ A sang B.

Sau đó có thể truy vấn:

SELECT * FROM table_name@remote_db_link;

Ký hiệu:
@remote_db_link = tên dblink đã tạo.

========================================================
4. DBLINK TRONG ORACLE
========================================================

DBLINK thường được nhắc đến nhiều nhất trong Oracle Database.

Cú pháp tạo:

CREATE DATABASE LINK link_name
CONNECT TO username IDENTIFIED BY password
USING 'remote_service';

Sau khi tạo xong có thể dùng:

SELECT * FROM table_name@link_name;

========================================================
5. PHÂN LOẠI DBLINK
========================================================

5.1 Private DBLINK
- Chỉ user tạo ra mới dùng được.

5.2 Public DBLINK
- Mọi user trong database đều có thể dùng.

========================================================
6. VÍ DỤ THỰC TẾ
========================================================

Hệ thống:

Core Banking DB (Database A)
CRM DB (Database B)

Core cần lấy thông tin khách hàng từ CRM.

Giải pháp:
Tạo DBLINK từ Core sang CRM.

Sau đó:

SELECT * FROM customer@crm_link;

========================================================
7. ƯU ĐIỂM CỦA DBLINK
========================================================

- Truy cập dữ liệu từ xa trực tiếp
- Không cần sao chép dữ liệu
- Dễ triển khai
- Tiết kiệm chi phí phát triển API

========================================================
8. NHƯỢC ĐIỂM VÀ RỦI RO
========================================================

8.1 Về bảo mật
- Lưu username/password trong database
- Có thể lộ thông tin kết nối

8.2 Về hiệu năng
- Phụ thuộc vào network
- Query chậm nếu join lớn

8.3 Về phụ thuộc hệ thống
- Nếu DB remote down => query lỗi

========================================================
9. CƠ CHẾ KỸ THUẬT BÊN TRONG
========================================================

Khi dùng DBLINK:

1) Database local mở kết nối network tới remote DB.
2) Xác thực user/password.
3) Gửi câu SQL sang remote.
4) Remote xử lý và trả dữ liệu.
5) Local nhận dữ liệu và tiếp tục xử lý.

========================================================
10. DBLINK KHÁC GÌ API?
========================================================

DBLINK:
- Truy cập trực tiếp ở mức database
- Phụ thuộc chặt vào cấu trúc bảng

API:
- Truy cập ở mức application
- An toàn hơn
- Kiểm soát logic tốt hơn

========================================================
11. KHI NÀO NÊN DÙNG DBLINK?
========================================================

Nên dùng khi:

- Hệ thống nội bộ
- Cần truy vấn nhanh
- Không cần public ra ngoài

Không nên dùng khi:

- Hệ thống độc lập
- Yêu cầu bảo mật cao
- Kiến trúc microservices

========================================================
12. TƯ DUY THIẾT KẾ
========================================================

DBLINK phù hợp với kiến trúc monolithic
hoặc hệ thống legacy.

Trong kiến trúc hiện đại,
người ta ưu tiên:

- API
- Message queue
- Data replication

========================================================
13. KẾT LUẬN BẢN CHẤT
========================================================

DBLINK là một cơ chế cho phép
một database truy cập trực tiếp
đến dữ liệu của database khác
thông qua kết nối từ xa.

Nó đóng vai trò như một "cầu nối dữ liệu"
giữa các hệ quản trị cơ sở dữ liệu.

--- APACHE CAMEL LÀ GÌ? CÓ PHÁT HIỆN FILE MỚI KHÔNG?

GIẢI THÍCH CHI TIẾT: APACHE CAMEL LÀ GÌ? CÓ PHÁT HIỆN FILE MỚI KHÔNG?

========================================================
1. APACHE CAMEL LÀ GÌ?
========================================================

Apache Camel là một framework tích hợp (integration framework)
mã nguồn mở dùng để kết nối các hệ thống khác nhau
một cách linh hoạt và dễ mở rộng.

Camel giúp:

- Kết nối hệ thống A với hệ thống B
- Chuyển đổi dữ liệu
- Định tuyến thông điệp
- Tích hợp nhiều giao thức khác nhau

Apache Camel được xây dựng dựa trên:

Enterprise Integration Patterns (EIP)

========================================================
2. APACHE CAMEL DÙNG ĐỂ LÀM GÌ?
========================================================

Camel thường được dùng để:

- Tích hợp hệ thống
- Xử lý message
- Đồng bộ dữ liệu
- Tự động hóa luồng xử lý

Ví dụ:

- Nhận file → xử lý → ghi vào DB
- Nhận message từ queue → gọi API
- Đọc email → lưu file đính kèm

========================================================
3. KHÁI NIỆM ROUTE TRONG CAMEL
========================================================

Trong Camel, mọi thứ xoay quanh "Route".

Route là:

Luồng xử lý dữ liệu từ điểm đầu (from)
đến điểm cuối (to).

Ví dụ:

from("file:/input")
  .to("jms:queue");

Nghĩa là:
Đọc file từ thư mục /input
rồi gửi nội dung vào queue.

========================================================
4. CAMEL CÓ PHÁT HIỆN FILE MỚI KHÔNG?
========================================================

CÓ.

Apache Camel có component tên là:

File Component

Nó có khả năng:

- Theo dõi thư mục
- Phát hiện file mới
- Tự động xử lý khi file xuất hiện

========================================================
5. CƠ CHẾ PHÁT HIỆN FILE MỚI
========================================================

Camel sử dụng cơ chế:

Polling (quét định kỳ)

Nghĩa là:

- Mỗi khoảng thời gian (mặc định vài giây)
- Camel kiểm tra thư mục
- Nếu có file mới → xử lý

Ví dụ:

from("file:/data/input?delay=5000")
  .to("log:received");

delay=5000 nghĩa là:
Mỗi 5 giây quét thư mục một lần.

========================================================
6. CÁC TÍNH NĂNG KHI XỬ LÝ FILE
========================================================

Camel hỗ trợ:

- Tự động move file sau khi xử lý
- Rename file
- Xóa file
- Đọc file theo pattern
- Tránh đọc file đang ghi dở

Ví dụ:

from("file:/input?move=/backup")
  .to("bean:processFile");

Sau khi xử lý xong,
file sẽ được chuyển vào thư mục /backup.

========================================================
7. TRÁNH ĐỌC FILE CHƯA GHI XONG
========================================================

Camel hỗ trợ:

readLock

Ví dụ:

from("file:/input?readLock=changed")
  .to("log:done");

readLock=changed nghĩa là:
Chỉ đọc file khi file không còn thay đổi kích thước.

========================================================
8. CAMEL HỖ TRỢ NHỮNG GIAO THỨC NÀO?
========================================================

Camel hỗ trợ rất nhiều component:

- file
- ftp
- sftp
- http
- https
- jms
- kafka
- database
- rest
- smtp
- nhiều loại khác

Tổng cộng hơn 300 component.

========================================================
9. KIẾN TRÚC BÊN TRONG
========================================================

Camel gồm các thành phần chính:

1) Component
   (file, http, jms...)

2) Endpoint
   (địa chỉ cụ thể)

3) Route
   (luồng xử lý)

4) Processor
   (logic xử lý)

========================================================
10. VÍ DỤ THỰC TẾ: XỬ LÝ FILE NGÂN HÀNG
========================================================

Bài toán:

- Hệ thống Core xuất file giao dịch
- Camel đọc file
- Parse nội dung
- Ghi vào database

Flow:

from("file:/core/output?move=/processed")
  .process(parseFile)
  .to("jdbc:dataSource");

========================================================
11. ƯU ĐIỂM CỦA APACHE CAMEL
========================================================

- Dễ cấu hình
- Hỗ trợ nhiều giao thức
- Linh hoạt
- Dễ mở rộng
- Tích hợp tốt với Spring Boot

========================================================
12. NHƯỢC ĐIỂM
========================================================

- Polling nên không phải real-time tuyệt đối
- Có thể tốn tài nguyên nếu cấu hình không đúng
- Cần hiểu rõ EIP để dùng hiệu quả

========================================================
13. SO SÁNH FILE POLLING VỚI EVENT-BASED
========================================================

Polling (Camel file component):
- Kiểm tra định kỳ
- Dễ triển khai
- Không cần OS hook

Event-based (watch service):
- Phản ứng ngay khi file xuất hiện
- Phức tạp hơn
- Phụ thuộc hệ điều hành

Camel chủ yếu dùng polling.

========================================================
14. KẾT LUẬN BẢN CHẤT
========================================================

Apache Camel là một framework tích hợp
giúp kết nối và xử lý dữ liệu giữa các hệ thống.

Và:

Có.
Apache Camel hoàn toàn có chức năng
phát hiện file mới
thông qua File Component
bằng cơ chế quét thư mục định kỳ (polling).

--- OSB LÀ GÌ?

GIẢI THÍCH CHI TIẾT: OSB LÀ GÌ?

========================================================
1. OSB LÀ GÌ?
========================================================

OSB là viết tắt của:

Oracle Service Bus

Đây là một sản phẩm middleware
thuộc hệ sinh thái Oracle,
được sử dụng để tích hợp và kết nối
các hệ thống khác nhau trong doanh nghiệp.

Nói đơn giản:

OSB là một Enterprise Service Bus (ESB).

========================================================
2. ESB LÀ GÌ?
========================================================

ESB (Enterprise Service Bus) là:

Một nền tảng trung gian
giúp các hệ thống giao tiếp với nhau
thông qua một lớp tích hợp chung.

Thay vì:

System A gọi trực tiếp System B

Ta sẽ:

System A → OSB → System B

OSB đóng vai trò trung gian.

========================================================
3. MỤC ĐÍCH CỦA OSB
========================================================

OSB được dùng để:

- Tích hợp hệ thống (System Integration)
- Định tuyến request
- Chuyển đổi dữ liệu (XML, JSON...)
- Bảo mật service
- Logging và monitoring
- Kiểm soát traffic

========================================================
4. OSB HOẠT ĐỘNG NHƯ THẾ NÀO?
========================================================

Luồng cơ bản:

1) Client gửi request tới OSB
2) OSB kiểm tra, validate
3) OSB transform dữ liệu
4) OSB gọi service backend
5) OSB nhận response
6) OSB trả kết quả về client

========================================================
5. CÁC THÀNH PHẦN CHÍNH TRONG OSB
========================================================

5.1 Proxy Service

Là service public.
Client sẽ gọi vào đây.

5.2 Business Service

Là service backend thực tế.
OSB sẽ gọi tới đây.

5.3 Pipeline

Nơi xử lý logic:
- Validate
- Transform
- Route
- Logging

========================================================
6. OSB CÓ THỂ LÀM GÌ?
========================================================

OSB hỗ trợ:

- SOAP Web Service
- REST Service
- JMS
- HTTP
- FTP
- Database Adapter
- Email
- MQ

========================================================
7. VÍ DỤ THỰC TẾ
========================================================

Hệ thống ngân hàng:

Mobile App → OSB → Core Banking

Mobile App không gọi Core trực tiếp.
Tất cả request đi qua OSB.

OSB sẽ:

- Kiểm tra token
- Log giao dịch
- Chuyển đổi định dạng
- Gọi Core
- Trả kết quả

========================================================
8. ƯU ĐIỂM CỦA OSB
========================================================

- Tách biệt frontend và backend
- Dễ quản lý service
- Centralized logging
- Dễ thay đổi backend mà không ảnh hưởng client
- Tăng tính bảo mật

========================================================
9. NHƯỢC ĐIỂM
========================================================

- Chi phí license cao
- Phụ thuộc vào hệ sinh thái Oracle
- Có thể trở thành bottleneck nếu cấu hình sai

========================================================
10. OSB KHÁC GÌ APACHE CAMEL?
========================================================

OSB:
- Sản phẩm thương mại của Oracle
- Có giao diện quản lý GUI
- Triển khai trên WebLogic
- Tập trung vào ESB doanh nghiệp lớn

Apache Camel:
- Open source
- Cấu hình bằng code
- Nhẹ hơn
- Linh hoạt hơn

========================================================
11. KIẾN TRÚC TRIỂN KHAI
========================================================

OSB thường chạy trên:

Oracle WebLogic Server

Kiến trúc có thể gồm:

- Load Balancer
- Cluster OSB
- Backend services

========================================================
12. TẠI SAO DOANH NGHIỆP DÙNG OSB?
========================================================

Vì:

- Cần tích hợp nhiều hệ thống
- Cần kiểm soát tập trung
- Cần đảm bảo bảo mật và logging
- Cần khả năng mở rộng

========================================================
13. OSB TRONG KIẾN TRÚC MICROservices?
========================================================

Trong kiến trúc cũ (SOA):
OSB là trung tâm.

Trong microservices hiện đại:
Vai trò của OSB có thể được thay thế bởi:

- API Gateway
- Service Mesh
- Message Broker

========================================================
14. KẾT LUẬN BẢN CHẤT
========================================================

OSB (Oracle Service Bus) là:

Một nền tảng tích hợp trung gian (ESB)
giúp kết nối, định tuyến,
chuyển đổi và bảo mật các service
trong hệ thống doanh nghiệp.

Nó đóng vai trò là "cầu nối thông minh"
giữa client và các hệ thống backend.

--- RUNNABLE TRONG JAVA, Runnable khác gì timertask, Runnable chạy khi nào

GIẢI THÍCH CHI TIẾT: RUNNABLE TRONG JAVA

========================================================
1. RUNNABLE LÀ GÌ?
========================================================

Runnable là một interface trong Java.

Nó nằm trong package:

java.lang

Khai báo:

public interface Runnable {
    void run();
}

Runnable đại diện cho một đơn vị công việc
(task) có thể được thực thi bởi một Thread.

Hiểu đơn giản:

Runnable = Một khối công việc có thể chạy song song.

========================================================
2. TẠI SAO CẦN RUNNABLE?
========================================================

Java hỗ trợ đa luồng (multithreading).

Để tạo một luồng chạy song song,
ta cần cung cấp cho Thread một công việc.

Runnable chính là cách định nghĩa công việc đó.

========================================================
3. CÁCH SỬ DỤNG RUNNABLE
========================================================

Bước 1: Tạo class implement Runnable

class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Task is running");
    }
}

Bước 2: Tạo Thread

Thread t = new Thread(new MyTask());
t.start();

Quan trọng:

Phải gọi start() chứ không gọi run() trực tiếp.

========================================================
4. RUNNABLE CHẠY KHI NÀO?
========================================================

Runnable sẽ chạy khi:

Thread.start() được gọi.

Quy trình:

1) Gọi start()
2) JVM tạo thread mới
3) JVM gọi phương thức run() bên trong thread đó

Nếu chỉ gọi:

myRunnable.run();

Thì:

Nó sẽ chạy như một phương thức bình thường,
không tạo thread mới.

========================================================
5. RUNNABLE KHÁC GÌ VỚI EXTENDS THREAD?
========================================================

Có 2 cách tạo thread:

1) Kế thừa Thread
2) Implement Runnable

Runnable tốt hơn vì:

- Không bị giới hạn kế thừa (Java chỉ cho extends 1 class)
- Tách biệt logic task và thread
- Linh hoạt hơn

========================================================
6. RUNNABLE KHÁC GÌ TIMERTASK?
========================================================

TimerTask là một class trong package:

java.util

Khai báo:

public abstract class TimerTask implements Runnable

Nghĩa là:

TimerTask đã implement Runnable.

--------------------------------------------------------

So sánh:

Runnable:
- Chỉ có 1 phương thức run()
- Không có cơ chế hẹn giờ
- Dùng với Thread hoặc Executor

TimerTask:
- Kế thừa Runnable
- Dùng với Timer
- Hỗ trợ chạy theo lịch

========================================================
7. VÍ DỤ TIMERTASK
========================================================

Timer timer = new Timer();

timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("Run after delay");
    }
}, 5000);

Nghĩa là:

Chạy sau 5 giây.

========================================================
8. SO SÁNH RUNNABLE VÀ TIMERTASK

Runnable:
- Đại diện cho một task chung
- Không có scheduling
- Dùng với Thread, ExecutorService

TimerTask:
- Là Runnable đặc biệt
- Có thể được lên lịch
- Dùng với Timer

========================================================
9. RUNNABLE TRONG EXECUTOR FRAMEWORK
========================================================

Runnable thường dùng với:

ExecutorService

Ví dụ:

ExecutorService executor = Executors.newFixedThreadPool(2);
executor.submit(new MyTask());

Executor quản lý thread thay vì ta tự tạo.

========================================================
10. LUỒNG CHẠY CỦA RUNNABLE
========================================================

Khi dùng:

new Thread(runnable).start();

Luồng thực thi:

Main Thread
    |
    ---> Tạo Thread mới
            |
            ---> Gọi runnable.run()

========================================================
11. ĐẶC ĐIỂM QUAN TRỌNG CỦA RUNNABLE
========================================================

- Không trả về giá trị
- Không ném checked exception
- Chỉ có một phương thức run()

Nếu cần trả về giá trị,
ta dùng:

Callable

========================================================
12. TƯ DUY BẢN CHẤT
========================================================

Runnable không phải là Thread.

Runnable chỉ là:

Mô tả công việc.

Thread mới là:

Thực thể thực thi công việc đó.

Có thể ví:

Runnable = Công việc
Thread = Công nhân thực hiện công việc

========================================================
13. TÓM TẮT NGẮN GỌN
========================================================

Runnable là:

Interface đại diện cho một task
có thể chạy trong một thread.

Runnable chạy khi:

Thread.start() được gọi.

Runnable khác TimerTask ở chỗ:

TimerTask có thêm khả năng hẹn giờ
và được dùng với Timer,
trong khi Runnable là khái niệm chung hơn.

--- "UPLOAD TO IBPS1" LÀ GÌ?

GIẢI THÍCH CHI TIẾT: "UPLOAD TO IBPS1" LÀ GÌ?

========================================================
1. IBPS1 LÀ GÌ?
========================================================

IBPS = Inter-Bank Payment System
(Hệ thống thanh toán điện tử liên ngân hàng)

IBPS1 thường là:

- Tên một môi trường
- Hoặc một server
- Hoặc một node trong hệ thống IBPS

Trong thực tế triển khai tại ngân hàng,
IBPS thường có nhiều môi trường như:

- IBPS1 (Production hoặc Primary node)
- IBPS2 (Backup / DR)
- IBPS UAT
- IBPS Test

Vì vậy:

IBPS1 thường là server chính
kết nối trực tiếp tới hệ thống IBPS của Ngân hàng Nhà nước.

========================================================
2. "UPLOAD TO IBPS1" LÀ GÌ?
========================================================

"Upload to IBPS1" nghĩa là:

Tải file giao dịch
hoặc dữ liệu thanh toán
lên server IBPS1 để gửi đi liên ngân hàng.

Nói đơn giản:

Upload to IBPS1 = Đưa file thanh toán
lên hệ thống IBPS để xử lý.

========================================================
3. UPLOAD CÁI GÌ LÊN IBPS1?
========================================================

Thông thường là:

- File chuyển tiền liên ngân hàng
- File bù trừ
- File thanh toán giá trị cao
- File thanh toán giá trị thấp
- File đối soát

Các file này thường ở định dạng:

- TXT
- DAT
- XML
- File theo chuẩn IBPS quy định

========================================================
4. LUỒNG XỬ LÝ THỰC TẾ
========================================================

Ví dụ quy trình:

Bước 1:
Core Banking sinh file thanh toán.

Bước 2:
Hệ thống trung gian (Middleware / ESB / Batch Job)
thực hiện "upload to IBPS1".

Bước 3:
IBPS1 tiếp nhận file.

Bước 4:
IBPS1 truyền file lên hệ thống IBPS của Ngân hàng Nhà nước.

Bước 5:
Nhận phản hồi (ACK / NACK / kết quả xử lý).

========================================================
5. UPLOAD BẰNG CÁCH NÀO?
========================================================

Tùy hệ thống, có thể dùng:

- SFTP
- FTP
- Web Service
- MQ
- Direct socket connection

Phổ biến nhất là:

SFTP tự động (batch job).

========================================================
6. TẠI SAO PHẢI CÓ IBPS1?
========================================================

Vì ngân hàng không kết nối trực tiếp
từ Core Banking ra Ngân hàng Nhà nước.

Thay vào đó:

Core → Middleware → IBPS1 → NHNN

IBPS1 đóng vai trò:

- Gateway
- Bộ chuyển đổi định dạng
- Bộ kiểm tra dữ liệu
- Điểm kiểm soát an toàn

========================================================
7. PHÂN BIỆT IBPS1 VÀ IBPS2
========================================================

IBPS1:
- Server chính
- Hoạt động thường xuyên

IBPS2:
- Server dự phòng (DR - Disaster Recovery)
- Dùng khi IBPS1 gặp sự cố

========================================================
8. RỦI RO KHI UPLOAD TO IBPS1
========================================================

Có thể xảy ra:

- Sai định dạng file
- File lỗi checksum
- Kết nối SFTP lỗi
- IBPS1 full disk
- Timeout
- Trùng file

Do đó hệ thống thường có:

- Logging
- Retry mechanism
- Kiểm tra trùng file
- Kiểm tra trạng thái ACK

========================================================
9. TRONG NGỮ CẢNH CÔNG VIỆC IT NGÂN HÀNG
========================================================

Nếu bạn nghe:

"Batch chưa upload to IBPS1"
có nghĩa là:

File thanh toán chưa được đẩy
lên server IBPS chính.

Nếu nghe:

"Upload to IBPS1 failed"
nghĩa là:

Quá trình truyền file lên hệ thống IBPS gateway bị lỗi.

========================================================
10. BẢN CHẤT KỸ THUẬT
========================================================

Upload to IBPS1 về bản chất là:

Một hành động truyền file
hoặc truyền message
từ hệ thống nội bộ
lên gateway thanh toán liên ngân hàng.

Nó là bước trung gian trước khi
giao dịch thực sự đi ra ngoài ngân hàng.

========================================================
11. KẾT LUẬN NGẮN GỌN
========================================================

"Upload to IBPS1" là:

Hành động gửi file thanh toán
hoặc dữ liệu giao dịch
từ hệ thống nội bộ ngân hàng
lên server IBPS chính
để thực hiện thanh toán liên ngân hàng.

IBPS1 thường là gateway trung gian
kết nối ngân hàng với hệ thống IBPS quốc gia.

--- TẠI SAO "KÊNH NGOÀI" LẠI ĐẨY VÀO AML TRONG CITAD SYSTEM?

GIẢI THÍCH CHI TIẾT:
TẠI SAO "KÊNH NGOÀI" LẠI ĐẨY VÀO AML TRONG CITAD SYSTEM?

========================================================
1. GIẢI THÍCH CÁC THUẬT NGỮ
========================================================

1.1 Kênh ngoài là gì?

"Kênh ngoài" thường là các kênh giao dịch không phải Core nội bộ,
ví dụ:

- Internet Banking
- Mobile Banking
- ATM
- POS
- API Open Banking
- Ví điện tử

Tức là các kênh khách hàng trực tiếp thao tác.

--------------------------------------------------------

1.2 AML là gì?

AML = Anti-Money Laundering
(Hệ thống phòng chống rửa tiền)

AML dùng để:

- Phát hiện giao dịch đáng ngờ
- So khớp danh sách đen
- Phân tích hành vi bất thường
- Chặn giao dịch rủi ro cao

--------------------------------------------------------

1.3 CITAD là gì?

CITAD là hệ thống thanh toán điện tử liên ngân hàng
(trước đây, sau này nâng cấp thành IBPS).

CITAD dùng để gửi tiền liên ngân hàng
qua Ngân hàng Nhà nước.

========================================================
2. LUỒNG GIAO DỊCH LIÊN NGÂN HÀNG
========================================================

Ví dụ khách hàng chuyển tiền liên ngân hàng:

Mobile Banking
     ↓
Core Banking
     ↓
AML
     ↓
CITAD
     ↓
Ngân hàng Nhà nước

========================================================
3. TẠI SAO PHẢI ĐẨY QUA AML TRƯỚC CITAD?
========================================================

Vì:

CITAD là cổng ra bên ngoài ngân hàng.

Một khi giao dịch đã đi vào CITAD,
nó gần như đã rời khỏi phạm vi kiểm soát nội bộ.

Do đó:

Ngân hàng phải kiểm soát rủi ro
trước khi giao dịch ra khỏi hệ thống.

========================================================
4. LÝ DO CỤ THỂ
========================================================

4.1 Tuân thủ pháp luật

Luật phòng chống rửa tiền yêu cầu:

Mọi giao dịch đáng ngờ phải được kiểm tra
trước khi thực hiện.

Nếu không kiểm soát AML,
ngân hàng có thể bị:

- Phạt tiền
- Mất giấy phép
- Điều tra hình sự

--------------------------------------------------------

4.2 Ngăn chặn giao dịch rủi ro

AML sẽ kiểm tra:

- Giao dịch giá trị lớn bất thường
- Chuyển tiền nhiều lần trong thời gian ngắn
- Người nhận thuộc danh sách đen
- Quốc gia rủi ro cao

--------------------------------------------------------

4.3 Giảm rủi ro pháp lý

Nếu tiền đã đi qua CITAD
và được quyết toán liên ngân hàng,

việc thu hồi rất khó.

========================================================
5. TẠI SAO KÊNH NGOÀI BẮT BUỘC PHẢI QUA AML?
========================================================

Vì kênh ngoài là nơi:

- Khách hàng thao tác trực tiếp
- Dễ phát sinh hành vi gian lận
- Không có kiểm soát thủ công

Giao dịch từ kênh ngoài thường:

- Nhanh
- Số lượng lớn
- Tự động

Do đó cần AML kiểm soát tự động.

========================================================
6. VÌ SAO KHÔNG ĐẨY THẲNG VÀO CITAD?
========================================================

Nếu bỏ qua AML:

Mobile Banking
     ↓
Core
     ↓
CITAD

Nguy cơ:

- Rửa tiền
- Tài trợ khủng bố
- Lừa đảo
- Vi phạm luật AML

CITAD chỉ xử lý thanh toán,
không kiểm tra rủi ro hành vi.

========================================================
7. AML LÀ TẦNG KIỂM SOÁT TRƯỚC KHI RA NGOÀI
========================================================

Có thể hiểu kiến trúc như sau:

Kênh ngoài = cửa vào
CITAD = cửa ra
AML = chốt kiểm soát ở giữa

Nếu AML phát hiện rủi ro:

- Có thể hold giao dịch
- Đưa vào danh sách kiểm tra thủ công
- Từ chối giao dịch

========================================================
8. PHÂN TÍCH Ở GÓC ĐỘ KIẾN TRÚC HỆ THỐNG
========================================================

Hệ thống ngân hàng thường thiết kế:

Layer 1: Channel Layer
Layer 2: Core Banking
Layer 3: Compliance Layer (AML)
Layer 4: Payment Gateway (CITAD)

Compliance luôn nằm trước Payment Gateway.

========================================================
9. TRONG THỰC TẾ VẬN HÀNH
========================================================

Nếu nghe câu:

"Kênh ngoài đẩy vào AML trước khi vào CITAD"

Có nghĩa là:

Giao dịch liên ngân hàng từ khách hàng
phải qua bước kiểm soát rửa tiền
trước khi gửi đi hệ thống thanh toán quốc gia.

========================================================
10. KẾT LUẬN BẢN CHẤT
========================================================

Kênh ngoài phải đẩy vào AML trước CITAD vì:

- Đảm bảo tuân thủ luật phòng chống rửa tiền
- Giảm rủi ro pháp lý
- Ngăn chặn giao dịch đáng ngờ
- Kiểm soát trước khi tiền ra khỏi ngân hàng

AML đóng vai trò là lớp bảo vệ
giữa hệ thống nội bộ và hệ thống thanh toán quốc gia.

--- TẠI SAO CẦN DÙNG SFTP ĐỂ ĐẨY FILE LÊN?

GIẢI THÍCH CHI TIẾT:
TẠI SAO CẦN DÙNG SFTP ĐỂ ĐẨY FILE LÊN?

========================================================
1. SFTP LÀ GÌ?
========================================================

SFTP = SSH File Transfer Protocol

Là giao thức truyền file
chạy trên nền tảng SSH (Secure Shell).

Nó cho phép:

- Upload file
- Download file
- Quản lý thư mục
- Thực hiện truyền file an toàn qua mạng

========================================================
2. TẠI SAO KHÔNG DÙNG FTP THƯỜNG?
========================================================

FTP (File Transfer Protocol) truyền dữ liệu:

- Không mã hóa
- Username/password gửi dạng plain text
- Dữ liệu có thể bị nghe lén

Trong môi trường ngân hàng hoặc doanh nghiệp,
điều này là không chấp nhận được.

========================================================
3. SFTP GIẢI QUYẾT VẤN ĐỀ GÌ?
========================================================

3.1 Mã hóa dữ liệu

Toàn bộ:

- Nội dung file
- Username
- Password
- Thông tin điều khiển

đều được mã hóa qua SSH.

--------------------------------------------------------

3.2 Xác thực an toàn

Hỗ trợ:

- Password authentication
- Public key authentication

Public key giúp:

- Không cần lưu password
- Tăng độ an toàn

--------------------------------------------------------

3.3 Toàn vẹn dữ liệu

SFTP đảm bảo:

- Dữ liệu không bị thay đổi trên đường truyền
- Có cơ chế kiểm tra tính toàn vẹn

========================================================
4. TẠI SAO HỆ THỐNG NGÂN HÀNG PHẢI DÙNG SFTP?
========================================================

Vì file thường chứa:

- Thông tin khách hàng
- Số tài khoản
- Số tiền
- Giao dịch thanh toán

Đây là dữ liệu nhạy cảm.

Nếu truyền không mã hóa,
nguy cơ:

- Rò rỉ dữ liệu
- Bị tấn công MITM (man-in-the-middle)
- Vi phạm quy định bảo mật

========================================================
5. YÊU CẦU TUÂN THỦ VÀ KIỂM TOÁN
========================================================

Các tiêu chuẩn bảo mật như:

- PCI-DSS
- ISO 27001
- Quy định của Ngân hàng Nhà nước

đều yêu cầu:

Dữ liệu truyền qua mạng phải được mã hóa.

SFTP đáp ứng yêu cầu này.

========================================================
6. SFTP ỔN ĐỊNH CHO BATCH JOB
========================================================

Trong hệ thống:

Core Banking
     ↓
Batch Job
     ↓
Upload file qua SFTP
     ↓
Gateway thanh toán

SFTP phù hợp vì:

- Hoạt động tốt trong môi trường tự động
- Dễ script hóa
- Có thể retry khi lỗi
- Log rõ ràng

========================================================
7. SO SÁNH NHANH

FTP:
- Không mã hóa
- Không an toàn
- Dễ bị sniffing

SFTP:
- Mã hóa toàn bộ
- An toàn
- Phù hợp hệ thống tài chính

FTPS:
- FTP qua SSL
- Cũng an toàn
- Nhưng phức tạp hơn về firewall

========================================================
8. CƠ CHẾ HOẠT ĐỘNG
========================================================

Quy trình SFTP:

1) Thiết lập kết nối SSH
2) Xác thực user (password hoặc key)
3) Thiết lập kênh mã hóa
4) Truyền file
5) Đóng kết nối

Toàn bộ quá trình được mã hóa end-to-end.

========================================================
9. TẠI SAO KHÔNG DÙNG HTTP UPLOAD?
========================================================

HTTP upload có thể dùng HTTPS,
nhưng:

- Cần xây dựng API
- Phức tạp hơn cho batch file lớn
- Không tối ưu cho hệ thống legacy

SFTP:

- Đơn giản
- Chuẩn công nghiệp lâu đời
- Phù hợp trao đổi file hệ thống với hệ thống

========================================================
10. RỦI RO NẾU KHÔNG DÙNG SFTP
========================================================

- Lộ thông tin tài khoản
- Bị sửa file trên đường truyền
- Bị chiếm quyền truy cập
- Vi phạm chính sách bảo mật
- Bị phạt do không tuân thủ

========================================================
11. KẾT LUẬN BẢN CHẤT
========================================================

Cần dùng SFTP để đẩy file lên vì:

- Đảm bảo bảo mật (mã hóa)
- Đảm bảo xác thực an toàn
- Đảm bảo toàn vẹn dữ liệu
- Đáp ứng yêu cầu tuân thủ
- Phù hợp với môi trường ngân hàng và doanh nghiệp

SFTP là tiêu chuẩn truyền file an toàn
giữa các hệ thống quan trọng.

--- TẠI SAO ĐÃ CÓ DATABASE NHƯNG VẪN PHẢI ĐẨY FILE LÊN BẰNG SFTP?

GIẢI THÍCH CHI TIẾT:
TẠI SAO ĐÃ CÓ DATABASE NHƯNG VẪN PHẢI ĐẨY FILE LÊN BẰNG SFTP?

========================================================
1. CÂU HỎI BẢN CHẤT
========================================================

Nhiều người thắc mắc:

"Đã có database rồi,
tại sao không kết nối DB trực tiếp,
mà vẫn phải xuất file và đẩy bằng SFTP?"

Đây là câu hỏi liên quan đến:

- Kiến trúc hệ thống
- Bảo mật
- Ranh giới tổ chức
- Chuẩn giao tiếp liên ngân hàng

========================================================
2. DATABASE CHỈ HOẠT ĐỘNG TRONG PHẠM VI NỘI BỘ
========================================================

Database thường:

- Chỉ dùng trong nội bộ ngân hàng
- Không expose ra bên ngoài
- Không cho phép hệ thống ngoài kết nối trực tiếp

Nếu cho phép:

Ngân hàng khác hoặc Ngân hàng Nhà nước
kết nối trực tiếp vào DB nội bộ

→ Rủi ro bảo mật cực lớn.

========================================================
3. RANH GIỚI HỆ THỐNG (SYSTEM BOUNDARY)
========================================================

Mỗi tổ chức có:

- Network riêng
- Firewall riêng
- Chính sách bảo mật riêng

Việc mở port database ra ngoài:

- Rất nguy hiểm
- Khó kiểm soát
- Khó audit

Trong khi đó:

SFTP là cơ chế truyền file
qua gateway bảo mật.

========================================================
4. CHUẨN TRAO ĐỔI LIÊN NGÂN HÀNG LÀ FILE
========================================================

Trong hệ thống thanh toán quốc gia:

CITAD / IBPS thường quy định:

- Định dạng file chuẩn
- Cấu trúc file chuẩn
- Cách đặt tên file
- Cách phản hồi ACK/NACK

Tức là:

Chuẩn giao tiếp là file-based,
không phải database-based.

========================================================
5. TÁCH BIỆT TRÁCH NHIỆM HỆ THỐNG
========================================================

Core Banking:
- Ghi nhận giao dịch
- Lưu dữ liệu vào DB

Gateway thanh toán:
- Chỉ nhận file chuẩn
- Không truy cập DB nội bộ

Việc này giúp:

- Giảm phụ thuộc
- Tách biệt trách nhiệm
- Dễ kiểm soát

========================================================
6. DATABASE KHÔNG PHÙ HỢP CHO LIÊN KẾT GIỮA TỔ CHỨC
========================================================

Nếu 2 tổ chức dùng DB trực tiếp:

- Phải thống nhất version DB
- Phải thống nhất schema
- Phải cấp quyền truy cập chéo
- Phải tin tưởng nhau ở mức rất cao

Điều này gần như không khả thi
trong môi trường liên ngân hàng.

========================================================
7. FILE CÓ TÍNH ĐỘC LẬP CAO
========================================================

File có ưu điểm:

- Là snapshot tại một thời điểm
- Có thể lưu trữ để đối soát
- Có thể ký số
- Có thể kiểm tra checksum
- Có thể lưu làm bằng chứng pháp lý

Database transaction thì không dễ
tạo ra artifact độc lập như file.

========================================================
8. DỄ KIỂM SOÁT VÀ ĐỐI SOÁT
========================================================

Trong ngân hàng:

Đối soát rất quan trọng.

File giúp:

- So sánh file gửi và file nhận
- Lưu trữ file nhiều năm
- Audit lại khi cần

Nếu dùng DB trực tiếp:

Việc audit phức tạp hơn nhiều.

========================================================
9. GIẢM RỦI RO LAN TRUYỀN
========================================================

Nếu kết nối DB trực tiếp:

Lỗi ở hệ thống A
có thể ảnh hưởng trực tiếp hệ thống B.

File-based giúp:

- Tách rời hệ thống
- Nếu bên kia lỗi, file vẫn giữ nguyên
- Retry dễ dàng

========================================================
10. ĐẢM BẢO TÍNH BẤT BIẾN (IMMUTABILITY)
========================================================

File sau khi sinh ra:

- Không thay đổi
- Có thể hash
- Có thể ký số

Database thì dữ liệu có thể update.

Trong môi trường tài chính,
tính bất biến rất quan trọng.

========================================================
11. VÍ DỤ THỰC TẾ
========================================================

Luồng liên ngân hàng:

Core Banking (DB)
      ↓
Sinh file thanh toán
      ↓
Upload SFTP
      ↓
IBPS Gateway
      ↓
Ngân hàng Nhà nước

Core chỉ lưu DB nội bộ.
Giao tiếp ra ngoài bằng file.

========================================================
12. KẾT LUẬN BẢN CHẤT
========================================================

Dù có database,
vẫn phải đẩy file bằng SFTP vì:

- Không thể mở database nội bộ ra ngoài
- Chuẩn liên ngân hàng là file-based
- Tăng bảo mật
- Dễ audit và đối soát
- Giảm phụ thuộc giữa hệ thống
- Đảm bảo tính bất biến và pháp lý

Database dùng cho lưu trữ nội bộ.
File + SFTP dùng cho giao tiếp giữa tổ chức.

--- FTPClient VÀ CÁC HÀM remove / rename

GIẢI THÍCH CHI TIẾT:
FTPClient VÀ CÁC HÀM remove / rename

========================================================
1. FTPClient LÀ GÌ?
========================================================

FTPClient là một class trong thư viện:

org.apache.commons.net.ftp.FTPClient

Nó thuộc thư viện Apache Commons Net,
được dùng để:

- Kết nối đến FTP server
- Upload file
- Download file
- Xóa file
- Đổi tên file
- Quản lý thư mục từ xa

FTPClient hoạt động theo giao thức FTP.

========================================================
2. QUY TRÌNH LÀM VIỆC VỚI FTPClient
========================================================

Thông thường gồm các bước:

1) Tạo đối tượng FTPClient
2) connect(server, port)
3) login(username, password)
4) Thực hiện thao tác (upload, delete, rename...)
5) logout()
6) disconnect()

Ví dụ:

FTPClient client = new FTPClient();
client.connect("ftp.example.com", 21);
client.login("user", "pass");

========================================================
3. HÀM REMOVE (DELETE FILE)
========================================================

Phương thức dùng để xóa file trên FTP server:

boolean deleteFile(String pathname);

Ví dụ:

boolean result = client.deleteFile("/data/test.txt");

Ý nghĩa:

- pathname là đường dẫn file trên FTP server
- Trả về true nếu xóa thành công
- Trả về false nếu thất bại

--------------------------------------------------------

3.1 Khi nào dùng deleteFile?

- Sau khi xử lý file xong
- Dọn dẹp thư mục
- Xóa file lỗi
- Tránh xử lý trùng file

--------------------------------------------------------

3.2 Lưu ý quan trọng

- Phải có quyền ghi (write permission)
- File phải tồn tại
- Không thể xóa thư mục bằng deleteFile

========================================================
4. HÀM RENAME (ĐỔI TÊN FILE)
========================================================

Phương thức:

boolean rename(String from, String to);

Ví dụ:

boolean result = client.rename(
    "/data/test.txt",
    "/data/test_done.txt"
);

Ý nghĩa:

- from: tên file cũ
- to: tên file mới
- Trả về true nếu thành công

--------------------------------------------------------

4.1 Khi nào dùng rename?

- Đánh dấu file đã xử lý
- Đổi trạng thái file
- Di chuyển file sang thư mục khác
- Tránh đọc file chưa hoàn tất

========================================================
5. RENAME ĐỂ DI CHUYỂN FILE
========================================================

Trong FTP:

Đổi tên file sang path khác
thực chất là di chuyển file.

Ví dụ:

client.rename(
    "/input/file1.txt",
    "/processed/file1.txt"
);

Kết quả:

File được chuyển từ thư mục input
sang thư mục processed.

========================================================
6. VÌ SAO THƯỜNG RENAME THAY VÌ DELETE?
========================================================

Trong hệ thống batch:

Thay vì xóa file ngay,
người ta thường:

- Rename sang .done
- Move sang thư mục archive

Lý do:

- Dễ audit
- Có thể rollback
- Có bằng chứng xử lý

========================================================
7. CÁC LỖI THƯỜNG GẶP
========================================================

7.1 deleteFile trả về false

Nguyên nhân:

- File không tồn tại
- Không có quyền
- Sai đường dẫn
- FTP ở chế độ passive/active không phù hợp

--------------------------------------------------------

7.2 rename trả về false

Nguyên nhân:

- File nguồn không tồn tại
- Thư mục đích không tồn tại
- Không có quyền ghi
- Kết nối timeout

========================================================
8. KIỂM TRA RESPONSE CODE
========================================================

Sau mỗi thao tác,
nên kiểm tra:

client.getReplyCode();

Ví dụ:

if (!result) {
    System.out.println(client.getReplyString());
}

Điều này giúp debug chính xác lỗi từ FTP server.

========================================================
9. THỰC HÀNH AN TOÀN
========================================================

Nên:

- Kiểm tra file tồn tại trước khi rename/delete
- Bắt exception
- Đóng kết nối trong finally block
- Log đầy đủ kết quả

========================================================
10. KHÁC BIỆT GIỮA DELETE VÀ RENAME TRONG THỰC TẾ
========================================================

deleteFile:
- File bị xóa hoàn toàn
- Không thể khôi phục nếu không có backup

rename:
- Chỉ đổi tên hoặc di chuyển
- An toàn hơn
- Phù hợp quy trình batch

========================================================
11. LUỒNG XỬ LÝ THỰC TẾ
========================================================

Ví dụ hệ thống đọc file từ FTP:

1) List file trong thư mục
2) Download file
3) Xử lý dữ liệu
4) Nếu thành công → rename sang .done
5) Nếu lỗi → rename sang .error

Điều này giúp:

- Tránh xử lý lại file cũ
- Phân loại file theo trạng thái

========================================================
12. KẾT LUẬN BẢN CHẤT
========================================================

FTPClient là công cụ Java
giúp thao tác với FTP server.

deleteFile dùng để xóa file khỏi server.
rename dùng để đổi tên hoặc di chuyển file.

Trong hệ thống thực tế,
rename thường được dùng nhiều hơn delete
để đảm bảo audit và kiểm soát trạng thái xử lý.

--- TRONG JAVA, ĐỌC FILE .TXT VÀ .CSV CÓ GIỐNG NHAU KHÔNG?

GIẢI THÍCH CHI TIẾT:
TRONG JAVA, ĐỌC FILE .TXT VÀ .CSV CÓ GIỐNG NHAU KHÔNG?

========================================================
1. CÂU TRẢ LỜI NGẮN GỌN
========================================================

Về mặt kỹ thuật đọc file:

GIỐNG NHAU.

Về mặt xử lý nội dung:

KHÁC NHAU.

========================================================
2. JAVA ĐỌC FILE DỰA TRÊN CÁI GÌ?
========================================================

Java không quan tâm đến phần mở rộng file (.txt, .csv).

Java đọc file dựa trên:

- Đường dẫn
- Byte stream hoặc character stream
- Encoding

Ví dụ:

FileReader
BufferedReader
Files.readAllLines
InputStreamReader

Tất cả đều đọc nội dung dưới dạng:

Chuỗi ký tự (text).

========================================================
3. FILE .TXT LÀ GÌ?
========================================================

.txt chỉ là:

File văn bản thuần (plain text).

Nó có thể chứa:

- Văn bản tự do
- Dòng bất kỳ
- Không có cấu trúc cố định

Ví dụ nội dung:

Hello world
Java is good
Line 3

========================================================
4. FILE .CSV LÀ GÌ?
========================================================

.csv cũng là:

File văn bản thuần.

Nhưng có cấu trúc:

Comma Separated Values
(Dữ liệu phân cách bằng dấu phẩy)

Ví dụ:

id,name,age
1,An,25
2,Binh,30

CSV có cấu trúc dạng bảng.

========================================================
5. VÌ SAO NÓI GIỐNG NHAU?
========================================================

Vì khi đọc bằng Java:

BufferedReader reader = new BufferedReader(
    new FileReader("file.csv")
);

Hoặc:

new FileReader("file.txt")

Cơ chế đọc giống hệt nhau:

- Mở file
- Đọc từng dòng
- Trả về String

Java không tự động hiểu CSV.

========================================================
6. VÌ SAO NÓI KHÁC NHAU?
========================================================

Khác nhau ở bước xử lý nội dung.

6.1 Với file .txt

Bạn chỉ cần:

- Đọc từng dòng
- In ra
- Hoặc xử lý tùy ý

Không có cấu trúc bắt buộc.

--------------------------------------------------------

6.2 Với file .csv

Bạn phải:

- Split theo dấu phẩy
- Xử lý cột
- Bỏ header nếu có
- Xử lý dấu ngoặc kép
- Xử lý trường hợp có dấu phẩy trong dữ liệu

CSV phức tạp hơn.

========================================================
7. VÍ DỤ SO SÁNH

7.1 Đọc file .txt

while ((line = reader.readLine()) != null) {
    System.out.println(line);
}

Không cần parse gì thêm.

--------------------------------------------------------

7.2 Đọc file .csv

while ((line = reader.readLine()) != null) {
    String[] columns = line.split(",");
    System.out.println(columns[0]);
}

Phải tách cột.

========================================================
8. VẤN ĐỀ PHỨC TẠP CỦA CSV
========================================================

CSV thực tế có thể có:

"Nguyen, Van A",25,"HCM"

Nếu dùng split(",") đơn giản,
sẽ sai.

Do đó:

CSV thường nên dùng thư viện như:

- OpenCSV
- Apache Commons CSV

========================================================
9. VỀ BẢN CHẤT KỸ THUẬT
========================================================

Cả .txt và .csv đều là:

File text (character-based).

Java đọc bằng:

- InputStream (byte)
- Reader (character)

Không có sự khác biệt ở tầng IO.

Khác biệt nằm ở:

Cách interpret dữ liệu.

========================================================
10. ENCODING CŨNG QUAN TRỌNG
========================================================

Cả hai loại file đều cần chú ý:

- UTF-8
- UTF-16
- ISO-8859-1

Nếu encoding sai:

- Lỗi font
- Ký tự đặc biệt bị hỏng

Điều này áp dụng cho cả .txt và .csv.

========================================================
11. KHI NÀO NÊN COI CHÚNG KHÁC NHAU?
========================================================

Nếu mục tiêu là:

Chỉ đọc text → giống nhau.

Nếu mục tiêu là:

Xử lý dữ liệu dạng bảng → CSV cần parse logic riêng.

========================================================
12. KẾT LUẬN BẢN CHẤT
========================================================

Trong Java:

Việc đọc file .txt và .csv về mặt kỹ thuật IO là giống nhau.

Sự khác biệt nằm ở:

Cấu trúc dữ liệu bên trong.

.txt = văn bản tự do.
.csv = văn bản có cấu trúc dạng bảng.

Java không phân biệt theo đuôi file,
mà bạn phải tự xử lý nội dung theo mục đích sử dụng.

--- VIỆC ĐỌC FILE .TXT VÀ .CSV KHI DÙNG BUFFEREDREADER TRONG JAVA CÓ GÌ KHÁC NHAU KHÔNG?

GIẢI THÍCH CHI TIẾT:
VIỆC ĐỌC FILE .TXT VÀ .CSV KHI DÙNG BUFFEREDREADER TRONG JAVA
CÓ GÌ KHÁC NHAU KHÔNG?

========================================================
1. CÂU TRẢ LỜI NGẮN GỌN
========================================================

KHÔNG KHÁC NHAU về cơ chế đọc.

KHÁC NHAU ở cách xử lý nội dung sau khi đọc.

========================================================
2. BUFFEREDREADER LÀM GÌ?
========================================================

BufferedReader là lớp trong java.io
dùng để đọc file dạng text theo từng dòng.

Nó:

- Đọc dữ liệu dạng character
- Có buffer để tăng hiệu năng
- Thường dùng với readLine()

Ví dụ:

BufferedReader reader = new BufferedReader(
    new FileReader("file.txt")
);

========================================================
3. JAVA CÓ PHÂN BIỆT .TXT VÀ .CSV KHÔNG?
========================================================

KHÔNG.

Java không quan tâm phần mở rộng file.

Đối với JVM:

- file.txt
- file.csv
- file.data
- file.anything

đều chỉ là file chứa byte.

BufferedReader chỉ đọc:

Chuỗi ký tự (String).

========================================================
4. CƠ CHẾ ĐỌC HOÀN TOÀN GIỐNG NHAU
========================================================

Dù là .txt hay .csv:

while ((line = reader.readLine()) != null) {
    System.out.println(line);
}

Cơ chế:

1) Mở file
2) Đọc từng dòng
3) Trả về String
4) Gặp EOF thì dừng

Không có logic riêng cho CSV.

========================================================
5. SỰ KHÁC BIỆT NẰM Ở ĐÂU?
========================================================

Khác biệt không nằm ở BufferedReader.

Khác biệt nằm ở:

Cách bạn xử lý nội dung sau khi đọc.

--------------------------------------------------------

5.1 File .txt

Thường là:

- Văn bản tự do
- Không có cấu trúc cố định

Sau khi đọc:
Có thể in ra luôn hoặc xử lý đơn giản.

--------------------------------------------------------

5.2 File .csv

Có cấu trúc bảng:

cột1,cột2,cột3

Sau khi đọc mỗi dòng:
Phải tách cột.

Ví dụ:

String[] columns = line.split(",");

========================================================
6. VẤN ĐỀ PHỨC TẠP CỦA CSV
========================================================

CSV thực tế có thể chứa:

"Nguyen, Van A",25,"HCM"

Nếu dùng split(",") đơn giản,
kết quả sẽ sai.

Do đó:

CSV chuẩn cần xử lý:

- Dấu ngoặc kép
- Escape ký tự
- Dấu phẩy trong chuỗi

BufferedReader không xử lý những thứ này.
Nó chỉ đọc dòng.

========================================================
7. ENCODING ẢNH HƯỞNG CẢ HAI
========================================================

Cả .txt và .csv đều chịu ảnh hưởng của:

- UTF-8
- UTF-16
- ANSI

Nếu encoding sai:

- Ký tự tiếng Việt bị lỗi
- Dữ liệu bị hỏng

Điều này không phụ thuộc vào đuôi file.

========================================================
8. HIỆU NĂNG CÓ KHÁC NHAU KHÔNG?
========================================================

Không.

BufferedReader đọc dữ liệu theo:

- Kích thước buffer
- Encoding
- Kích thước file

Không liên quan đến việc file là .txt hay .csv.

========================================================
9. KẾT LUẬN BẢN CHẤT
========================================================

Khi dùng BufferedReader:

Việc đọc file .txt và .csv là hoàn toàn giống nhau
về mặt kỹ thuật IO.

BufferedReader:

- Không hiểu cấu trúc CSV
- Không phân biệt phần mở rộng file
- Chỉ đọc text theo dòng

Sự khác biệt chỉ xuất hiện
ở bước xử lý dữ liệu sau khi đọc.

.txt = thường xử lý trực tiếp.
.csv = phải parse theo cấu trúc cột.

--- ĐẶC ĐIỂM CỦA FILE .CSV LÀ GÌ? NÓ GIẢI QUYẾT VẤN ĐỀ GÌ?

GIẢI THÍCH CHI TIẾT:
ĐẶC ĐIỂM CỦA FILE .CSV LÀ GÌ? NÓ GIẢI QUYẾT VẤN ĐỀ GÌ?

========================================================
1. CSV LÀ GÌ?
========================================================

CSV là viết tắt của:

Comma-Separated Values
(Tạm dịch: Các giá trị được phân tách bởi dấu phẩy)

CSV là một định dạng file dạng text
được dùng để lưu trữ dữ liệu có cấu trúc dạng bảng.

Bản chất của CSV:

- Là file văn bản thuần (plain text)
- Mỗi dòng là một record (bản ghi)
- Các cột được phân tách bởi dấu phân cách (delimiter)
  thường là dấu phẩy (,)

========================================================
2. CẤU TRÚC CƠ BẢN CỦA FILE CSV
========================================================

Ví dụ:

id,name,age,city
1,Nguyen Van A,25,HCM
2,Tran Thi B,30,Hanoi

Cấu trúc:

- Dòng đầu tiên thường là header (tên cột)
- Mỗi dòng sau là một bản ghi dữ liệu
- Các giá trị ngăn cách bởi dấu phẩy

========================================================
3. ĐẶC ĐIỂM KỸ THUẬT CỦA FILE CSV
========================================================

3.1 Là file text thuần

- Có thể mở bằng Notepad
- Không chứa định dạng như font, màu sắc
- Không chứa công thức như Excel

3.2 Dữ liệu dạng bảng

- Tổ chức theo hàng và cột
- Mỗi dòng tương ứng một record
- Mỗi cột tương ứng một thuộc tính

3.3 Dễ đọc bằng máy

- Dễ parse bằng hầu hết ngôn ngữ lập trình
- Có thể đọc bằng BufferedReader
- Có thể xử lý bằng split() hoặc thư viện CSV

3.4 Nhẹ và đơn giản

- Không chứa metadata phức tạp
- Không chứa binary data
- Kích thước nhỏ hơn Excel (.xlsx)

3.5 Tính tương thích cao

- Mở được bằng Excel
- Mở được bằng Google Sheets
- Import được vào database
- Được hầu hết hệ thống hỗ trợ

========================================================
4. CSV GIẢI QUYẾT VẤN ĐỀ GÌ?
========================================================

4.1 Giải quyết vấn đề trao đổi dữ liệu giữa hệ thống

Ví dụ:

- Hệ thống A viết bằng Java
- Hệ thống B viết bằng .NET
- Hệ thống C là Database

CSV cho phép:

- Xuất dữ liệu từ A
- Gửi sang B
- B đọc và xử lý

Không phụ thuộc công nghệ.

--------------------------------------------------------

4.2 Giải quyết vấn đề lưu trữ dữ liệu dạng bảng đơn giản

Thay vì:

- Tạo database
- Tạo schema
- Cấu hình server

Chỉ cần:

- Xuất ra file CSV

Đơn giản và nhanh.

--------------------------------------------------------

4.3 Giải quyết vấn đề import/export dữ liệu

Ví dụ:

- Xuất danh sách khách hàng
- Xuất báo cáo giao dịch
- Import dữ liệu hàng loạt

CSV là chuẩn phổ biến cho import/export.

--------------------------------------------------------

4.4 Giải quyết vấn đề trung gian giữa Database và File

Nhiều hệ thống không kết nối trực tiếp DB:

Thay vào đó:

- Export dữ liệu DB ra CSV
- Gửi file qua SFTP
- Hệ thống khác đọc CSV và insert vào DB

CSV đóng vai trò:
Định dạng trung gian (intermediate format)

========================================================
5. ƯU ĐIỂM CỦA CSV
========================================================

1) Đơn giản
2) Nhẹ
3) Dễ đọc bằng máy
4) Dễ debug (mở lên xem được ngay)
5) Tương thích đa nền tảng
6) Không phụ thuộc vendor

========================================================
6. NHƯỢC ĐIỂM CỦA CSV
========================================================

1) Không có kiểu dữ liệu rõ ràng
   - 123 là số hay chuỗi?
   - true là boolean hay text?

2) Không hỗ trợ cấu trúc phức tạp
   - Không có nested object
   - Không có array lồng nhau

3) Không lưu được:
   - Công thức
   - Hình ảnh
   - Định dạng

4) Có thể lỗi khi:
   - Dữ liệu chứa dấu phẩy
   - Dữ liệu chứa xuống dòng
   - Không xử lý đúng dấu ngoặc kép

========================================================
7. SO SÁNH CSV VỚI EXCEL (.XLSX)
========================================================

CSV:
- Text thuần
- Nhẹ
- Dễ parse
- Không có formatting

Excel:
- File binary/zip
- Có format, style
- Có công thức
- Phức tạp hơn

CSV phù hợp cho:
Truyền dữ liệu.

Excel phù hợp cho:
Xem báo cáo.

========================================================
8. CSV PHÙ HỢP KHI NÀO?
========================================================

- Trao đổi dữ liệu giữa hệ thống
- Export/import số lượng lớn
- Batch processing
- Tích hợp qua SFTP
- Làm staging data

========================================================
9. BẢN CHẤT THẬT SỰ CỦA CSV
========================================================

CSV không phải là:

- Database
- File báo cáo đẹp
- Chuẩn dữ liệu phức tạp

CSV là:

Một định dạng text đơn giản
để biểu diễn dữ liệu dạng bảng
một cách nhẹ, dễ trao đổi,
và độc lập công nghệ.

========================================================
10. KẾT LUẬN

CSV là định dạng file text
dùng để lưu dữ liệu dạng bảng
với các giá trị phân tách bằng dấu phẩy.

Nó giải quyết vấn đề:

- Trao đổi dữ liệu giữa hệ thống
- Import/export dữ liệu đơn giản
- Làm trung gian tích hợp
- Lưu trữ dữ liệu bảng nhẹ và dễ xử lý

--- CÁCH XÓA 1 FILE KHI DÙNG java.io TRONG JAVA

GIẢI THÍCH CHI TIẾT:
CÁCH XÓA 1 FILE KHI DÙNG java.io TRONG JAVA

========================================================
1. TỔNG QUAN
========================================================

Trong Java, để xóa một file khi dùng java.io,
ta thường sử dụng lớp:

java.io.File

Lớp File cung cấp phương thức:

boolean delete()

để xóa file hoặc thư mục.

========================================================
2. CÁCH XÓA FILE CƠ BẢN
========================================================

Bước 1: Tạo đối tượng File
Bước 2: Gọi phương thức delete()

Ví dụ:

import java.io.File;

public class Main {
    public static void main(String[] args) {

        File file = new File("C:/data/test.txt");

        if (file.delete()) {
            System.out.println("Xóa file thành công");
        } else {
            System.out.println("Xóa file thất bại");
        }
    }
}

========================================================
3. PHƯƠNG THỨC delete() HOẠT ĐỘNG NHƯ THẾ NÀO?
========================================================

Khai báo:

public boolean delete()

Giá trị trả về:

- true  -> xóa thành công
- false -> xóa thất bại

delete() KHÔNG ném exception nếu thất bại.
Bạn phải kiểm tra giá trị trả về.

========================================================
4. CÁC TRƯỜNG HỢP XÓA THẤT BẠI
========================================================

delete() trả về false khi:

1) File không tồn tại
2) Không có quyền xóa (permission)
3) File đang bị mở bởi process khác
4) Là thư mục nhưng thư mục không rỗng

========================================================
5. KIỂM TRA TRƯỚC KHI XÓA
========================================================

Nên kiểm tra:

- file.exists()
- file.isFile()

Ví dụ:

File file = new File("C:/data/test.txt");

if (file.exists() && file.isFile()) {
    if (file.delete()) {
        System.out.println("Xóa thành công");
    } else {
        System.out.println("Xóa thất bại");
    }
} else {
    System.out.println("File không tồn tại");
}

========================================================
6. XÓA THƯ MỤC
========================================================

6.1 Xóa thư mục rỗng

File dir = new File("C:/data/myfolder");

dir.delete();

Chỉ thành công nếu thư mục rỗng.

--------------------------------------------------------

6.2 Xóa thư mục có chứa file (đệ quy)

Phải xóa toàn bộ file con trước.

Ví dụ:

public static void deleteDirectory(File dir) {

    if (dir.isDirectory()) {
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                deleteDirectory(file);
            }
        }
    }

    dir.delete();
}

========================================================
7. LƯU Ý QUAN TRỌNG
========================================================

7.1 Không có thùng rác (Recycle Bin)

File.delete() xóa trực tiếp.
Không thể khôi phục.

7.2 Không có cảnh báo

Java không hỏi xác nhận.
Bạn phải tự kiểm soát logic.

7.3 Không ném IOException

Khác với java.nio.file.Files.delete(),
File.delete() không ném exception.

========================================================
8. SO SÁNH VỚI java.nio.file (THAM KHẢO)
========================================================

java.io.File.delete():
- Trả boolean
- Không ném exception
- API cũ

java.nio.file.Files.delete():
- Ném IOException
- Có thể biết rõ nguyên nhân lỗi
- API mới (khuyến nghị dùng)

Ví dụ:

Files.delete(Paths.get("C:/data/test.txt"));

========================================================
9. CÁC TRƯỜNG HỢP THỰC TẾ HAY GẶP
========================================================

1) Xóa file sau khi upload SFTP thành công
2) Xóa file tạm sau khi xử lý xong
3) Xóa file log cũ
4) Xóa file batch sau khi import DB

========================================================
10. TÓM TẮT BẢN CHẤT

Để xóa file trong java.io:

- Dùng lớp java.io.File
- Gọi phương thức delete()
- Kiểm tra boolean trả về

Quan trọng:

delete() không đảm bảo thành công,
vì vậy luôn kiểm tra:

- File có tồn tại không
- Có quyền xóa không
- File có đang bị lock không

========================================================
11. KẾT LUẬN

Cách xóa file trong java.io rất đơn giản:

File file = new File("duong_dan");
file.delete();

Nhưng trong hệ thống thực tế,
cần kiểm tra kỹ điều kiện trước khi xóa
và xử lý trường hợp thất bại.

--- CÁCH LẤY TÊN FILE KHÔNG CHỨA ĐƯỜNG DẪN TRONG JAVA

GIẢI THÍCH CHI TIẾT:
CÁCH LẤY TÊN FILE KHÔNG CHỨA ĐƯỜNG DẪN TRONG JAVA

========================================================
1. YÊU CẦU BÀI TOÁN
========================================================

Giả sử ta có đường dẫn:

C:/data/upload/report_2024.csv

Ta chỉ muốn lấy:

report_2024.csv

Tức là:
Lấy phần tên file, không bao gồm đường dẫn.

========================================================
2. CÁCH CHUẨN NHẤT: DÙNG java.io.File
========================================================

Java cung cấp sẵn phương thức:

getName()

Ví dụ:

import java.io.File;

public class Main {
    public static void main(String[] args) {

        String path = "C:/data/upload/report_2024.csv";

        File file = new File(path);

        String fileName = file.getName();

        System.out.println(fileName);
    }
}

Kết quả:
report_2024.csv

--------------------------------------------------------

Giải thích:

new File(path)
-> tạo đối tượng đại diện cho file

file.getName()
-> trả về phần tên file cuối cùng trong đường dẫn

========================================================
3. CÁCH DÙNG java.nio.file (HIỆN ĐẠI HƠN)
========================================================

Dùng lớp Paths và Path:

import java.nio.file.Path;
import java.nio.file.Paths;

public class Main {
    public static void main(String[] args) {

        String pathStr = "C:/data/upload/report_2024.csv";

        Path path = Paths.get(pathStr);

        String fileName = path.getFileName().toString();

        System.out.println(fileName);
    }
}

Kết quả:
report_2024.csv

--------------------------------------------------------

Giải thích:

path.getFileName()
-> lấy phần cuối cùng của đường dẫn

========================================================
4. CÁCH DÙNG STRING (KHÔNG KHUYẾN NGHỊ)
========================================================

Có thể dùng substring + lastIndexOf

Ví dụ:

String path = "C:/data/upload/report_2024.csv";

int index = path.lastIndexOf("/");

String fileName = path.substring(index + 1);

System.out.println(fileName);

--------------------------------------------------------

Vấn đề:

- Windows dùng "\" thay vì "/"
- Không portable
- Dễ lỗi khi xử lý đa nền tảng

Vì vậy:
NÊN dùng File hoặc Path.

========================================================
5. XỬ LÝ CẢ WINDOWS VÀ LINUX
========================================================

Nếu bắt buộc dùng String:

int index1 = path.lastIndexOf("/");
int index2 = path.lastIndexOf("\\");

int index = Math.max(index1, index2);

String fileName = path.substring(index + 1);

Nhưng vẫn không nên dùng cách này
trong hệ thống lớn.

========================================================
6. LẤY TÊN FILE KHÔNG CÓ PHẦN MỞ RỘNG
========================================================

Ví dụ:

report_2024.csv
-> muốn lấy:
report_2024

Cách làm:

String fileName = file.getName();

int dotIndex = fileName.lastIndexOf(".");

String nameWithoutExtension =
    (dotIndex == -1) ? fileName
                     : fileName.substring(0, dotIndex);

========================================================
7. TÓM TẮT CÁCH NÊN DÙNG
========================================================

Cách đơn giản và an toàn nhất:

File file = new File(path);
String fileName = file.getName();

Hoặc:

Path path = Paths.get(pathStr);
String fileName = path.getFileName().toString();

========================================================
8. KẾT LUẬN

Để lấy tên file không chứa đường dẫn trong Java:

- Không nên tự xử lý bằng String
- Nên dùng:
  + java.io.File.getName()
  hoặc
  + java.nio.file.Path.getFileName()

Đây là cách:

- An toàn
- Chuẩn Java
- Hoạt động đa nền tảng
- Tránh lỗi khi đổi hệ điều hành

--- ĐIỆN DÙNG Ở GIA ĐÌNH LÀ ĐIỆN 1 CHIỀU HAY XOAY CHIỀU?

GIẢI THÍCH CHI TIẾT:
ĐIỆN DÙNG Ở GIA ĐÌNH LÀ ĐIỆN 1 CHIỀU HAY XOAY CHIỀU?

========================================================
1. CÂU TRẢ LỜI NGẮN GỌN
========================================================

Điện dùng trong gia đình là:

ĐIỆN XOAY CHIỀU (AC – Alternating Current)

KHÔNG phải điện một chiều (DC).

========================================================
2. ĐIỆN 1 CHIỀU (DC) LÀ GÌ?
========================================================

DC (Direct Current) là dòng điện:

- Chỉ chạy theo 1 hướng cố định
- Không đổi chiều theo thời gian

Ví dụ nguồn DC:

- Pin tiểu
- Pin điện thoại
- Ắc quy
- Pin mặt trời (đầu ra ban đầu là DC)

Đặc điểm:

- Cực dương (+)
- Cực âm (-)
- Dòng điện đi từ dương sang âm

========================================================
3. ĐIỆN XOAY CHIỀU (AC) LÀ GÌ?
========================================================

AC (Alternating Current) là dòng điện:

- Thay đổi chiều liên tục theo chu kỳ
- Điện áp thay đổi theo dạng hình sin

Ví dụ:

- Ở Việt Nam: 220V – 50Hz
- Nghĩa là:
  + Điện áp hiệu dụng 220V
  + Đảo chiều 50 lần mỗi giây

========================================================
4. TẠI SAO GIA ĐÌNH DÙNG ĐIỆN XOAY CHIỀU?
========================================================

Lý do chính:

1) Truyền tải xa hiệu quả hơn
2) Dễ tăng/giảm điện áp bằng máy biến áp
3) Tổn hao điện năng thấp hơn khi truyền xa

--------------------------------------------------------

4.1 Truyền tải điện xa

Điện được sản xuất tại nhà máy điện.
Sau đó:

- Tăng điện áp lên rất cao (110kV, 220kV, 500kV)
- Truyền đi xa
- Hạ áp xuống 220V để dùng trong nhà

Máy biến áp chỉ hoạt động với AC.

--------------------------------------------------------

4.2 Nếu dùng DC thì sao?

DC khó thay đổi điện áp (trước đây rất khó).
Vì vậy:

- Không thuận tiện cho truyền tải đại trà
- Không phổ biến trong điện dân dụng

========================================================
5. CÁC THIẾT BỊ GIA ĐÌNH DÙNG AC HAY DC?
========================================================

Ổ cắm trong nhà: AC 220V

Nhưng bên trong nhiều thiết bị lại dùng DC.

Ví dụ:

- TV
- Laptop
- Router wifi
- Điện thoại

Chúng có bộ nguồn (adapter):

AC 220V -> chuyển thành DC 5V, 12V, 19V,...

========================================================
6. VÍ DỤ THỰC TẾ
========================================================

Ổ điện trên tường:
-> AC 220V

Cục sạc điện thoại ghi:
Input: 100-240V ~ 50/60Hz  (AC)
Output: 5V --- 2A         (DC)

Dấu "~" là AC
Dấu "---" là DC

========================================================
7. TẠI SAO KHÔNG DÙNG DC LUÔN TRONG NHÀ?
========================================================

Lý do lịch sử và kỹ thuật:

- AC dễ tạo ra bằng máy phát điện
- AC dễ biến đổi điện áp
- Hạ tầng điện quốc gia thiết kế theo AC

Hiện nay có xu hướng:

- Hệ thống năng lượng mặt trời
- Hệ thống DC microgrid

Nhưng điện dân dụng tiêu chuẩn vẫn là AC.

========================================================
8. TÓM TẮT SO SÁNH

Điện gia đình:
- Là AC
- 220V
- 50Hz (ở Việt Nam)

Điện pin, ắc quy:
- Là DC

Thiết bị điện tử:
- Nhận AC
- Chuyển thành DC để sử dụng

========================================================
9. KẾT LUẬN

Điện dùng trong gia đình là:

ĐIỆN XOAY CHIỀU (AC)

Lý do:

- Dễ truyền tải xa
- Dễ biến đổi điện áp
- Phù hợp với hệ thống điện quốc gia
- Đã được chuẩn hóa toàn cầu

Tuy nhiên,
nhiều thiết bị trong nhà vẫn hoạt động bằng DC
sau khi đã được bộ nguồn chuyển đổi từ AC sang DC.

--- ĐIỆN TRUYỀN TẢI LÀ LOẠI ĐIỆN GÌ?

GIẢI THÍCH CHI TIẾT:
ĐIỆN TRUYỀN TẢI LÀ LOẠI ĐIỆN GÌ?

========================================================
1. CÂU TRẢ LỜI NGẮN GỌN
========================================================

Điện truyền tải trong hệ thống điện quốc gia hiện nay chủ yếu là:

ĐIỆN XOAY CHIỀU (AC – Alternating Current)

Ở mức điện áp rất cao.

========================================================
2. ĐIỆN TRUYỀN TẢI LÀ GÌ?
========================================================

Điện truyền tải là:

Dòng điện được truyền từ nhà máy điện
đến các khu vực tiêu thụ (thành phố, khu công nghiệp, hộ gia đình).

Quá trình gồm 3 giai đoạn:

1) Phát điện
2) Truyền tải điện
3) Phân phối điện

Điện truyền tải thuộc giai đoạn số 2.

========================================================
3. TẠI SAO PHẢI TRUYỀN TẢI ĐIỆN Ở ĐIỆN ÁP RẤT CAO?
========================================================

Công suất điện:

P = U x I

Trong đó:
P = công suất
U = điện áp
I = dòng điện

Để truyền cùng một công suất:

- Nếu tăng U (điện áp)
- Thì I (dòng điện) sẽ giảm

Tổn hao trên dây dẫn:

P_mất = I^2 x R

Nếu dòng điện nhỏ,
tổn hao sẽ giảm rất nhiều.

Vì vậy:

Muốn giảm hao phí -> tăng điện áp.

========================================================
4. MỨC ĐIỆN ÁP TRUYỀN TẢI

Ví dụ ở Việt Nam:

- 110 kV
- 220 kV
- 500 kV

Đây đều là điện xoay chiều 3 pha.

========================================================
5. LOẠI ĐIỆN ĐƯỢC DÙNG ĐỂ TRUYỀN TẢI
========================================================

5.1 Phổ biến nhất: AC (Điện xoay chiều)

Lý do:

- Dễ tăng/giảm điện áp bằng máy biến áp
- Công nghệ ổn định
- Hạ tầng toàn cầu sử dụng AC

Máy biến áp chỉ hoạt động với AC.

--------------------------------------------------------

5.2 Có dùng DC không?

Có.

Gọi là:

HVDC (High Voltage Direct Current)

Nhưng chỉ dùng trong một số trường hợp đặc biệt:

- Truyền tải rất xa (hàng nghìn km)
- Truyền tải dưới biển
- Kết nối hai hệ thống điện không đồng bộ

========================================================
6. SO SÁNH AC VÀ DC TRONG TRUYỀN TẢI

AC truyền tải:

Ưu điểm:
- Dễ biến đổi điện áp
- Hệ thống phổ biến
- Thiết bị rẻ hơn

Nhược điểm:
- Có tổn hao do cảm kháng và điện dung
- Khó kiểm soát pha khi truyền rất xa

--------------------------------------------------------

DC truyền tải (HVDC):

Ưu điểm:
- Tổn hao thấp hơn khi truyền rất xa
- Không có vấn đề về đồng bộ pha

Nhược điểm:
- Cần trạm chuyển đổi AC-DC rất đắt
- Công nghệ phức tạp

========================================================
7. TẠI SAO HỆ THỐNG ĐIỆN QUỐC GIA CHỦ YẾU DÙNG AC?
========================================================

Vì:

1) Lịch sử phát triển điện lực chọn AC
2) Máy biến áp chỉ hoạt động với AC
3) Hệ thống đồng bộ toàn quốc
4) Chi phí thấp hơn khi triển khai diện rộng

========================================================
8. DÒNG ĐIỆN TRUYỀN TẢI CÓ GIỐNG ĐIỆN GIA ĐÌNH KHÔNG?
========================================================

Giống ở bản chất: đều là AC

Khác ở:

- Điện áp:
  + Truyền tải: 110kV – 500kV
  + Gia đình: 220V

- Số pha:
  + Truyền tải: 3 pha
  + Gia đình: 1 pha (thường)

========================================================
9. QUY TRÌNH ĐIỆN TỪ NHÀ MÁY ĐẾN NHÀ DÂN

Bước 1:
Nhà máy phát điện tạo ra AC khoảng 6kV – 20kV

Bước 2:
Tăng áp lên 110kV – 500kV để truyền tải xa

Bước 3:
Đến trạm phân phối:
Hạ xuống 22kV – 35kV

Bước 4:
Hạ tiếp xuống 220V để cấp cho hộ gia đình

========================================================
10. KẾT LUẬN

Điện truyền tải chủ yếu là:

ĐIỆN XOAY CHIỀU (AC)
ở điện áp rất cao (110kV – 500kV).

Mục đích:

- Giảm tổn hao
- Truyền đi xa hiệu quả
- Phù hợp với hệ thống điện quốc gia

Trong một số trường hợp đặc biệt,
có thể dùng điện một chiều cao áp (HVDC),
nhưng không phải là hình thức phổ biến trong mạng điện quốc gia thông thường.

--- ĐẶC ĐIỂM CỦA CÁC LOẠI ĐIỆN TỪ KHI SẢN XUẤT ĐẾN KHI SỬ DỤNG TRONG GIA ĐÌNH

GIẢI THÍCH CHI TIẾT:
ĐẶC ĐIỂM CỦA CÁC LOẠI ĐIỆN TỪ KHI SẢN XUẤT ĐẾN KHI SỬ DỤNG TRONG GIA ĐÌNH

========================================================
I. TỔNG QUAN QUÁ TRÌNH ĐIỆN TỪ NHÀ MÁY ĐẾN NHÀ DÂN
========================================================

Quá trình điện năng đi từ nơi sản xuất đến gia đình gồm 4 giai đoạn chính:

1) Phát điện
2) Tăng áp và truyền tải
3) Hạ áp và phân phối
4) Sử dụng trong gia đình

Trong toàn bộ quá trình này, loại điện chủ yếu được sử dụng là:

ĐIỆN XOAY CHIỀU (AC)

Tuy nhiên, trong một số khâu đặc biệt có thể sử dụng điện một chiều (DC).

========================================================
II. GIAI ĐOẠN 1: PHÁT ĐIỆN (TẠI NHÀ MÁY)
========================================================

1. Loại điện được tạo ra

Các nhà máy điện (thủy điện, nhiệt điện, điện gió...) sử dụng máy phát điện xoay chiều.

Điện tạo ra là:

- Điện xoay chiều (AC)
- Thường là 3 pha
- Điện áp khoảng 6kV – 20kV
- Tần số: 50Hz (ở Việt Nam)

2. Đặc điểm

- Dòng điện có dạng sóng hình sin
- Ba pha lệch nhau 120 độ
- Công suất lớn
- Phù hợp truyền tải công nghiệp

3. Vì sao phát điện là AC?

- Máy phát điện quay tự nhiên tạo ra AC
- Dễ biến đổi điện áp bằng máy biến áp

========================================================
III. GIAI ĐOẠN 2: TĂNG ÁP VÀ TRUYỀN TẢI
========================================================

1. Loại điện

- Vẫn là điện xoay chiều (AC)
- 3 pha
- Điện áp rất cao:
  + 110kV
  + 220kV
  + 500kV

2. Đặc điểm

- Điện áp cao
- Dòng điện nhỏ (để giảm tổn hao)
- Truyền đi xa hàng trăm km

3. Mục đích tăng áp

Công suất P = U x I

Để truyền cùng công suất:
- Tăng điện áp (U)
- Giảm dòng điện (I)

Tổn hao trên dây:
P_mất = I^2 x R

Dòng càng nhỏ → tổn hao càng thấp

4. Một số trường hợp đặc biệt

Có thể dùng:
HVDC (High Voltage Direct Current)

- Điện một chiều cao áp
- Dùng cho truyền tải rất xa hoặc dưới biển

Nhưng không phổ biến bằng AC.

========================================================
IV. GIAI ĐOẠN 3: HẠ ÁP VÀ PHÂN PHỐI
========================================================

1. Loại điện

- Vẫn là AC
- 3 pha ở cấp trung thế (22kV – 35kV)
- Sau đó hạ xuống 220V/380V

2. Đặc điểm

- Từ trạm biến áp khu vực
- Hạ điện áp xuống mức an toàn để sử dụng

3. Điện cấp cho hộ gia đình

- 220V
- 1 pha
- 50Hz

========================================================
V. GIAI ĐOẠN 4: SỬ DỤNG TRONG GIA ĐÌNH
========================================================

1. Tại ổ cắm điện

- Điện xoay chiều (AC)
- 220V
- 50Hz
- 1 pha

2. Bên trong thiết bị gia đình

Nhiều thiết bị KHÔNG dùng AC trực tiếp.

Chúng chuyển đổi AC thành DC.

Ví dụ:

- Điện thoại
- Laptop
- Router wifi
- TV
- Máy tính

Bộ nguồn (adapter) thực hiện:

AC 220V → DC 5V / 12V / 19V

3. Thiết bị dùng trực tiếp AC

- Quạt điện
- Máy bơm
- Điều hòa
- Bếp điện
- Ấm siêu tốc

========================================================
VI. TỔNG HỢP CÁC LOẠI ĐIỆN TRONG TOÀN BỘ QUÁ TRÌNH
========================================================

1) Nhà máy điện:
   AC 3 pha, trung áp

2) Truyền tải:
   AC 3 pha, cao áp (110kV – 500kV)

3) Phân phối:
   AC 3 pha → hạ xuống 220V

4) Gia đình:
   AC 220V (1 pha)

5) Bên trong thiết bị điện tử:
   DC điện áp thấp

========================================================
VII. SO SÁNH AC VÀ DC TRONG TOÀN HỆ THỐNG
========================================================

AC (Điện xoay chiều):

Ưu điểm:
- Dễ biến đổi điện áp
- Dễ truyền tải xa
- Phù hợp máy phát điện
- Hệ thống điện quốc gia chuẩn hóa theo AC

Nhược điểm:
- Có tổn hao do cảm kháng
- Phức tạp khi truyền rất xa

--------------------------------------------------------

DC (Điện một chiều):

Ưu điểm:
- Phù hợp thiết bị điện tử
- Ổn định cho mạch điện tử
- Tổn hao thấp khi truyền cực xa (HVDC)

Nhược điểm:
- Khó biến đổi điện áp (cần thiết bị điện tử công suất)
- Không phổ biến trong điện dân dụng truyền tải

========================================================
VIII. BẢN CHẤT CỦA HỆ THỐNG ĐIỆN QUỐC GIA
========================================================

Toàn bộ hệ thống điện quốc gia được thiết kế dựa trên:

ĐIỆN XOAY CHIỀU (AC)

Từ khâu phát điện → truyền tải → phân phối → ổ cắm gia đình.

Điện một chiều chỉ xuất hiện:

- Trong pin, ắc quy
- Trong hệ thống năng lượng mặt trời
- Bên trong thiết bị điện tử

========================================================
IX. KẾT LUẬN

Từ khi sản xuất đến khi vào gia đình:

- Điện chủ yếu là AC
- Điện áp thay đổi qua các cấp
- Cao áp khi truyền tải
- Thấp áp khi sử dụng

Bên trong nhiều thiết bị gia đình:

- AC được chuyển thành DC
- Phù hợp cho mạch điện tử

Như vậy:

AC là xương sống của hệ thống điện quốc gia.
DC là dạng điện phục vụ thiết bị điện tử và nguồn lưu trữ.

--- 3 DÂY PHA + 1 DÂY TRUNG TÍNH → 380V BA PHA VÀ 220V MỘT PHA

GIẢI THÍCH CHI TIẾT:
3 DÂY PHA + 1 DÂY TRUNG TÍNH → 380V BA PHA VÀ 220V MỘT PHA

========================================================
I. KHÁI NIỆM HỆ THỐNG ĐIỆN 3 PHA
========================================================

Hệ thống điện 3 pha là hệ thống gồm:

- 3 dây pha: L1, L2, L3
- 1 dây trung tính: N

Tổng cộng: 4 dây

Đây là hệ thống điện phổ biến trong lưới điện phân phối hiện nay.

========================================================
II. 3 DÂY PHA LÀ GÌ?
========================================================

Ba dây pha là:

- Ba nguồn điện xoay chiều
- Có cùng biên độ điện áp
- Lệch pha nhau 120 độ

Hình dung đơn giản:

L1: sóng sin thứ nhất
L2: sóng sin lệch 120°
L3: sóng sin lệch 240°

Điện áp giữa mỗi pha và trung tính là:

220V (ở Việt Nam)

========================================================
III. DÂY TRUNG TÍNH (N) LÀ GÌ?
========================================================

Dây trung tính là:

- Điểm nối chung của 3 cuộn dây trong máy biến áp
- Thường được nối đất
- Làm mốc điện áp 0V

Nhiệm vụ:

- Hoàn thành mạch điện cho tải 1 pha
- Cân bằng dòng khi tải không đều giữa các pha

========================================================
IV. TẠI SAO CÓ 380V VÀ 220V?
========================================================

1. Điện áp giữa PHA và TRUNG TÍNH:

= 220V

2. Điện áp giữa 2 PHA với nhau:

= 380V

Vì:

380V ≈ 220V x √3

Do sự lệch pha 120 độ giữa các pha.

========================================================
V. 380V BA PHA DÙNG CHO GÌ?
========================================================

Dùng cho:

- Động cơ công suất lớn
- Máy móc công nghiệp
- Thang máy
- Hệ thống lạnh công nghiệp
- Máy bơm lớn

Ưu điểm của 3 pha:

1) Công suất lớn hơn
2) Dòng điện ổn định hơn
3) Động cơ chạy mượt hơn
4) Hiệu suất cao hơn

========================================================
VI. 220V MỘT PHA DÙNG CHO GÌ?
========================================================

Dùng cho:

- Hộ gia đình
- Thiết bị dân dụng
- Ổ cắm điện
- Đèn chiếu sáng
- Quạt, tivi, tủ lạnh

Cách lấy 220V:

Lấy 1 dây pha bất kỳ (L1 hoặc L2 hoặc L3)
kết hợp với dây trung tính (N).

Ví dụ:

L1 + N = 220V
L2 + N = 220V
L3 + N = 220V

========================================================
VII. TẠI SAO HỘ GIA ĐÌNH CHỈ DÙNG 1 PHA?
========================================================

Vì:

- Nhu cầu công suất không quá lớn
- Tiết kiệm chi phí dây dẫn
- Hệ thống đơn giản
- An toàn hơn

Mỗi nhà thường được cấp:

1 pha + 1 trung tính → 220V

Các hộ trong khu dân cư sẽ được phân bổ:

- Nhà A dùng pha L1
- Nhà B dùng pha L2
- Nhà C dùng pha L3

Để cân bằng tải toàn hệ thống.

========================================================
VIII. CẤU TRÚC TẠI TRẠM BIẾN ÁP KHU VỰC
========================================================

Từ trạm biến áp:

Cuộn thứ cấp được đấu hình sao (Y).

Điểm giữa của hình sao:

→ là dây trung tính (N)

Ba đầu còn lại:

→ là 3 dây pha (L1, L2, L3)

Từ đây tỏa đi khu dân cư.

========================================================
IX. TÓM TẮT MỐI QUAN HỆ ĐIỆN ÁP

Giữa pha và trung tính:
= 220V

Giữa hai pha bất kỳ:
= 380V

Công thức quan hệ:

U dây = U pha x √3

Ở Việt Nam:

220V x 1.732 ≈ 380V

========================================================
X. BẢN CHẤT VẬT LÝ

Ba pha lệch nhau 120 độ tạo ra:

- Trường điện quay
- Phù hợp cho động cơ 3 pha
- Tạo mô-men quay liên tục

Đó là lý do động cơ 3 pha:

- Chạy khỏe
- Không rung nhiều
- Không cần tụ khởi động

========================================================
XI. KẾT LUẬN

Hệ thống 3 dây pha + 1 dây trung tính cho phép:

- 380V giữa hai pha → dùng cho động cơ lớn
- 220V giữa pha và trung tính → dùng cho hộ gia đình

Nhờ cấu trúc này:

- Hệ thống điện linh hoạt
- Vừa phục vụ công nghiệp
- Vừa phục vụ dân dụng
- Tối ưu truyền tải và phân phối điện năng



