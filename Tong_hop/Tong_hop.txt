Phương thức Objects.isNull(date) có thể được sử dụng với bất kỳ loại đối tượng nào, trong khi date != null chỉ áp dụng cho biến tham chiếu.




JAVA--:

	Collection: stream, add, remove, clear, size, isEmpty, equals, contains. hasNext, next

	Array: stream, length, sort, asList, spliterator

	String: length, isEmpty, equals, contains, charAt, concat, toUpperCase, toLowerCase, replace, trim, startsWith, endsWith, valueOf, indexOf, lastIndexOf, split, substring

	Stream: map, filter, limit, skip, distinct, sorted. forEach, reduce, count, min, max, collect, allMatch, anyMatch, noneMatch, findAny, findFirst

	Optional: Optional.empty, Optional.of, Optional.ofNullable, isPresent, ifPresent, orElse, orElseGet, orElseThrow, map, filter, get









JAVASCRIPT--:

	Array:
		join, forEach, every, some, includes, length, indexOf, lastIndexOf, findIndex, at, find, findIndex, reduce.
		Dont mutate: filter, map, concat, slice.
		Mutate: splice, pop, shift, push, unshift, reverse, sort, fill, copyWithin. flat, flatMap. Array.isArray, Array.from, Array.of
		
	String:
		concat, slice, split, includes, indexOf, lastIndexOf, at, toLowerCase, toUpperCase, trim, trimStart, trimEnd
		charAt, valueOf, subString, toLocaleLowerCase, toLocaleUpperCase, repeat, replace, replaceAll
		search, match, matchAll, endsWith, startsWith, padStart, padEnd, substr, substring
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
JAVA---:

	Collection--JAVA: 							
												- Vì Array trong Java là immutate nên Collection được xem là giải pháp thay thế.
												- Trong java collection phải có key hoặc index thì mới có get hoặc set, set không có key hoặc index nên không có get hoặc set
												
												List<String> list = new ArrayList<>(List.of("apple", "banana", "orange"));
		- add(exclude Map): 					list.add("apple");
		addAll(exclude Map):									
												List<String> additionalFruits = List.of("grape", "watermelon", "kiwi");
												list.addAll(additionalFruits); // [apple, banana, orange, grape, watermelon, kiwi]. Cú pháp này chỉ nhận collection làm đối số
		- remove:								list.remove("banana");
		removeAll:								
												List<String> fruitsToRemove = List.of("banana", "orange");
												list.removeAll(fruitsToRemove);// [apple]
		removeIf(only List):					list.removeIf(fruit -> fruit.length() > 5); // [Apple]											
		- clear: 								list.clear(); // []
		- size: 								list.size(); // Size: 3
		- isEmpty: 								list.isEmpty(); // Is empty? false
		- equals: 								
												List<String> list2 = new ArrayList<>(List.of("apple", "banana", "orange"));
												boolean isEqual = list.equals(list2); // true. So sánh nếu có bất kỳ từ nào khác thì kết quả là false		
		- stream: 								
												List<String> fruits = new ArrayList<>(List.of("apple", "banana", "orange", "grape", "kiwi"));
												List<String> result = fruits.stream()
													.filter(fruit -> fruit.length() > 5)            // Lọc các phần tử có độ dài lớn hơn 5. [banana, orange]
													.map(String::toUpperCase)                       // Chuyển đổi thành chữ in hoa. [BANANA, ORANGE]
													.distinct()                                     // Loại bỏ các phần tử trùng lặp. [BANANA, ORANGE]
													.sorted()                                       // Sắp xếp các phần tử theo thứ tự từ điển. [BANANA, ORANGE]
													.peek(System.out::println)                      // Hiển thị mỗi phần tử (không ảnh hưởng đến stream). BANANA ORANGE
													.collect(Collectors.toList());                  // Chuyển đổi kết quả thành một danh sách. [BANANA, ORANGE]
		parallelStream(exclude Map):			list.parallelStream().map(String::toUpperCase).forEach(System.out::println); // Chuyển đổi các chuỗithành chữ in hoa. APPLE BANANA ORANGE		
		- contains: 							list.contains("apple"); // true
		containsAll:							
												List<String> fruitsToCheck = List.of("banana", "orange");
												boolean containsAll = list.containsAll(fruitsToCheck); // containsAll để kiểm tra xem list có chứa tất cả các phần tử của fruitsToCheck không. true
		- next, hasNext:      					
												Iterator<String> iterator = list.iterator();
												while (iterator.hasNext()) {
													String element = iterator.next();
													System.out.println(element); // apple banana orange
												}
		retainAll:								
												List<String> fruitsToRetain = List.of("banana", "orange");
												list.retainAll(fruitsToRetain); // retainAll để giữ lại chỉ các phần tử có trong cả hai collections. [banana, orange]
		iterator:								
												Iterator<String> iterator = list.iterator();
												while (iterator.hasNext()) {
													String element = iterator.next();
													// Thực hiện các thao tác với phần tử, ví dụ in ra màn hình
													System.out.println(element); // apple banana orange
												}
		toArray:								
												String[] array = list.toArray(new String[0]); // Chuyển đổi List thành mảng
												for (String element : array) {
													System.out.println(element); // apple banana orange
												}
		spliterator:							
												Spliterator<String> spliterator = list.spliterator(); // chia nhỏ một tập dữ liệu thành các phần nhỏ có thể được xử lý độc lập
																									// thường được sử dụng trong việc xử lý song song hoặc trong các tác vụ đòi hỏi hiệu suất cao
												spliterator.forEachRemaining(element -> System.out.println(element)); // apple banana orange
		hashCode:								
												list1.hashCode(); // 918045048
												List<String> list2 = new ArrayList<>(List.of("apple", "banana", "orange"));
												list2.hashCode() // 918045048
												
	ArrayList, LinkedList, HashSet, HashMap, TreeMap--JAVA:					List<String> additionalFruits = List.of("Apple", "Banana", "Orange");
		for-each:			
																			for (String fruit : additionalFruits) {
																				// Thực hiện thao tác với fruit
																			}													
		
	List--JAVA:				
				
				- Một list có thể chứa giá trị null phía trong
				- Một danh sách được coi là rỗng nếu nó không chứa bất kỳ phần tử nào. Nếu danh sách chứa một hoặc nhiều phần tử, kể cả khi một trong số đó là null, thì danh sách đó không được coi là rỗng.
				- List: Các phần tử trong List interface được sắp xếp có thứ tự và có thể có giá trị giống nhau.
				- LinkedList: Là 1 cấu trúc dữ liệu lưu trữ các phần tử dưới dạng danh sách. Các phần tử trong LinkedList được sắp xếp có thứ
							tự và có thể có giá trị giống nhau. là một lớp kế thừa lớp AbstractSequentialList và triển khai của List,
							Queue Interface trong Collections Framework
					Singly Linked List:	Trong Singly Linked List, mỗi node trong danh sách này được lưu trữ dữ liệu của node và con trỏ trỏ
										tới node tiếp theo trong danh sách
					Doubly Linked List: Trong Double Linked List, có hai tham chiếu, đến node tiếp theo và đến node trước đó.										
				- ArrayList: Là kiểu danh sách sử dụng cấu trúc mảng để lưu trữ phần tử. Thứ tự các phần tử dựa theo thứ tự lúc thêm vào và
						   giá trị của các phần tử này có thể trùng nhau.
						   Được sử dụng như một mảng động để lưu trữ các phần tử. Là một lớp kế thừa từ AbtractList và implements List
						   interface trong collections framework
				- AbstractList: kế thừa từ AbstractCollection và implements hầu hết List interface
				- List khi chuyển sang Javascript sẽ là một Array.
				
				List<String> additionalFruits = List.of("Apple", "Banana", "Orange");
				
		Khởi tạo:			
							List<String> list1 = new ArrayList<>();
							list1.add("Apple");
							list1.add("Banana");
							
							List<String> list2 = Arrays.asList("Apple", "Banana", "Orange");
							
							List<String> list3 = List.of("Apple", "Banana", "Orange");
							
							List<String> list4 = Lists.newArrayList("Apple", "Banana", "Orange");
							
							List<String> list5 = new ArrayList<>(Arrays.asList("Apple", "Banana", "Orange"));
							
							List<String> list6 = new LinkedList<>();
							list6.add("Apple");
							list6.add("Banana");
							
							List<String> list7 = new CopyOnWriteArrayList<>();
							list7.add("Apple");
							list7.add("Banana");
							
							List<String> list8 = new ArrayList<>(List.of("Apple", "Banana", "Orange"));
							
							List<String> emptyList = Collections.emptyList();
		- add:				additionalFruits.add("Apple"); [Apple, Banana, Orange, Apple]
		addAll:				
							List<String> additionalFruits = List.of("Mango", "Strawberry");
							fruits.addAll(additionalFruits); // Thêm tất cả phần tử từ một collection. [Apple, Banana, Orange, Mango, Strawberry]
		- remove:
							List<String> fruits = new ArrayList<>();
							fruits.add("Apple");
							fruits.add("Banana");
							fruits.add("Orange");
							fruits.remove("Banana"); // [Apple, Orange]
		removeAll:			fruits.removeAll(fruitsToRemove); // Loại bỏ tất cả phần tử có trong một collection. []
		- get:				String retrievedFruit = additionalFruits.get(1); // Lấy phần tử tại index 1. Banana
		- set:				additionalFruits.set(1, "Mango"); // Sử dụng phương thức set để thay đổi giá trị tại index 1. [Apple, Mango, Orange]
		- indexOf:			int indexOfBanana = additionalFruits.indexOf("Banana"); // 1
		- lastIndexOf:		
							List<String> additionalFruits = List.of("Apple", "Banana", "Orange", "Banana");
							int lastIndexOfBanana = additionalFruits.lastIndexOf("Banana"); // Lấy index của phần tử "Banana" cuối cùng trong danh sách. 3
		toArray:			
							String[] array = additionalFruits.toArray(new String[0]); // Chuyển đổi danh sách thành mảng
							System.out.print("Array: ");
							for (String fruit : array) {
								System.out.print(fruit + " "); // Apple Banana Orange
							}
		subList:			List<String> subListOfFruits = additionalFruits.subList(1, 2); // Lấy danh sách con từ index 1 đến index 2
																					       // (không bao gồm index 2). [Banana]
		- sort:				Collections.sort(additionalFruits); // Sắp xếp danh sách theo thứ tự tăng dần. [Apple, Banana, Orange]
		listIterator:		
							ListIterator<String> iterator = additionalFruits.listIterator();
							System.out.println("Iterating forward:");
							while (iterator.hasNext()) {
								System.out.println(iterator.next()); // apple banana orange
							}
							
							ListIterator<String> iterator = additionalFruits.listIterator(1);
							System.out.println("Iterating forward from index 1:");
							while (iterator.hasNext()) {
								System.out.println(iterator.next()); // banana orange
							}
		
		

	Set--JAVA:				
							Set: Các phần tử trong Set là duy nhất, không chứa các phần tử chùng lặp. Là một dạng riêng của Set interface, trong đó các giá trị của các phần tử mặc định được sắp xếp tăng dần.
							AbstractSet: extends AbstractCollection và implements hầu hết Set interface
							HashSet: Extends AbstractSet để sử dụng với bảng băm.
							TreeSet: Implements một tập hợp được lưu trữ bởi tree. Extends AbstractSet
							Set khi chuyển sang Javascript sẽ là một Array.
							
							Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
		Khởi tạo:			
							Set<String> set1 = new HashSet<>();
							set1.add("Apple");
							set1.add("Banana");
							
							Set<String> set2 = new LinkedHashSet<>();
							set2.add("Apple");
							set2.add("Banana");
							
							Set<String> set3 = new TreeSet<>();
							set3.add("Apple");
							set3.add("Banana");
							
							Set<String> set4 = new HashSet<>(Arrays.asList("Apple", "Banana", "Orange"));
							
							Set<String> set5 = Set.of("Apple", "Banana", "Orange");
							
							Set<String> set6 = Sets.newHashSet("Apple", "Banana", "Orange");
							
							Set<String> set8 = new CopyOnWriteArraySet<>();
							set8.add("Apple");
							set8.add("Banana");
		- add:				set.add("Apple");
		addAll:				
							Set<String> additionalSet = new HashSet<>(Arrays.asList("B", "C", "D", "E"));
							set.addAll(additionalSet); // Sử dụng phương thức addAll để thêm tất cả các phần tử từ additionalSet vào set. [A, B, C, D, E]
							
							Set<String> set = new HashSet<>();
							List<String> fruits = new ArrayList<>();
							fruits.add("kiwi");
							fruits.add("grape");
							set.addAll(fruits);
		- remove:				
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							set.add("orange");
							set.remove("banana");
							System.out.println(set); // Output: [apple, orange]
		removeAll:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							set.add("orange");
							List<String> fruitsToRemove = new ArrayList<>();
							fruitsToRemove.add("banana");
							fruitsToRemove.add("orange");
							set.removeAll(fruitsToRemove);
							System.out.println(set); // Output: [apple]
		- clear:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							set.add("orange");
							set.clear();
							System.out.println(set); // Output: []
		- contains:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							System.out.println(set.contains("banana")); // Output: true
							System.out.println(set.contains("grape")); // Output: false
		containsAll:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							List<String> fruitsToCheck = new ArrayList<>();
							fruitsToCheck.add("apple");
							fruitsToCheck.add("banana");
							System.out.println(set.containsAll(fruitsToCheck)); // Output: true
		- isEmpty:
							Set<String> set = new HashSet<>();
							System.out.println(set.isEmpty()); // Output: true
							set.add("apple");
							System.out.println(set.isEmpty()); // Output: false
		- size:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							System.out.println(set.size()); // Output: 2
		iterator:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							Iterator<String> iterator = set.iterator();
							while(iterator.hasNext()) {
								System.out.println(iterator.next()); // apple banana
							}
		toArray:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							Object[] array = set.toArray();
							for(Object obj : array) {
								System.out.println(obj); // apple banana
							}
		retainAll:
							Set<String> set = new HashSet<>();
							set.add("apple");
							set.add("banana");
							set.add("orange");
							List<String> fruitsToRetain = new ArrayList<>();
							fruitsToRetain.add("banana");
							fruitsToRetain.add("orange");
							set.retainAll(fruitsToRetain);
							System.out.println(set); // Output: [banana, orange]

	Map--JAVA:				
							Map: Lưu trữ các cặp key/value, key của các phần tử này là duy nhất. SortedMap: Là một dạng riêng của Map interface, trong đó key được sắp xếp theo thứ tự tăng dần.
							HashMap: Extends AbstractMap để sử dụng bảng băm. HashMap là một phần trong java collections. Nó cung cấp triển khai cơ bản của Map interface. Được sử dụng để lưu trữ dữ
									 liệu theo cặp key-value. Để truy cập một giá trị, ta phải biết key của nó.
							TreeMap: Extends AbstractMap để sử dụng tree. TreeMap được sử dụng để triển khai Map interface và NavigableMap. TreeMap sắp xếp các phần tử theo thứ tự tự nhiên dựa vào key
							         hoặc bởi Comparator được cung cấp tại thời điểm map được tạo, tùy vào constructor nào được sử dụng
							WeakHashMap: Extends AbstractMap để sử dụng bảng băm với các khóa yếu.
							LinkedHashMap: Extends HashMap, cho phép lặp lại thứ tự chèn. LinkedHashMap cũng tương tự HashMap nhưng nó được bổ sung tính năng là duy trì thứ tự chèn vào map. HashMap có
							               lợi thế là chèn, tìm kiếm và xóa nhanh chóng nhưng nó không bao giờ duy trì thứ tự chèn. Khi muốn duy trì thứ tự chèn ta có thể sử dụng LinkedHashMap
							IdentityHashMap: Extends AbstractMap
							Map.Entry interface: Entry là một interface con của Map. Vì vậy, chúng ta có thể truy cập nó bằng tên Map.Entry. Nó cung cấp các phương thức để truy xuất key và value
							Map từ Java khi chuyển qua Javascript sẽ ở dạng object.
							
							Map<String, Integer> map = new HashMap<>();
							map.put("A", 1);
							map.put("B", 2);
							map.put("C", 3);
		Khởi tạo:
		
							- keySet và entrySet sẽ hoàn lại 1 Set
							- values sẽ hoàn lại 1 Collection
							- Trong Java, "entry" thường được sử dụng để đề cập đến một cặp khóa-giá trị trong một cấu trúc dữ liệu như một Map. Một "entry" trong Java thường đại diện cho một phần tử trong một Map, nơi mỗi
							phần tử được lưu trữ dưới dạng một cặp khóa-giá trị.
		
							Map<String, Integer> map1 = new HashMap<>();
							
							Map<String, Integer> map2 = Map.of("apple", 10, "banana", 20);
							
							Map<String, Integer> map3 = new HashMap<>() {{
								put("apple", 10);
								put("banana", 20);
							}};
							
							Map<String, Integer> map4 = new HashMap<>();
							map4.putAll(Map.of("apple", 10, "banana", 20));
							
							Map<String, Integer> map5 = new HashMap<>();
							map5.computeIfAbsent("apple", key -> 10);
							map5.computeIfAbsent("banana", key -> 20);
							
							Map<String, Integer> map6 = new HashMap<>();
							map6.computeIfPresent("apple", (key, value) -> value + 10);
							map6.computeIfPresent("banana", (key, value) -> value + 20);
							
							Map<String, Integer> map7 = new HashMap<>();
							map7.merge("apple", 10, Integer::sum);
							map7.merge("banana", 20, Integer::sum);
							
							Map<String, Integer> map8 = new HashMap<>();
							map8.putIfAbsent("apple", 10);
							map8.putIfAbsent("banana", 20);
							
							Map<String, Integer> map9 = new HashMap<>();
							map9.put("A", 1);
							map9.put("B", 2);
							map9.put("C", 3);
							
							Map<Integer, String> map = new LinkedHashMap<>();
							map.put(5, "Java");
							map.put(1, "HTML/CSS");
							map.put(7, "Python");
							map.put(4, "C/C++");

							Map<Integer, String> map = new TreeMap<Integer, String>(new Comparator<Integer>() {
								@Override
								public int compare(Integer o1, Integer o2) {
									return o2.compareTo(o1);
								}
							});
							map.put(5, "Ford");
							map.put(1, "Suzuki");
							map.put(7, "Mercedes");
							map.put(4, "Mazda");
		- put:				
							map.put("D", 4);
							for (Map.Entry<String, Integer> entry : map.entrySet()) {
								System.out.println(entry.getKey() + ": " + entry.getValue()); // 1 2 3 4
							}
		putAll:				
							Map<String, Integer> anotherMap = new HashMap<>();
							anotherMap.put("D", 4);
							anotherMap.put("E", 5);
							map.putAll(anotherMap); // Sử dụng phương thức putAll để thêm tất cả các cặp key-value từ anotherMap vào map. 1 2 3 4 5
		- get:				Integer valueB = map.get("B"); // Sử dụng phương thức get để lấy giá trị tương ứng với key "B". 2
		- remove:
							Map<String, Integer> map = new HashMap<>();
							map.put("apple", 10);
							map.put("banana", 20);
							map.remove("apple");
							System.out.println(map); // Output: {banana=20}
		- isEmpty:
							Map<String, Integer> map = new HashMap<>();
							System.out.println(map.isEmpty()); // Output: true
		- size:
							Map<String, Integer> map = new HashMap<>();
							map.put("apple", 10);
							map.put("banana", 20);
							System.out.println(map.size()); // Output: 2
		- clear:
							Map<String, Integer> map = new HashMap<>();
							map.put("apple", 10);
							map.put("banana", 20);
							map.clear();
							System.out.println(map); // Output: {}
		- containsKey:		
							boolean containsKeyB = map.containsKey("B"); // Kiểm tra xem key "B" có tồn tại trong map hay không. true
							boolean containsKeyD = map.containsKey("D"); // Kiểm tra xem key "D" có tồn tại trong map hay không. false
		- containsValue:		
							boolean containsValue2 = map.containsValue(2); // Kiểm tra xem giá trị 2 có tồn tại trong map hay không. true
							boolean containsValue4 = map.containsValue(4); // Kiểm tra xem giá trị 4 có tồn tại trong map hay không. false
		- keySet:				
							Set<String> keySet = map.keySet(); // Sử dụng phương thức keySet để lấy tập hợp chứa tất cả các key
							for (String key : keySet) {
								System.out.println(key); // A B C
							}
		- values:				
							Collection<Integer> values = map.values(); // Sử dụng phương thức values để lấy Collection chứa tất cả các giá trị
							for (Integer value : values) {
								System.out.println(value); // 1 2 3
							}
		- entrySet:			
							Set<Entry<String, Integer>> entrySet = map.entrySet(); // Sử dụng phương thức entrySet để lấy Set chứa tất cả các cặp key-value
							for (Entry<String, Integer> entry : entrySet) {
								System.out.println(entry.getKey() + ": " + entry.getValue()); // A: 1. B: 2. C: 3 
							}
							
							Map<Integer, String> map = new HashMap<>();
							map.put(5, "Anna");
							map.put(1, "John");
							map.put(7, "Chris");
							map.put(4, "Ryan");							
							for(Map.Entry<Integer, String> entry : map.entrySet()){ //Sử dụng Map.Entry
								System.out.println(entry.getKey() + " - " +entry.getValue());
							}
		Note:
							- Vấn đề là khi bạn thêm listResult2 vào listResult1, thì thực chất bạn đang thêm một tham chiếu đến đối tượng listResult2 vào listResult1. Vì vậy, tất cả các phần tử trong listResult1 sẽ cùng trỏ đến
							cùng một đối tượng listResult2.
							- Khi bạn gọi phương thức clear() trên listResult2, nó sẽ xóa tất cả các cặp key-value trong đối tượng listResult2. Do listResult1 chỉ chứa các tham chiếu đến đối tượng listResult2, nên khi phương thức
							clear() được gọi, tất cả các phần tử trong listResult1 cũng sẽ thấy sự thay đổi và chứa các giá trị rỗng.
							- serviceLifecycle thực chất là 1 đối tượng của service
							
							@Override
							public List<Map<String, Object>> getAllProjectListViewWithEmpId(ServiceLifecycle serviceLifecycle, String empId) {
									List<Object[]> listResult = new ArrayList<>();
									List<Map<String, Object>> listResult1 = new ArrayList<>();
									Map<String, Object> listResult2 = new HashMap<>();
									listResult = this.store.getAllProjectListViewWithEmpId();
									for (Object[] object : listResult) {
										listResult2.put("Project Name", object[0]);
										listResult2.put("Task Count", object[1]);
										listResult2.put("Finished Count", object[2]);
										listResult2.put("Finished (%)", object[3]);
										listResult2.put("Testing Count", object[4]);
										listResult2.put("Testing (%)", object[5]);
										listResult2.put("Remain Count", object[6]);
										listResult2.put("Remain (%)", object[7]);
										listResult2.put("Delayed Count", object[8]);
										listResult2.put("Delayed (%)", object[9]);
										listResult1.add(listResult2);
										listResult2.clear();
									}
									return listResult1;
							}
							
							- Trong mỗi vòng lặp for, một đối tượng listResult2 mới được tạo và các giá trị được thêm vào đối tượng này. Sau đó, đối tượng listResult2 được thêm vào listResult1. Do đó, không có sự chia sẻ tham
							chiếu giữa các đối tượng listResult2 được tạo trong mỗi vòng lặp.
							- Mỗi phần tử trong listResult1 đều chứa một đối tượng listResult2 riêng biệt, chứa các giá trị khác nhau tùy thuộc vào vòng lặp hiện tại. Điều này đảm bảo không có mất tham chiếu và mỗi phần tử trong
							listResult1 đều giữ giá trị của nó.
							- Trong mỗi vòng lặp, một đối tượng listResult2 mới được tạo bằng cách sử dụng constructor new HashMap<>(). Điều này đảm bảo mỗi đối tượng listResult2 trong từng vòng lặp đều là một đối tượng riêng
							biệt, không chia sẻ tham chiếu với nhau.
							Sau khi kết thúc vòng lặp for, listResult1 vẫn giữ giá trị của các phần tử được thêm vào từ các đối tượng listResult2 trong mỗi vòng lặp. Mất tham chiếu của biến listResult2 không ảnh hưởng đến giá
							trị của listResult1.
							
							listResult = this.store.getAllProjectListViewWithEmpId();
							for (Object[] object : listResult) {
								Map<String, Object> listResult2 = new HashMap<>();
								listResult2.put("Project Name", object[0]);
								listResult2.put("Task Count", object[1]);
								listResult2.put("Finished Count", object[2]);
								listResult2.put("Finished (%)", object[3]);
								listResult2.put("Testing Count", object[4]);
								listResult2.put("Testing (%)", object[5]);
								listResult2.put("Remain Count", object[6]);
								listResult2.put("Remain (%)", object[7]);
								listResult2.put("Delayed Count", object[8]);
								listResult2.put("Delayed (%)", object[9]);
								listResult1.add(listResult2);
							}
							return listResult1;
	LinkedList--JAVA:
							The LinkedList class is a collection which can contain many objects of the same type, just like the ArrayList.
							The LinkedList class has all of the same methods as the ArrayList class because they both implement the List interface. This means that you can add items, change items, remove items and clear the list
							in the same way.
							However, while the ArrayList class and the LinkedList class can be used in the same way, they are built very differently.
		addFirst():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");								
								// Use addFirst() to add the item to the beginning
								cars.addFirst("Mazda");
								System.out.println(cars); // [Mazda, Volvo, BMW, Ford]
							  }
							}
		addLast():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");							
								// Use addLast() to add the item to the end
								cars.addLast("Mazda");
								System.out.println(cars); // [Volvo, BMW, Ford, Mazda]
							  }
							}
		removeFirst():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");
								cars.add("Mazda");
								
								// Use removeFirst() remove the first item from the list
								cars.removeFirst();
								System.out.println(cars); [BMW, Ford, Mazda]
							  }
							}
		removeLast():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");
								cars.add("Mazda");							
								// Use removeLast() remove the last item from the list
								cars.removeLast();
								System.out.println(cars); // [Volvo, BMW, Ford]
							  }
							}
		getFirst():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");
								cars.add("Mazda");						
								// Use getFirst() to display the first item in the list
								System.out.println(cars.getFirst()); // Volvo
							  }
							}
		getLast():
							import java.util.LinkedList;
							public class Main {
							  public static void main(String[] args) {
								LinkedList<String> cars = new LinkedList<String>();
								cars.add("Volvo");
								cars.add("BMW");
								cars.add("Ford");
								cars.add("Mazda");
								
								// Use getLast() to display the last item in the list
								System.out.println(cars.getLast()); // Mazda
							  }
							}							
	Array--JAVA:			
							Immutable
							
							String[] names = {"Alice", "Bob", "Charlie", "David", "Eva"};
		- stream:			Arrays.stream(names).forEach(System.out::println); // Alice Bob Charlie David Eva
		- length:			names.length; // 5
		- sort:				Arrays.sort(names); // [Alice, Bob, Charlie, David, Eva]
		- asList:			List<String> nameList = Arrays.asList(names);
							System.out.println("\nList from array: " + nameList); // List from array: [Alice, Bob, Charlie, David, Eva]
		spliterator:		Spliterator<String> spliterator = Arrays.spliterator(names);
							System.out.println("\nUsing spliterator:");
							spliterator.forEachRemaining(System.out::println); // Alice Bob Charlie David Eva\
		- for-each:			for (String name : names) {
								// Thực hiện thao tác với num
							}

	String--JAVA:			String str1 = "Hello";
							String str2 = "World";
		- length:			int length = str1.length(); // 5
		- isEmpty:			str1.isEmpty(); // false
		- equals:			str1.equals(str2); // false
		- contains:			str1.contains("World"); // false
		- charAt:			str1.charAt(2); // l
		- concat:			str1.concat(" ").concat(str2); // Hello World
		- toUpperCase:		str1.toUpperCase(); // HELLO
		- toLowerCase:		str2.toLowerCase(); // world
		- replace:			str1.replace("l", "X"); // HeXXo
		- trim:				
							String trimmedStr1 = "   " + str1 + "   ";
							String trimmedStr2 = trimmedStr1.trim(); // Hello
		- startsWith:		str1.startsWith("Hello"); // true
		- endsWith:			str2.endsWith("World"); // true
		- valueOf:			
							int number = 123;
							String numberStr2 = String.valueOf(number); // Chuyển đối một giá trị sang chuỗi
		- indexOf:			str1.indexOf("H"); // 0
		- lastIndexOf:		str2.lastIndexOf("o"); // 4
		- split:			
							Chia một chuỗi thành một mảng các chuỗi con dựa trên một biểu thức chính quy (regex) hoặc một chuỗi phân tách (delimiter) được chỉ định.
		
							String str3 = "Java Programming";
							String[] words = str3.split(" "); // Java
															  // Programming
		- substring:		
							String substring1 = str1.substring(1, 4); // ell, cut start at index 1, before at index 4
							String substring2 = str2.substring(3); // ld
		- compareTo:		
							String str1 = "apple";
							String str2 = "banana";
							String str3 = "apple";
							int result1 = str1.compareTo(str2); // Khi so sánh "apple" với "banana", kết quả là -1 vì "apple" đứng trước "banana" trong thứ tự từ điển. -1
							int result2 = str1.compareTo(str3); // 0
							int result3 = str2.compareTo(str1); // Khi so sánh "banana" với "apple", kết quả là 1 vì "banana" đứng sau "apple" trong thứ tự từ điển. 1
		- join:				String joinString1 = String.join("-", "welcome", "to", "java"); // welcome-to-java	
		- format:			projectMonitoringViewDto.setFinishedPercent(((taskCount != 0 ? String.format("%.2f", (100.0 * finishedCount / taskCount)) : "0") + "%")); // chuỗi đại đã làm tròn đến 2 chữ số thập phân phía sau, 
																																									  // kết hợp với ký tự "%".

	Stream--JAVA:			List<Integer> numbers1 = Arrays.asList(1, 2, 3, 4, 5, 3, 2, 1);
							List<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
		
		- map, filter, limit, skip, distinct, sorted:				        
																		
							List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 3, 2, 1);
							List<Integer> squaredDistinctNumbers = numbers.stream()
									.map(x -> x * x)                // map(): ánh xạ từng phần tử thành bình phương của nó
									.filter(x -> x % 2 == 0)        // filter(): lọc các số chẵn
									.distinct()                     // distinct(): loại bỏ các phần tử trùng lặp
									.sorted()                       // sorted(): sắp xếp các phần tử
									.limit(3)                       // limit(): giới hạn số lượng phần tử
									.skip(1)                        // skip(): bỏ qua n phần tử đầu tiên
									.collect(Collectors.toList());  // thu thập kết quả vào một danh sách // [4, 16, 36]
																				
		- forEach:			numbers.stream().forEach(System.out::print); // 123456789
		- reduce:			int sum = numbers.stream().reduce(0, Integer::sum); // 45
		- count:			long count = numbers.stream().count(); // 9 elements
		- min:				Optional<Integer> min = numbers.stream().min(Integer::compare); // 1
		- max:				Optional<Integer> max = numbers.stream().max(Integer::compare); // 9
		- collect:			
							List<Integer> evenNumbers = numbers.stream()
															   .filter(x -> x % 2 == 0)
															   .collect(Collectors.toList()); // [2, 4, 6, 8]
							
							Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5, 5);
							Set<Integer> numberSet = numbers.collect(Collectors.toSet());
							System.out.println(numberSet); // Output: [1, 2, 3, 4, 5]
							
							Stream<String> countries = Stream.of("Vietnam", "USA", "France");
							Map<String, Integer> countryLengthMap = countries.collect(Collectors.toMap(country -> country, String::length));
							System.out.println(countryLengthMap); // Output: {Vietnam=7, USA=3, France=6}
							
							Stream<String> words = Stream.of("Hello", "world", "Java");
							String joinedString = words.collect(Collectors.joining(" "));
							System.out.println(joinedString); // Output: Hello world Java
							
							Stream<String> fruits = Stream.of("apple", "banana", "orange", "grape", "banana");
							Map<Integer, List<String>> lengthGroup = fruits.collect(Collectors.groupingBy(String::length));
							System.out.println(lengthGroup); // Output: {5=[apple, grape], 6=[orange], 6=[banana, banana]}
							
							Stream<Integer> numbers = Stream.of(1, 2, 3, 4, 5);
							Map<Boolean, List<Integer>> partitionedMap = numbers.collect(Collectors.partitioningBy(num -> num % 2 == 0));
							System.out.println(partitionedMap); // Output: {false=[1, 3, 5], true=[2, 4]}
		- allMatch:			boolean allEven = numbers.stream().allMatch(x -> x % 2 == 0); // false
		- anyMatch:			boolean anyEven = numbers.stream().anyMatch(x -> x % 2 == 0); // true
		noneMatch:			boolean noneEven = numbers.stream().noneMatch(x -> x % 2 == 0); // false
		findAny:			Optional<Integer> anyElement = numbers.stream().findAny(); // 1
		- findFirst:		Optional<Integer> firstElement = numbers.stream().findFirst(); // 1

	Optional--JAVA:				Optional<String> optional = Optional.of("Hello");
		Optional.empty:			Optional<String> emptyOptional = Optional.empty();
		Optional.of:			Optional<String> ofOptional = Optional.of("Hello");
		Optional.ofNullable:	
								String nullableValue = null;
								Optional<String> nullableOptional = Optional.ofNullable(nullableValue); // nullableValue là null
																										// nên nullableOptional sẽ là một Optional không chứa giá trị nào (empty).
		isPresent:				
								Optional<String> presentOptional = Optional.of("World");
								if (presentOptional.isPresent()) {
									System.out.println("Value is present: " + presentOptional.get()); // Value is present: World
								}
		ifPresent:			
								Optional<String> presentOptional = Optional.of("World");
								presentOptional.ifPresent(value -> System.out.println("Value is present: " + value)); // Value is present: World
		orElse:					String result = optional.orElse("Default Value"); // Hello
		orElseGet:				String resultSupplier = optional.orElseGet(() -> "Default Value from Supplier"); // Hello. Phương thức này hoạt động tương tự như orElse(), nhưng thay vì trả về một giá
																												 // trị mặc định ngay lập tức, nó sẽ trả về kết quả của một Supplier nếu Optional trống.
		orElseThrow:			
								try {
									String resultThrow = optional.orElseThrow(() -> new RuntimeException("No value present")); // Hello. Phương thức này trả về giá trị bên trong Optional nếu tồn tại.
																															   // Nếu Optional trống, nó sẽ ném ra một ngoại lệ mà bạn cung cấp.
								} catch (Exception e) {
									System.out.println("Exception caught: " + e.getMessage());
								}
		map:					Optional<String> mappedOptional = optional.map(s -> s + " World"); // Hello World
		filter:					Optional<String> filteredOptional = optional.filter(s -> s.length() > 5);
		get:					
								try {
									String value = optional.get(); // Phương thức này trả về giá trị bên trong Optional nếu tồn tại. Nếu Optional trống, nó sẽ ném ra một NoSuchElementException.
									System.out.println("Value is present: " + value); // Hello
								} catch (Exception e) {
									System.out.println("Exception caught: " + e.getMessage());
								}
	Data Type--JAVA:
													- Trong Java, phép ép kiểu trực tiếp, như (Integer) bigInteger, chỉ hoạt động khi có một mối quan hệ kế thừa hoặc giao diện giữa các kiểu dữ liệu.
													- Tuy nhiên, BigInteger và Integer không có mối quan hệ kế thừa hoặc giao diện trực tiếp. Chúng là hai kiểu dữ liệu riêng biệt trong Java và không thể được ép kiểu trực tiếp từ
													BigInteger sang Integer.
	
		Primitive Data Types:
			Numbers:
				Integer Types:
													byte:			
																	Stores whole numbers from -128 to 127. 1 byte
																	
																	byte myNum = 100;
													short:			
																	Stores whole numbers from -32,768 to 32,767. 2 bytes
																	
																	short myNum = 5000;
													int:			
																	Stores whole numbers from -2,147,483,648 to 2,147,483,647. 4 bytes
																	
																	int myNum = 100000;
				Floating Point Types:
													long:			Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. 8 bytes
													float:			
																	Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits. 4 bytes
																	
																	float f1 = 35e3f;
																	float myNum = 5.75f;
													double:			
																	Stores fractional numbers. Sufficient for storing 15 decimal digits. 8 bytes
														
																	double d1 = 12E4d;
																	double myNum = 19.99d;
													boolean:		
																	Stores true or false values. 1 bit
													
																	boolean isJavaFun = true;
													char:			
																	Stores a single character/letter or ASCII values. 2 bytes
																	
																	char myGrade = 'B';
		Non-Primitive Data Types:
													String:
																			Strings are used for storing text.	
																			
																			String greeting = "Hello";
													Array:		
																			Arrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.
																			
																			String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
													Classes:		
																			A Class is like an object constructor, or a "blueprint" for creating objects.
																			
																			public class Main {
																			int x = 5;
		
																			public static void main(String[] args) {
																				Main myObj = new Main();
																				System.out.println(myObj.x);
																			}
																			}
													Interface:		
																			An interface is a completely "abstract class" that is used to group related methods with empty bodies:
																			
																			interface FirstInterface {
																			public void myMethod(); // interface method
																			}
																			interface SecondInterface {
																			public void myOtherMethod(); // interface method
																			}
																			class DemoClass implements FirstInterface, SecondInterface {
																			public void myMethod() {
																				System.out.println("Some text..");
																			}
																			public void myOtherMethod() {
																				System.out.println("Some other text...");
																			}
																			}
																			class Main {
																			public static void main(String[] args) {
																				DemoClass myObj = new DemoClass();
																				myObj.myMethod();
																				myObj.myOtherMethod();
																			}
																			}
													Integer:		
																			Đại diện cho số nguyên.
																			
																			Integer num = 10;
													Float:		
																			Đại diện cho số thực (float).
																			
																			Float f = 3.14f;
													Double:		
																			Đại diện cho số thực (double).
																			
																			Double d = 3.14;
													Boolean:		
																			Đại diện cho giá trị logic true hoặc false.
																			
																			Boolean isJavaFun = true;
													Character:		
																			Đại diện cho một ký tự.
																			
																			Character ch = 'A';
													ArrayList:		
																			Một danh sách động có thể mở rộng.
																			
																			import java.util.ArrayList;
																			ArrayList<String> list = new ArrayList<>();
																			list.add("Apple");
																			list.add("Banana");
													HashMap:		
																			Một bản đồ không có thứ tự với các cặp key-value.
																			
																			import java.util.HashMap;
																			HashMap<String, Integer> map = new HashMap<>();
																			map.put("apple", 10);
																			map.put("banana", 20);
													LocalDate:		
																			Represents a date (year, month, day (yyyy-MM-dd))
																			
																			LocalDate myObj = LocalDate.now();
																			LocalDate specificDate = LocalDate.of(2022, 12, 31); // 2022-12-31
																			int year = currentDate.getYear();
																			int month = currentDate.getMonthValue();
																			int day = currentDate.getDayOfMonth();
																			LocalDate futureDate = currentDate.plusDays(7); // thêm 7 ngày
																			LocalDate pastDate = currentDate.minusMonths(1); // giảm 1 tháng
													LocalTime:		
																			Represents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))
																			
																			LocalTime myObj = LocalTime.now();
																			LocalTime specificTime = LocalTime.of(12, 30, 45); // 12:30:45
																			int hour = currentTime.getHour();
																			int minute = currentTime.getMinute();
																			int second = currentTime.getSecond();
																			LocalTime futureTime = currentTime.plusHours(3).plusMinutes(20); // thêm 3 giờ 20 phút
																			LocalTime pastTime = currentTime.minusSeconds(15); // giảm 15 giây
													LocalDateTime:		
																			Represents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)
																			
																			LocalDateTime currentDateTime = LocalDateTime.now();
																			LocalDateTime specificDateTime = LocalDateTime.of(2022, 12, 31, 15, 30); // 2022-12-31T15:30
																			int year = currentDateTime.getYear();
																			int month = currentDateTime.getMonthValue();
																			int day = currentDateTime.getDayOfMonth();
																			int hour = currentDateTime.getHour();
																			int minute = currentDateTime.getMinute();
																			int second = currentDateTime.getSecond();
													DateTimeFormatter:
																			Formatter for displaying and parsing date-time objects
																		
																			LocalDateTime currentDateTime = LocalDateTime.now();
																			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
																			String formattedDateTime = currentDateTime.format(formatter); // định dạng currentDateTime thành một chuỗi theo định dạng đã được chỉ định bởi formatter.
																																		  // 26/02/2024 15:48:30
																			String dateTimeString = "25/02/2024 15:30:00";
																			LocalDateTime parsedDateTime = LocalDateTime.parse(dateTimeString, formatter); // parse chuỗi dateTimeString thành một đối tượng LocalDateTime.
																			                                                                               // 2024-02-25T15:30:00
																																						   // parse là chuyển một input thành kiểu của nó
													Date:
																																														Date không tự động điều chỉnh cho múi giờ hoặc thời gian mùa hè (DST - Daylight Saving Time). Nó chỉ đơn giản lưu trữ một số mili giây
																							kể từ Epoch (1/1/1970 00:00:00 UTC). Do đó, khi hiển thị một đối tượng Date, nó sẽ hiển thị ngày và giờ tương ứng với múi giờ của hệ thống
																							Lớp java.util.Date trong java biểu diễn ngày và giờ (date và time)
																							Lớp java.util.Date implements các giao diện Serializable, Cloneable and Comparable<Date>. Nó được kế thừa bởi các lớp java.sql.Date,
																							java.sql.Time và java.sql.Timestamp.
																							Sau khi lớp Calendar ra đời, hầu hết các Constructor và phương thức của lớp java.util.Date đã bị khuyến cáo không nên dùng
																							nữa (@deprecated).
													
														Các cách tạo Date:					
															Ngày và giờ hiện tại--Date:
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									Date currentDate = new Date();
																									System.out.println("Current date and time: " + currentDate); // Current date and time: Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Ngày cụ thể--Date::
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									Date specificDate = new Date(1645624200000L); // 23/02/2022
																									System.out.println("Specific date: " + specificDate); // Specific date: Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Sử dụng thời gian từ chuỗi--Date::
																							import java.util.Date;
																							import java.text.SimpleDateFormat;
																							public class Main {
																								public static void main(String[] args) throws Exception {
																									SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
																									Date parsedDate = sdf.parse("2022-02-23 15:30:00");
																									System.out.println("Parsed date: " + parsedDate); // Parsed date: Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Thời gian từ số mili giây--Date::
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									Date dateFromMilliseconds = new Date(1645624200000L); // 23/02/2022
																									System.out.println("Date from milliseconds: " + dateFromMilliseconds); // Date from milliseconds: Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Sử dụng lớp Calendar--Date::
																							import java.util.Calendar;
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									Calendar calendar = Calendar.getInstance();
																									Date currentDate = calendar.getTime();
																									System.out.println("Current date and time using Calendar: " + currentDate); // Current date and time using Calendar:
																																												// Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Sử dụng lớp Instant--Date::
																							import java.time.Instant;
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									Instant instant = Instant.now();
																									Date currentDate = Date.from(instant);
																									System.out.println("Current date and time using Instant: " + currentDate); // Current date and time using Instant:
																																											   // Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
															Sử dụng lớp LocalDateTime--Date::
																							import java.time.LocalDateTime;
																							import java.util.Date;
																							public class Main {
																								public static void main(String[] args) {
																									LocalDateTime localDateTime = LocalDateTime.now();
																									Date currentDate = Date.from(localDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant());
																									System.out.println("Current date and time using LocalDateTime: " + currentDate); // Current date and time using LocalDateTime:
																																													 // Wed Feb 23 15:30:00 UTC 2022
																								}
																							}
														boolean after(Date date):
																							Date currentDate = new Date();
																							Date futureDate = new Date(currentDate.getTime() + 1000); // Tạo một Date trong tương lai
																							System.out.println("Is futureDate after currentDate? " + futureDate.after(currentDate)); // Is futureDate after currentDate? true
														boolean before(Date date):
																							Date currentDate = new Date();
																							Date pastDate = new Date(currentDate.getTime() - 1000); // Tạo một Date trong quá khứ
																							System.out.println("Is pastDate before currentDate? " + pastDate.before(currentDate)); // Is pastDate before currentDate? true
														Object clone():
																							Date currentDate = new Date();
																							Date clonedDate = new Date(currentDate.getTime()); // Sử dụng phương thức khởi tạo với tham số là số mili giây của currentDate
																							System.out.println("Original Date: " + currentDate); // Original Date: Wed Feb 23 15:30:00 UTC 2022
																							System.out.println("Cloned Date: " + clonedDate); // Cloned Date: Wed Feb 23 15:30:00 UTC 2022
														int compareTo(Date date):
																							Date currentDate = new Date();
																							Date futureDate = new Date(currentDate.getTime() + 1000); // Tạo một Date trong tương lai
																							Date pastDate = new Date(currentDate.getTime() - 1000); // Tạo một Date trong quá khứ
																							System.out.println("Comparing futureDate with currentDate: " + futureDate.compareTo(currentDate)); // Comparing futureDate with
																																															   // currentDate: 1
																							System.out.println("Comparing pastDate with currentDate: " + pastDate.compareTo(currentDate)); // Comparing pastDate with currentDate: -1
														boolean equals(Date date):
																							Date date1 = new Date();
																							Date date2 = new Date(date1.getTime());
																							boolean isEqual = date1.equals(date2);
																							System.out.println("Are date1 and date2 equal? " + isEqual); // Are date1 and date2 equal? true
														static Date from(Instant instant):
																							Instant instant = Instant.now();
																							Date date = Date.from(instant);
																							System.out.println("Date from Instant: " + date); // Date from Instant: Wed Feb 23 15:30:00 UTC 2022
														long getTime():
																							Date date = new Date();
																							long timeInMillis = date.getTime();
																							System.out.println("Time in milliseconds: " + timeInMillis); // Time in milliseconds: 1645624200000
														int hashCode():
																							Date date = new Date();
																							int hashCode = date.hashCode();
																							System.out.println("Hash code of date: " + hashCode); // Hash code of date: 1401071853
														void setTime(long time):
																							Date date = new Date();
																							date.setTime(0); // Set time to Epoch time
																							System.out.println("Date after setTime: " + date); // Date after setTime: Thu Jan 01 07:00:00 UTC 1970
														Instant toInstant():
																							Date date = new Date();
																							Instant instant = date.toInstant();
																							System.out.println("Instant from Date: " + instant); // Instant from Date: 2022-02-23T15:30:00Z
														String toString():
																							Date date = new Date();
																							String dateString = date.toString();
																							System.out.println("String representation of Date: " + dateString); // String representation of Date: Wed Feb 23 15:30:00 UTC 2022		
	
	Ngày và giờ trong Java--JAVA:
	
			- Các kiểu dữ liệu ngày tháng phổ biến trong Java và cách chúng thường xuất hiện trong JSON khi gửi từ backend đến frontend:
			
				Múi giờ mặc định của JVM sẽ khớp với múi giờ của hệ điều hành mà JVM đang chạy. Ví dụ, nếu hệ điều hành được cấu hình để sử dụng
				múi giờ "America/New_York", thì JVM cũng sẽ sử dụng "America/New_York" làm múi giờ mặc định.
			
				java.util.Date
					Đại diện cho một thời gian cụ thể tính theo mili giây kể từ epoch. Không lưu trữ múi giờ, nhưng khi được chuyển đổi thành chuỗi, nó sử dụng múi giờ mặc định của hệ thống Java (JVM).
					Độ chính xác: Date có độ chính xác đến mili giây (millisecond).
					Không có múi giờ: Date không chứa thông tin về múi giờ; nó chỉ lưu trữ thời gian dưới dạng số mili giây kể từ epoch. Tuy nhiên, khi được chuyển thành chuỗi (string) hoặc được
					định dạng, nó sử dụng múi giờ mặc định của hệ thống (JVM).
					Khi sử dụng System.out.println() hoặc toString() trên một đối tượng java.util.Date, định dạng chuỗi mặc định sẽ là:
						EEE MMM dd HH:mm:ss zzz yyyy
						Tue Sep 03 12:34:56 UTC 2024
					JSON Format: Chuỗi thời gian ISO-8601.
					Example: "2024-09-03T12:34:56.789Z"
				
				java.time.LocalDate
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd".
					Example: "2024-09-03"
				
				java.time.LocalTime
					JSON Format: Chuỗi theo định dạng "HH:mm:ss.SSS".
					Example: "12:34:56.789"
				
				java.time.LocalDateTime
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd'T'HH:mm:ss.SSS".
					Example: "2024-09-03T12:34:56.789"
				
				java.time.ZonedDateTime
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd'T'HH:mm:ss.SSSXXX".
					Example: "2024-09-03T12:34:56.789+00:00"
				
				java.time.OffsetDateTime
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd'T'HH:mm:ss.SSSXXX".
					Example: "2024-09-03T12:34:56.789+00:00"
				
				java.time.Instant
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'".
					Example: "2024-09-03T12:34:56.789Z"
				
				java.sql.Date
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd".
					Example: "2024-09-03"
				
				java.sql.Time
					JSON Format: Chuỗi theo định dạng "HH:mm:ss".
					Example: "12:34:56"
				
				java.sql.Timestamp
					java.sql.Timestamp là một lớp con của java.util.Date và được thiết kế cụ thể để đại diện cho các kiểu dữ liệu thời gian của SQL (như TIMESTAMP trong cơ sở dữ liệu SQL). Nó được sử dụng
					chủ yếu trong JDBC để tương thích với cơ sở dữ liệu.
					Độ chính xác: Timestamp có độ chính xác cao hơn Date; nó có thể lưu trữ thời gian chính xác đến nano giây (nanosecond). Tuy nhiên, các phần milli giây và nano giây được tính toán riêng biệt.
					Không có múi giờ: Giống như Date, Timestamp cũng không chứa thông tin về múi giờ. Tuy nhiên, nó có thể được sử dụng với múi giờ mặc định của JVM khi thực hiện định dạng hoặc chuyển đổi thành chuỗi.
					JSON Format: Chuỗi theo định dạng "yyyy-MM-dd'T'HH:mm:ss.SSS".
					Example: "2024-09-03T12:34:56.789"
					
				Định dạng mặc định với GSON:
					Mặc định, GSON chuyển đổi các kiểu dữ liệu này thành chuỗi theo định dạng dựa trên ngôn ngữ (locale) và múi giờ (timezone) mặc định
					của hệ thống. GSON không sử dụng định dạng ISO-8601 cho Date và Timestamp mà sử dụng định dạng chuỗi thân thiện với người đọc.
					java.util.Date: Chuỗi định dạng theo toString() của Date.
					java.sql.Date: Chuỗi định dạng yyyy-MM-dd.
					java.sql.Timestamp: Chuỗi định dạng theo toString() của Timestamp.
					java.sql.Time: Chuỗi định dạng HH:mm:ss.
					java.time.* classes (Java 8+): Không được hỗ trợ mặc định bởi GSON; cần cấu hình bổ sung hoặc sử dụng thư viện bổ sung để serialize sang JSON.
					
					import com.google.gson.Gson;
					import java.util.Date;
					public class Main {
						public static void main(String[] args) {
							Gson gson = new Gson();
							Date date = new Date();
							String json = gson.toJson(date);
							System.out.println(json); // "Sep 3, 2024 12:34:56 PM"
						}
					}
					
					Các kiểu dữ liệu từ java.time package (Java 8+):
						Mặc định, GSON không hỗ trợ các kiểu dữ liệu trong gói java.time như LocalDate, LocalTime, LocalDateTime, ZonedDateTime, v.v. Nếu
						bạn không thêm cấu hình cụ thể cho GSON, nó sẽ không thể chuyển đổi chúng sang JSON và sẽ gây ra lỗi UnsupportedOperationException.
						Để chuyển đổi các kiểu dữ liệu này, bạn cần sử dụng thư viện bổ sung như Gson-Java8-Adapters hoặc viết TypeAdapter tùy chỉnh. Tuy
						nhiên, nếu bạn sử dụng một thư viện bổ sung, các kiểu dữ liệu thường được chuyển đổi sang định dạng ISO-8601.



			LocalDate--Ngày và giờ trong Java:	
			
									- Dù có thế nào thì kiểu từ string sang ngày vẫn là dạng 2020-05-03, còn kiểu từ ngày chuyển sang string có sẽ có nhiều dạng khác nhau tùy theo mình format
									- Represents a date (year, month, day (yyyy-MM-dd)							
									- LocalDate class là một immutable class đại diện cho ngày-tháng-năm không có múi giờ, ví dụ như 2020-01-03.
									- Lớp Java LocalDate là bất biến, có nghĩa là khi một phiên bản được tạo, bạn không thể sửa đổi nó. LocalDate cung cấp nhiều phương pháp hữu ích để thao tác và truy vấn ngày, chẳng hạn như
									cộng hoặc trừ ngày, tháng hoặc năm, lấy ngày trong tuần hoặc kiểm tra xem một ngày có trước hay sau một ngày khác hay không.
									- parse là chuyển chuỗi về date (nếu chỉ là chuỗi thì chuỗi phải dạng chuẩn, nếu có thêm đối số format thì chuỗi phải theo dạng của format) còn format là chuyển date về chuỗi (date thì
									luôn ở dạng chuẩn rồi, vậy nên chỉ có 1 đối số là kiểu để format string, kiểu format này sẽ quyết định string sẽ có dạng như thế nào)
			
				Khởi tạo LocalDate--LocalDate Java:
					
									Để khởi tạo LocalDate object chúng ta có thể sử dụng LocalDate.now() (Lấy giá trị ngày hiện tại trong hệ thống) hoặc LocalDate.of().
										
										import java.time.LocalDate;
										import java.time.Month;
										class LocalDateExample {
											public static void main(String[] args) {
												// Current date
												LocalDate localDate = LocalDate.now();
												System.out.println(localDate); // 2020-01-04
												//Specific date
												LocalDate localDate2 = LocalDate.of(2017, Month.MAY, 15);
												System.out.println(localDate2); // 2017-05-15
											}
										}
				
				Lấy ngày, tháng, năm từ LocalDate--LocalDate Java:
				
									Chúng ta có thể sử dụng getYear(), getMonth(), getDay() để lấy giá trị năm, tháng, ngày tương ứng trong LocalDate object.
										
										import java.time.LocalDate;
											class LocalDateExample {
											public static void main(String[] args) {
												LocalDate localDate = LocalDate.now();
												System.out.println("Year : " + localDate.getYear()); // Year : 2020
												System.out.println("Month : " + localDate.getMonth().getValue()); // Month : 1
												System.out.println("Day of Month : " + localDate.getDayOfMonth()); // Day of Month : 4
												System.out.println("Day of Week : " + localDate.getDayOfWeek()); // Day of Week : SATURDAY
												System.out.println("Day of Year : " + localDate.getDayOfYear()); // Day of Year : 4
											}
										}
				
				Cộng và trừ ngày, tháng, năm trong LocalDate--LocalDate Java:
				
									LocalDate có sẵn các method plus(), minus() tương ứng với ngày tháng năm để thực hiện thao tác cộng và trừ trong LocalDate object.
										
										import java.time.LocalDate;
										class LocalDateExample {
											public static void main(String[] args) {
												LocalDate localDate = LocalDate.now();
												// LocalDate's plus methods
												System.out.println("Addition of days : " + localDate.plusDays(5)); // Addition of days : 2020-01-09
												System.out.println("Addition of months : " + localDate.plusMonths(15)); // Addition of months : 2021-04-04
												System.out.println("Addition of weeks : " + localDate.plusWeeks(45)); // Addition of weeks : 2020-11-14
												System.out.println("Addition of years : " + localDate.plusYears(5)); // Addition of years : 2025-01-04
												// LocalDate's minus methods
												System.out.println("Subtraction of days : " + localDate.minusDays(5)); // Subtraction of days : 2019-12-30
												System.out.println("Subtraction of months : " + localDate.minusMonths(15)); // Subtraction of months : 2018-10-04
												System.out.println("Subtraction of weeks : " + localDate.minusWeeks(45)); // Subtraction of weeks : 2019-02-23
												System.out.println("Subtraction of years : " + localDate.minusYears(5)); // Subtraction of years : 2015-01-04
											}
										}
				
				So sánh LocalDate object trong java--LocalDate Java:
							
									Để so sánh LocalDate object trong java chúng ta có các method như isEqual() để so sánh bằng, isAfter(), isBefore(), compareTo().
									
					isEqual(LocalDate other)
										
										Trả về true nếu LocalDate object hiện tại bằng với other, ngược lại false.
											
											// Example
											LocalDate d1 = LocalDate.now();
											LocalDate d2 = LocalDate.now();
											LocalDate d3 = LocalDate.now().minusDays(1);
											System.out.println(d1.isEqual(d2)); // true
											System.out.println(d1.isEqual(d3)); // false
											
					isAfter(LocalDate other)
										
										isAfter() trả về true nếu LocalDate hiện tại có giá trị lớn hơn LocalDate other truyền vào, ngược lại false.
											
											LocalDate d1 = LocalDate.now();
											LocalDate d2 = LocalDate.now().plusDays(1);
											LocalDate d3 = LocalDate.now().minusDays(1);
											System.out.println(d1.isAfter(d2)); // false
											System.out.println(d1.isAfter(d3)); // true
											System.out.println(d1.isAfter(d1)); // false
											
					isBefore(LocalDate other)
									
										isBefore() trả về true nếu LocalDate hiện tại có giá trị nhỏ hơn LocalDate other truyền vào, ngược lại false.
											
											LocalDate d1 = LocalDate.now();
											LocalDate d2 = LocalDate.now().plusDays(1);
											LocalDate d3 = LocalDate.now().minusDays(1);
											System.out.println(d1.isBefore(d2)); // true
											System.out.println(d1.isBefore(d3)); // false
											System.out.println(d1.isBefore(d1)); // false
											
					compareTo(LocalDate other)
										
										So sánh LocalDate object hiện tại với other từ tham số truyền vào. Trả về  số dương nếu object hiện tại lớn hơn other, 0 nếu bằng nhau và âm nếu nhỏ hơn.
											
											LocalDate d1 = LocalDate.now();
											LocalDate d2 = LocalDate.now();
											LocalDate d3 = LocalDate.now().minusDays(1);
											System.out.println(d1.compareTo(d2)); // 0
											System.out.println(d1.compareTo(d3)); // 1
											System.out.println(d3.compareTo(d2)); // -1
				
				Kiểm tra năm nhuận trong java--LocalDate Java:
				
									LocalDate cung cấp method isLeapYear() để kiểm tra năm nhuận trong java.
										
										import java.time.LocalDate;
										import java.time.Month;
										class LocalDateExample {
											public static void main(String[] args) {
												LocalDate localDate1 = LocalDate.of(2017, Month.JANUARY, 1);
												LocalDate localDate2 = LocalDate.of(2016, Month.JANUARY, 1);
												if(localDate1.isLeapYear()){
													System.out.println(localDate1.getYear()+ " is a leap year");
												}else{
													System.out.println(localDate1.getYear()+ " is not a leap year");
												}
												if(localDate2.isLeapYear()){
													System.out.println(localDate2.getYear()+ " is a leap year");
												}else{
													System.out.println(localDate2.getYear()+ " is not a leap year");
												}

											}
										}
										Output:
										2017 is not a leap year
										2016 is a leap year
				
				Convert String sang LocalDate trong java--LocalDate Java:
				
										- Chúng ta có thể sử dụng method parse() trong LocalDate class để convert một chuỗi sang LocalDate.
											
											import java.time.LocalDate;
											import java.time.format.DateTimeFormatter;
											class LocalDateExample {
												public static void main(String[] args) {
													// ISO Date
													LocalDate localDate = LocalDate.parse("2020-05-03", DateTimeFormatter.ISO_LOCAL_DATE);
													System.out.println(localDate); // 2020-05-03
													
													// yyyy/MM/dd pattern
													LocalDate localDate1 = LocalDate.parse("2020/05/12", DateTimeFormatter.ofPattern("yyyy/MM/dd"));
													System.out.println(localDate1); // 2020-05-12
													
													// MMM dd, yyyy pattern
													LocalDate localDate2 = LocalDate.parse("May 05, 2020", DateTimeFormatter.ofPattern("MMM dd, yyyy"));
													System.out.println(localDate2); // 2020-05-05
													
													// dd-MMM-yyyy pattern
													LocalDate localDate3 = LocalDate.parse("12-Jan-2020", DateTimeFormatter.ofPattern("dd-MMM-yyyy"));
													System.out.println(localDate3); // 2020-01-12
													
													// dd-LL-yyyy pattern
													LocalDate localDate4 = LocalDate.parse("12-01-2020", DateTimeFormatter.ofPattern("dd-LL-yyyy"));
													System.out.println(localDate4); // 2020-01-12
												}
											}
				
				Convert LocalDate sang String trong java--LocalDate Java:
				
										Chúng ta có thể sử dụng format() method trong LocalDate class để chuyển LocalDate object sang String.
											
											import java.time.LocalDate;
											import java.time.format.DateTimeFormatter;
											class LocalDateExample {
												public static void main(String[] args) {
													// ISO Date
													LocalDate localDate = LocalDate.now();
													DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE;
													System.out.println(localDate.format(dateFormatter)); // 2020-01-04
													
													// yyyy/MM/dd pattern
													DateTimeFormatter dateFormatter1 = DateTimeFormatter.ofPattern("yyyy/MM/dd");
													System.out.println(localDate.format(dateFormatter1)); // 2020/01/04
													
													// MMMM dd, yyyy pattern
													DateTimeFormatter dateFormatter2 = DateTimeFormatter.ofPattern("MMMM dd, yyyy");
													System.out.println(localDate.format(dateFormatter2)); // January 04, 2020
													
													// dd-MMM-yyyy pattern
													DateTimeFormatter dateFormatter3 = DateTimeFormatter.ofPattern("dd-MMM-yyyy");
													System.out.println(localDate.format(dateFormatter3)); // 04-Jan-2020
													
													// dd-LL-yyyy pattern
													DateTimeFormatter dateFormatter4 = DateTimeFormatter.ofPattern("dd-LL-yyyy");
													System.out.println(localDate.format(dateFormatter4)); // 04-01-2020
												}
											}
			
			LocalTime--Ngày và giờ trong Java:	
			
									- Từ string thành time sẽ luôn có ở dạng 13:10:20.000012345, từ time chuyển thành chuỗi sẽ ở dạng theo như chúng ta format
									- Represents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))					
									- Lớp LocalTime đại diện cho thời gian địa phương (local time), nó không bao gồm thông tin ngày tháng và múi giờ. LocalTime bao gồm các thông tin giờ, phút, giây, thậm chí cả nano
									giây (1 giây = 1 tỷ nano giây).
									- Lớp LocalTime nằm trong package java.time. Cũng giống như các lớp khác được giới thiệu trong Java 8 Date Time API, LocalTime là bất biến (immutable) điều này có nghĩa là tất cả các tính
									toán trên LocalTime đều tạo ra một đối tượng LocalTime mới, vì vậy nó an toàn khi được sử dụng trong môi trường multithreading.
				
				Static Factory Methods--LocalTime Java:
										
									Lớp LocalTime không cung cấp bất kỳ một constructor nào, nhưng nó cung cấp các phương thức nhà máy tĩnh (static factory method) để tạo ra đối tượng mới:
									
										public static LocalTime now()
										public static LocalTime now(ZoneId zone)
										public static LocalTime now(Clock clock)
										public static LocalTime of(int hour, int minute)
										public static LocalTime of(int hour, int minute, int second)
										public static LocalTime of(int hour, int minute, int second, int nanoOfSecond)
										public static LocalTime ofInstant(Instant instant, ZoneId zone)
										public static LocalTime ofSecondOfDay(long secondOfDay)  
										public static LocalTime ofNanoOfDay(long nanoOfDay)
										public static LocalTime from(TemporalAccessor temporal)
										public static LocalTime parse(CharSequence text)  
										public static LocalTime parse(CharSequence text, DateTimeFormatter formatter)
											
									Tạo đối tượng LocalTime đại diện cho thời điểm hiện tại có được từ đồng hồ hệ thống và múi giờ mặc định (Trên máy tính của bạn).
												
										// Current time from the system clock in the default time-zone.
										LocalTime localTime = LocalTime.now();
										System.out.println("localTime: " + localTime);
									
									Tạo đối tượng LocalTime đại diện cho thời điểm hiện thời từ một đồng hồ được chỉ định:
										
										// Clock from system default zone
										Clock clockDefault = Clock.systemDefaultZone();
										Clock clock = Clock.system(ZoneId.of("Europe/Paris"));
										// Current time from the specified clock.
										LocalTime localTime = LocalTime.now(clock);
										System.out.println("localTime: " + localTime); // 19:51:11.990871 (Example)
									
									Tạo đối tượng LocalTime đại diện cho thời điểm hiện thời từ một ZoneId được chỉ định:
										
										// System default zone
										ZoneId zoneIdDefault = ZoneId.systemDefault();
										ZoneId zoneId = ZoneId.of("Australia/Sydney");
										LocalTime localTime = LocalTime.now(zoneId);
										System.out.println("Now is: " + localTime); // 03:56:06.006877 (Example)
										
									Tạo đối tượng LocalTime từ các giá trị hour, minute, second, nanoOfSecond được chỉ định:
										
										// of(int hour, int minute, int second, int nanoOfSecond)
										LocalTime localTime1 = LocalTime.of(13, 10, 20, 12345);  
										System.out.println("localTime1: " + localTime1); // 13:10:20.000012345
										// of(int hour, int minute, int second)
										LocalTime localTime2 = LocalTime.of(13, 10, 20);
										System.out.println("localTime2: " + localTime2); // 13:10:20
										// of(int hour, int minute)
										LocalTime localTime3 = LocalTime.of(13, 10);
										System.out.println("localTime3: " + localTime3); // 13:10
									
									Tạo đối tượng LocalTime với các đối tượng Instant và ZoneId được chỉ định:
										
										// ofInstant(Instant instant, ZoneId zone)
										Instant instant = Instant.now();
										ZoneId zoneId = ZoneId.systemDefault();
										LocalTime localTime = LocalTime.ofInstant(instant, zoneId);
										System.out.println("localTime: " + localTime);
									
									Tạo đối tượng LocalTime từ việc phân tích một văn bản có định dạng thời gian:
										
										// parse(CharSequence text)  
										LocalTime localTime1 = LocalTime.parse("10:15:30"); // 10:15:30
										System.out.println("localTime1: " + localTime1);
										// parse(CharSequence text, DateTimeFormatter formatter)
										DateTimeFormatter fmt2 = DateTimeFormatter.ofPattern("HH:mm");
										LocalTime localTime2 = LocalTime.parse("13:15", fmt2); // 13:15
										System.out.println("localTime2: " + localTime2);
									
									Tạo đối tượng LocalTime từ một đối tượng TemporalAccessor được chỉ định.
										
										// from(TemporalAccessor temporal)
										TemporalAccessor nowDatetime = LocalDateTime.now();
										System.out.println("LocalDateTime.now(): " + nowDatetime);
										LocalTime nowTime = LocalTime.from(nowDatetime);
										System.out.println("nowTime: " + nowTime);
									
				isAfter(..), isBefore(..)--LocalTime Java:
										
									
									Phương thức isBefore(LocalTime) được sử dụng để kiểm tra đối tượng LocalTime này có đứng trước (before) một đối tượng LocalTime khác đã cho hay không.
										
										public boolean isAfter(LocalTime other)
									
									Phương thức isAfter(LocalTime) được sử dụng để kiểm tra đối tượng LocalDate này có đứng sau (after) một đối tượng LocalTime khác đã cho hay không.
										
										public boolean isBefore(LocalTime other)
									
									Ví dụ:
										
										package org.o7planning.localtime.ex;
										import java.time.LocalTime;
										public class LocalTime_isBefore_isAfter_ex1 {
											public static void main(String[] args) {
												LocalTime localTime1 = LocalTime.parse("10:20"); // 10:20
												LocalTime localTime2 = LocalTime.parse("21:15:30.12345"); // 21:15:30.123450																				
												System.out.println("localTime1: " + localTime1); // 10:20
												System.out.println("localTime2: " + localTime2); // 21:15:30.123450
												System.out.println();									
												System.out.println("localTime1.isBefore(localTime2): " + localTime1.isBefore(localTime2)); // true
												System.out.println("localTime1.isAfter(localTime2): " + localTime1.isAfter(localTime2)); // false  
											}
										}
										Output:
										localTime1: 10:20
										localTime2: 21:15:30.123450
										localTime1.isBefore(localTime2): true
										localTime1.isAfter(localTime2): false
									
				format(DateTimeFormatter)--LocalTime Java:
				
									Định dạng đối tượng LocalTime này bằng một DateTimeFormatter được chỉ định.
										
										public String format(DateTimeFormatter formatter)
										
										Ví dụ:
											
											LocalTime localTime = LocalTime.parse("10:15:30.12345");  
											System.out.println("localTime: " + localTime); // 10:15:30.123450
											System.out.println();
											// '10:15', '10:15:30' or '10:15:30+01:00'.
											DateTimeFormatter fmt1 = DateTimeFormatter.ISO_TIME;  
											System.out.println("ISO_TIME: " + localTime.format(fmt1)); // 10:15:30.12345
											DateTimeFormatter fmt2 = DateTimeFormatter.ofPattern("HH:mm");  
											System.out.println("HH:mm: " + localTime.format(fmt2)); // 10:15
									
				getX() *--LocalTime Java:
										
										Phương thức getNano() trả về phần nano giây của LocalDate này. Nó tương đương với việc gọi phương thức get(ChronoField.NANO_OF_SECOND). Giá trị trả về nằm trong phạm vi từ 0 đến 10^9-1.
											
											public int getHour()  
											public int getMinute()  
											public int getSecond()  
											public int getNano()
										
										Các phương thức getHour(),getMinute(), getSecond() cũng được hiểu một cách tương tự giống như cái tên của nó.
											
											Method Same As Range
											getNano() get(ChronoField.NANO_OF_SECOND) 0-10^9-1
											getSecond() get(ChronoField.SECOND_OF_MINUTE) 0-59
											getMinute() get(ChronoField.MINUTE_OF_HOUR) 0-59
											getHour() get(ChronoField.HOUR_OF_DAY) 0-23
										
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											System.out.println("localTime.getHour(): " + localTime.getHour());  // 13
											System.out.println("localTime.getMinute(): " + localTime.getMinute()); // 45
											System.out.println("localTime.getSecond(): " + localTime.getSecond()); // 30
											System.out.println("localTime.getNano(): " + localTime.getNano());  // 123450000
											Output:
												localTime: 13:45:30.123450
												localTime.getHour(): 13
												localTime.getMinute(): 45
												localTime.getSecond(): 30
												localTime.getNano(): 123450000
									
				get(TemporalField)--LocalTime Java:
				
										Trả về giá trị của trường (field) đã chỉ định của đối tượng LocalTime này dưới dạng một số nguyên 32 bit.
										
											// Inherited from TemporalAccessor interface
											public int get(TemporalField field)
										
										Chú ý: Một số trường (field) có thể không được hỗ trợ bởi LocalTime và UnsupportedTemporalTypeException sẽ được ném ra. Để chắc chắn, hãy sử dụng phương thức isSupported(TemporalField) để kiểm tra xem một trường nào đó có được LocalTime hỗ trợ hay không.
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime time = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											System.out.println("localTime: " + time); // 13:45:30.123450
											System.out.println();
											// int get(TemporalField field)
											System.out.println("AMPM_OF_DAY: " + time.get(ChronoField.AMPM_OF_DAY)); // 13
											System.out.println("CLOCK_HOUR_OF_AMPM: " + time.get(ChronoField.CLOCK_HOUR_OF_AMPM)); // 1
											System.out.println("CLOCK_HOUR_OF_DAY: " + time.get(ChronoField.CLOCK_HOUR_OF_DAY)); // 13
											System.out.println("HOUR_OF_AMPM: " + time.get(ChronoField.HOUR_OF_AMPM)); // 1
											System.out.println("HOUR_OF_DAY: " + time.get(ChronoField.HOUR_OF_DAY)); // 13
											System.out.println("MILLI_OF_DAY: " + time.get(ChronoField.MILLI_OF_DAY)); // 49530123
											System.out.println("MILLI_OF_SECOND: " + time.get(ChronoField.MILLI_OF_SECOND)); // 123
											System.out.println("MINUTE_OF_DAY: " + time.get(ChronoField.MINUTE_OF_DAY)); // 825
											System.out.println("MINUTE_OF_HOUR: " + time.get(ChronoField.MINUTE_OF_HOUR)); // 45
											System.out.println("MICRO_OF_SECOND: " + time.get(ChronoField.MICRO_OF_SECOND)); // 123450
											System.out.println("NANO_OF_SECOND: " + time.get(ChronoField.NANO_OF_SECOND)); // 123450000
											System.out.println("SECOND_OF_DAY: " + time.get(ChronoField.SECOND_OF_DAY)); // 49530
											System.out.println("SECOND_OF_MINUTE: " + time.get(ChronoField.SECOND_OF_MINUTE)); // 30
											// Use getLong() instead
											// System.out.println("NANO_OF_DAY: " + time.get(ChronoField.NANO_OF_DAY)); // 49530123450000
											// Unsupported
											// System.out.println("INSTANT_SECONDS: " + time.get(ChronoField.INSTANT_SECONDS));
											// System.out.println("OFFSET_SECONDS: " + time.get(ChronoField.OFFSET_SECONDS));
				
				getLong(TemporalField)--LocalTime Java:
				
										Trả về giá trị của trường (field) đã chỉ định của đối tượng LocalTime này dưới dạng một số nguyên 64 bit.
										
										// Inherited from TemporalAccessor interface									
										public long getLong(TemporalField field)
										
										Chú ý: Một số trường (field) có thể không được hỗ trợ bởi LocalTime và UnsupportedTemporalTypeException sẽ được ném ra. Để chắc chắn, hãy sử dụng phương thức isSupported(TemporalField) để kiểm tra xem một trường nào đó có được LocalTime hỗ trợ hay không.
										
										Ví dụ:
										
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime time = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											System.out.println("localTime: " + time); // 13:45:30.123450
											System.out.println();

											// long getLong(TemporalField field)
											System.out.println("AMPM_OF_DAY: " + time.getLong(ChronoField.AMPM_OF_DAY)); // 13
											System.out.println("CLOCK_HOUR_OF_AMPM: " + time.getLong(ChronoField.CLOCK_HOUR_OF_AMPM)); // 1
											System.out.println("CLOCK_HOUR_OF_DAY: " + time.getLong(ChronoField.CLOCK_HOUR_OF_DAY)); // 13
											System.out.println("HOUR_OF_AMPM: " + time.getLong(ChronoField.HOUR_OF_AMPM)); // 1
											System.out.println("HOUR_OF_DAY: " + time.getLong(ChronoField.HOUR_OF_DAY)); // 13

											System.out.println("MILLI_OF_DAY: " + time.getLong(ChronoField.MILLI_OF_DAY)); // 49530123
											System.out.println("MILLI_OF_SECOND: " + time.getLong(ChronoField.MILLI_OF_SECOND)); // 123
											System.out.println("MINUTE_OF_DAY: " + time.getLong(ChronoField.MINUTE_OF_DAY)); // 825

											System.out.println("MINUTE_OF_HOUR: " + time.getLong(ChronoField.MINUTE_OF_HOUR)); // 45

											System.out.println("MICRO_OF_SECOND: " + time.getLong(ChronoField.MICRO_OF_SECOND)); // 123450
											System.out.println("NANO_OF_SECOND: " + time.getLong(ChronoField.NANO_OF_SECOND)); // 123450000

											System.out.println("SECOND_OF_DAY: " + time.getLong(ChronoField.SECOND_OF_DAY)); // 49530
											System.out.println("SECOND_OF_MINUTE: " + time.getLong(ChronoField.SECOND_OF_MINUTE)); // 30

											 
											System.out.println("NANO_OF_DAY: " + time.getLong(ChronoField.NANO_OF_DAY)); // 49530123450000

											// Unsupported
											// System.out.println("INSTANT_SECONDS: " + time.getLong(ChronoField.INSTANT_SECONDS));
											// System.out.println("OFFSET_SECONDS: " + time.getLong(ChronoField.OFFSET_SECONDS));
				
				plusX(..) *--LocalTime Java:
				
										- Phương thức plusHours(hoursToAdd) trả về một bản sao của đối tượng LocalTime này với một lượng giờ chỉ định được thêm vào.
										- Các phương thức plusMinutes(minutesToAdd), plusSeconds(secondsToAdd), plusNanos(nanosToAdd) cũng được hiểu tương tự giống như cái tên của chúng.
											
											public LocalTime plusHours(long hoursToAdd)   
											public LocalTime plusMinutes(long minutesToAdd)   
											public LocalTime plusSeconds(long secondstoAdd)   
											public LocalTime plusNanos(long nanosToAdd)
												
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// plusHours(long hoursToAdd)
											LocalTime localTime1 = localTime.plusHours(10);
											System.out.println("localTime1: " + localTime1); // 23:45:30
											// plusHours(long hoursToAdd)
											LocalTime localTime2 = localTime.plusHours(20);
											System.out.println("localTime2: " + localTime2); // 09:45:30
											LocalTime localTime3 = localTime.plusHours(-10);
											System.out.println("localTime3: " + localTime3); // 03:45:30
											// plusMinutes(long minutesToAdd)
											LocalTime localTime4 = localTime.plusMinutes(5);
											System.out.println("localTime4: " + localTime4); // 13:50:30
											// plusSeconds(long secondstoAdd)
											LocalTime localTime5 = localTime.plusSeconds(29);
											System.out.println("localTime5: " + localTime5); // 13:45:59
											// plusNanos(long nanosToAdd)
											LocalTime localTime6 = localTime.plusNanos(12345);
											System.out.println("localTime6: " + localTime6); // 13:45:30.000012345
				
				plus(TemporalAmount)--LocalTime Java:
				
										Trả về một bản sao của đối tượng LocalTime này với một lượng thời gian chỉ định được thêm vào.
											
											// Inherited from Temporal interface
											public LocalTime plus(TemporalAmount amountToAdd)
										
										Bạn có thể sử dụng phương thức TemporalAmount.addTo(Temporal) để có được kết quả tương tự.
											
											// Defined in TemporalAmount interface:
											public Temporal addTo​(Temporal temporal)
										
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// ofSeconds(long seconds, long nanoAdjustment)
											TemporalAmount amount1 = Duration.ofSeconds(10, 12345);
											//plus(TemporalAmount amountToAdd)
											LocalTime localTime1 = localTime.plus(amount1);
											System.out.println("localTime1: " + localTime1); // 13:45:40.000012345
											// plus(TemporalAmount amountToAdd)
											LocalTime from = LocalTime.of(10, 20, 35); // of(int hour, int minute, int second)
											LocalTime to = LocalTime.of(10, 25, 45);
											TemporalAmount amount2 = Duration.between(from, to); // 00:05:10
											LocalTime localTime2 = localTime.plus(amount2);
											System.out.println("localTime2: " + localTime2); // 13:50:40
				
				plus(long, TemporalUnit)--LocalTime Java:
				
										Trả về một bản sao của đối tượng LocalTime này với một giá trị chỉ định được thêm vào theo đơn vị tính đã cho.
											
											// Inherited from Temporal interface
											public LocalTime plus(long amountToAdd, TemporalUnit unit)
										
										Các đơn vị tính tiêu chuẩn được hỗ trợ:
											NANOS plusNanos(amountToAdd)
											MICROS plusNanos(amountToAdd*1000)
											MILLIS plusNanos(amountToAdd*100_000)
											SECONDS plusSeconds(amountToAdd)
											MINUTES plusMinutes(amountToAdd)
											HOURS plusHours(amountToAdd)
											HALF_DAYS plusHours(amountToAdd*12)
										
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// plus(long amountToAdd, TemporalUnit unit)
											LocalTime localTime1 = localTime.plus(5, ChronoUnit.HOURS);
											System.out.println("localTime1: " + localTime1); // 18:45:30
											// plus(long amountToAdd, TemporalUnit unit)
											LocalTime localTime2 = localTime.plus(10, ChronoUnit.SECONDS);
											System.out.println("localTime2: " + localTime2); // 13:45:40
											// plus(long amountToAdd, TemporalUnit unit)
											LocalTime localTime3 = localTime.plus(12345, ChronoUnit.NANOS);
											System.out.println("localTime3: " + localTime3); // 13:45:30.000012345
				
				minusX(..) *--LocalTime Java:
				
										- Phương thức minusHours(hoursToSubtract) trả về một bản sao của đối tượng LocalTime này với một lượng giờ chỉ định được trừ đi.
										- Các phương thức minusMinutes(minutesToSubtract), minusSeconds(secondsToSubtract), minusNanos(nanosToSubtract) cũng được hiểu tương tự giống như cái tên của chúng.
											
											public LocalTime minusHours(long hoursToSubtract)
											public LocalTime minusMinutes(long minutesToSubtract)  
											public LocalTime minusSeconds(long secondsToSubtract)
											public LocalTime minusNanos(long nanosToSubtract)
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// minusHours(long hoursToSubtract)
											LocalTime localTime1 = localTime.minusHours(10);
											System.out.println("localTime1: " + localTime1); // 03:45:30
											// minusHours(long hoursToSubtract)
											LocalTime localTime2 = localTime.minusHours(20);
											System.out.println("localTime2: " + localTime2); // 17:45:30
											LocalTime localTime3 = localTime.minusHours(-10);
											System.out.println("localTime3: " + localTime3); // 23:45:30
											// minusMinutes(long minutesToSubtract)
											LocalTime localTime4 = localTime.minusMinutes(5);
											System.out.println("localTime4: " + localTime4); // 13:40:30
											// minusSeconds(long secondstoSubtract)
											LocalTime localTime5 = localTime.minusSeconds(29);
											System.out.println("localTime5: " + localTime5); // 13:45:01
											// minusNanos(long nanosToSubtract)
											LocalTime localTime6 = localTime.minusNanos(12345);
											System.out.println("localTime6: " + localTime6); // 13:45:29.999987655									

				minus(TemporalAmount)--LocalTime Java:
									
										Trả về một bản sao của đối tượng LocalTime này với một lượng thời gian chỉ định được trừ đi.
											
											// Inherited from Temporal interface
											public LocalTime minus(TemporalAmount amountToSubtract)
										
										Bạn có thể sử dụng phương thức TemporalAmount.subtractFrom(Temporal) để có được kết quả tương tự.
											
											// Defined in TemporalAmount interface:
											public Temporal subtractFrom(Temporal temporal)
										
										Ví dụ:
										
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// ofSeconds(long seconds, long nanoAdjustment)
											TemporalAmount amount1 = Duration.ofSeconds(10, 12345);
											// minus(TemporalAmount amountToSubtract)
											LocalTime localTime1 = localTime.minus(amount1);
											System.out.println("localTime1: " + localTime1); // 13:45:19.999987655
											// minus(TemporalAmount amountToSubtract)
											LocalTime from = LocalTime.of(10, 20, 35); // of(int hour, int minute, int second)
											LocalTime to = LocalTime.of(10, 25, 45);
											TemporalAmount amount2 = Duration.between(from, to); // 00:05:10
											LocalTime localTime2 = localTime.minus(amount2);
											System.out.println("localTime2: " + localTime2); // 13:40:20
									
				minus(long, TemporalUnit)--LocalTime Java:
				
										Trả về một bản sao của đối tượng LocalTime này với một giá trị chỉ định được trừ đi theo đơn vị tính đã cho.
											
											// Inherited from Temporal interface
											public LocalTime minus(long amountToSubtract, TemporalUnit unit)
										
										Các đơn vị tính tiêu chuẩn được hỗ trợ:
											
											NANOS minusNanos(amountToSubtract)
											MICROS minusNanos(amountToSubtract*1000)
											MILLIS minusNanos(amountToSubtract*100_000)
											SECONDS minusSeconds(amountToSubtract)
											MINUTES minusMinutes(amountToSubtract)
											HOURS minusHours(amountToSubtract)
											HALF_DAYS minusHours(amountToSubtract*12)
										
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// minus(long amountToSubtract, TemporalUnit unit)
											LocalTime localTime1 = localTime.minus(5, ChronoUnit.HOURS);
											System.out.println("localTime1: " + localTime1); // 08:45:30
											// minus(long amountToSubtract, TemporalUnit unit)
											LocalTime localTime2 = localTime.minus(10, ChronoUnit.SECONDS);
											System.out.println("localTime2: " + localTime2); // 13:45:20
											// minus(long amountToSubtract, TemporalUnit unit)
											LocalTime localTime3 = localTime.minus(12345, ChronoUnit.NANOS);
											System.out.println("localTime3: " + localTime3); // 13:45:29.999987655
				
				withX(..) *--LocalTime Java:
				
										- Phương thức withHour(hour) trả về một bản sao của LocalTime này với giờ được thay đổi thành giờ đã chỉ định.
										- Các phương thức withMinute(minute), withSecond(second), withNano(nanoOfSecond) cũng được hiểu tương tự giống như cái tên của nó.
											
											public LocalTime withHour(int hour)
											public LocalTime withMinute(int minute)
											public LocalTime withSecond(int second)
											public LocalTime withNano(int nanoOfSecond)
												
										Ví dụ:
											
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30"); // 13:45:30
											System.out.println("localTime: " + localTime); // 13:45:30
											System.out.println();
											// withHour(int hour)  [0 - 23]
											LocalTime localTime1 = localTime.withHour(23);
											System.out.println("localTime1: " + localTime1); // 23:45:30
											// withMinute(int minute)   [0 - 59]
											LocalTime localTime2 = localTime.withMinute(59);
											System.out.println("localTime2: " + localTime2); // 13:59:30
											// withSecond(int second)   [0 - 59]
											LocalTime localTime3 = localTime.withSecond(59);
											System.out.println("localTime3: " + localTime3); // 13:45:59
											// withNano(int nanoOfSecond)    [0 - 10^9-1]
											LocalTime localTime4 = localTime.withNano(12345);
											System.out.println("localTime4: " + localTime4); // 13:45:30.000012345
				
				with(TemporalAdjuster)--LocalTime Java:
				
										Trả về bản sao của đối tượng LocalDate này, với dữ liệu thời gian được điều chỉnh bởi đối tượng TemporalAdjuster.
											
											// Inherited from Temporal interface
											public LocalTime with(TemporalAdjuster adjuster)
										
										Ví dụ:
											
											LocalTime now = LocalTime.now();
											System.out.println("Now is: " + now);
											System.out.println();

											// with(TemporalAdjuster adjuster)
											LocalTime noon = now.with(LocalTime.NOON);
											System.out.println("NOON: " + noon); // 12:00

											// with(TemporalAdjuster adjuster)
											LocalTime midnight = now.with(LocalTime.MIDNIGHT);
											System.out.println("MIDNIGHT: " + midnight);  // 00:00
										
										Ví dụ: Viết một TemporalAdjuster tuỳ biến:
											
											package org.o7planning.localtime.ex;
											import java.time.LocalTime;
											import java.time.temporal.ChronoField;
											import java.time.temporal.Temporal;
											import java.time.temporal.TemporalAdjuster;
											public class LocalTime_with_adjuster_ex2 {
												public static void main(String[] args) {
													LocalTime now = LocalTime.now();
													System.out.println("Now is: " + now);
													System.out.println();
													LocalTime lastMinOfHour = now.with(new LastMinOfHourAdjuster());
													System.out.println("lastMinOfHour: " + lastMinOfHour);
												}
											}
											class LastMinOfHourAdjuster implements TemporalAdjuster {
												@Override
												public Temporal adjustInto(Temporal temporal) {
													LocalTime t = LocalTime.from(temporal);
													return t.with(ChronoField.MINUTE_OF_HOUR, 59);
												}
											};
											Output:
												Now is: 19:37:57.524205
												lastMinOfHour: 19:59:57.524205
				
				with(TemporalField, long)--LocalTime Java:
				
										Trả về bản sao của đối tượng LocalTime này với trường (field) chỉ định được thay đổi sang giá trị mới.
											
											// Inherited from Temporal interface
											public LocalTime with(TemporalField field, long newValue)
										
										Ví dụ:
										
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime myTime = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											System.out.println("myTime is: " + myTime);
											System.out.println("myTime CLOCK_HOUR_OF_AMPM: " + myTime.get(ChronoField.CLOCK_HOUR_OF_AMPM)); // 1
											System.out.println("myTime CLOCK_HOUR_OF_DAY: " + myTime.get(ChronoField.CLOCK_HOUR_OF_DAY)); // 13
											System.out.println("myTime SECOND_OF_MINUTE: " + myTime.get(ChronoField.SECOND_OF_MINUTE)); // 30
											System.out.println();
											LocalTime localTime1 = myTime.with(ChronoField.CLOCK_HOUR_OF_AMPM, 10); // 22:45:30.123450
											System.out.println("localTime1: " + localTime1);
											LocalTime localTime2 = myTime.with(ChronoField.CLOCK_HOUR_OF_DAY, 10); // 10:45:30.123450
											System.out.println("localTime2: " + localTime2);
											LocalTime localTime3 = myTime.with(ChronoField.SECOND_OF_MINUTE, 59); // 13:45:59.123450
											System.out.println("localTime3: " + localTime3);
				
				adjustInto(Temporal)--LocalTime Java:
				
										Phương thức adjustInto(Temporal) trả về bản sao của đối tượng Temporal đã cho với dữ liệu thời gian được điều chỉnh để giống với đối tượng LocalTime này.
											
											Before adjustInto(): 2021-06-18T17:18:06.355673+06:00[Asia/Bishkek]
											After adjustInto(): 2021-06-18T19:30:55+06:00[Asia/Bishkek]
				
				atDate(LocalDate)--LocalTime Java:
				
										Phương thức atDate(LocalDate) được sử dụng để kết hợp đối tượng LocalTime này với đối tượng LocalDate được chỉ định để tạo ra một đối tượng LocalDateTime.
											
											public LocalDateTime atDate(LocalDate date)
										
										Ví dụ:
											
											LocalTime localTime = LocalTime.parse("19:30:55");
											LocalDate localDate = LocalDate.parse("2000-05-20");
											LocalDateTime localDateTime = localTime.atDate(localDate);
											System.out.println(localDateTime); // 2000-05-20T19:30:55
				
				atOffset(ZoneOffset)--LocalTime Java:
				
										Phương thức atOffset(ZoneOffset) được sử dụng để kết hợp đối tượng LocalTime này với đối tượng ZoneOffset được chỉ định để tạo ra một đối tượng OffsetTime.
											
											public OffsetTime atOffset(ZoneOffset offset)
										
										Ví dụ:
											
											LocalTime localTime = LocalTime.parse("16:30:59");
											System.out.println("localTime: " + localTime); // 16:30:59
											// Create a ZoneOffset object
											ZoneOffset offset = ZoneOffset.ofHours(2);
											// atOffset(ZoneOffset)
											OffsetTime offsetTime = localTime.atOffset(offset);
											System.out.println("offsetTime: " + offsetTime); // 16:30:59+02:00
				
				toX(..) *--LocalTime Java:
				
										public int toSecondOfDay()

										public long toNanoOfDay()  

										public long toEpochSecond(LocalDate date, ZoneOffset offset)
				
				until(Temporal, TemporalUnit)--LocalTime Java:
				
										Tính lượng thời gian cho đến ngày-giờ khác theo đơn vị được chỉ định.
											
											// Inherited from Temporal interface
											public long until(Temporal endExclusive, TemporalUnit unit)
										
										Ví dụ:
										
											LocalTime localTime_from = LocalTime.of(1, 0, 0);
											System.out.println("Time From: " + localTime_from); // 01:00
											LocalTime localTime_to = LocalTime.of(13, 30, 59);  
											System.out.println("Time To: " + localTime_to); // 13:30:59
											System.out.println();
											long hours = localTime_from.until(localTime_to, ChronoUnit.HOURS);
											System.out.println("hours: " + hours); // 12
											long minutes = localTime_from.until(localTime_to, ChronoUnit.MINUTES);
											System.out.println("minutes: " + minutes); // 750
												Bạn cũng có thể sử dụng phương thức TemporalUnit.between(Temporal,Temporal) để có kết quả tương tự:
													LocalTime localTime_from = LocalTime.of(1, 0, 0);
											System.out.println("Time From: " + localTime_from); // 01:00
											LocalTime localTime_to = LocalTime.of(13, 30, 59);
											System.out.println("Time To: " + localTime_to); // 13:30:59
											System.out.println();
											long hours = ChronoUnit.HOURS.between(localTime_from, localTime_to);
											System.out.println("hours: " + hours); // 12
											long minutes = ChronoUnit.MINUTES.between(localTime_from, localTime_to);
											System.out.println("minutes: " + minutes); // 750
				
				truncatedTo(TemporalUnit)--LocalTime Java:
				
										Trả về một bản sao của đối tượng LocalTime này với thời gian bị cắt cụt (truncated) theo đơn vị tính chỉ định.
											
											public LocalTime truncatedTo(TemporalUnit unit)
										
										Ví dụ:
											
											LocalTime localTime = LocalTime.parse("21:30:59.12345");
											System.out.println("localTime: " + localTime); // 21:30:59.123450
											// truncatedTo(TemporalUnit unit)
											LocalTime truncatedLocalTime = localTime.truncatedTo(ChronoUnit.MINUTES);											
											System.out.println("truncatedLocalTime: " + truncatedLocalTime); // 21:30
				
				range(TemporalField)--LocalTime Java:
				
										Trả về một phạm vi các giá trị hợp lệ cho trường (field) được chỉ định.
											
											// Inherited from TemporalAccessor interface
											public ValueRange range(TemporalField field)
										
										Ví dụ:
											
											LocalTime localTime = LocalTime.parse("09:30:45.12345");
											// range(TemporalField field)
											ValueRange range1 = localTime.range(ChronoField.MILLI_OF_SECOND);
											System.out.println("Range in MILLI_OF_SECOND: " + range1);
											ValueRange range2 = localTime.range(ChronoField.CLOCK_HOUR_OF_DAY);
											System.out.println("Range in CLOCK_HOUR_OF_DAY: " + range2);
											ValueRange range3 = localTime.range(ChronoField.CLOCK_HOUR_OF_AMPM);
											System.out.println("Range in CLOCK_HOUR_OF_AMPM: " + range3);
													Output:
														Range in MILLI_OF_SECOND: 0 - 999
											Range in CLOCK_HOUR_OF_DAY: 1 - 24
											Range in CLOCK_HOUR_OF_DAY: 1 - 12
				
				query(TemporalQuery<R>)--LocalTime Java:
				
										Truy vấn đối tượng LocalTime này bằng đối tượng TemporalQuery đã chỉ định để trích ra thông tin.
											
											// Inherited from TemporalAccessor interface
											public <R> R query(TemporalQuery<R> query)
										
										Ví dụ:
											
											package org.o7planning.localtime.ex;
											import java.time.LocalDate;
											import java.time.LocalTime;
											import java.time.ZoneId;
											import java.time.ZoneOffset;
											import java.time.chrono.Chronology;
											import java.time.temporal.TemporalQueries;
											import java.time.temporal.TemporalUnit;
											public class LocalTime_query_ex1 {
												public static void main(String[] args) {
													LocalTime localTime = LocalTime.of(11, 30, 59, 12345);  
													System.out.printf("localTime: %s%n", localTime); // 11:30:59.000012345
													TemporalUnit unit = localTime.query(TemporalQueries.precision());
													System.out.printf("precision: %s%n", unit);
													LocalTime localTime2 = localTime.query(TemporalQueries.localTime());
													System.out.printf("localTime2: %s%n", localTime2);
													LocalDate localDate = localTime.query(TemporalQueries.localDate());
													System.out.printf("localDate: %s%n", localDate);
													ZoneOffset zoneOffset = localTime.query(TemporalQueries.offset());
													System.out.printf("ZoneOffset: %s%n", zoneOffset);
													ZoneId zone = localTime.query(TemporalQueries.zone());
													System.out.printf("zone: %s%n", zone);
													ZoneId zoneId = localTime.query(TemporalQueries.zoneId());
													System.out.printf("zoneId: %s%n", zoneId);
													Chronology chronology = localTime.query(TemporalQueries.chronology());
													System.out.printf("chronology: %s%n", chronology);
												}
											}
											Output:
											
												localTime: 11:30:59.000012345
												precision: Nanos
												localTime2: 11:30:59.000012345
												localDate: null
												ZoneOffset: null
												zone: null
												zoneId: null
												chronology: null
				
				isSupported(TemporalField)--LocalTime Java:
				
										// Inherited from TemporalAccessor interface									
										public boolean isSupported(TemporalField field)
										
										Về cơ bản, LocalTime hỗ trợ các trường tiêu chuẩn sau:
											
											ChronoField.NANO_OF_SECOND
											ChronoField.NANO_OF_DAY
											ChronoField.MICRO_OF_SECOND
											ChronoField.MICRO_OF_DAY
											ChronoField.MILLI_OF_SECOND
											ChronoField.MILLI_OF_DAY
											ChronoField.SECOND_OF_MINUTE
											ChronoField.SECOND_OF_DAY
											ChronoField.MINUTE_OF_HOUR
											ChronoField.MINUTE_OF_DAY
											ChronoField.HOUR_OF_AMPM
											ChronoField.CLOCK_HOUR_OF_AMPM
											ChronoField.HOUR_OF_DAY
											ChronoField.CLOCK_HOUR_OF_DAY
											ChronoField.AMPM_OF_DAY
										
										Ví dụ:
										
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											// boolean isSupported(TemporalField field)
											// LocalTime does not support ChronoField.DAY_OF_MONTH, DAY_OF_YEAR,.. (** Used for LocalDateTime, LocalDate)
											System.out.println("DAY_OF_MONTH is supported? " + localTime.isSupported(ChronoField.DAY_OF_MONTH)); // false
											System.out.println("DAY_OF_YEAR is supported? " + localTime.isSupported(ChronoField.DAY_OF_YEAR)); // false
											// LocalTime support ChronoField.MINUTE_OF_DAY, SECOND_OF_MINUTE,..
											System.out.println("MINUTE_OF_DAY is supported? " + localTime.isSupported(ChronoField.MINUTE_OF_DAY)); // true
											System.out.println("SECOND_OF_MINUTE is supported? " + localTime.isSupported(ChronoField.SECOND_OF_MINUTE)); // true
				
				isSupported(TemporalUnit)--LocalTime Java:
				
										Kiểm tra xem một TemporalUnit đã cho có được hỗ trợ hay không.
											
											// Inherited from Temporal interface
											public boolean isSupported(TemporalUnit unit)
										
										Về cơ bản, LocalTime hỗ trợ các đơn vị tính tiêu chuẩn sau:
											
											ChronoUnit.NANOS
											ChronoUnit.MICROS
											ChronoUnit.MILLIS
											ChronoUnit.SECONDS
											ChronoUnit.MINUTES
											ChronoUnit.HOURS
											ChronoUnit.HALF_DAYS
										
										Ví dụ:
										
											// Format: 13:45:30.12345 or 13:45:30 or 13:45
											LocalTime localTime = LocalTime.parse("13:45:30.12345"); // 13:45:30.123450000
											// boolean isSupported(TemporalUnit unit)
											// LocalTime does not support ChronoUnit.CENTURIES, WEEKS,.. (** Used for LocalDateTime, LocalDate)
											System.out.println("CENTURIES is supported? " + localTime.isSupported(ChronoUnit.CENTURIES)); // false
											System.out.println("WEEKS is supported? " + localTime.isSupported(ChronoUnit.WEEKS)); // false
											// LocalTime support ChronoUnit.HOURS, MINUTES,..
											System.out.println("HOURS is supported? " + localTime.isSupported(ChronoUnit.HOURS)); // true
											System.out.println("MINUTES is supported? " + localTime.isSupported(ChronoUnit.MINUTES)); // true
												
			LocalDateTime--Ngày và giờ trong Java:	
			
									Represents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)
									
									LocalDateTime currentDateTime = LocalDateTime.now();
									LocalDateTime specificDateTime = LocalDateTime.of(2022, 12, 31, 15, 30); // 2022-12-31T15:30
									int year = currentDateTime.getYear();
									int month = currentDateTime.getMonthValue();
									int day = currentDateTime.getDayOfMonth();
									int hour = currentDateTime.getHour();
									int minute = currentDateTime.getMinute();
									int second = currentDateTime.getSecond();

				Lớp LocalDateTime đại diện cho ngày tháng và thời gian địa phương (local date time) trong hệ thống lịch ISO, nó không bao gồm thông tin múi giờ.
										
										public final class LocalDateTime
										implements Temporal, TemporalAdjuster, ChronoLocalDateTime<LocalDate>, Serializable
				
				Lớp LocalDateTime nằm trong package java.time. Cũng giống như các lớp khác được giới thiệu trong Java 8 Date Time API, LocalDateTime là bất biến (immutable) điều này có nghĩa là tất cả các tính toán
				trên LocalDateTime đều tạo ra một đối tượng LocalDateTime mới, vì vậy nó an toàn khi được sử dụng trong môi trường multithreading.
				
				Static Factory methodsLocalDateTime--LocalDateTime Java:
				
					Lớp LocalDateTime không cung cấp bất kỳ một constructor nào, nhưng nó cung cấp các phương thức nhà máy tĩnh (static factory method) để tạo ra một đối tượng mới:
											
											public static LocalDateTime now()  
											public static LocalDateTime now(ZoneId zone)  
											public static LocalDateTime now(Clock clock)
											public static LocalDateTime of(int year, Month month, int dayOfMonth,
																		   int hour, int minute)
											public static LocalDateTime of(int year, Month month, int dayOfMonth,
																		   int hour, int minute, int second)
											public static LocalDateTime of(int year, Month month, int dayOfMonth,
																		   int hour, int minute, int second, int nanoOfSecond)
											public static LocalDateTime of(int year, int month, int dayOfMonth,
																		   int hour, int minute)
											public static LocalDateTime of(int year, int month, int dayOfMonth,
																		   int hour, int minute, int second)
											public static LocalDateTime of(int year, int month, int dayOfMonth,
																		   int hour, int minute, int second, int nanoOfSecond)
											public static LocalDateTime of(LocalDate date, LocalTime time)
											public static LocalDateTime ofInstant(Instant instant, ZoneId zone)
											public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset)
											public static LocalDateTime from(TemporalAccessor temporal)  
											public static LocalDateTime parse(CharSequence text)
											public static LocalDateTime parse(CharSequence text, DateTimeFormatter formatter)
					
					Tạo đối tượng LocalDateTime đại diện cho ngày tháng và thời gian hiện thời từ đồng hồ hệ thống và múi giờ mặc định (Trên máy tính của bạn).
					
											// Ex: Current Date Time from the system clock in the default time-zone.
											LocalDateTime dt1 = LocalDateTime.now();
											System.out.println("dt1: " + dt1);
											
											// Ex: Current Date Time from the specified clock.
											Clock clock2 = Clock.systemDefaultZone();
											LocalDateTime dt2 = LocalDateTime.now(clock2);
											System.out.println("dt2: " + dt2);
											
											// Ex: Current Date Time from the system clock in the specified time-zone.
											ZoneId zoneId3 = ZoneId.systemDefault();
											LocalDateTime dt3 = LocalDateTime.now(zoneId3);
											System.out.println("dt3: " + dt3);
											
											Output:
												dt1: 2021-06-02T21:33:45.249967
												dt2: 2021-06-02T21:33:45.250606
												dt3: 2021-06-02T21:33:45.250714
					
					Tạo đối tượng LocalDateTime từ các giá trị ngày, tháng, năm, giờ, phút, giây,.. được chỉ định:
											
											// Ex: of(int year, Month month, int dayOfMonth, int hour, int minute)
											LocalDateTime dt1 = LocalDateTime.of(2000, Month.MAY, 20, 13, 45, 30);  
											System.out.println("dt1: " + dt1); // 2000-05-20T13:45:30
											
											// Ex: of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond)
											LocalDateTime dt2 = LocalDateTime.of(2000, 5, 20, 13, 45, 30, 12345);
											System.out.println("dt2: " + dt2); // 2000-05-20T13:45:30.000012345
					
					Tạo đối tượng LocalDateTime bằng cách kết hợp 2 đối tượng LocalDate và LocalTime:
											
											LocalDate date = LocalDate.parse("2020-05-15");
											LocalTime time = LocalTime.parse("13:45:30");										
											// Ex: of(LocalDate date, LocalTime time)
											LocalDateTime dt  = LocalDateTime.of(date, time);
											System.out.println("Date time: " + dt); // 2020-05-15T13:45:30
					
					Tạo một đối tượng LocalDateTime từ một đối tượng TemporalAccessor:
					
											// TemporalAccessor
											ZonedDateTime z = ZonedDateTime.of(2016, 10, 12,
																			   15, 20, 30, 0,
																			   ZoneId.systemDefault());
											System.out.println("ZonedDateTime: " + z); // 2016-10-12T15:20:30+06:00[Asia/Bishkek]
											// from(TemporalAccessor temporal)
											LocalDateTime dateTime = LocalDateTime.from(z);
											System.out.println("dateTime: " + dateTime); // 2016-10-12T15:20:30
					
					Tạo đối tượng LocalDateTime từ các đối tượng Instant và ZoneId:
					
											Instant instant = Instant.now();
											ZoneId zoneId = ZoneId.systemDefault();
											// ofInstant(Instant instant, ZoneId zone)
											LocalDateTime dateTime = LocalDateTime.ofInstant(instant, zoneId);
											System.out.println("dateTime: " + dateTime); // 2021-06-02T21:07:39.970782
					
					Tạo đối tượng LocalDateTime từ việc phân tích một văn bản có định dạng ngày tháng và thời gian:
					
											- Không có format phía sau thì phải theo chuẩn yyyy-MM-ddTmm:HH:ss.SSS, còn không phải có format rõ ràng
											- Đã về dạng kiểu datetime thì phải luôn là dạng yyyy-MM-ddTmm:HH:ss.SSS
					
											// Default Format: yyyy-MM-ddTmm:HH:ss
											LocalDateTime dt1 = LocalDateTime.parse("2011-11-20T13:45:30");
											System.out.println("dt1: " + dt1); // 2011-11-20T13:45:30
											
											// Default Format: yyyy-MM-ddTmm:HH:ss.SSS
											LocalDateTime dt2 = LocalDateTime.parse("2011-11-20T13:45:30.12345");
											System.out.println("dt2: " + dt2); // 2011-11-20T13:45:30.123450
											
											// Ex: parse(CharSequence text, DateTimeFormatter formatter)
											DateTimeFormatter fmt3 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
											LocalDateTime dt3 = LocalDateTime.parse("20/11/2020 13:45:30", fmt3);
											System.out.println("dt3: " + dt3); // 2020-11-20T13:45:30
				
				isAfter(..), isBefore(..)--LocalDateTime Java:
				
					Phương thức isBefore(ChronoLocalDate) được sử dụng để kiểm tra đối tượng LocalDateTime này có đứng trước (before) một đối tượng được chỉ định khác trên dòng thời gian hay không.
											
											// Inherited from ChronoLocalDateTime interface
											public boolean isBefore(ChronoLocalDateTime<?> other)
										
					Phương thức isAfter(ChronoLocalDate) được sử dụng để kiểm tra đối tượng LocalDateTime này có đứng sau (after) một đối tượng được chỉ định khác trên dòng thời gian hay không.
											
											// Inherited from ChronoLocalDateTime interface
											public boolean isAfter(ChronoLocalDateTime<?> other)
				
				format(DateTimeFormatter)--LocalDateTime Java:
				
										Định dạng đối tượng LocalDateTime này bằng một DateTimeFormatter được chỉ định.
											
											public String format(DateTimeFormatter formatter)
										
										Ví dụ:
										
											LocalDateTime localDateTime = LocalDateTime.of(2020, 5, 15, 20, 59);
											System.out.println("localDateTime: " + localDateTime); // 2020-May-15 20:59
											System.out.println();
											// For example:
											// '2011-12-03T10:15:30',
											// '2011-12-03T10:15:30+01:00' if has offset
											// '2011-12-03T10:15:30+01:00[Europe/Paris]' if has time-zone
											DateTimeFormatter fmt1 = DateTimeFormatter.ISO_DATE_TIME;
											System.out.println("ISO_DATE_TIME: " + localDateTime.format(fmt1)); // 2020-05-15T20:59:00  
											// Custom Formatter:
											DateTimeFormatter fmt2 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss.SSS");  
											// 15/05/2020 20:59:00.000
											System.out.println("dd/MM/yyyy HH:mm:ss.SSS: " + localDateTime.format(fmt2));
				
				getX() *--LocalDateTime Java:
				
										Phương thức getYear() trả về năm được biểu thị bởi LocalDateTime này, nó tương đương với việc gọi phương thức get(ChronoField.YEAR), nếu muốn lấy năm trong kỷ nguyên (year of era)
										hãy gọi phương thức get(ChronoField.YEAR_OF_ERA).
											
											public int getYear()
											public int getMonthValue()  
											public Month getMonth()  
											public int getDayOfMonth()  
											public int getDayOfYear()   
											public DayOfWeek getDayOfWeek()
											public int getHour()  
											public int getMinute()
											public int getSecond()
											public int getNano()
										
										Ví dụ:
											
											LocalDateTime dateTime = LocalDateTime.parse("2020-05-15T13:45:30.12345");
											System.out.println("Date Time: " + dateTime); // 2020-05-15T13:45:30.123450
											System.out.println();										
											System.out.println("getDayOfYear(): " + dateTime.getDayOfYear()); // 136
											System.out.println("getDayOfMonth(): " + dateTime.getDayOfMonth()); // 15
											System.out.println("getYear(): " + dateTime.getYear());  // 2020
											System.out.println("getMonth(): " + dateTime.getMonth());  // Month.MAY (enum)
											System.out.println("getMonthValue(): " + dateTime.getMonthValue()); // 5
											System.out.println("getDayOfWeek(): " + dateTime.getDayOfWeek()); // DayOfWeek.FRIDAY (enum)
											System.out.println("getHour(): " + dateTime.getHour());  // 13
											System.out.println("getMinute(): " + dateTime.getMinute()); // 45
											System.out.println("getSecond(): " + dateTime.getSecond()); // 30
											System.out.println("getNano(): " + dateTime.getNano());  // 123450000
				
				get(TemporalField)--LocalDateTime Java:
				
										Trả về giá trị của trường (field) đã chỉ định của đối tượng LocalDateTime này dưới dạng một số nguyên 32 bit.
											
											public int get(TemporalField field)
										
										Chú ý: Một số trường có thể không được hỗ trợ bởi LocalDateTime và UnsupportedTemporalTypeException sẽ được ném ra. Để chắc chắn, hãy sử dụng phương thức isSupported(TemporalField) để kiểm tra xem một trường nào đó có được LocalDateTime hỗ trợ hay không.
										
										Ví dụ:
											
											LocalDateTime dt = LocalDateTime.parse("2020-05-15T13:45:30.12345");
											System.out.println("Date Time: " + dt); // 2020-05-15T13:45:30.123450
											System.out.println();
											// int get(TemporalField field)
											System.out.println("DAY_OF_MONTH: " + dt.get(ChronoField.DAY_OF_MONTH)); // 15
											System.out.println("DAY_OF_WEEK: " + dt.get(ChronoField.DAY_OF_WEEK)); // 5
											System.out.println("DAY_OF_YEAR: " + dt.get(ChronoField.DAY_OF_YEAR)); // 136
											System.out.println("ERA: " + dt.get(ChronoField.ERA)); // 1
											System.out.println("YEAR: " + dt.get(ChronoField.YEAR)); // 2020
											System.out.println("YEAR_OF_ERA: " + dt.get(ChronoField.YEAR_OF_ERA)); // 2020
											System.out.println("ALIGNED_DAY_OF_WEEK_IN_MONTH: " + dt.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)); // 1
											System.out.println("ALIGNED_DAY_OF_WEEK_IN_YEAR: " + dt.get(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)); // 3
											System.out.println("ALIGNED_WEEK_OF_MONTH: " + dt.get(ChronoField.ALIGNED_WEEK_OF_MONTH)); // 3
											System.out.println("ALIGNED_WEEK_OF_YEAR: " + dt.get(ChronoField.ALIGNED_WEEK_OF_YEAR)); // 20
											// Use getLong() instead
											// System.out.println("PROLEPTIC_MONTH: " + dt.get(ChronoField.PROLEPTIC_MONTH)); // 24244
											// System.out.println("EPOCH_DAY: " + dt.get(ChronoField.EPOCH_DAY)); // 18397
											// Time:
											System.out.println("AMPM_OF_DAY: " + dt.get(ChronoField.AMPM_OF_DAY)); // 13
											System.out.println("CLOCK_HOUR_OF_AMPM: " + dt.get(ChronoField.CLOCK_HOUR_OF_AMPM)); // 1
											System.out.println("CLOCK_HOUR_OF_DAY: " + dt.get(ChronoField.CLOCK_HOUR_OF_DAY)); // 13
											System.out.println("HOUR_OF_AMPM: " + dt.get(ChronoField.HOUR_OF_AMPM)); // 1
											System.out.println("HOUR_OF_DAY: " + dt.get(ChronoField.HOUR_OF_DAY)); // 13
											System.out.println("MILLI_OF_DAY: " + dt.get(ChronoField.MILLI_OF_DAY)); // 49530123
											System.out.println("MILLI_OF_SECOND: " + dt.get(ChronoField.MILLI_OF_SECOND)); // 123
											System.out.println("MINUTE_OF_DAY: " + dt.get(ChronoField.MINUTE_OF_DAY)); // 825
											System.out.println("MINUTE_OF_HOUR: " + dt.get(ChronoField.MINUTE_OF_HOUR)); // 45
											System.out.println("MICRO_OF_SECOND: " + dt.get(ChronoField.MICRO_OF_SECOND)); // 123450
											System.out.println("NANO_OF_SECOND: " + dt.get(ChronoField.NANO_OF_SECOND)); // 123450000
											System.out.println("SECOND_OF_DAY: " + dt.get(ChronoField.SECOND_OF_DAY)); // 49530
											System.out.println("SECOND_OF_MINUTE: " + dt.get(ChronoField.SECOND_OF_MINUTE)); // 30
											// Use getLong() instead
											// System.out.println("NANO_OF_DAY: " + dt.get(ChronoField.NANO_OF_DAY)); // 49530123450000
											// Unsupported
											// System.out.println("INSTANT_SECONDS: " + dt.get(ChronoField.INSTANT_SECONDS));
											// System.out.println("OFFSET_SECONDS: " + dt.get(ChronoField.OFFSET_SECONDS));
				
				getLong(TemporalField)--LocalDateTime Java:
				
										Trả về giá trị của trường (field) đã chỉ định của đối tượng LocalDateTime này dưới dạng một số nguyên 64 bit.
											
											public long getLong(TemporalField field)
										
										Chú ý: Một số trường có thể không được hỗ trợ bởi LocalDateTime và UnsupportedTemporalTypeException sẽ được ném ra. Để chắc chắn, hãy sử dụng phương thức isSupported(TemporalField) để kiểm tra xem một trường nào đó có được LocalDateTime hỗ trợ hay không.
										
										Ví dụ:
											
											LocalDateTime dt = LocalDateTime.parse("2020-05-15T13:45:30.12345");
											System.out.println("Date Time: " + dt); // 2020-05-15T13:45:30.123450
											System.out.println();
											// long getLong(TemporalField field)
											System.out.println("DAY_OF_MONTH: " + dt.getLong(ChronoField.DAY_OF_MONTH)); // 15
											System.out.println("DAY_OF_WEEK: " + dt.getLong(ChronoField.DAY_OF_WEEK)); // 5
											System.out.println("DAY_OF_YEAR: " + dt.getLong(ChronoField.DAY_OF_YEAR)); // 136
											System.out.println("ERA: " + dt.getLong(ChronoField.ERA)); // 1
											System.out.println("YEAR: " + dt.getLong(ChronoField.YEAR)); // 2020
											System.out.println("YEAR_OF_ERA: " + dt.getLong(ChronoField.YEAR_OF_ERA)); // 2020
											System.out.println("ALIGNED_DAY_OF_WEEK_IN_MONTH: " + dt.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)); // 1
											System.out.println("ALIGNED_DAY_OF_WEEK_IN_YEAR: " + dt.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)); // 3
											System.out.println("ALIGNED_WEEK_OF_MONTH: " + dt.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH)); // 3
											System.out.println("ALIGNED_WEEK_OF_YEAR: " + dt.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR)); // 20
											//
											System.out.println("PROLEPTIC_MONTH: " + dt.getLong(ChronoField.PROLEPTIC_MONTH)); // 24244
											System.out.println("EPOCH_DAY: " + dt.getLong(ChronoField.EPOCH_DAY)); // 18397
											// Time:
											System.out.println("AMPM_OF_DAY: " + dt.getLong(ChronoField.AMPM_OF_DAY)); // 13
											System.out.println("CLOCK_HOUR_OF_AMPM: " + dt.getLong(ChronoField.CLOCK_HOUR_OF_AMPM)); // 1
											System.out.println("CLOCK_HOUR_OF_DAY: " + dt.getLong(ChronoField.CLOCK_HOUR_OF_DAY)); // 13
											System.out.println("HOUR_OF_AMPM: " + dt.getLong(ChronoField.HOUR_OF_AMPM)); // 1
											System.out.println("HOUR_OF_DAY: " + dt.getLong(ChronoField.HOUR_OF_DAY)); // 13
											System.out.println("MILLI_OF_DAY: " + dt.getLong(ChronoField.MILLI_OF_DAY)); // 49530123
											System.out.println("MILLI_OF_SECOND: " + dt.getLong(ChronoField.MILLI_OF_SECOND)); // 123
											System.out.println("MINUTE_OF_DAY: " + dt.getLong(ChronoField.MINUTE_OF_DAY)); // 825
											System.out.println("MINUTE_OF_HOUR: " + dt.getLong(ChronoField.MINUTE_OF_HOUR)); // 45
											System.out.println("MICRO_OF_SECOND: " + dt.getLong(ChronoField.MICRO_OF_SECOND)); // 123450
											System.out.println("NANO_OF_SECOND: " + dt.getLong(ChronoField.NANO_OF_SECOND)); // 123450000
											System.out.println("SECOND_OF_DAY: " + dt.getLong(ChronoField.SECOND_OF_DAY)); // 49530
											System.out.println("SECOND_OF_MINUTE: " + dt.getLong(ChronoField.SECOND_OF_MINUTE)); // 30
											//  
											System.out.println("NANO_OF_DAY: " + dt.getLong(ChronoField.NANO_OF_DAY)); // 49530123450000
											// Unsupported
											// System.out.println("INSTANT_SECONDS: " + dt.getLong(ChronoField.INSTANT_SECONDS));
											// System.out.println("OFFSET_SECONDS: " + dt.getLong(ChronoField.OFFSET_SECONDS));
				
				toLocalDate()--LocalDateTime Java:
				
										Trả về phần LocalDate của đối tượng LocalDateTime này.
											
											// Inherited from ChronoLocalDateTime interface
											public LocalDate toLocalDate()
										
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 05, 15, 13, 30, 45, 123);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45.000000123
											System.out.println();
											LocalDate localDate = localDateTime.toLocalDate();
											System.out.println("localDate: " + localDate); // 2020-05-15
				
				toLocalTime()--LocalDateTime Java:
				
										Trả về phần LocalTime của đối tượng LocalDateTime này.
											
											// Inherited from ChronoLocalDateTime interface
											public LocalTime toLocalTime()
										
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 05, 15, 13, 30, 45, 123);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45.000000123
											System.out.println();
											LocalTime localTime = localDateTime.toLocalTime();
											System.out.println("localTime: " + localTime); // 13:30:45.000000123
				
				atZone(ZoneId)--LocalDateTime Java:
				
										Phương thức atZone(ZoneId) được sử dụng để kết hợp đối tượng LocalDateTime này với đối tượng ZoneId được chỉ định để tạo ra một đối tượng ZonedDateTime.
											
											// Inherited from ChronoLocalDateTime interface
											public ZonedDateTime atZone(ZoneId zone)
										
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 05, 15, 13, 30, 45, 123);
											System.out.println(localDateTime); // 2020-05-15T13:30:45.000000123
											System.out.println();
											ZoneId parisZoneId = ZoneId.of("Europe/Paris");
											ZonedDateTime zonedDateTime = localDateTime.atZone(parisZoneId);
											System.out.println(zonedDateTime); // 2020-05-15T13:30:45.000000123+02:00[Europe/Paris]
				
				atOffset(ZoneOffset)--LocalDateTime Java:
				
										Phương thức atOffset(ZoneOffset) được sử dụng để kết hợp đối tượng LocalDateTime này với đối tượng ZoneOffset được chỉ định để tạo ra một đối tượng OffsetDateTime.
											
											public OffsetDateTime atOffset(ZoneOffset offset)
										
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 05, 15, 13, 30, 45, 123);
											System.out.println(localDateTime); // 2020-05-15T13:30:45.000000123
											System.out.println();
											ZoneOffset zoneOffset2H30 = ZoneOffset.ofHoursMinutes(2, 30);
											OffsetDateTime offsetDateTime = localDateTime.atOffset(zoneOffset2H30);
											System.out.println(offsetDateTime); // 2020-05-15T13:30:45.000000123+02:30
				
				plusX(..) *--LocalDateTime Java:
				
									- Các phương thức plusSeconds(seconds) trả về một bản sao của đối tượng LocalDateTime này với một số lượng giây chỉ định được thêm vào.
									- Các phương thức plusNanos(nanos), plusHours(hours),... cũng được hiểu tương tự như cái tên của chúng.
											
											public LocalDateTime plusYears(long years)  
											public LocalDateTime plusMonths(long months)  
											public LocalDateTime plusWeeks(long weeks)  
											public LocalDateTime plusDays(long days)  
											public LocalDateTime plusHours(long hours)
											public LocalDateTime plusMinutes(long minutes)  
											public LocalDateTime plusSeconds(long seconds)  
											public LocalDateTime plusNanos(long nanos)
									
									Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// plusDays(long daysToAdd)
											LocalDateTime localDateTime1 = localDateTime.plusDays(10);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-05-25T13:30:45
											LocalDateTime localDateTime2 = localDateTime.plusDays(-15);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-04-30T13:30:45
											// plusHours(long hoursToAdd)
											LocalDateTime localDateTime3 = localDateTime.plusHours(12);
											System.out.println("localDateTime3: " + localDateTime3); // 2020-05-16T01:30:45
				
				plus(TemporalAmount)--LocalDateTime Java:
				
										Trả về một bản sao của đối tượng LocalDateTime này với một giá trị chỉ định được thêm vào.
											
											// Inherited from Temporal interface
											public LocalDateTime plus(TemporalAmount amountToAdd)
										
										Ví dụ:
										
											LocalDateTime localDateTime = LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// plus(TemporalAmount amountToAdd)
											TemporalAmount amount1 = Period.ofDays(5);
											LocalDateTime localDateTime1 = localDateTime.plus(amount1);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-05-20T13:30:45
											// plus(TemporalAmount amountToAdd)
											LocalDateTime from = LocalDateTime.of(2020, 5, 10, 0, 0, 0);
											LocalDateTime to = LocalDateTime.of(2020, 5, 12, 12, 0, 0);
											TemporalAmount amount2 = Duration.between(from, to); // 2 days 12 hours
											LocalDateTime localDateTime2 = localDateTime.plus(amount2);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-05-18T01:30:45
				
				plus(long, TemporalUnit)--LocalDateTime Java:
				
										Trả về một bản sao của đối tượng LocalDateTime này với một giá trị chỉ định được thêm vào theo đơn vị tính đã cho.
											
											// Inherited from Temporal interface
											
											public LocalDateTime plus(long amountToAdd, TemporalUnit unit)
										
										Ví dụ:
											
											LocalDateTime localDateTime =  LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// plus(long amountToAdd, TemporalUnit unit)
											LocalDateTime localDateTime1 = localDateTime.plus(20, ChronoUnit.DAYS);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-06-04T13:30:45
											// plus(long amountToAdd, TemporalUnit unit)
											LocalDateTime localDateTime2 = localDateTime.plus(50, ChronoUnit.MINUTES);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-05-15T14:20:45
	
				minusX(..) *--LocalDateTime Java:
				
										- Các phương thức minusSeconds(seconds) trả về một bản sao của đối tượng LocalDateTime này với một số lượng giây chỉ định được trừ đi.
										- Các phương thức minusNanos(nanos), minusHours(hours),... cũng được hiểu tương tự như cái tên của chúng.
											
											public LocalDateTime minusYears(long years)  
											public LocalDateTime minusMonths(long months)  
											public LocalDateTime minusWeeks(long weeks)  
											public LocalDateTime minusDays(long days)  
											public LocalDateTime minusHours(long hours)  
											public LocalDateTime minusMinutes(long minutes)  
											public LocalDateTime minusSeconds(long seconds)  
											public LocalDateTime minusNanos(long nanos)
											
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// minusDays(long daysToSubtract)
											LocalDateTime localDateTime1 = localDateTime.minusDays(10);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-05-05T13:30:45
											LocalDateTime localDateTime2 = localDateTime.minusDays(-15);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-05-30T13:30:45
											// minusHours(long monthsToSubtract)
											LocalDateTime localDateTime3 = localDateTime.minusHours(15);
											System.out.println("localDateTime3: " + localDateTime3); // 2020-05-14T22:30:45
				
				minus(TemporalAmount)--LocalDateTime Java:
				
										Trả về một bản sao của đối tượng LocalDateTime này với một giá trị chỉ định được trừ đi.
											
											// Inherited from Temporal interface
											public LocalDateTime minus(TemporalAmount amountToSubtract)
										
										Ví dụ:
											
											LocalDateTime localDateTime = LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// minus(TemporalAmount amountToSubtract)
											TemporalAmount amount1 = Period.ofDays(20);
											LocalDateTime localDateTime1 = localDateTime.minus(amount1);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-04-25T13:30:45
											// minus(TemporalAmount amountToSubtract)
											LocalDateTime from = LocalDateTime.of(2020, 5, 10, 0, 0, 0);
											LocalDateTime to = LocalDateTime.of(2020, 5, 12, 15, 0, 0);
											TemporalAmount amount2 = Duration.between(from, to); // 2 days 15 hours
											LocalDateTime localDateTime2 = localDateTime.minus(amount2);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-05-12T22:30:45
				
				minus(long, TemporalUnit)--LocalDateTime Java:
				
										Trả về một bản sao của đối tượng LocalDateTime này với một giá trị chỉ định được trừ đi theo đơn vị tính đã cho.
											
											// Inherited from Temporal interface
											public LocalDateTime minus(long amountToSubtract, TemporalUnit unit)
										
										Ví dụ:
											
											LocalDateTime localDateTime =  LocalDateTime.of(2020, 5, 15, 13, 30, 45);
											System.out.println("localDateTime: " + localDateTime); // 2020-05-15T13:30:45
											System.out.println();
											// minus(long amountToSubtract, TemporalUnit unit)
											LocalDateTime localDateTime1 = localDateTime.minus(20, ChronoUnit.DAYS);
											System.out.println("localDateTime1: " + localDateTime1); // 2020-04-25T13:30:45
											// minus(long amountToSubtract, TemporalUnit unit)
											LocalDateTime localDateTime2 = localDateTime.minus(50, ChronoUnit.MINUTES);
											System.out.println("localDateTime2: " + localDateTime2); // 2020-05-15T12:40:45
				
				withX(..) *--LocalDateTime Java:
				
										- Phương thức withYear(year) trả về một bản sao của đối tượng LocalDateTime này với năm đã được thay đổi thành giá trị được chỉ định.
										- Các phương thức khác như withMonths(months), withDayOfMonth(dayOfMonth),... cũng được hiểu tương tự như cái tên của chúng.
											
											public LocalDateTime withYear(int year)
											public LocalDateTime withMonth(int month)
											public LocalDateTime withDayOfMonth(int dayOfMonth)
											public LocalDateTime withDayOfYear(int dayOfYear)
											public LocalDateTime withHour(int hour)
											public LocalDateTime withMinute(int minute)
											public LocalDateTime withSecond(int second)
											public LocalDateTime withNano(int nanoOfSecond)
										
										Phương thức withYear(year) trả về một bản sao của đối tượng LocalDateTime này với năm đã được thay đổi. Nếu ngày trong tháng (day-of-month) không hợp lệ trong năm, ngày đó sẽ được thay
										đổi thành ngày trong tháng hợp lệ cuối cùng.
											
											LocalDateTime ldt1 = LocalDateTime.parse("2020-02-29T13:30:45").withYear(2024);  
											System.out.println("ldt1: " + ldt1); // 2024-02-29T13:30:45
											LocalDateTime ldt2 = LocalDateTime.parse("2020-02-29T13:30:45").withYear(2019); // Important Note!
											System.out.println("ldt2: " + ldt2); // 2019-02-28T13:30:45
											LocalDateTime ldt3 = LocalDateTime.parse("2020-02-28T13:30:45").withYear(2019);  
											System.out.println("ldt3: " + ldt3); // 2019-02-28T13:30:45
											LocalDateTime ldt4 = LocalDateTime.parse("2020-02-21T13:30:45").withYear(2019);  
											System.out.println("ldt4: " + ldt4); // 2019-02-21T13:30:45
										
										Phương thức withMonth(month) trả về một bản sao của đối tượng LocalDateTime này với tháng đã được thay đổi. Nếu ngày trong tháng (day-of-month) không hợp lệ trong năm, ngày đó sẽ được
										thay đổi thành ngày trong tháng hợp lệ cuối cùng.
											
											LocalDateTime ldt1 = LocalDateTime.parse("2020-03-31T13:30:45").withMonth(2); // Important Note!
											System.out.println("ldt1: " + ldt1); // 2020-02-29T13:30:45
											LocalDateTime ldt2 = LocalDateTime.parse("2020-03-31T13:30:45").withMonth(2); // Important Note!
											System.out.println("ldt2: " + ldt2); // 2020-02-29T13:30:45
											LocalDateTime ldt3 = LocalDateTime.parse("2020-03-29T13:30:45").withMonth(2);  
											System.out.println("ldt3: " + ldt3); // 2020-02-29T13:30:45
											LocalDateTime ldt4 = LocalDateTime.parse("2020-03-21T13:30:45").withMonth(2);  
											System.out.println("ldt4: " + ldt4); // 2020-02-21T13:30:45
				
				with(TemporalAdjuster)--LocalDateTime Java:
				
										Trả về bản sao của đối tượng LocalDateTime này, với dữ liệu ngày tháng và thời gian được điều chỉnh bởi đối tượng TemporalAdjuster.
											
											// Inherited from Temporal interface
											public LocalDateTime with(TemporalAdjuster adjuster)
										
										Ví dụ:
											
											LocalDateTime now = LocalDateTime.now();
											System.out.println("Now is: " + now);
											System.out.println();
											// TemporalAdjuster: First day-of-month
											TemporalAdjuster adjuster1 = TemporalAdjusters.firstDayOfMonth();
											LocalDateTime firstDayOfMonth = now.with(adjuster1);
											System.out.println("firstDayOfMonth: " + firstDayOfMonth);
											// TemporalAdjuster: Next monday.
											TemporalAdjuster adjuster2 = TemporalAdjusters.next(DayOfWeek.MONDAY);
											LocalDateTime nextMonday = now.with(adjuster2);
											System.out.println("nextMonday: " + nextMonday);
											// TemporalAdjuster: First day of next year.
											TemporalAdjuster adjuster3 = TemporalAdjusters.firstDayOfNextYear();
											LocalDateTime firstDayOfNextYear = now.with(adjuster3);
											System.out.println("firstDayOfNextYear: " + firstDayOfNextYear);
											Output:
												Now is: 2021-07-08T18:01:05.965972
												firstDayOfMonth: 2021-07-01T18:01:05.965972
												nextMonday: 2021-07-12T18:01:05.965972
												firstDayOfNextYear: 2022-01-01T18:01:05.965972
				
				with(TemporalField, long)--LocalDateTime Java:
				
										Trả về bản sao của đối tượng LocalDateTime này với trường (field) chỉ định được thay đổi sang giá trị mới.
											
											// Inherited from Temporal interface
											public LocalDateTime with(TemporalField field, long newValue)
										
										Trong một số trường hợp, việc thay đổi trường (field) được chỉ định có thể khiến ngày kết quả trở nên không hợp lệ, chẳng hạn như việc thay đổi tháng từ ngày 31 tháng 1 sang tháng 2 sẽ làm cho ngày trong tháng (day-of-month) không hợp lệ. Trong những trường hợp như thế này, vấn đề đã được phương thức này xử lý. Thông thường, nó sẽ chọn ngày hợp lệ trước đó, sẽ là ngày hợp lệ cuối cùng của tháng 2 trong ví dụ này.
											
											LocalDateTime myDateTime = LocalDateTime.parse("2021-05-29T13:30:45");
											System.out.println("myDateTime is: " + myDateTime); // 2021-05-29T13:30:45
											System.out.println("myDateTime day of week: " + myDateTime.get(ChronoField.DAY_OF_WEEK));  // 6
											System.out.println("myDateTime day of month: " + myDateTime.get(ChronoField.DAY_OF_MONTH)); // 29
											System.out.println();
											LocalDateTime localDateTime1 =    myDateTime.with(ChronoField.DAY_OF_WEEK, 3);   
											System.out.println("localDateTime1: " + localDateTime1); // 2021-05-26T13:30:45
											LocalDateTime localDateTime2 =    myDateTime.with(ChronoField.DAY_OF_MONTH, 10);  
											System.out.println("localDateTime2: " + localDateTime2);  // 2021-05-10T13:30:45
											// February 2021 has only 28 days.
											LocalDateTime localDateTime3 =    myDateTime.with(ChronoField.MONTH_OF_YEAR, 2);  
											System.out.println("localDateTime3: " + localDateTime3);  // 2021-02-28T13:30:45  (***)
											Output:
												myDateTime is: 2021-05-29T13:30:45
												myDateTime day of week: 6
												myDateTime day of month: 29
												localDateTime1: 2021-05-26T13:30:45
												localDateTime2: 2021-05-10T13:30:45
												localDateTime3: 2021-02-28T13:30:45
				
				adjustInto(Temporal)--LocalDateTime Java:
				
										Phương thức adjustInto(Temporal) trả về bản sao của đối tượng Temporal đã chỉ định với dữ liệu ngày tháng và thời gian được điều chỉnh để nó giống với đối tượng LocalDateTime này.
											
											// Inherited from TemporalAdjuster interface
											public Temporal adjustInto(Temporal temporal)
										
										Về cơ bản, hai cách tiếp cận dưới đây là tương tự nhau:
											
											Temporal copiedTemporal = thisLocalDateTime.adjustInfo(aTemporal);  // (1)
											// Same as:
											Temporal copiedTemporal = aTemporal.with(thisLocalDateTime);           // (2)
										
										Ví dụ:
											
											ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("Asia/Ho_Chi_Minh"));
											System.out.println("Now is: " + zonedDateTime);
											LocalDateTime localDateTime = LocalDateTime.parse("1999-01-01T00:30:30");
											zonedDateTime = (ZonedDateTime) localDateTime.adjustInto(zonedDateTime);
											System.out.println("After adjusting: " + zonedDateTime);
											Output:
												Now is: 2021-07-08T20:05:56.439468+07:00[Asia/Ho_Chi_Minh]
												After adjusting: 1999-01-01T00:30:30+07:00[Asia/Ho_Chi_Minh]
				
				query(TemporalQuery<R>)--LocalDateTime Java:
				
											Truy vấn đối tượng LocalDateTime này bằng đối tượng TemporalQuery đã cho để trích ra thông tin.
											
											// Inherited from TemporalAccessor interface
											public <R> R query(TemporalQuery<R> query)
				
				until(Temporal, TemporalUnit)--LocalDateTime Java:
				
										Tính lượng thời gian cho đến ngày-giờ khác theo đơn vị được chỉ định.
											
											// Inherited from Temporal interface
											public long until(Temporal endExclusive, TemporalUnit unit)
										
										Ví dụ:
											
											LocalDateTime localDateTime_from = LocalDateTime.of(2020, 5, 15, 0, 0, 0);
											System.out.println("Date Time From: " + localDateTime_from); // 2020-05-15T00:00
											LocalDateTime localDateTime_to = LocalDateTime.of(2020, 5, 15, 13, 30, 59);  
											System.out.println("Date Time To: " + localDateTime_to); // 2020-05-15T13:30:59
											System.out.println();
											long hours = localDateTime_from.until(localDateTime_to, ChronoUnit.HOURS);
											System.out.println("hours: " + hours); // 13
											long minutes = localDateTime_from.until(localDateTime_to, ChronoUnit.MINUTES);
											System.out.println("minutes: " + minutes); // 810
										
										Bạn cũng có thể sử dụng phương thức TemporalUnit.between(Temporal,Temporal) để có kết quả tương tự:
											
											LocalDateTime localDateTime_from = LocalDateTime.of(2020, 5, 15, 0, 0, 0);
											System.out.println("Date Time From: " + localDateTime_from); // 2020-05-15T00:00
											LocalDateTime localDateTime_to = LocalDateTime.of(2020, 5, 15, 13, 30, 59);  
											System.out.println("Date Time To: " + localDateTime_to); // 2020-05-15T13:30:59
											System.out.println();
											long hours = ChronoUnit.HOURS.between(localDateTime_from, localDateTime_to);
											System.out.println("hours: " + hours); // 13
											long minutes = ChronoUnit.MINUTES.between(localDateTime_from, localDateTime_to);
											System.out.println("minutes: " + minutes); // 810
				
				isSupported(TemporalField)--LocalDateTime Java:
				
										Kiểm tra xem một TemporalField đã cho có được hỗ trợ bởi đối tượng LocalDateTime này hay không.
											
											// Inherited from TemporalAccessor interface
											public boolean isSupported(TemporalField field)
										
										Về cơ bản, LocalDateTime hỗ trợ các TemporalField tiêu chuẩn sau:
											
											ChronoField.NANO_OF_SECOND
											ChronoField.NANO_OF_DAY
											ChronoField.MICRO_OF_SECOND
											ChronoField.ChronoField.MICRO_OF_DAY
											ChronoField.MILLI_OF_SECOND
											ChronoField.MILLI_OF_DAY
											ChronoField.SECOND_OF_MINUTE
											ChronoField.SECOND_OF_DAY
											ChronoField.MINUTE_OF_HOUR
											ChronoField.MINUTE_OF_DAY
											ChronoField.HOUR_OF_AMPM
											ChronoField.CLOCK_HOUR_OF_AMPM
											ChronoField.HOUR_OF_DAY
											ChronoField.CLOCK_HOUR_OF_DAY
											ChronoField.AMPM_OF_DAY
											ChronoField.DAY_OF_WEEK
											ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH
											ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR
											ChronoField.DAY_OF_MONTH
											ChronoField.DAY_OF_YEAR
											ChronoField.EPOCH_DAY
											ChronoField.ALIGNED_WEEK_OF_MONTH
											ChronoField.ALIGNED_WEEK_OF_YEAR
											ChronoField.MONTH_OF_YEAR
											ChronoField.PROLEPTIC_MONTH
											ChronoField.YEAR_OF_ERA
											ChronoField.YEAR
											ChronoField.ERA
				
				isSupported(TemporalUnit)--LocalDateTime Java:
				
										Kiểm tra xem một TemporalUnit đã cho có được hỗ trợ bởi đối tượng LocalDateTime này hay không.
											
											// Inherited from Temporal interface
											public boolean isSupported(TemporalUnit unit)
										
										Về cơ bản, LocalDateTime hỗ trợ các TemporalUnit tiêu chuẩn sau:
											
											ChronoUnit.NANOS
											ChronoUnit.MICROS
											ChronoUnit.MILLIS
											ChronoUnit.SECONDS
											ChronoUnit.MINUTES
											ChronoUnit.HOURS
											ChronoUnit.HALF_DAYS
											ChronoUnit.DAYS
											ChronoUnit.WEEKS
											ChronoUnit.MONTHS
											ChronoUnit.YEARS
											ChronoUnit.DECADES
											ChronoUnit.CENTURIES
											ChronoUnit.MILLENNIA
											ChronoUnit.ERAS
	
			DateTimeFormatter--Ngày và giờ trong Java:
			
									Formatter for displaying and parsing date-time objects
								
									LocalDateTime currentDateTime = LocalDateTime.now();
									DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
									String formattedDateTime = currentDateTime.format(formatter); // định dạng currentDateTime thành một chuỗi theo định dạng đã được chỉ định bởi formatter.
																								  // 26/02/2024 15:48:30
									String dateTimeString = "25/02/2024 15:30:00";
									LocalDateTime parsedDateTime = LocalDateTime.parse(dateTimeString, formatter); // parse chuỗi dateTimeString thành một đối tượng LocalDateTime.
									                                                                               // 2024-02-25T15:30:00
																												   // parse là chuyển một input thành kiểu của nó
			
			Date--Ngày và giờ trong Java:
			
													- Date không tự động điều chỉnh cho múi giờ hoặc thời gian mùa hè (DST - Daylight Saving Time). Nó chỉ đơn giản lưu trữ một số mili giây
													kể từ Epoch (1/1/1970 00:00:00 UTC). Do đó, khi hiển thị một đối tượng Date, nó sẽ hiển thị ngày và giờ tương ứng với múi giờ của hệ thống
													- Lớp java.util.Date trong java biểu diễn ngày và giờ (date và time)
													- Lớp java.util.Date implements các giao diện Serializable, Cloneable and Comparable<Date>. Nó được kế thừa bởi các lớp java.sql.Date,
													java.sql.Time và java.sql.Timestamp.
													- Sau khi lớp Calendar ra đời, hầu hết các Constructor và phương thức của lớp java.util.Date đã bị khuyến cáo không nên dùng
													nữa (@deprecated).
			
				Các cách tạo Date--Date Java:
				
					Ngày và giờ hiện tại:
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															Date currentDate = new Date();
															System.out.println("Current date and time: " + currentDate); // Current date and time: Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Ngày cụ thể:
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															Date specificDate = new Date(1645624200000L); // 23/02/2022
															System.out.println("Specific date: " + specificDate); // Specific date: Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Sử dụng thời gian từ chuỗi:
													import java.util.Date;
													import java.text.SimpleDateFormat;
													public class Main {
														public static void main(String[] args) throws Exception {
															SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
															Date parsedDate = sdf.parse("2022-02-23 15:30:00");
															System.out.println("Parsed date: " + parsedDate); // Parsed date: Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Thời gian từ số mili giây:
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															Date dateFromMilliseconds = new Date(1645624200000L); // 23/02/2022
															System.out.println("Date from milliseconds: " + dateFromMilliseconds); // Date from milliseconds: Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Sử dụng lớp Calendar:
													import java.util.Calendar;
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															Calendar calendar = Calendar.getInstance();
															Date currentDate = calendar.getTime();
															System.out.println("Current date and time using Calendar: " + currentDate); // Current date and time using Calendar:
																																		// Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Sử dụng lớp Instant:
													import java.time.Instant;
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															Instant instant = Instant.now();
															Date currentDate = Date.from(instant);
															System.out.println("Current date and time using Instant: " + currentDate); // Current date and time using Instant:
																																	   // Wed Feb 23 15:30:00 UTC 2022
														}
													}
					Sử dụng lớp LocalDateTime:
					
													- Từ kiểu LocalDateTime đưa về Instant, sau đó mới đưa về Date
					
													import java.time.LocalDateTime;
													import java.util.Date;
													public class Main {
														public static void main(String[] args) {
															LocalDateTime localDateTime = LocalDateTime.now();
															Date currentDate = Date.from(localDateTime.atZone(java.time.ZoneId.systemDefault()).toInstant());
															System.out.println("Current date and time using LocalDateTime: " + currentDate); // Current date and time using LocalDateTime:
																																			 // Wed Feb 23 15:30:00 UTC 2022
														}
													}
													
				boolean after(Date date)--Date Java:
				
													Date currentDate = new Date();
													Date futureDate = new Date(currentDate.getTime() + 1000); // Tạo một Date trong tương lai
													System.out.println("Is futureDate after currentDate? " + futureDate.after(currentDate)); // Is futureDate after currentDate? true
				
				boolean before(Date date)--Date Java:
				
													Date currentDate = new Date();
													Date pastDate = new Date(currentDate.getTime() - 1000); // Tạo một Date trong quá khứ
													System.out.println("Is pastDate before currentDate? " + pastDate.before(currentDate)); // Is pastDate before currentDate? true
				
				Object clone()--Date Java:
				
													Date currentDate = new Date();
													Date clonedDate = new Date(currentDate.getTime()); // Sử dụng phương thức khởi tạo với tham số là số mili giây của currentDate
													System.out.println("Original Date: " + currentDate); // Original Date: Wed Feb 23 15:30:00 UTC 2022
													System.out.println("Cloned Date: " + clonedDate); // Cloned Date: Wed Feb 23 15:30:00 UTC 2022
				
				int compareTo(Date date)--Date Java:
				
													Date currentDate = new Date();
													Date futureDate = new Date(currentDate.getTime() + 1000); // Tạo một Date trong tương lai
													Date pastDate = new Date(currentDate.getTime() - 1000); // Tạo một Date trong quá khứ
													System.out.println("Comparing futureDate with currentDate: " + futureDate.compareTo(currentDate)); // Comparing futureDate with
																																					   // currentDate: 1
													System.out.println("Comparing pastDate with currentDate: " + pastDate.compareTo(currentDate)); // Comparing pastDate with currentDate: -1
				
				boolean equals(Date date)--Date Java:
				
													Date date1 = new Date();
													Date date2 = new Date(date1.getTime());
													boolean isEqual = date1.equals(date2);
													System.out.println("Are date1 and date2 equal? " + isEqual); // Are date1 and date2 equal? true
				
				static Date from(Instant instant)--Date Java:
				
													Instant instant = Instant.now();
													Date date = Date.from(instant);
													System.out.println("Date from Instant: " + date); // Date from Instant: Wed Feb 23 15:30:00 UTC 2022
				
				long getTime()--Date Java:
				
													Date date = new Date();
													long timeInMillis = date.getTime();
													System.out.println("Time in milliseconds: " + timeInMillis); // Time in milliseconds: 1645624200000
				
				int hashCode()--Date Java:
				
													Date date = new Date();
													int hashCode = date.hashCode();
													System.out.println("Hash code of date: " + hashCode); // Hash code of date: 1401071853
				
				void setTime(long time)--Date Java:
				
													Date date = new Date();
													date.setTime(0); // Set time to Epoch time
													System.out.println("Date after setTime: " + date); // Date after setTime: Thu Jan 01 07:00:00 UTC 1970
				
				Instant toInstant()--Date Java:
				
													Date date = new Date();
													Instant instant = date.toInstant();
													System.out.println("Instant from Date: " + instant); // Instant from Date: 2022-02-23T15:30:00Z
				
				String toString()--Date Java:
				
													Date date = new Date();
													String dateString = date.toString();
													System.out.println("String representation of Date: " + dateString); // String representation of Date: Wed Feb 23 15:30:00 UTC 2022	
	
			DateFormat--Ngày và giờ trong Java:				

														- Trong Java, DateFormat là một abstract class được sử dụng để định dạng và phân tích các định dạng ngày tháng trong các chuỗi và các đối tượng Date.
														- Không có constructor như SimpleDateFormat mà thay vào đó dùng các loại get instance để lấy các loại format
			
														Date currentDate = new Date(); // Mon Sep 11 10:36:12 ICT 2017
				
				DateFormat.getInstance().format:											
				
														String dateToStr = DateFormat.getInstance().format(currentDate); // 17/09/11 10:36
				
				DateFormat.getDateInstance().format:										
				
														dateToStr = DateFormat.getDateInstance().format(currentDate); // 2017/09/11
				
				DateFormat.getTimeInstance().format:										
				
														dateToStr = DateFormat.getTimeInstance().format(currentDate); // 10:36:12
				
				DateFormat.getDateTimeInstance().format:									
				
														dateToStr = DateFormat.getDateTimeInstance().format(currentDate); // 2017/09/11 10:36:12
				
				DateFormat.getTimeInstance(DateFormat.SHORT).format:						
				
														dateToStr = DateFormat.getTimeInstance(DateFormat.SHORT).format(currentDate); // 10:36
				
				DateFormat.getTimeInstance(DateFormat.MEDIUM).format:						
				
														dateToStr = DateFormat.getTimeInstance(DateFormat.MEDIUM).format(currentDate); // 10:36:12
				
				DateFormat.getTimeInstance(DateFormat.LONG).format:							
				
														dateToStr = DateFormat.getTimeInstance(DateFormat.LONG).format(currentDate); // 10:36:12 ICT
				
				DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT).format:	
				
														dateToStr = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.SHORT).format(currentDate); // 2017/09/11 10:36
				
				DateFormat.getDateInstance().parse:											
				
														Date date = DateFormat.getDateInstance().parse("2017/11/09"); // Thu Nov 09 00:00:00 ICT 2017
														
				Ví dụ về DateFormat trong java - chuyển đổi date thành string:
				
														package vn.viettuts.date;
														 
														import java.text.DateFormat;
														import java.util.Date;												 
														public class DateFormatExample1 {
															public static void main(String[] args) {
																Date currentDate = new Date();
																System.out.println("Date hien tai: " + currentDate);
																String dateToStr = DateFormat.getInstance().format(currentDate);
																System.out.println("Date Format su dung getInstance(): " + dateToStr);
															}
														}		
														Kết quả:
														Date hien tai: Mon Sep 11 10:32:45 ICT 2017
														Date Format su dung getInstance(): 17/09/11 10:32
														
														package vn.viettuts.date;													 
														import java.text.DateFormat;
														import java.util.Date;													 
														public class DateFormatExample2 {
															public static void main(String[] args) {
																Date currentDate = new Date();													 
																System.out.println("Date hien tai: " + currentDate);													 
																String dateToStr = DateFormat.getInstance().format(currentDate);
																System.out.println("Su dung getInstance(): " + dateToStr);													 
																dateToStr = DateFormat.getDateInstance().format(currentDate);
																System.out.println("Su dung getDateInstance(): " + dateToStr);													 
																dateToStr = DateFormat.getTimeInstance().format(currentDate);
																System.out.println("Su dung getTimeInstance(): " + dateToStr);														 
																dateToStr = DateFormat.getDateTimeInstance().format(currentDate);
																System.out.println("Su dung getDateTimeInstance(): " + dateToStr);													 
																dateToStr = DateFormat.getTimeInstance(DateFormat.SHORT)
																		.format(currentDate);
																System.out.println("Su dung getTimeInstance(DateFormat.SHORT): "
																	   + dateToStr);													 
																dateToStr = DateFormat.getTimeInstance(DateFormat.MEDIUM)
																		.format(currentDate);
																System.out.println("Su dung getTimeInstance(DateFormat.MEDIUM): "
																		+ dateToStr);														 
																dateToStr = DateFormat.getTimeInstance(DateFormat.LONG)
																		.format(currentDate);
																System.out.println("Su dung getTimeInstance(DateFormat.LONG): "
																		+ dateToStr);													 
																dateToStr = DateFormat.getDateTimeInstance(DateFormat.LONG, 
																		DateFormat.SHORT).format(currentDate);
																System.out.println("Su dung "
																		+ "getDateTimeInstance(DateFormat.LONG,DateFormat.SHORT): "
																		+ dateToStr);
															}
														}	
														Kết quả:														
														Date hien tai: Mon Sep 11 10:36:12 ICT 2017
														Su dung getInstance(): 17/09/11 10:36
														Su dung getDateInstance(): 2017/09/11
														Su dung getTimeInstance(): 10:36:12
														Su dung getDateTimeInstance(): 2017/09/11 10:36:12
														Su dung getTimeInstance(DateFormat.SHORT): 10:36
														Su dung getTimeInstance(DateFormat.MEDIUM): 10:36:12
														Su dung getTimeInstance(DateFormat.LONG): 10:36:12 ICT
														Su dung getDateTimeInstance(DateFormat.LONG,DateFormat.SHORT): 2017/09/11 10:36
														
				Ví dụ về DateFormat trong java - chuyển đổi string thành date:

														package vn.viettuts.date;													 
														import java.text.DateFormat;
														import java.util.Date;												 
														public class DateFormatExample3 {
															public static void main(String[] args) throws Exception {
																Date date = DateFormat.getDateInstance().parse("2017/11/09");
																System.out.println("Date: " + date);
															}
														}			
														Kết quả:
														Date: Thu Nov 09 00:00:00 ICT 2017
			SimpleDateFormat--Ngày và giờ trong Java:									
																
														- SimpleDateFormat là một lớp trong Java được sử dụng để định dạng và phân tích các chuỗi ngày tháng. Nó là một lớp con của lớp DateFormat và cung cấp một
														cách dễ dàng để thực hiện các hoạt động liên quan đến định dạng ngày tháng.
														- Có hai lớp để định dạng ngày trong java: DateFormat và SimpleDateFormat.
														- Lớp java.text.SimpleDateFormat trong java cung cấp các phương thức để định dạng và phân tích ngày tháng và thời gian trong java. SimpleDateFormat kế thừa
														lớp java.text.DateFormat.
														- Lưu ý: rằng định dạng (format) có nghĩa là chuyển đổi date thành string và phân tích (parse) có nghĩa là chuyển đổi string thành date.
														- Phương thức SimpleDateFormat.format(java.util.Date date): được sử dụng để chuyển đổi date thành string trong java.
			                                            - Phương thức SimpleDateFormat.parse(String string): được dụng để phân tích string thành date trong java.
														
														Date date = new Date();
																	
				SimpleDateFormat("MM/dd/yyyy"):        				
				
																	SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy");
																	String strDate = formatter.format(date); // 09/11/2017 // chuyển đổi đối tượng date thành một chuỗi ngày
				
				SimpleDateFormat("dd-M-yyyy hh:mm:ss"):				
				
																	formatter = new SimpleDateFormat("dd-M-yyyy hh:mm:ss");
																	strDate = formatter.format(date); // 11-9-2017 11:06:23
				
				SimpleDateFormat("dd MMMM yyyy"):        			
				
																	formatter = new SimpleDateFormat("dd MMMM yyyy");
																	strDate = formatter.format(date); // 11 September 2017
				
				SimpleDateFormat("dd MMMM yyyy zzzz"):				
				
																	formatter = new SimpleDateFormat("dd MMMM yyyy zzzz");
																	strDate = formatter.format(date); // 11 September 2017 Indochina Time														
				
				SimpleDateFormat("E, dd MMM yyyy HH:mm:ss z"):      
				
																	formatter = new SimpleDateFormat("E, dd MMM yyyy HH:mm:ss z");
																	strDate = formatter.format(date); // Mon, 11 Sep 2017 11:06:23 ICT
				
				parse:												
				
																	SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
																	Date date = formatter.parse("31/09/2017"); // chuyển đổi một chuỗi đại diện cho ngày thành một đối tượng Date trong Java.																	
				
				Ví dụ SimpleDateFormat trong java - chuyển đổi date thành string
				
					Dưới đây là ví dụ định dạng date trong java theo pattern bằng việc sử dụng lớp java.text.SimpleDateFormat:
						
						package vn.viettuts.date;				
						import java.text.SimpleDateFormat;
						import java.util.Date;					 
						public class SimpleDateFormatExample1 {
							public static void main(String[] args) {
								Date date = new Date();
								SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
								String strDate = formatter.format(date);
								System.out.println(strDate);
							}
						}
						
						Kết quả:
							11/09/2017
					
					Dưới đây là ví dụ đầy đủ định dạng date trong java theo pattern bằng việc sử dụng lớp java.text.SimpleDateFormat:
						
						package vn.viettuts.date;			 
						import java.text.SimpleDateFormat;
						import java.util.Date;					 
						public class SimpleDateFormatExample2 {
							public static void main(String[] args) {
								Date date = new Date();
								SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy");
								String strDate = formatter.format(date);
								System.out.println("Date Format with MM/dd/yyyy: " + strDate);
								//
								formatter = new SimpleDateFormat("dd-M-yyyy hh:mm:ss");
								strDate = formatter.format(date);
								System.out.println("Date Format with dd-M-yyyy hh:mm:ss: " + strDate);
								//
								formatter = new SimpleDateFormat("dd MMMM yyyy");
								strDate = formatter.format(date);
								System.out.println("Date Format with dd MMMM yyyy: " + strDate);
								//
								formatter = new SimpleDateFormat("dd MMMM yyyy zzzz");
								strDate = formatter.format(date);
								System.out.println("Date Format with dd MMMM yyyy zzzz: " + strDate);
								//
								formatter = new SimpleDateFormat("E, dd MMM yyyy HH:mm:ss z");
								strDate = formatter.format(date);
								System.out.println("Date Format with E, dd MMM yyyy HH:mm:ss z: "
										+ strDate);
							}
						}
						
						Kết quả:
							Date Format with MM/dd/yyyy: 09/11/2017
							Date Format with dd-M-yyyy hh:mm:ss: 11-9-2017 11:06:23
							Date Format with dd MMMM yyyy: 11 September 2017
							Date Format with dd MMMM yyyy zzzz: 11 September 2017 Indochina Time
							Date Format with E, dd MMM yyyy HH:mm:ss z: Mon, 11 Sep 2017 11:06:23 ICT
				
				Ví dụ SimpleDateFormat trong java - chuyển đổi string thành date
				
					Dưới đây là ví dụ parse string thành date trong java bằng việc sử dụng lớp java.text.SimpleDateFormat:
						
						package vn.viettuts.date;			 
						import java.text.ParseException;
						import java.text.SimpleDateFormat;
						import java.util.Date;					 
						public class SimpleDateFormatExample3 {
							public static void main(String[] args) {
								SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
								try {
									Date date = formatter.parse("31/09/2017");
									System.out.println("Date: " + date);
								} catch (ParseException e) {
									e.printStackTrace();
								}
							}
						}
						
						Kết quả:
							Date: Sun Oct 01 00:00:00 ICT 2017
	
			Calendar--Ngày và giờ trong Java:
			
												Lớp Calendar trong java là một lớp trừu tượng (abstract) cung cấp phương thức chuyển đổi ngày giữa một thời điểm cụ thể theo thời gian và một tập hợp các trường
												của calendar như MONTH, YEAR, HOUR, ... Nó kế thừa lớp Object và implements giao diện Comparable.
				
				Các phương thức của lớp Calendar trong java
					
					abstract void add(int field, int amount)
						
						Nó được sử dụng để thêm hoặc trừ số lượng thời gian nhất định vào trường calendar đã cho, dựa trên các quy tắc của calendar.
					
					int get(int field)
						
						Nó được sử dụng để trả lại giá trị của trường calendar đã cho.
					
					static Calendar getInstance()
						
						Nó được dùng để lấy calendar sử dụng time zone và locale mặc định.
					
					abstract int getMaximum(int field)
						
						Nó được sử dụng để trả về giá trị MAX cho trường calendar đã cho của thể hiện Calendar hiện tại.
					
					abstract int getMinimum(int field)
						
						Nó được sử dụng để trả về giá trị MIN cho trường calendar đã cho của thể hiện Calendar hiện tại.
					
					void set(int field, int value)
						
						Nó được sử dụng để thiết lập trường cho trước với giá trị đã cho.
					
					void setTime(Date date)
						
						Nó được sử dụng để thiết lập time của Calendar với Date đã cho.
					
					Date getTime()
						
						Nó được sử dụng để trả về đối tượng Date biểu diễn giá trị time của Calendar.
						
				Ví dụ về Calendar trong java
				
														package vn.viettuts.date;													
														import java.util.Calendar;													 
														public class CalendarExample1 {
															public static void main(String[] args) {
																Calendar calendar = Calendar.getInstance();
																System.out.println("Ngay gio hien tai: " + calendar.getTime());
																calendar.add(Calendar.DATE, -15);
																System.out.println("15 ngay sau: " + calendar.getTime());
																calendar.add(Calendar.MONTH, 4);
																System.out.println("4 thang sau: " + calendar.getTime());
																calendar.add(Calendar.YEAR, 2);
																System.out.println("2 nam sau: " + calendar.getTime());
															}
														}@
														Kết quả:
														Ngay gio hien tai: Mon Sep 11 09:33:11 ICT 2017
														15 ngay sau: Sun Aug 27 09:33:11 ICT 2017
														4 thang sau: Wed Dec 27 09:33:11 ICT 2017
														2 nam sau: Fri Dec 27 09:33:11 ICT 2019
														
				Ví dụ về Calendar trong java - phương thức get()
				
														package vn.viettuts.date;												 
														import java.util.Calendar;												 
														public class CalendarExample2 {
															public static void main(String[] args) {
																Calendar calendar = Calendar.getInstance();
																System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
																System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
																System.out.println("DAY: " + calendar.get(Calendar.DATE));
																System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
															}
														}
														Kết quả:
														YEAR: 2017
														MONTH: 8
														DAY: 11
														DAY_OF_WEEK: 2
				
				Ví dụ về Calendar trong java - phương thức getTime()
				
														package vn.viettuts.date;													 
														import java.util.Calendar;													 
														public class CalendarExample3 {
															public static void main(String[] args) {
																Calendar calendar = Calendar.getInstance();
																System.out.print("Date And Time: " + calendar.getTime());
															}
														}
														Kết quả:
														Date And Time: Mon Sep 11 09:50:21 ICT 2017
														
				Ví dụ về Calendar trong java - phương thức getMaximum()
															
														package vn.viettuts.date;														 
														import java.util.Calendar;													 
														public class CalendarExample4 {
															public static void main(String[] args) {
																Calendar calendar = Calendar.getInstance();
																int maximum = calendar.getMaximum(Calendar.DAY_OF_WEEK);
																System.out.println("Gia tri MAX cua so ngay trong tuan: " + maximum);
																maximum = calendar.getMaximum(Calendar.WEEK_OF_YEAR);
																System.out.println("Gia tri MAX cua so tuan trong nam: " + maximum);
															}
														}
														Kết quả:
														Gia tri MAX cua so ngay trong tuan: 7
														Gia tri MAX cua so tuan trong nam: 53
														
				Ví dụ về Calendar trong java - phương thức getMinimum()
				
														package vn.viettuts.date;													 
														import java.util.Calendar;													 
														public class CalendarExample5 {
															public static void main(String[] args) {
																Calendar cal = Calendar.getInstance();
																int minimum = cal.getMinimum(Calendar.DAY_OF_WEEK);
																System.out.println("Gia tri MIN cua so ngay trong tuan: " + minimum);
																maximum = cal.getMinimum(Calendar.WEEK_OF_YEAR);
																System.out.println("Gia tri MIN cua so tuan trong nam: " + minimum);
															}
														}
														Kết quả:
														Gia tri MIN cua so ngay trong tuan: 1
														Gia tri MIN cua so tuan trong nam: 1	

			TimeZone--Ngày và giờ trong Java:

														Lớp TimeZone trong java được sử dụng để biểu diễn múi giờ. TimeZone là một lớp trừu tượng (abstract) kế thừa lớp Object và implements các giao diện Serializable,
														Cloneable.
														
				Các phương thức của lớp TimeZone trong java
					static String[] getAvailableIDs()
					
														Nó được sử dụng để nhận được tất cả các ID có sẵn được hỗ trợ.
					
					static TimeZone getDefault()
						
														Nó được sử dụng để lấy TimeZone mặc định cho máy chủ hiện tại.
					
					String getDisplayName()
						
														Nó được sử dụng để trả về tên của múi giờ phù hợp để trình bày cho người dùng ở vùng miền mặc định.
					
					String getID()
						
														Nó được sử dụng để lấy ID của múi giờ hiện tại.
					
					int getOffset(long date)
						
														Nó được sử dụng để trả về offset của múi giờ này từ UTC tại một date nhất định.
					
					void setID(String ID)
						
														Nó được sử dụng để thiết lập ID cho múi giờ hiện tại.
														
					Ví dụ về TimeZone trong java - phương thức getAvailableIDs()
														
														package vn.viettuts.date;													 
														import java.util.TimeZone;													 
														public class TimeZoneExample1 {
															public static void main(String args[]) {
																String[] id = TimeZone.getAvailableIDs();
																System.out.println("Danh sach id co san la: ");
																for (int i = 0; i < id.length; i++) {
																	System.out.println(id[i]);
																}
															}
														}
														Kết quả:
														Danh sach id co san la: 
														Africa/Abidjan
														Africa/Accra
														Africa/Addis_Ababa
														Africa/Algiers
														Africa/Asmara
														...
														PST
														SST
														VST
					
					Ví dụ về TimeZone trong java - phương thức getOffset()
														
														package vn.viettuts.date;
														import java.util.Calendar;
														import java.util.TimeZone;												 
														public class TimeZoneExample2 {
															public static void main(String args[]) {
																TimeZone zone = TimeZone.getTimeZone("Asia/Ho_Chi_Minh");
																System.out.println("Gia tri Offset cua TimeZone: "
																		+ zone.getOffset(Calendar.ZONE_OFFSET));
															}
														}
														Kết quả:
														Gia tri Offset cua TimeZone: 28800000
					
					Ví dụ về TimeZone trong java - phương thức getID()
					
														package vn.viettuts.date;													 
														import java.util.TimeZone;													 
														public class TimeZoneExample3 {
															public static void main(String args[]) {
																TimeZone timezone = TimeZone.getTimeZone("Asia/Ho_Chi_Minh");
																System.out.println("Gia tri cua ID la: " + timezone.getID());
															}
														}
														Kết quả:
														Gia tri cua ID la: Asia/Ho_Chi_Minh
														
					Ví dụ về TimeZone trong java - phương thức getDisplayName()
														
														package vn.viettuts.date;												 
														import java.util.TimeZone;													 
														public class TimeZoneExample4 {
															public static void main(String args[]) {
																TimeZone zone = TimeZone.getDefault();
																String name = zone.getDisplayName();
																System.out.println("Ten hien thi mac dinh cua mui gio: " + name);
															}
														}
														Kết quả:
														Ten hien thi mac dinh cua mui gio: Indochina Time			
	
			Java Timestamp--Ngày và giờ trong Java:
			
				Java Timestamp class
					
					Timestamp provides formatting and parsing operations to support JDBC escape syntax. It also adds the ability to hold the SQL TIMESTAMP fractional seconds value.
				
				Methods
					
					after()	
				
						Returns Boolean value true if this Timestamp object comes later than given Timestamp object.
					
					before()	
				
						Returns Boolean value true if this Timestamp object comes earlier than given Timestamp object.
					
					compareTo()	
				
						Compares this Timestamp object to the given Timestamp object or to the given date object
					
					equals()	
				
						Returns a Boolean value true if this Timestamp object is equal specified object or to the given Timestamp object .
					
					from()	
				
						Obtains an instance of Timestamp from an Instant object
					
					getNanos()	
				
						Fetches the Timestamp object's nanos value
					
					getTime()	
				
						Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT
					
					hashCode()	
				
						Returns a hash code value for this object
					
					setNanos()	
				
						Sets a nanos value for the specified integer value
					
					setTime()	
				
						Sets this class's object to indicate a point in time (milliseconds) after January 1, 1970 00:00:00 GMT
					
					toInstant()	
				
						Coverts the Timespan object to an Instant which represents the same point on the time-line as this Timestamp
					
					toLocalDateTime()	
				
						Converts this Timespan object to a LocalDateTime which represents the same date-time value as this Timestamp
					
					toString()	
				
						Converts the Timespan object in JDBC timestamp escape format
					
					valueOf()	
				
						Converts the string object to Timestamp value or obtains an instance of Timestamp from a LocalDateTime object.
				
				Example 1
				
					import java.sql.Timestamp;  
					import java.time.Instant;  
					public class JavaTimestampFromExample_1 {  
						public static void main(String[] args) {  
						   Timestamp instant= Timestamp.from(Instant.now());  // 2018-09-06 12:42:53.885. from() method Obtains an instance of Timestamp from an Instant object  
							String str="2018-09-01 09:01:15";  
							Timestamp timestamp= Timestamp.valueOf(str);  // 2018-09-01 09:01:15.0. valueOf() method returns a Timestamp value corresponding to the given string  
							Integer val=timestamp.getNanos(); // 0. getNanos() method gets the Timestamp obejct's nanos value  
							Timestamp ts2 = Timestamp.valueOf("2018-09-01 09:01:16"); // true
							System.out.println("4. Boolean value returned : "+timestamp.before(ts2)); // true. before() returns Boolean value true if this ts1 comes earlier than given ts2						
						}  
					}
					
				Example 2
					
					import java.sql.Timestamp;  
					import java.time.Instant;  
					public class JavaTimespanExample2 {  
						public static void main(String[] args) {  
							Timestamp ts1 = Timestamp.valueOf("2018-09-01 09:01:15"); // 2018-09-01 09:01:15.0
							Long val=ts1.getTime(); // 1535772675000. getTime() method returns the number of milliseconds  
							Integer val1=ts1.hashCode(); // -1825617187. hashCode() method returns the hash code for this object.  
							ts1.setNanos(54647); // 2018-09-01 09:01:15.000054647. setNanos() method sets nanos value for the specified integer value.  
							Instant instant = ts1.toInstant(); // 2018-09-01T03:31:15.000054647Z. toInstant() method returns an Instant which represents the same point on the time-line as this Timestamp  
						}  
					}
					
				Chuyển Date thành Timestamp và Timestamp thành Date
					
					- Date ở đây là class thuộc gói java.util (java.util.Date)
					
					- Timestamp là class thuộc gói java.sql (java.sql.Timestamp)
					
					- Sở dĩ có khi bạn gặp trường hợp này là vì MySQL và một số Hệ quản trị CSDL khác có một kiểu dữ liệu là Timestamp, muốn insert được dữ liệu vào CSDL cho các trường có kiểu dữ liệu này thì trong Java
					bạn cũng phải khai báo kiểu dữ liệu Timestamp cho các dữ liệu đó. Mà mặt khác, việc thao tác với dữ liệu kiểu Date dễ dàng hơn nhiều so với Timestamp nên nhiều lúc đang làm việc với Date nhưng lại
					chuyển về Timestamp và ngược lại.
					
					Ví dụ
					
						package com.ngockhuong;
						import java.sql.Timestamp;
						import java.util.Date;
						public class DateToTimestamp {
							public static void main(String[] args) {
								// lấy ngày giờ hiện tại
								Date now = new Date();
								System.out.println(now);							
								// chuyển Date sang Timestamp
								Timestamp timestamp = new Timestamp(now.getTime());
								System.out.println(timestamp);								
								// chuyển Timestamp sang Date 
								Date last = new Date(timestamp.getTime());
								System.out.println(last);
							}
						}
						Tue Feb 14 01:53:24 ICT 2017
						2017-02-14 01:53:24.981
						Tue Feb 14 01:53:24 ICT 2017
						
	Mapping SQL and Java Types--JAVA: https://download.oracle.com/otn_hosted_doc/jdeveloper/904preview/jdk14doc/docs/guide/jdbc/getstart/mapping.html
	
		Khi sql không thể hiện dữ liệu cụ thể thì khi chuyển đổi qua Java sẽ là kiểu BigInteger
	
		JDBC Types Mapped to Java Types--Mapping SQL and Java Types:
		
			JDBC Type				Java Type				
						
			CHAR					String				
						
			VARCHAR					String			
						
			LONGVARCHAR				String				
						
			NUMERIC					java.math.BigDecimal				
						
			DECIMAL					java.math.BigDecimal				
						
			BIT						boolean			
						
			TINYINT					byte			
						
			SMALLINT				short				
						
			INTEGER					int				
						
			BIGINT					long
										
			REAL					float				
						
			FLOAT					double			
						
			DOUBLE					double			
						
			BINARY					byte[]				
						
			VARBINARY				byte[]
		
			LONGVARBINARY			byte[]
		
			DATE					java.sql.Date
		
			TIME					java.sql.Time
		
			TIMESTAMP				java.sql.Timestamp
		
			CLOB					Clob
		
			BLOB					Blob
		
			ARRAY					Array
		
			DISTINCT				mapping of underlying type
		
			STRUCT					Struct
		
			REF						Ref
		
			JAVA_OBJECT				underlying Java class
			
		Java Types Mapped to JDBC Types--Mapping SQL and Java Types:
		
			Java Type						JDBC Type
		
			String							CHAR, VARCHAR, or LONGVARCHAR
		
			java.math.BigDecimal			NUMERIC
		
			boolean							BIT
		
			byte							TINYINT
		
			short							SMALLINT
		
			int								INTEGER
		
			long							BIGINT
		
			float							REAL
		
			double							DOUBLE
		
			byte[]							BINARY, VARBINARY, or LONGVARBINARY
		
			java.sql.Date					DATE
		
			java.sql.Time					TIME
		
			java.sql.Timestamp				TIMESTAMP
		
			Clob							CLOB
		
			Blob							BLOB
		
			Array							ARRAY
		
			Struct							STRUCT
		
			Ref								REF
		
			Java class						JAVA_OBJECT			
			
		JDBC Types Mapped to Java Object Types--Mapping SQL and Java Types:
		
			JDBC Type				Java Object Type

			CHAR					String

			VARCHAR					String

			LONGVARCHAR				String

			NUMERIC					java.math.BigDecimal

			DECIMAL					java.math.BigDecimal

			BIT						Boolean

			TINYINT					Integer

			SMALLINT				Integer

			INTEGER					Integer

			BIGINT					Long

			REAL					Float

			FLOAT					Double

			DOUBLE					Double

			BINARY					byte[]

			VARBINARY				byte[]

			LONGVARBINARY			byte[]

			DATE					java.sql.Date

			TIME					java.sql.Time

			TIMESTAMP				java.sql.Timestamp

			DISTINCT				Object type of underlying type

			CLOB					Clob

			BLOB					Blob

			ARRAY					Array

			STRUCT					Struct or SQLData

			REF						Ref

			JAVA_OBJECT				underlying Java class
			
		Java Object Types Mapped to JDBC Types--Mapping SQL and Java Types:

			Java Object Type			JDBC Type

			String						CHAR, VARCHAR, or LONGVARCHAR

			java.math.BigDecimal		NUMERIC

			Boolean						BIT

			Integer						INTEGER

			Long						BIGINT

			Float						REAL

			Double						DOUBLE

			byte[]						BINARY, VARBINARY, or LONGVARBINARY

			java.sql.Date				DATE

			java.sql.Time				TIME

			java.sql.Timestamp			TIMESTAMP

			Clob						CLOB

			Blob						BLOB

			Array						ARRAY

			Struct						STRUCT

			Ref							REF

			Java class					JAVA_OBJECT
			
	Java Peristence Framework--JAVA
	
		- Lập trình cơ sở dữ liệu là một trong những khía cạnh quan trọng của lập trình. Trong java ta đã từng làm quen với JDBC (Java DataBase Connectivity) dùng để kết nối đến một Datasource, và trong ứng dụng Enterprise
		ta có EJB (Enterprise Java Beans).
		
		- Nhưng với sự phát triển của ngành lập trình, ORM (Object-Relational Mapping) ra đời như một sự cải tiến cho JDBC. ORM cho phép lập trình dễ dàng hơn, tuân thủ chặt chẽ lý thuyết lập trình hướng đối tượng, phù hợp
		với ứng dụng n-tier. Trong các framework ORM cho java nổi trội hơn cả là MyBatis, Hibernate, và JPA (sự cải tiến của EJB, trở thành chuẩn của Java EE). Vậy chúng ta cùng thử 1 so sánh nho nhỏ về 3 công cụ nổi tiếng
		và mạnh mẽ này.
		
		Persistence Layer
			
			Trước hết chúng ta nói qua một chút về persistence layer.
			
			Các ứng dụng enterprise thường được xây dựng theo kiến trúc nhiều tầng, ví dụ như Presentation layer, Bussiness Layer, Persistence Layer. Tầng Persistence sẽ là tầng kết nối với DB, là cầu nối giúp ứng dụng
			tương tác lên cơ sở dữ liệu như INSERT, UPDATE data, hoặc lưu giữ data cho ứng dụng được get (SELECT) từ DB.
			
			Như vậy một Persistence layer sẽ bao gồm sau:
				
				Tạo session
					
					- Persistence layer có nhiệm vụ tạo các phiên kết nối từ ứng dụng đến Cơ sở dữ liệu, mà qua các phiên này, ứng dụng sẽ tương tác được với DB, các phiên kết nối được thực hiện khi các connections
					được thiết lập.
				
				Thực thi query
					
					- Khi các connections được thiết lập, tầng persistence có nhiệm vụ thực thi các truy vấn của ứng dụng lên cơ sở dữ liệu như update, insert và select data, call store procedure… thông qua các phương
					thức được xây dựng và cung cấp trong persistence layer
				
				Mapping
					
					Persistence layer sẽ ánh xạ cấu trúc DB, tables, columns, rows với các class, object của java, và nhờ dó, các java object có nhiệm vụ lưu trữ thông tin của các thực thể trong tables khi truy
					vấn (SELECT) hoặc lưu giữ thông tin từ người dùng và cập nhật vào DB(INSERT,UPDATE). ví dụ một mapping như sau:
						
						CREATE TABLE PRODUCT (
						  ID INT PRIMARY KEY AUTO_INCREMENT,
						  NAME VARCHAR(255) NOT NULL,
						  PRICE INT NOT NULL
						)
					
					Một table có cấu trúc như trên sẽ được ánh xạ bởi class sau:
						
						public class Product{
						 private int id;
						 private String name;
						 private int price;
						 public int getId(){
						  return id;
						 }
						 public void setId(int id) {
						  this.id = id;
						 }
						 public String getName() {
						  return name;
						  }
						  public void setName(String name) {
						   this.name = name;
						  }
						  public String getPrice() {
						   return price;
						  }
						  public void setPrice(String price) {
						   this.price = price;
						  }
						}
						
				Transaction and Exception
				
					- Khi truy vấn dữ liệu sẽ xảy ra các trường hợp các truy vấn được thực thi không thành công( truy vấn theo batch, ngắt kết nối….) những rủi ro xảy ra cho ứng dụng và dữ liệu trong DB khi truy vấn thất
					bại, hoặc connection bị ngắt kết nối thì peristence phải có nhiệm vụ phục hồi tình trạng trước đó của dữ liệu, hoặc đưa ra các ngoại lệ, các hướng dẫn, log để thông báo cho ứng dụng.
				
				Cache
				
					- Để phục vụ tốt hơn cho việc truy vấn ( hiệu suất, tốc độ, tính tương thích..) thông thường persistence layer sẽ load một metadata của Database vào ứng dụng, các mapping giữa các đối tượng trong ứng dụng
					với các tables thông qua các config, xml file, hoặc tạo ra các đối tượng, được lưu trữ như cache để có thể truy vấn lại mà không phải kết nối đến DB… Điều này sẽ làm cải thiện tốc độ cho chương trình
					nhưng đôi khi lại gây ra một sự cồng kềnh, phức tạp.
					
					- Java cung cấp JDBC để xây dựng tầng persistence, các  JDBC API sẽ sử dụng các SQL query được viết chung với code java và thực thi nó thông qua các command, statement… Tuy nhiên những ORM fw sau này được
					xây dựng đã lược bỏ sự phức tạp của JDBC, thay vào đó, bản thân các ORM sẽ định nghĩa các API cho riêng mình, giúp cho developer khỏi bận tâm hơn việc thao tác DB, mà tập trung vào xây dựng bussiness
					cho ứng dụng.
		
		MyBatis
		
			MyBatis là sự cải tiến của phiên bản IBatis 2, là một persistence framework, tự động mapping giữa SQL database và Java object thông qua các config được định nghĩa trong file xml.
			
			Là một persistence framework nhưng MyBatis khá đơn giản, dễ học và có kích thước nhỏ, số lượng các package ít hơn nhiều so với các persistence fw khác. MyBatis thao tác trực tiếp với câu lệnh SQL, nên dù là
			một persistence fw nhưng MyBatis chỉ có các tính năng như Create session, query data. còn Transaction thì không cũng cấp mà dùng của SQL.
			
			Ngoài ra MyBatis cũng không lưu trữ cache như Hibernate hoặc JPA. Các config để mapping được đặt trong các file xml, theo các cấu trúc của mybatis. Là một persistence framework nhưng thực ra Mybatis không
			truy vấn trên java object như các framework khác, mà truy vấn trược tiếp trên SQL, sau đó kết quả trả về sẽ mapping với java object thông qua resutset mapping. tính năng này ở Hibernate và JPA cũng có nhưng
			Mybatis đã tận dụng và phát huy sức mạnh, khiến cho framework này dù đơn giản, dễ học và phát triển ứng dụng nhanh nhưng tốc độ truy vấn cao, dễ dàng tùy biến với những query phức tạp, và không gây khó khăn
			hay ức chế cho dev.
			
			Vì thế nếu xây dựng ứng dụng mà yêu cầu thời gian phát triển ngắn, không phức tạp, dễ bảo trì, và dễ tìm hiểu cho dev thì mybatis là lựa chọn tối ưu nhất
		
		Hibernate
		
			Hibernate là một persistence fw được phát triển bởi Gavin King năm 2001 theo mô hình entity bean của EJB2, fw này sẽ mapping DB với các POJOs(Plain Old Java Object) và sẽ thao tác trên các oject đó.
			
			Hibernate sử dụng ngôn ngữ truy vấn riêng của mình là HQL (Hibernate Query language), tượng tự SQL, nhưng các truy vấn của Hibernate đều thực hiện trên object, điều này khá mới mẻ và khó tiếp cận đối với
			những ai chưa quen làm việc với ORM.
			
			Ngoài ra hibernate hỗ trợ rất lớn provider cho hầu hết các hệ quản trị cơ sở dữ liệu thông dụng, hỗ trợ Transaction, lưu cache.
			
			Nên nếu một ứng dụng mà yêu cầu tương thích với nhiều datasource hỗ trợ truy vấn tự động, mạnh mẽ và an toàn, hoặc có thể thay đổi cấu hình mà không ảnh hưởng tới code bên trong thì Hibernate là một sự lựa
			chọn tốt hơn hẳn so với Mybatis
			
		JPA
			
			Về cơ bản JPA khá giống với Hibernate, cả hai đều là nỗ lực khắc phục nhược điểm của EJB, đều sử dụng mô hình entity bean để mapping với database, và truy vấn trên các object đó.
			
			Tuy nhiên, điểm khác biệt là JPA sử dụng ngôn ngữ truy vấn JPQL(Java Persistence Query Language) – tương đồng với HQL, ngoài ra JPA không sử dụng riêng lẻ được, mà phải đi kèm với một provider khác
			để config, ví dụ như EclipseLink, Oracle TopLink, Hibernate.
			
			JPA trở thành chuẩn persistence của java, các API được định nghĩa trong package javax.pesistence.
			
			Nếu yêu cầu xây dựng ứng dụng tuân thủ chặt chẽ quy tắc của java enterprise, được hỗ trợ bởi java thì JPA là một đối thủ nặng ký đối với Hibernate
			
		Tổng kết
			
			MyBatis
				
				Phù hợp với các ứng dụng có yêu cầu thời gian xây dựng ngắn, chi phí phát triển thấp, đơn giản và dễ học.
			
			Hibernate vs JPA
			
				Phù hớp với các ứng dụng tuân thủ chặt chẽ quy tắc của ORM, hỗ trợ kết nối đến nhiều cơ sở dữ liệu, dễ điều khiển.
				
				Ngoài ra sự hỗ trợ tài liệu, trợ giúp bởi cộng đồng dev của Hibernate và JPA (đặc biệt là Hibernate) là rất lớn.
				
				Tuy nhiên để xây dựng một ứng dụng với Hibernate hoặc JPA mất rất nhiều thời gian phát triển, không kể thời gian dài tìm hiểu công nghệ, và phải hiểu rõ, phân tích tường tận mọi khía cạnh của ứng
				dụng. Đặc biệt là mô hình ER của dữ liệu. vì các quan hệ của các bảng(1-1,1-n,n-n) được định nghĩa trong các entity, qua đó JPQL(hay HQL) mới có thể truy vấn được.
				
				Ngay cả việc xử lý kết quả lấy từ nhiều tables(SELECT nhiều tables) cũng gây ra khá nhiều rắc rối cho những người mới bắt đầu. Tuy nhiên các persistence sử dụng entity bean vẫn được ưa chuộng hơn cả.						
	
	super--JAVA:
		Tham chiếu trực tiếp đến biến instance của lớp cha:
																		class Vehicle {
																			int speed = 50;
																		}																		 
																		public class Bike2 extends Vehicle {
																			int speed = 100;																		 
																			void display() {
																				System.out.println(super.speed);//in speed của lớp Vehicle  
																			}																		 
																			public static void main(String args[]) {
																				Bike2 b = new Bike2();
																				b.display(); // 50																		 
																			}
																		}
		Gọi trực tiếp Constructor của lớp cha:
																		class Vehicle {
																			Vehicle() {
																				System.out.println("Vehicle is created");
																			}
																		}																		 
																		class Bike2 extends Vehicle {
																			Bike2() {
																				super();//gọi Constructor của lớp cha  
																				System.out.println("Bike is created");
																			}																		 
																			public static void main(String args[]) {
																				Bike2 b = new Bike2(); // Vehicle is created
																									   // Bike is created
																			}
																		}
		super() được tự động thêm vào câu lệnh đầu tiên mỗi Constructor của class bởi trình biên dịch:
																											class Vehicle {
																												Vehicle() {
																													System.out.println("Vehicle is created");
																												}
																											}																		 
																											public class Bike6 extends Vehicle {
																												int speed;
																											 
																												Bike6(int speed) {
																													this.speed = speed;
																													System.out.println(speed);
																												}																		 
																												public static void main(String args[]) {
																													Bike6 b = new Bike6(10); // Vehicle is created
																																			 // 10
																												}
																											}
		super được sử dụng để gọi trực tiếp phương thức của lớp cha:
																		class Person {
																			void message() {
																				System.out.println("welcome");
																			}
																		}																		 
																		public class Student16 extends Person {
																			void message() {
																				System.out.println("welcome to java");
																			}																		 
																			void display() {
																				message();// gọi phương thức message() của lớp hiện tại
																				super.message();// gọi phương thức message() của lớp cha
																			}																		 
																			public static void main(String args[]) {
																				Student16 s = new Student16();
																				s.display(); // welcome to java
																							 // welcome
																			}
																		}
																		
																		class Person {
																			void message() {
																				System.out.println("welcome");
																			}
																		}																		 
																		public class Student17 extends Person {																		 
																			void display() {
																				message(); // will invoke parent class message() method
																				           // Trong TH không có phương thức ở class con giống class cha thì không cần phải sử dụng super
																			}																		 
																			public static void main(String args[]) {
																				Student17 s = new Student17();
																				s.display(); // welcome
																			}
																		}
	this--JAVA:
		Tham chiếu tới biến instance của lớp hiện tại:
			Khi không có this:
																	public class Student10 {
																		int id;
																		String name;																		 
																		Student10(int id, String name) {
																			id = id;
																			name = name;
																		}																		 
																		void display() {
																			System.out.println(id + " " + name);
																		}																		 
																		public static void main(String args[]) {
																			Student10 s1 = new Student10(111, "Viet");
																			Student10 s2 = new Student10(222, "Nam");
																			s1.display(); // 0 null 
																			s2.display(); // 0 null 
																		}
																	}															
			Khi có this:														
																	public class Student11 {
																		int id;
																		String name;																		 
																		Student11(int id, String name) {
																			this.id = id;
																			this.name = name;
																		}																		 
																		void display() {
																			System.out.println(id + " " + name);
																		}																		 
																		public static void main(String args[]) {
																			Student11 s1 = new Student11(111, "Viet");
																			Student11 s2 = new Student11(222, "Nam");
																			s1.display(); // 111 Viet
																			s2.display(); // 222 Nam
																		}
																	}
			Nếu biến cục bộ và biến toàn cục có tên khác nhau thì không cần sử dụng từ khóa this:				
																											public class Student12 {
																												int id;
																												String name;																												 
																												Student12(int i, String n) {
																													id = i;
																													name = n;
																												}																												 
																												void display() {
																													System.out.println(id + " " + name);
																												}																												 
																												public static void main(String args[]) {
																													Student12 e1 = new Student12(111, "Viet");
																													Student12 e2 = new Student12(222, "Nam");
																													e1.display(); // 111 Viet
																													e2.display(); // 222 Name
																												}
																											}
		Sử dụng this() gọi Constructor của lớp hiện tại:
																	public class Student14 {
																		int id;
																		String name;
																		String city;																	 
																		Student14(int id, String name) {
																			this.id = id;
																			this.name = name;
																		}																	 
																		Student14(int id, String name, String city) {
																			this(id, name); // now no need to initialize id and name. Sẽ gọi constructor 2 tham số phía trên ở đây
																							// Quy tắc: this() phải được khai báo dòng lệnh đầu tiên trong Constructor.
																			this.city = city;
																		}																	 
																		void display() {
																			System.out.println(id + " " + name + " " + city);
																		}																	 
																		public static void main(String args[]) {
																			Student14 e1 = new Student14(111, "Viet");
																			Student14 e2 = new Student14(222, "Nam", "Ha Noi");
																			e1.display(); // 111 Viet null
																			e2.display(); // 222 Nam Ha Noi
																		}
																	}
		Gọi phương thức của lớp hiện tại:
																	public class Example3 {
																		void m() {
																			System.out.println("Gọi phương thức bằng từ khóa this");
																		}																	 
																		void n() {
																			this.m();
																		}																	 
																		void p() {
																			n();// trình biên dịch sẽ thêm this để gọi phương thức n() như this.n()
																		}																	 
																		public static void main(String args[]) {
																			Example3 o1 = new Example3();
																			o1.p();
																		}
																	}
		Sử dụng từ khóa this như một tham số của phương thức:
																	public class Example4 {
																		void m(Example4 obj) {
																			System.out.println("Hello Java");
																		}																	 
																		void p() {
																			m(this); // Từ khóa this được sử dụng như một tham số trong việc xử lý sự kiện
																					 // hoặc trong trường hơp mà chúng ta phải cung cấp tham chiếu của một lớp cho một lớp khác.
																		}																	 
																		public static void main(String args[]) {
																			Example4 o1 = new Example4();
																			o1.p(); // Hello Java
																		}
																	}
		Sử dụng từ khóa this như một tham số của Constructor:
																	class B {  
																	  A4 obj;  
																	  B(A4 obj) {  
																		this.obj=obj; 
																	  }  
																	  void display() {  
																		System.out.println(obj.data);// sử dụng biến thành viên cửa lớp A4
																	  }  
																	}  
																	   
																	class A4 {  
																	  int data=10;  
																	  A4(){  
																	   B b = new B(this); // Bạn cũng có thể truyền từ khóa this trong Constructor.
																					      // Tính năng này rất hữu ích nếu chúng ta phải sử dụng một đối tượng trong nhiều lớp.
																	   b.display();  
																	  }  
																	  public static void main(String args[]) {  
																	   A4 a = new A4(); // 10
																	  }  
																	}
		Sử dụng từ khóa this để trả về instance của lớp hiện tại:
																	class A {  
																		A getA() {  
																			return this;  
																		}  
																		void msg() {
																			System.out.println("Hello Java");
																		}  
																	}  																	   
																	class Test1 {  
																		public static void main(String args[]) {  
																			new A().getA().msg(); // Hello java
																		}  
																	}
	
																	class A5 {
																		void m() {
																			System.out.println(this); //in ra cung tham chieu ID  
																		}																	 
																		public static void main(String args[]) {
																			A5 obj = new A5();
																			System.out.println(obj); //in tham chieu ID. A5@22b3ea59																	 
																			obj.m(); // A5@22b3ea59
																		}
																	}
	
	

	
	
	

	Regex--JAVA:				var inputString = "The quick brown fox jumps over the lazy dog";
		match(/./)				var regexPattern = /./g;
								var matches = inputString.match(regexPattern); // /./g được sử dụng để tìm tất cả các ký tự trong chuỗi.
																			   // ["T", "h", "e", " ", "q", "u", "i", "c", "k", " ", "b", "r", "o", "w",
																				  "n", " ", "f", "o", "x", " ", "j", "u", "m", "p", "s", " ", "o", "v",
																				  "e", "r", " ", "t", "h", "e", " ", "l", "a", "z", "y", " ", "d", "o", "g"]	
		match(/b/)				var regexPattern = /b/g;
								var matches = inputString.match(regexPattern); // tìm kiếm chuỗi ký tự "b" trong chuỗi đầu vào inputString.
																			   // Kết quả của đoạn mã này sẽ là một mảng chứa tất cả các ký tự "b" trong chuỗi. ["b"]
								var regexPattern = /b/;
								var matches = inputString.match(regexPattern); // Kết quả của đoạn mã này sẽ là một mảng chứa thông tin về ký tự "b" đầu tiên trong chuỗi. ["b"]
		match(/ab/)				var regexPattern = /ab/;
								var matches = inputString.match(regexPattern); // tìm kiếm chuỗi "ab" trong chuỗi đầu vào inputString. null
		match(/a|z/)			var regexPattern = /a|z/g;
								var matches = inputString.match(regexPattern); // tìm kiếm bất kỳ ký tự "a" hoặc "z" trong chuỗi đầu vào inputString. ["a", "z"]
		match(/z*/)				var regexPattern = /z*/g; // Biểu thức này khớp với 0 hoặc nhiều ký tự "z".
								var matches = inputString.match(regexPattern); // z*: Biểu thức này khớp với bất kỳ chuỗi nào trong đó ký tự "z" xuất hiện 0 hoặc nhiều lần
																			   // Các chuỗi rỗng ("") đại diện cho các vị trí trong chuỗi inputString mà không chứa ký tự "z".
																			   // ["", "", "", "", "", "", "", "", "", "z", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
		match(/z+/)				var regexPattern = /z+/g;
								var matches = inputString.match(regexPattern); // một mảng chứa tất cả các chuỗi con trong inputString mà bắt đầu bằng một hoặc nhiều ký tự "z". ["z"]
		match(/z?/)				var regexPattern = /z?/g; // Biểu thức này khớp với 0 hoặc 1 ký tự "z". 
								var matches = inputString.match(regexPattern); // một mảng chứa tất cả các chuỗi con trong inputString mà có hoặc không có chứa một ký tự "z".
																			   // ["", "", "", "", "", "", "", "", "", "z", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
																			   //"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""]
		match(/(ab)/)
		match(/[ab-e]/)
		match(/[^ab-e]/)
		match(/\d/)
		match(/\D/)
		match(/\s/)
		match(/\S/)
		match(/\w/)
		match(/\W/)
		match(/\^a/)
		match(/\c$/)
		match(/\t/)
		match(/\n/)
		match(/\r/)
		match(/\0/)
		match(/a{5}/)
		match(/a{3,5}/)
		match(/a{3,}/)
		match(/g/)
		match(/i/)
																																											
	StringBuffer, String Builder--JAVA:		
	
											- StringBuffer: Là mutable, tức là bạn có thể thay đổi nội dung của nó mà không tạo ra một đối tượng mới.
											- String: Là immutable, tức là một khi đã được tạo ra, không thể thay đổi nội dung của nó. Mọi thay đổi trên một đối tượng String sẽ tạo ra một đối tượng mới.
											- Vì String là immutable, việc thực hiện các phép toán như nối chuỗi (+) hoặc thay đổi nội dung của chuỗi sẽ tạo ra nhiều đối tượng String tạm thời, làm tăng chi phí về bộ nhớ và
											thời gian.
											- StringBuffer thích hợp cho các tác vụ mà yêu cầu sự thay đổi nhiều lần nội dung của chuỗi, như khi bạn cần thực hiện các phép toán như nối chuỗi, chèn, xoá.
											- StringBuffer là thread-safe, có nghĩa là nó được đồng bộ hóa và an toàn để sử dụng trong môi trường đa luồng. Điều này đảm bảo rằng các phương thức của StringBuffer sẽ không gây
											ra xung đột dữ liệu khi được sử dụng trong các luồng khác nhau.
											- String không đồng bộ hóa, nghĩa là nó không an toàn để sử dụng trong môi trường đa luồng mà không được đảm bảo.
											- StringBuilder là một lớp tương tự như StringBuffer nhưng không đồng bộ hóa, nghĩa là nó không an toàn để sử dụng trong môi trường đa luồng, nhưng có hiệu suất cao hơn vì không
											phải đồng bộ hóa. Vì vậy, khi cần xây dựng một chuỗi một cách hiệu quả trong một luồng đơn, StringBuilder thường là sự lựa chọn tốt hơn.
	
											StringBuffer sb1 = new StringBuffer();
											StringBuffer sb2 = new StringBuffer(10); // Tạo ra một StringBuffer với kích thước ban đầu là 10 ký tự.
											StringBuffer sb3 = new StringBuffer("Hello"); // Tạo ra một StringBuffer với nội dung ban đầu là "Hello".
		
		append:								
		
											Phương thức append() trong StringBuffer được sử dụng để nối thêm chuỗi hoặc các giá trị khác vào cuối chuỗi hiện tại.
											
											public StringBuffer append(String str)
		
											sb1.append("Hello"); // Thêm chuỗi "Hello"
											sb1.append(" "); // Thêm một khoảng trắng
		
		insert:								
		
											Phương thức insert() trong lớp StringBuffer của Java được sử dụng để chèn một chuỗi hoặc một giá trị vào vị trí cụ thể trong chuỗi hiện tại.
											
											public StringBuffer insert(int offset, String str)
		
											sb1.insert(0, "Java"); // Chèn chuỗi "Java" vào vị trí đầu tiên (index 0)
											sb1.insert(4, " is awesome"); // Chèn chuỗi " is awesome" vào vị trí thứ 4 (index 4).
											System.out.println(sb1.toString()); // "Java is awesome"
		
		delete:								
		
											Phương thức delete() trong lớp StringBuffer của Java được sử dụng để xoá một phần của chuỗi hiện tại, bắt đầu từ vị trí được chỉ định. 
		
											public StringBuffer delete(int start, int end)
											
											sb1.delete(5, 11); // Xóa phần từ vị trí thứ 5 (bao gồm) đến vị trí thứ 11 (không bao gồm).
											System.out.println(sb1.toString()); // "Hello!"
		
		deleteCharAt: 						
		
											Phương thức deleteCharAt() trong lớp StringBuffer của Java được sử dụng để xoá một ký tự ở vị trí được chỉ định trong chuỗi hiện tại.
											
											public StringBuffer deleteCharAt(int index)
		
											sb1.append("Hello world!"); // Thêm chuỗi "Hello world!"
											sb1.deleteCharAt(5); // Xóa ký tự tại vị trí thứ 5 trong chuỗi (" ").
											System.out.println(sb1.toString()); // "Helloworld!"
		
		replace:							
													
											Phương thức replace() trong lớp StringBuffer của Java được sử dụng để thay thế một phần của chuỗi hiện tại bằng một chuỗi khác.
											
											public StringBuffer replace(int start, int end, String str)
		
											sb1.append("Hello world!"); // Thêm chuỗi "Hello world!"
											sb1.replace(6, 11, "Java"); // Thay thế phần từ vị trí thứ 6 (bao gồm) đến vị trí thứ 11 (không bao gồm) bằng chuỗi "Java".
											System.out.println(sb1.toString()); // "Hello Java!"
		
		reverse:							
		
											Phương thức reverse() trong lớp StringBuffer của Java được sử dụng để đảo ngược nội dung của chuỗi hiện tại. 
											
											public StringBuffer reverse()
		
											sb1.append("Hello"); // Thêm chuỗi "Hello"
											sb1.reverse(); // Đảo ngược chuỗi.
											System.out.println(sb1.toString()); // "olleH"
		
		charAt:								
		
											Phương thức charAt() trong lớp StringBuffer của Java được sử dụng để trả về ký tự ở vị trí cụ thể trong chuỗi hiện tại.
											
											public char charAt(int index)
		
											sb1.append("Hello"); // Thêm chuỗi "Hello"
											char ch = sb1.charAt(1); // Lấy ký tự tại vị trí thứ 1 trong chuỗi.
											System.out.println(sb1.toString()); // 'e'
		
		substring:				

											Phương thức substring() trong lớp StringBuffer của Java được sử dụng để trích xuất một phần của chuỗi hiện tại, bắt đầu từ vị trí bắt đầu đến vị trí kết thúc được chỉ định.
											
											public String substring(int startIndex)
											public String substring(int startIndex, int endIndex)
		
											sb1.append("Hello world!"); // Thêm chuỗi "Hello world!"
											String subString1 = sb1.substring(6, 11); // Lấy phần từ vị trí thứ 6 (bao gồm) đến vị trí thứ 11 (không bao gồm).
											System.out.println(subString1.toString()); // "world"
											String subString2 = sb1.substring(6); // Lấy phần từ từ vị trí thứ 6 đến hết.
											System.out.println(subString2.toString()); // "world!"
		
		toString:							
		
											Phương thức toString() trong lớp StringBuffer của Java được sử dụng để chuyển đổi nội dung của StringBuffer thành một đối tượng String.
											
											public String toString()
		
											sb1.append("Hello world!"); // Thêm chuỗi "Hello world!"
											String result = sb1.toString(); // // Sử dụng phương thức toString() để chuyển đổi StringBuffer sb1 thành một String
											System.out.println(result); // "Hello world!"
		
		indexOf:							
													
											Phương thức indexOf() trong lớp StringBuffer của Java được sử dụng để tìm vị trí đầu tiên của một chuỗi con trong chuỗi hiện tại.
											
											public int indexOf(String str)
		
											sb1.append("Hello world!"); // Thêm chuỗi "Hello world!"
											int index1 = sb1.indexOf("world"); // 6
											int index = sb1.indexOf("Hello", 7); // Tìm vị trí xuất hiện đầu tiên của chuỗi con "Hello" trong StringBuffer sb1, bắt đầu từ vị trí thứ 7. 13
		
		lastIndexOf:						
													
											Phương thức lastIndexOf() trong lớp StringBuffer của Java tương tự như phương thức indexOf(), nhưng nó được sử dụng để tìm vị trí cuối cùng của một chuỗi con trong chuỗi hiện tại.

											public int lastIndexOf(String str)											
		
											sb1.append("Hello world! Hello universe!"); // Thêm chuỗi "Hello world! Hello universe!"
											int lastIndex1 = sb1.lastIndexOf("Hello"); // Tìm vị trí xuất hiện cuối cùng của chuỗi con "Hello" trong StringBuffer sb1. 13
											int lastIndex2 = sb1.lastIndexOf("Hello", 18); // Tìm vị trí xuất hiện cuối cùng của chuỗi con "Hello" trong StringBuffer sb1, bắt đầu từ vị trí thứ 18. 0				
	
	Apache Commons Lang3 in Java--JAVA:
	
		StringUtils--JAVA:				
		
										StringUtils là một lớp tiện ích trong thư viện Apache Commons Lang của Java, cung cấp một loạt các phương thức hữu ích để thực hiện các thao tác với chuỗi.
		
										String str = "Hello";
										
			isEmpty:					
										
										boolean empty = StringUtils.isEmpty(str); // false	
			
										import org.apache.commons.lang3.StringUtils;
										public class StringUtilsExample {
											public static void main(String[] args) {
												String emptyString = "";
												String nullString = null;
												String nonEmptyString = "Amit";
												System.out.println(StringUtils.isEmpty(emptyString)); // true
												System.out.println(StringUtils.isEmpty(nullString)); // true
												System.out.println(StringUtils.isEmpty(nonEmptyString)); // false
											}
										}
										
			isNotEmpty:					boolean notEmpty = StringUtils.isNotEmpty(str); // true
			trim:						String trimmed = StringUtils.trim(str); // Loại bỏ các khoảng trắng ở đầu và cuối chuỗi. "Hello"
			trimToNull:					String trimmedOrNull = StringUtils.trimToNull(str); // Loại bỏ các khoảng trắng ở đầu và cuối chuỗi và trả về null nếu chuỗi sau khi loại bỏ khoảng trắng trở thành rỗng."Hello"
			trimToEmpty:				String trimmedToEmpty = StringUtils.trimToEmpty(str); // Loại bỏ các khoảng trắng ở đầu và cuối chuỗi và trả về chuỗi rỗng nếu chuỗi sau khi loại bỏ khoảng trắng trở thành rỗng."Hello"
			capitalize:					
			
										String capitalized = StringUtils.capitalize(str); // Viết hoa ký tự đầu tiên của chuỗi. "Hello"
										
										import org.apache.commons.lang3.StringUtils;
										public class CapitalizeExample {
											public static void main(String[] args) {
												String name = "amit";
												String capitalized = StringUtils.capitalize(name);
												System.out.println(capitalized); // Amit
											}
										}
			uncapitalize:				String uncapitalized = StringUtils.uncapitalize(str); // "hello"
			equals:						
			
										String str2 = "HELLO";
										boolean equalsIgnoreCase = StringUtils.equals(str, str2); // So sánh hai chuỗi, bỏ qua sự khác biệt về hoa thường. true
			
			isNotBlank:					boolean notBlank = StringUtils.isNotBlank(str); // true
			defaultString:				
			
										String defaultStr = "Default";
										String result = StringUtils.defaultString(str, defaultStr); // Trả về chuỗi mặc định nếu chuỗi đầu vào là null, "", hoặc chỉ chứa khoảng trắng. "Hello"
			
			join:						
			
										List<String> list = Arrays.asList("apple", "banana", "orange");
										String joined = StringUtils.join(list, ','); // Ghép các phần tử của một Iterable thành một chuỗi, với ký tự phân tách được chỉ định. "apple,banana,orange"
																					 
										import org.apache.commons.lang3.StringUtils;
										public class StringJoinExample {
											public static void main(String[] args) {
												String[] names = {"Amit", "Priya", "Vikas"};
												String joinedNames = StringUtils.join(names, ", ");
												System.out.println(joinedNames); // Amit, Priya, Vikas
											}
										}											 
			
			startsWith:					boolean startsWith = StringUtils.startsWith(str, "He"); // true
			endsWith:					boolean endsWith = StringUtils.endsWith(str, "lo"); // true
			defaultIfBlank:				
			
										String defaultStr = "Default";
										String result = StringUtils.defaultIfBlank(str, defaultStr); // Trả về chuỗi mặc định nếu chuỗi đầu vào là null, "", hoặc chỉ chứa khoảng trắng.
																									 // "Hello"
			
			EMPTY:						String emptyString = StringUtils.EMPTY; // Một hằng số chuỗi rỗng, được định nghĩa trong StringUtils. ""
			isNotEmpty:					boolean notEmpty = StringUtils.isNotEmpty(str); // true
			
			reverse:
			
										import org.apache.commons.lang3.StringUtils;
										public class ReverseStringExample {
											public static void main(String[] args) {
												String name = "Amit";
												String reversed = StringUtils.reverse(name);
												System.out.println(reversed); // timA
											}
										}
			
		ObjectUtils--JAVA:					
		
										Trong thư viện Apache Commons Lang của Java, ObjectUtils là một lớp tiện ích cung cấp các phương thức hữu ích để làm việc với các đối tượng Java.
		
			isEmpty:					
			
										Object obj1 = null;
										Object obj2 = "";
										Object obj3 = new int[0];

										boolean isEmpty1 = ObjectUtils.isEmpty(obj1); // true
										boolean isEmpty2 = ObjectUtils.isEmpty(obj2); // true
										boolean isEmpty3 = ObjectUtils.isEmpty(obj3); // true
			
			isNotEmpty:
			
										- ObjectUtils.isNotEmpty được sử dụng để kiểm tra xem một đối tượng có rỗng hay không. Cụ thể, phương thức này kiểm tra đối tượng có phải là null hoặc, nếu đối tượng là một mảng, mảng đó
										có kích thước lớn hơn 0.
										
										String[] nonEmptyArray = {"element"}; // Trong Java, mảng phải được khởi tạo bằng cách sử dụng cặp ngoặc nhọn {} để chứa các phần tử của mảng. 
										String[] emptyArray = {};
										String nullString = null;
										boolean result1 = ObjectUtils.isNotEmpty(nonEmptyArray); // true
										boolean result2 = ObjectUtils.isNotEmpty(emptyArray); // false
										boolean result3 = ObjectUtils.isNotEmpty(nullString); // false
			
			defaultIfNull:				
			
										String str = null;
										String defaultValue = "Default";

										String result = ObjectUtils.defaultIfNull(str, defaultValue); // "Default"
			equals:						
			
										Object obj1 = "Hello";
										Object obj2 = "Hello";
										boolean equals = ObjectUtils.equals(obj1, obj2); // So sánh hai đối tượng xem chúng có bằng nhau không, xử lý null an toàn. true
			
			notEqual:
			
										- Phương thức ObjectUtils.notEqual trong Spring Framework được sử dụng để so sánh hai đối tượng và xác định xem chúng có khác nhau hay không. Nó trả về true nếu hai đối tượng không
										bằng nhau, và ngược lại, trả về false nếu hai đối tượng bằng nhau.
										
										String str1 = "hello";
										String str2 = "hello";
										String str3 = "world";
										String str4 = null;
										boolean result1 = ObjectUtils.notEqual(str1, str2); // false
										boolean result2 = ObjectUtils.notEqual(str1, str3); // true
										boolean result3 = ObjectUtils.notEqual(str1, str4); // true
										boolean result4 = ObjectUtils.notEqual(str4, str4); // false
			
			hashCode:					
			
										Object obj = "Hello";
										int hashCode = ObjectUtils.hashCode(obj); // mã băm của chuỗi "Hello"	
			
			toString:					
			
										Object obj = null;
										String defaultValue = "Null Object";
										String result = ObjectUtils.toString(obj, defaultValue); // Trả về biểu diễn chuỗi của một đối tượng,
																								 // xử lý null an toàn và sử dụng giá trị chuỗi mặc định
																								 // nếu đối tượng là null. "Null Object"		
			
			min:						
			
										Integer num1 = 10;
										Integer num2 = 5;
										Integer min = ObjectUtils.min(num1, num2); // 5	
			
			max:						
			
										Integer num1 = 10;
										Integer num2 = 5;
										Integer max = ObjectUtils.max(num1, num2); // 10
			
			nonNull:					
			
										String str = "Hello";
										String result = ObjectUtils.nonNull(str, "Default"); // kiểm tra xem một đối tượng có khác null không. "Hello"
										
			allNotNull:
			
										- Phương thức ObjectUtils.allNotNull trong Spring Framework được sử dụng để kiểm tra xem tất cả các đối tượng trong một tập hợp có phải là không null hay không. Nó trả về true nếu tất
										cả các đối tượng trong tập hợp đều không null, và trả về false nếu có bất kỳ đối tượng nào là null.
										
										String str1 = "hello";
										String str2 = "world";
										String str3 = null;
										Integer num1 = 123;
										boolean result1 = ObjectUtils.allNotNull(str1, str2, num1); // true
										boolean result2 = ObjectUtils.allNotNull(str1, str2, str3); // false
										boolean result3 = ObjectUtils.allNotNull(str3, null, null); // false

			compare:
			
										import org.apache.commons.lang3.ObjectUtils;
										public class CompareExample {
											public static void main(String[] args) {
												String name1 = "Amit";
												String name2 = "Vikas";
												int comparison = ObjectUtils.compare(name1, name2);
												System.out.println(comparison); // -1
											}
										}										
										
		NumberUtils--JAVA:
		
			isCreatable:
										
										- Checking for Numeric Strings
										- You can check if a string is numeric using NumberUtils.
												
												import org.apache.commons.lang3.math.NumberUtils;
												public class NumericCheckExample {
													public static void main(String[] args) {
														String numericString = "12345";
														String nonNumericString = "123A";
														System.out.println(NumberUtils.isCreatable(numericString)); // true
														System.out.println(NumberUtils.isCreatable(nonNumericString)); // false
													}
												}
			
			max:
			
										- Finding the Maximum Value
										- Finding the maximum value in an array is easy with NumberUtils.
												
												import org.apache.commons.lang3.math.NumberUtils;
												public class MaxValueExample {
													public static void main(String[] args) {
														int[] numbers = {5, 10, 15, 20, 25};
														int max = NumberUtils.max(numbers);
														System.out.println(max); // 25
													}
												}
			
			min:
			
										- Finding the Minimum Value
										- Finding the minimum value in an array is simple with NumberUtils.
											
										import org.apache.commons.lang3.math.NumberUtils;
										public class MinValueExample {
											public static void main(String[] args) {
												int[] numbers = {5, 10, 15, 20, 25};
												int min = NumberUtils.min(numbers);
												System.out.println(min); // 5
											}
										}

		ArrayUtils--JAVA:
		
			isEmpty:

										- Checking if an Array is Empty
										- You can check if an array is empty using ArrayUtils.
												
										import org.apache.commons.lang3.ArrayUtils;
										public class ArrayEmptyCheckExample {
											public static void main(String[] args) {
												String[] names = {};
												boolean isEmpty = ArrayUtils.isEmpty(names);
												System.out.println(isEmpty); // true
											}
										}
			
			add:
			
										- Adding Elements to an Array
										- You can add elements to an array using ArrayUtils.
												
										import org.apache.commons.lang3.ArrayUtils;
										public class AddElementExample {
											public static void main(String[] args) {
												String[] names = {"Amit", "Priya"};
												names = ArrayUtils.add(names, "Vikas");
												for (String name : names) {
													System.out.println(name); // Amit Priya Vikas
												}
											}
										}
			
			removeElement:
			
										- Removing Elements from an Array
										- You can remove elements from an array using ArrayUtils.
												
										import org.apache.commons.lang3.ArrayUtils;
										public class RemoveElementExample {
											public static void main(String[] args) {
												String[] names = {"Amit", "Priya", "Vikas"};
												names = ArrayUtils.removeElement(names, "Priya");
												for (String name : names) {
													System.out.println(name); // Amit Vikas
												}
											}
										}	

		DateUtils--JAVA:

			addHours:
			
										- You can add time to dates using DateUtils.
										
										import org.apache.commons.lang3.time.DateUtils;
										import java.util.Date;
										public class AddTimeExample {
											public static void main(String[] args) {
												Date now = new Date();
												Date oneHourLater = DateUtils.addHours(now, 1);
												System.out.println(now); // Fri May 17 12:00:00 IST 2024
												System.out.println(oneHourLater); // Fri May 17 13:00:00 IST 2024
											}
										}
																						
		DateFormatUtils--JAVA:
		
			format:
			
										- Formatting dates can be done using DateFormatUtils.
										
										import org.apache.commons.lang3.time.DateFormatUtils;
										import java.util.Date;
										public class DateFormatExample {
											public static void main(String[] args) {
												Date date = new Date();
												String formattedDate = DateFormatUtils.ISO_8601_EXTENDED_DATE_FORMAT.format(date);
												System.out.println(formattedDate); // 2024-05-17
											}
										}

		RandomStringUtils--JAVA:
		
			randomAlphanumeric:
			
										- Generating random strings can be done using RandomStringUtils.
										
										import org.apache.commons.lang3.RandomStringUtils;
										public class RandomStringExample {
											public static void main(String[] args) {
												String randomString = RandomStringUtils.randomAlphanumeric(10);
												System.out.println(randomString); // aB3dEfG7Hj
											}
										}
										
		RandomUtils--JAVA:

			nextInt:
			
										- Generating random numbers can be done using RandomUtils.
										
										import org.apache.commons.lang3.RandomUtils;
										public class RandomNumberExample {
											public static void main(String[] args) {
												int randomNumber = RandomUtils.nextInt(1, 100);
												System.out.println(randomNumber); // 42
											}
										}	

		CollectionUtils--JAVA:
			
			Ways to check if a collection is empty:
			
				- Here's how easy it is to determine if a collection is empty:
										
											CollectionUtils.isEmpty(null); // true
											CollectionUtils.isEmpty(new LinkedList<>()); // true
											CollectionUtils.isEmpty(Collections.singleton(new int[]{2, 1})); // false
												
												
				- It's just as easy to check that a collection is not empty:
										
											CollectionUtils.isNotEmpty(null); // false
											CollectionUtils.isNotEmpty(new LinkedList<>()); // false
											CollectionUtils.isNotEmpty(Collections.singleton(new int[]{2, 1})); // true
																						
				- Examples:
										
											User ivan = new User("Ivan", "ivan@email.com");
											User petr = new User("Petr", "petr@email.com");
											List<User> users = new ArrayList<>();
											System.out.println(CollectionUtils.isEmpty(users)); // true
											System.out.println(CollectionUtils.isNotEmpty(users)); // false
											users.add(ivan);
											users.add(petr);
											System.out.println(CollectionUtils.isEmpty(users)); // false
											System.out.println(CollectionUtils.isNotEmpty(users)); // true
											users = null;
											System.out.println(CollectionUtils.isEmpty(users)); // true
											System.out.println(CollectionUtils.isNotEmpty(users)); // false
											
			Operations on sets:
												
				- An association
										
											List<String> firstList = Arrays.asList("1", "2", "3", "4", "5", "6");
											List<String> secondList = Arrays.asList("2", "3", "6", "7", "8", "9");
											//combine two sets
											Collection<String> result = CollectionUtils.union(firstList, secondList);
											System.out.println(ArrayUtils.toString(result));     //[1, 2, 3, 4, 5, 6, 7, 8, 9]
										
				- intersection
										
											List<String> firstList = Arrays.asList("A", "B", "C", "D", "E", "F");
											List<String> secondList = Arrays.asList("B", "D", "F", "G", "H", "K");
											//intersections of two sets
											Collection<String> result = CollectionUtils.intersection(firstList, secondList);
											System.out.println(ArrayUtils.toString(result));     //[B, D, F]
												
				- Disjunction
										
											List<String> firstList = Arrays.asList("1", "2", "3", "4", "5", "6");
											List<String> secondList = Arrays.asList("2", "3", "6", "7", "8", "9");
											//disjunction
											Collection<String> result = CollectionUtils.disjunction(firstList, secondList);
											System.out.println(ArrayUtils.toString(result)); //[1, 4, 5, 7, 8, 9]
										
				- Difference (deduction)
										
											List<String> firstList = Arrays.asList("1", "2", "3", "4", "5", "6");
											List<String> secondList = Arrays.asList("2", "3", "6", "7", "8", "9");
											//difference
											Collection<String> result = CollectionUtils.subtract(firstList, secondList);
											System.out.println(ArrayUtils.toString(result)); // [1, 4, 5]
										
				Examples:
										
											List<Integer> firstList = Arrays.asList(1, 2, 3, 3, 4, 5);
											List<Integer> secondList = Arrays.asList(3, 4, 4, 5, 6, 7);
											Collection<Integer> union = CollectionUtils.union(firstList, secondList); // An association
											Collection<Integer> intersection = CollectionUtils.intersection(firstList, secondList); // Intersection
											Collection<Integer> disjunction = CollectionUtils.disjunction(firstList, secondList); // disjunction
											Collection<Integer> subtract = CollectionUtils.subtract(firstList, secondList); // Difference
											System.out.println("firstList: " + ArrayUtils.toString(firstList.toArray()));
											System.out.println("secondList: " + ArrayUtils.toString(secondList.toArray()));
											System.out.println("An association: " + ArrayUtils.toString(union.toArray()));
											System.out.println("Intersection: " + ArrayUtils.toString(intersection.toArray()));
											System.out.println("Disjunction: " + ArrayUtils.toString(disjunction.toArray()));
											System.out.println("Difference: " + ArrayUtils.toString(subtract.toArray()));
											
											Our result:
											firstList: {1,2,3,3,4,5}
											secondList: {3,4,4,5,6,7}
											An association: {1,2,3,3,4,4,5,6,7}
											intersection: {3,4,5}
											Disjunction: {1,2,3,4,6,7}
											Difference: {1,2,3}											
						
	java.util.Objects--JAVA:
		requireNonNull:		        String str = null;
									Objects.requireNonNull(str, "String str must not be null"); // Kiểm tra xem str có khác null không,
																								// nếu không sẽ ném ra ngoại lệ NullPointerException
									String str = null;
									Objects.requireNonNull(str); // Sẽ ném ra NullPointerException
		equals:						String str1 = "Hello";
									String str2 = "World";
									boolean isEqual = Objects.equals(str1, str2); // false

		isNull:						String str = null;
									boolean isNull = Objects.isNull(str); // true			
		nonNull:					String str = "Hello";
									boolean isNonNull = Objects.nonNull(str); // true	
		toString:					String str = "Hello";
									String strValue = Objects.toString(str); // "Hello"


	MultipartFile--JAVA:			
	
									public void processUploadedFile(MultipartFile file) throws IOException {}
		
		getOriginalFilename:		String originalFilename = file.getOriginalFilename(); // Trả về tên gốc của tệp được tải lên từ người dùng
		getContentType:				String contentType = file.getContentType(); // Trả về loại nội dung của tệp
		getBytes:					byte[] bytes = file.getBytes(); // Trả về nội dung của tệp dưới dạng một mảng byte
		getInputStream:				InputStream inputStream = file.getInputStream(); // Trả về một luồng đọc từ tệp
		new File(java.io.File):		File destFile = new File("destination.txt");  // Chuyển dữ liệu tệp đến một vị trí đích


	MailSender--JAVA:					MailSender mailSender = new MailSender();
		sendEmail:						mailSender.sendEmail("recipient@example.com", "Subject", "Hello, this is a simple email."); // Gửi email mà không yêu cầu xác thực
		sendEmailWithAuthentication:	mailSender.sendEmailWithAuthentication(
											"recipient@example.com", "Subject", "Hello, this is an email with authentication."); // // Gửi email với xác thực
		sendEmailWithAttachment:		File attachment = new File("attachment.txt");
										mailSender.sendEmailWithAttachment(
											"recipient@example.com", "Subject with Attachment", "Hello, this is an email with attachment.", attachment); // Gửi email với tệp đính kèm

	BeanUtils--JAVA:
		copyProperties:					
										Sao chép các thuộc tính từ một đối tượng nguồn sang một đối tượng đích.
										Tên thuộc tính phải trùng khớp: 		Cả bean nguồn và bean đích cần có các thuộc tính có cùng tên. Nếu không, phương thức copyProperties sẽ không thể tìm thấy thuộc tính tương ứng để sao chép
																				và sẽ bỏ qua các thuộc tính không khớp.
										Số lượng thuộc tính phải trùng khớp: 	Để phương thức copyProperties hoạt động chính xác, số lượng thuộc tính của bean nguồn và bean đích cần phải giống nhau. Nếu bean đích có các thuộc
																				tính không có trong bean nguồn, các thuộc tính đó sẽ không được thay đổi. Nếu bean nguồn có các thuộc tính mà bean đích không có, khi sử dụng phương
																				thức copyProperties từ BeanUtils, các thuộc tính không khớp sẽ bị bỏ qua và chỉ những thuộc tính có tên giống nhau giữa bean nguồn và bean đích mới
																				được sao chép.
										
										class Person {
											private String name;
											private int age;

											public Person() {
											}

											public Person(String name, int age) {
												this.name = name;
												this.age = age;
											}
										}
										
										Person sourcePerson = new Person("John", 30);
										Person destinationPerson = new Person();
										BeanUtils.copyProperties(destinationPerson, sourcePerson); // Destination Person: Person{name='John', age=30}
	

	Null--JAVA:
	
		Bất kì tham chiếu biến nào thì default là null:
		
															public class Test { 
																private static Object obj; 
																public static void main(String args[]) 
																{ 
																	System.out.println("Value of object obj is : " + obj); // null
																} 
															}
		
		Bất cứ kiểu nào cũng có thể cast về null:
		
															String str = null; // null có thể gán cho String
															Integer itr = null; // null có thể gán cho Integer
															Double dbl = null; // tương tự cho Double
															String myStr = (String) null; // null cũng cast được qua String
															Integer myItr = (Integer) null; // cast null qua Integer
		
		Bị kiểu nguyên thủy (primitive type) kì thị:
		
															public class Kieblog { 
																public static void main (String[] args) throws java.lang.Exception { 
																	Integer i = null; // Integer có thể gán là null 
																	int a = i; // Nhưng nếu gán null cho kiểu nguyên thủy thì sẽ NullpointerException 
																} 
															}

		Bạn biết rằng bạn không thể gọi một phương thức không tĩnh trên biến tham chiếu null, nó sẽ gọi NullPointerException, nhưng bạn có thể không biết rằng bạn có thể gọi một phương thức tĩnh trên biến tham chiếu null. Bởi
		vì các phương thức tĩnh sử dụng liên kết tĩnh, chúng không loại bỏ các tệp NullPointerException
		
															public class Testing {
																public static void main(String args[]){
																	Testing myObject = null;
																	myObject.iAmStaticMethod();
																	myObject.iAmNonStaticMethod();
																}
																private static void iAmStaticMethod(){
																	System.out.println("I am static method, can be called by null reference");
																}
																private void iAmNonStaticMethod(){
																	System.out.println("I am NON static method, don't date to call me by null");
																}
															}
		
		Bạn có thể truyền null làm tham số cho một phương thức chấp nhận bất kỳ loại tham chiếu nào:
		
															public void print(Object obj)
															
															print(null)
															
		Bạn có thể so sánh null bằng cách sử dụng toán ==tử (bằng) và !=(không bằng), nhưng bạn không thể sử dụng nó với các toán tử số học hoặc logic khác như <(nhỏ hơn) hoặc >(lớn hơn). Không giống như SQL, Java
		null == null sẽ trả về true:
		
															public class Test {
																public static void main(String args[]) throws InterruptedException {
																	String abc = null;
																	String cde = null;
																	if(abc == cde){
																		System.out.println("null == null is true in Java");
																	}
																	if(null != null){
																		System.out.println("null != null is false in Java");
																	}
																	// classical null check
																	if(abc == null){
																		// do something
																	}
																	// not ok, compile time error
																	if(abc > null){
																	}
																}
															}		
		
		Tránh lỗi NullPointerException:
		
			Return giá trị--Tránh lỗi NullPointerException Java:
				
				Return một EMPTY collection thay vì giá trị NULL:
																		List<String> findSomething(){
																			if(someCondition){
																				return Collections.emptyList();
																			}
																			//code
																		}
																		
																		public List<User> getUsers() {
																			User[] usersFromDb = getUsersFromDatabase();
																			if (usersFromDb == null) {
																				// No users found in database
																				return new ArrayList<>();    // A mutable list
																			}
																			else {
																				return Arrays.asList(usersFromDb);
																			}
																		}																	
			
			Return một giá trị Unknown/ Default thay vì Null--Tránh lỗi NullPointerException Java:
			
																		public User getUser(UserType type){
																			switch(type) {
																				case ADMIN:
																					return getAdmin();
																				case MANAGER:
																					return getManager();
																				default:
																				break;
																			}
																			return NullUser ();
																		}
																		class NullUser extends User {
																			// Implement all abstract methods of User
																			// Override neccessary methods to drive to do "Nothing" or "Default" action.
																		}
			
			Luôn kiểm tra NULL trước khi sử dụng--Tránh lỗi NullPointerException Java:
			
			Hạn chế sử dụng multi-dot syntax--Tránh lỗi NullPointerException Java:
			
															getLoggedinUser().getUser().getRole().setRoleName("Developer"); // Như bạn thấy đoạn code trên rất dễ gặp lỗi NPE
																															// nếu bất kỳ object LoggedinUser, User, hay Role trả về
																															// giá trị null. 																		
			
			Khởi tạo giá trị trước khi sử dụng--Tránh lỗi NullPointerException Java:				
															
															private List<User> users = new ArrayList<>(); // khởi tạo giá trị empty cho các property khi một instance của object được tạo
			
															public UserManager() {
																users = new ArrayList<>(); // Khởi tạo property trong hàm constructor
															}			

															public List<User> getUsers() {
																if(users == null) {
																	users = new ArrayList<>(); // Khởi tạo property trong Getter
																}
																return users ;
															}
			Wrap return type của mình với Optional--Tránh lỗi NullPointerException Java:			
															
															Optional<String> makingCheck(){
																//code check null
															}
															makingCheck().orElseThrow(SomeKindOfException::new);
															
			Đừng phức tạp hóa một vấn đề phức tạp--Tránh lỗi NullPointerException Java:			
															
															// Dùng máy chém để giết ruồi 
															if(Optional.ofNullable(myVariable).isPresent();

															// Dùng dao mổ trâu để giết ruồi
															if(Objects.nonNull(myVariable))

															// ....trong khi đây là giải pháp giết ruồi hiệu quả nhất
															if(myVariable != null)
															
			Sử dụng object method như là stream predicate--Tránh lỗi NullPointerException Java:		
			
																myStream.filter(Objects::nonNull)
																myStream.anyMatch(Objects:isNull) // khi áp dụng cho stream, chúng ta sẽ cần 2 method này
																
			Validate public API arguments--Tránh lỗi NullPointerException Java:						
			
																public Foo(Bar bar, Baz baz){
																	this.bar = Objects.requireNonNull(bar,"bar must not be null");
																	this.baz = Objects.requireNonNull(baz,"baz must not be null");
																}															
	
	UUID--JAVA:
		Version 4:				UUID uuid = UUID.randomUUID();
		
								MessageDigest salt = MessageDigest.getInstance("SHA-256");
								salt.update(UUID.randomUUID().toString().getBytes("UTF-8"));
								String digest = bytesToHex(salt.digest());
		Version 3 & 5:			String source = namespace + name;
								byte[] bytes = source.getBytes("UTF-8");
								UUID uuid = UUID.nameUUIDFromBytes(bytes);


	MD5--JAVA:
		MD5 Using Apache Commons:							@Test
															public void givenPassword_whenHashingUsingCommons_thenVerifying()  {
																String hash = "35454B055CC325EA1AF2126E27707052";
																String password = "ILoveJava";

																String md5Hex = DigestUtils.md5Hex(password).toUpperCase();
																	
																assertThat(md5Hex.equals(hash)).isTrue();
															}
		MD5 Using MessageDigest Class:						@Test
															public void givenPassword_whenHashing_thenVerifying() 
															  throws NoSuchAlgorithmException {
																String hash = "35454B055CC325EA1AF2126E27707052";
																String password = "ILoveJava";
																	
																MessageDigest md = MessageDigest.getInstance("MD5");
																md.update(password.getBytes());
																byte[] digest = md.digest();
																String myHash = DatatypeConverter
																  .printHexBinary(digest).toUpperCase();
																	
																assertThat(myHash.equals(hash)).isTrue();
															}
		MD5 Using Guava:									@Test
															public void givenFile_whenChecksumUsingGuava_thenVerifying() 
															  throws IOException {
																String filename = "src/test/resources/test_md5.txt";
																String checksum = "5EB63BBBE01EEED093CB22BB8F5ACDC3";
																	
																HashCode hash = com.google.common.io.Files
																  .hash(new File(filename), Hashing.md5());
																String myChecksum = hash.toString()
																  .toUpperCase();
																	
																assertThat(myChecksum.equals(checksum)).isTrue();
															}		


	Exception--JAVA:
	
														Lợi thế cốt lõi của việc xử lý ngoại lệ là duy trì luồng bình thường của ứng dụng. Ngoại lệ thường làm gián đoạn luồng bình thường của ứng dụng khi chương trình chạy đó
														là lý do tại sao chúng ta sử dụng xử lý ngoại lệ.
	
		ArithmeticException:							
		
														Nếu chúng ta chia bất kỳ số nào cho số 0, xảy ra ngoại lệ ArithmeticException.		
		
														int a = 10 / 0; // ArithmeticException
		
		NullPointerException:							
														
														Nếu một bất kỳ biến nào có giá trị null, thực hiện bất kỳ hoạt động nào bởi biến đó sẽ xảy ra ngoại lệ NullPointerException.
														
														String obj = null;
														System.out.println(obj .length()); // NullPointerException
		
		NumberFormatException:							
														
														Một biến String có giá trị là các ký tự, chuyển đổi biến này thành số sẽ xảy ra NumberFormatException.
														
														String str = "abc"; 
														int num = Integer.parseInt(str); // NumberFormatException
		
		ArrayIndexOutOfBoundsException:					
														
														Nếu bạn chèn bất kỳ giá trị nào vào index sai, sẽ xảy ra ngoại lệ ArrayIndexOutOfBoundsException.
														
														int arr[] = new int[5];
														arr[5] = 50; // ArrayIndexOutOfBoundsException
		ClassCastException:								
														
														Nếu không thể chuyển kiểu object này sang kiểu object khác, sẽ xảy ra ngoại lệ ClassCastException.
														
														Object dog = new Dog();
														Rectangle rect = (Rectangle) dog; // Nếu không thể chuyển kiểu object này sang kiểu object khác, sẽ xảy ra ngoại lệ ClassCastException.

		Java NullPointerException:
		
			NullPointerException when calling an instance method:
																									
																									public class Temp {
																										public static void main(String[] args) {
																											Temp t = initT();
																											t.foo("Hi");
																										}
																										private static Temp initT() {
																											return null;
																										}
																										public void foo(String s) {
																											System.out.println(s.toLowerCase());
																										}
																									}
			
			Java NullPointerException while accessing/modifying field of a null object:
																									
																									public class Temp {
																										public int x = 10;
																										public static void main(String[] args) {
																											Temp t = initT();
																											int i = t.x;
																										}
																										private static Temp initT() {
																											return null;
																										}
																									}
			
			Java NullPointerException when null is passed in method argument:
																									
																									public class Temp {
																										public static void main(String[] args) {
																											foo(null);
																										}
																										public static void foo(String s) {
																											System.out.println(s.toLowerCase());
																										}
																									}
			
			java.lang.NullPointerException when null is thrown:
																									
																									public class Temp {
																										public static void main(String[] args) {
																											throw null;
																										}
																									}
			
			NullPointerException when getting the length of null array:
																									
																									public class Temp {
																										public static void main(String[] args) {
																											int[] data = null;																											
																											int len = data.length;
																										}
																									}
			
			NullPointerException when synchronized on a null object:
																									
																									public class Temp {
																										public static String mutex = null;																										
																										public static void main(String[] args) {
																											synchronized(mutex) {
																												System.out.println("synchronized block");
																											}		
																										}
																									}
	GSON--JAVA:
								- GSON là một thư viện mã nguồn mở được sử dụng trong Java để chuyển đổi các đối tượng Java thành định dạng JSON và ngược lại.
								- Chuyển đổi đối tượng Java thành JSON (serialization).
								- Chuyển đổi JSON thành đối tượng Java (deserialization).
								- Hỗ trợ tùy chỉnh cấu hình và quy tắc chuyển đổi.
								- Xử lý các kiểu dữ liệu đặc biệt như null, số nguyên, số thực, mảng, danh sách, v.v.
								- Hỗ trợ cho các tính năng như trích xuất dữ liệu, thực thi ghi chú.
								- toJson() : phương thức dùng để chuyển Java Object sang chuỗi Json (quá trình này được gọi là Serialization). Phương thức này có 1 đối số là đối tượng cần chuyển sang chuỗi Json.
								- fromJson() : phương thức dùng để chuyển chuỗi Json sang Java Object (quá trình này được gọi là Deserialization). Phương thức này có 2 đối số, đối số đầu tiên là chuỗi json, đối
								số thứ hai là kiểu dữ liệu Java Object ứng với chuỗi json.
	
								<dependencies>  
								 <dependency>
									 <groupId>com.google.code.gson</groupId>
									 <artifactId>gson</artifactId>
									 <version>2.8.5</version>
									 <scope>compile</scope>
								 </dependency>
								</dependencies>
																									
								public class Address {
									private String street;									
									private String houseNumber;									
									private String city;									
									private String country;
									public Address(String street, String houseNumber, String city, String country) {
										this.street = street;
										this.houseNumber = houseNumber;
										this.city = city;
										this.country = country;
									}
								}
								public class NestedObject {
									private String name;							
									private String email;								
									private int age;								
									private boolean isDeveloper;								
									private Address address;
									public NestedObject(String name, String email, int age, boolean isDeveloper, Address address) {
										this.name = name;
										this.email = email;
										this.age = age;
										this.isDeveloper = isDeveloper;
										this.address = address;
									}
								}
								
								{
								  "userAddress": {
									"city": "Da Nang",
									"country": "Viet Nam",
									"houseNumber": "tang 4 FHome",
									"street": "ly thuong kiet"
								  },
								  "age": 22,
								  "email": "anh@gmail.com",
								  "isDeveloper": true,
								  "name": "anh"
								}
								Gson gson = new Gson();
								NestedObject nestedObject = new Gson().fromJson(json, NestedObject.class);
								
		Tại sao Gson ra đời--GSON Java:
		
									- Trước khi biết đến gson chắc các bạn đã từng Parse Json trong android bằng cách tạo ra các đối tượng JSONObject hoặc JSONArray. Nếu như đối tượng json của chúng ta khá phức tạp
									thì công việc đó trở nên rất khó khăn, tốn thời gian và nhiều code hơn, khiến dự án ta phình lên một cách không cần thiết.
									- May mắn cho chúng ta là Google đã biết đến điều đó và tạo ra một thư viện vô cùng mạnh mẽ trong việc chuyển đổi tự động từ 'Object' sang 'json' và ngược lại.
		
		Cài đặt thư viện Json--GSON Java:
		
									Chúng ta có những cách sau đây để cài đặt nó:
									
										Thứ nhất: Cách mình vẫn hay sử dụng nhất là sử dụng grandle đặt vào mục dependencies. implementation 'com.google.code.gson:gson:2.8.5
										Thứ hai: Sử dụng Maven:
										
											<dependencies>  
											 <dependency>
												 <groupId>com.google.code.gson</groupId>
												 <artifactId>gson</artifactId>
												 <version>2.8.5</version>
												 <scope>compile</scope>
											 </dependency>
											</dependencies>
								
		Gson làm được những gì?--GSON Java:
		
									- Chuyển đổi qua lại giữa Json và Java Object chưa bao giờ dễ đến thế
									
										Đầu tiên ta xem cách chuyển đổi từ Object sang Json trước nhé. Dữ liệu mình đang dùng chỉ là fake dưới local thôi nhé.
										
											public class User {  
												String name;
												String email;
												int age;
												boolean isDeveloper;										
												public User(String name, String email, int age, boolean isDeveloper) {
													this.name = name;
													this.email = email;
													this.age = age;
													this.isDeveloper = isDeveloper;
												}
											}
											
										Tiếp theo thực hiện khởi tạo một đối tượng Gson và parse object của chúng ta thành json nào.
											
											User user = new User("Sun", "dong.bin@sun-asterisk.com", "4", true)
											Gson gson = new Gson(); 
											String userJson = gson.toJson(user);
											
										Và đây là kết quả sau khi mình đã format cho các bạn dễ nhìn :
											
											{
											  "age": 4,
											  "email": "dong.bin@sun-asterisk.com",
											  "isDeveloper": true,
											  "name": "Sun"
											}
											
											Các bạn có thể thấy phần json kết quả trả về có gì đặc biệt không nào. Nó có { key : value } key là tên thuộc tính và value là phần giá trị mà ta khởi tạo ở trên. Ở đây là mình để mặc
											định nhé các bạn. Mình biết điều bạn đang thắc mắc nhưng để qua phần dưới nhé.
											
									- Tiếp theo ta tìm hiểu cách cách chuyển đổi từ Json sang Object như thế nào nhé !
									- Dấu gạch chéo ngược (\) trong chuỗi Java (hoặc các ngôn ngữ lập trình tương tự) được sử dụng như một ký tự thoát (escape character). Nó cho phép bạn bao gồm các ký tự
									đặc biệt trong chuỗi, mà nếu không, chúng có thể bị hiểu sai hoặc không được chấp nhận.
									
												
												Ta có đoạn json:
												
													String json = ""{\"age\":4,\"email\":\"dong.bin@sun-asterisk.com\"," // dấu \" được sử dụng để thể hiện dấu " trong chuỗi
														+ "\"isDeveloper\":true,\"name\":\"Sun\"}""
														
												Nào tương tự bước trên cùng tạo một đối tượng Gson và sử dụng phương thức fromJson để convert lại đối tượng của ta nào.
												
													Gson gson = new Gson();
													User user = gson.fromJson(json, User.class); // mAge = 4. mEmail = dong.bin@sun-asterisk.com. mIsDeveloper = true. mName = "Sun"
										
		Đối tượng lồng nhau thì làm thế nào ?--GSON Java:
		
									Ta có một lớp Address như bên dưới:
									
										public class Address {
											private String street;								
											private String houseNumber;									
											private String city;								
											private String country;
											public Address(String street, String houseNumber, String city, String country) {
												this.street = street;
												this.houseNumber = houseNumber;
												this.city = city;
												this.country = country;
											}
										}
									
										public class NestedObject {
											private String name;							
											private String email;									
											private int age;									
											private boolean isDeveloper;								
											private Address address;
											public NestedObject(String name, String email, int age, boolean isDeveloper, Address address) {
												this.name = name;
												this.email = email;
												this.age = age;
												this.isDeveloper = isDeveloper;
												this.address = address;
											}
										}
																	
									Bắt đầu thực hiện nào!!!
									
										Address address = new Address("ly thuong kiet", "tang 4 FHome", "Da Nang", "Viet Nam");
										NestedObject nestedObject = new NestedObject("anh", "anh@gmail.com", 22, true, address);
										String result = new Gson().toJson(nestedObject);
										
									- Bạn khoan hãy nhìn kết quả và hãy tự tưởng tượng thử nào !  Ở phần trên chúng ta đã thấy kết quả là nó sẽ parse nguyên một đối tượng sang json vậy thì bây giờ có thêm một đối tượng
									bên trong sẽ như thế nào? Và đây:
									- Khi Gson gặp khóa "userAddress" trong JSON, nó sẽ tìm một trường trong lớp NestedObject có tên userAddress và có kiểu Address. Vì vậy, nó sẽ tự động tạo một đối tượng Address và
									ánh xạ các giá trị của userAddress từ JSON vào đối tượng này.
									
										{
										  "userAddress": {
											"city": "Da Nang",
											"country": "Viet Nam",
											"houseNumber": "tang 4 FHome",
											"street": "ly thuong kiet"
										  },
										  "age": 22,
										  "email": "anh@gmail.com",
										  "isDeveloper": true,
										  "name": "anh"
										}
										
									Phần chuyển từ json trở lại đối tượng không khác gì phần trước các bạn tự kiểm tra nhé :
									
										Gson gson = new Gson();
										NestedObject nestedObject = new Gson().fromJson(json, NestedObject.class);
								
		Chuyển đổi qua lại của Array và List các Object--GSON Java:
		
									- Trong java có nhiều cách để lưu trữ kiểu dữ liệu danh sách. Nhưng ở đây chúng ta đề cập đến 2 cách đó là Array và List. Mỗi cái sẽ có sự khác nhau riêng trong việc parse
									qua json. Trong định dạng của json thì nó không có khái niệm array và list. Vậy chỉ có sự khác biệt nằm ở phía java. Vậy bây giờ chúng ta hãy đi so sánh chúng qua một vài ví dụ
									bên dưới nhé. Chuyển đổi đối tượng sang json Cả array và list đều tương tự như nhau nhé.
									
										Tạo một lớp Restaurant với một List các đối tượng MenuItem
										
											public class MenuItem {
												private String description;
												private float price;
												public MenuItem(String description, float price) {
													this.description = description;
													this.price = price;
												}
											}
											public class Restaurant {
												private String name;
												private List<MenuItem> menuItems;
												public Restaurant(String name, List<MenuItem> menuItems) {
													this.name = name;
													this.menuItems = menuItems;
												}
											}
											
											List<MenuItem> menuItems = new ArrayList<>();
											menuItems.add(new MenuItem("egg", 12.5f));
											menuItems.add(new MenuItem("chicken", 2.5f));
											menuItems.add(new MenuItem("vegetable", 7.5f));
											menuItems.add(new MenuItem("pig", 11.55f));
											Restaurant menu = new Restaurant("VN Food", menuItems);
											String json = new Gson().toJson(menu, Restaurant.class);
										
										Xem kết quả nào
										
											{
											  "menu": [
												{
												  "description": "egg",
												  "price": 12.5
												},
												{
												  "description": "chicken",
												  "price": 2.5
												},
												{
												  "description": "vegetable",
												  "price": 7.5
												},
												{
												  "description": "pig",
												  "price": 11.55
												}
											  ],
											  "name": "VN Food"
											}
											Thứ tự thuộc tính nó sắp xếp theo thứ tự bảng chữ cái nhé các bạn.
									
									Chuyển đổi json sang đối tượng
									
										Ví dụ có một file json như thế này:
										
											[
											  {
												"name": "Hoa Hong",
												"count": 1
											  },
											  {
												"name": "Hoa Lan",
												"count": 3
											  },
											  {
												"name": "Hoa Mai",
												"count": 2
											  }
											]
											
										Ta có một class tương ứng với json như sau:
											
											public class Flower {
												@SerializedName("name")
												private String mName;
												@SerializedName("count")
												private int mCount;
											}
											
										Trường hợp 1: Ta muốn trả về 1 mảng các đối tượng.
										
											// file json mình đã để bên trên
											Flower[] flowers = new Gson().fromJson(json, (Type) Flower[].class);
											
											Type là một giao diện (interface) trong Java thuộc gói java.lang.reflect. Nó là một giao diện chung cho các đối tượng mô tả các kiểu (type) trong Java, bao gồm các
											kiểu đơn giản (primitive), các kiểu tham chiếu (reference), và các kiểu generic (tổng quát hóa).
											Trong trường hợp này, (Type) Flower[].class là một cách để ép kiểu (cast) đối tượng Class<Flower[]> thành một đối tượng Type. Điều này cần thiết vì phương
											thức fromJson(String json, Type typeOfT) của Gson yêu cầu đối số thứ hai phải là một Type, không phải là một Class.
											
										Trường hợp 2: Ta muốn trả về 1 list các đối tượng Chúng ta không thể trực tiếp parse ra list các đối tượng từ json. Để cho Gson hiểu cấu trúc List đó bạn phải chỉ
										ra kiểu của nó. Thật là may mắn. Gson có một lớp TypeToken để giúp chúng ta tìm đúng kiểu của dữ liệu.
										
											// file json tương tự như trên nhé các bạn.
											Gson gson = new Gson();
											Type flowerList = new TypeToken<ArrayList<Flower>>(){}.getType();
											List<Flower> founderList = gson.fromJson(json, flowerList);
								
		Chuyển đổi giá trị null thì sao nhỉ?--GSON Java:
		
									User user = new User(null, "mva@gmail.com", 22, true);
									String json = new Gson().toJson(user); // ??
									
									Đối với những thuộc tính có giá trị null thì Gson sẽ bỏ qua. Kết quả:
										
										{"age":22,"email":"mva@gmail.com","isDeveloper":true}
										
									Thế json nếu như không có thuộc tính giống như đối tượng thì sẽ như thế nào
									
										Câu trả lời là nó sẽ về giá trị mặc định theo từng kiểu dữ liệu. String là null, int là 0...
										
		Thay đổi tên các trường cho phù hợp với json--GSON Java:
		
									Ở các ví dụ trên mình đã để key của các field trong json là tên biến của lớp luôn.
									
									Điều đó thì rất bất tiện
									
										Thứ nhất: về Code Style sẽ không đúng chuẩn
										Thứ hai: khi chúng ta vào dự án thực tế thì json sẽ phụ thuộc từ phía server. Mà chúng ta không thể nào đặt tên giống hoàn toàn theo nó được. Để thực hiện điều đó ta sử
										dụng các chú thích @SerializedName để định nghĩa tên trường cho nó. Quay lại với ví dụ User, thực hiện một số thay đổi nhé các bạn.
										
										private String name;
										//replace by
										@SerializedName(value = "name")
										private String mName;
									
									Ở đây mình có một trường hợp phòng hờ cho các bạn, nếu như phía API vì một lý do nào đó cùng trả về đối tượng đó nhưng tên field của thuộc tính có chút thay đổi để phù hợp
									về mặt ngữ nghĩa của phía Backend. Thì phía chúng ta không thể nào lấy được giá trị đó phải không nào (phần 3.4) mình có đề cập tới vấn đề này rồi nhé.
									Nhắc lại là nó sẽ trả về thuộc tính của đối tượng là null nếu như không có field trùng tên với @SerializedName() mình đã đặt nhé.
									
									Cách giải quyết là Gson hỗ trợ cho ta một thuộc tính thay thế alternate
										
										@SerializedName(value = "name", alternate = "other_name")
										
		Cách bỏ qua sự chuyển đổi của các field--GSON Java:
		
									- Lại là một vấn đề hay nữa, chắc chắn một số bạn mới tìm hiểu khi đọc code của người khác sẽ thắc mắc từ khóa transient và @Expose là gì phải không? Thì đây chính là
									từ khóa để giải quyết vấn đề nêu trên transient
										
										private boolean transient mIsDeveloper;
									
									- Sẽ không thể nào chuyển đổi qua lại giữa đối tượng và json đối với thuộc tính này của User nhé các bạn @Expose Tương tự như transient nhưng nó có sự tùy chỉnh nên rất
									thuận tiện. Mình sẽ giải thích trong code bên dưới nhé
										
										@Expose() // Đây là kiểu mặc định và cho phép thực hiện cả hai sự chuyển đổi
														// việc bạn thêm 2 tham số (serialize = true, deserialize = true) thì cũng như vậy
														// và sẽ có lời nhắc từ IDE là hãy xóa đi
										@SerializedName(value = "name", alternate = "other_name")
										private String mName; 

										@Expose(deserialize = false) // Chỉ cho phép chúng ta chuyển từ đối tượng sang json thôi nhé
										@SerializedName("email")
										private String mEmail;// equals serialize and not deserialize

										@Expose(serialize = false, deserialize = false) // cái này y chang như transient các bạn ạ. :)
										@SerializedName("age")
										private int mAge;  // neither serialize nor deserialize

										@Expose(serialize = false) // đoán xem nào
										@SerializedName("isDeveloper")
										private boolean mIsDeveloper; // not serialize
										
										- Chưa xong đâu các bạn ạ, nếu đã sử dụng @Expose thì phải nói cho Gson nó biết là mình dùng cái này nữa  Y chang như những ví dụ ở trên nhưng việc khởi tạo Gson
										có khác một chút nhé.
										
										Gson gson = new Gson();
										// thay thế bởi
										Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
										GsonBuilder là một kiểu Design Patterns - Builder Pattern. Nó giúp khởi tạo một đối tượng Gson bằng cách gán giá trị cho từng thuộc tính của đối tượng.
									
		Tùy chỉnh đối tượng gson của chúng ta--GSON Java:
		
									- Có rất nhiều kiểu tùy chỉnh cho gson, khi các bạn kết hợp với retrofit thì việc tùy chỉnh sẽ sảy ra rất thường xuyên. Ở đây mình có một ví dụ nhỏ về tùy chỉnh:
										
										Gson gson = new GsonBuilder().serializeNulls().create();
										
									- Ở đây mình cũng khởi tạo một đối tượng Gson bằng builder như ở trên nhé. Các bạn đã biết là với những giá trị null thì mặc định Gson sẽ không chuyển đổi nhưng với một đối
									tượng gson đã chuyển đổi như trên thì việc đó không còn đúng nữa nhé. Nó sẽ tạo ra field tương ứng với value bằng null đấy.
									
		Others--GSON Java:
		
									- Kiến thức về Gson thì rất là nhiều. Việc chúng ta đang học ở đây nhằm có thể thực hiện những việc thường gặp trong quá trình lập trình mà thôi nhé các bạn. Nếu trong một vài
									trường hợp đặc biệt thì mình xin đề xuất các bạn thêm một vài phần nữa về Gson:
										
										Mappings of Map
										Mappings of Set.
										Gson with Lenient Vân vân và mây mây nữa nhé các bạn!
										
		Sử dụng Gson với Collection và Generic Type--GSON Java:
		
									package com.gpcoder.gson;						 
									import java.lang.reflect.Type;
									import java.util.ArrayList;
									import java.util.List;							 
									import com.google.gson.Gson;
									import com.google.gson.GsonBuilder;
									import com.google.gson.reflect.TypeToken;							 
									public class CollectionExample2 {
										public static void main(String[] args) {
											// Gson gson = new Gson();
											Gson gson = new GsonBuilder().setPrettyPrinting().create();
											List<Person> persons = new ArrayList<Person>();
											persons.add(new Person("GP Coder", "Viet Nam"));
											persons.add(new Person("Vincent", "Canada"));							 
											// Serialization
											String json = gson.toJson(persons);  
											System.out.println(json);							 
											// Deserialization
											Type collectionType = new TypeToken<List<Person>>(){}.getType();
											List<Person> persons2 = gson.fromJson(json, collectionType);
											// ==> persons2 is same as persons
										}
									}
									
									Kết quả thực thi chương trình trên:
									
										[
										  {
											"name": "GP Coder",
											"location": "Viet Nam"
										  },
										  {
											"name": "Vincent",
											"location": "Canada"
										  }
										]
										
									Trong ví dụ trên tôi khởi tạo đối tượng Gson sử dụng phương thức GsonBuilder().setPrettyPrinting().create() để tạo chuỗi Json có format.
									
		Sử dụng Gson với Map--GSON Java:
		
									package com.gpcoder.gson;						 
									import java.lang.reflect.Type;
									import java.util.HashMap;
									import java.util.Map;						 
									import com.google.gson.Gson;
									import com.google.gson.reflect.TypeToken;						 
									public class MapExample {
										public static void main(String[] args) {
											Map<String, String> inputMap = new HashMap<String, String>();
											inputMap.put("name", "GP Coder");
											inputMap.put("site", "https://gpcoder.com");
											System.out.println("Input Map: " + inputMap);									 
											Gson gson = new Gson();
											// Serialization
											String json = gson.toJson(inputMap);
											System.out.println("Json: " + json); // {"site":"https://gpcoder.com","name":"GP Coder"}							 
											// Deserialization
											Type mapType = new TypeToken<Map<String, Object>>(){}.getType();
											Map<String, String> outputMap = gson.fromJson(json, mapType);
											System.out.println("Output Map: " + outputMap);
										}
									}
									
		Chuyển đổi qua lại giữa JSON và Java Object--GSON Java:
		
			Chuyển đổi từ Object sang Json
			
				Ví dụ mình có class sau:
				
					public class Person {
						private String name;
						private int age;
						private String address;
						public Person(String name, int age, String address) {
							this.name = name;
							this.age = age;
							this.address = address;
						}
						public String toString() {
							return name + " - " + age + " - " + address;
						}
					}
					
				Tiếp theo để có thể sử dụng các phương thức của Gson ta cần tạo đối tượng Gson. Để chuyển đổi một object sang JSON sử dụng phương thức toJson()
				
					import com.google.gson.Gson;
					public class Main {
						public static void main(String[] args) {
							//Tạo đối tượng Gson
							Gson gson = new Gson();
							Person person = new Person("Ngọc", 5, "Hà Giang");
							//Chuyển đổi từ Object sang JSON
							String result = gson.toJson(person);
							System.out.println(result);
						}
					}
					
					Kết quả nhận được:
						
						{"name":"Ngọc","age":5,"address":"Hà Giang"}
						
			Chuyển đổi từ JSON thành Object
			
				Để chuyển đổi từ JSON sang Object ta cũng cần tạo đối tượng Gson và sử dụng phương thức fromJson() để chuyển đổi
				
					import com.google.gson.Gson;
					public class Main {
						public static void main(String[] args) {
							//Tạo đối tượng Gson
							Gson gson = new Gson();
							//Chuyển đổi từ JSON sang Object
							String json = "{\"name\":\"Linh\",\"age\":8,\"address\":\"Hà Nội\"}";
							Person newPerson = gson.fromJson(json, Person.class);
							System.out.println(newPerson);
						}
					}
					
					Kết quả:
					
						Linh - 8 - Hà Nội
		
		Chuyển đổi giữa JSON và mảng--GSON Java:
		
			Chuyển đổi từ JSON sang mảng
			
				Giả sử mình có một file JSON như sau:
				
					[{
						"name": "Jimmy Buncom",
						"age": 30,
						"address": "Indonesia"
						}, {
						"name": "Lucille Pollastrone",
						"age": 24,
						"address": "Poland"
						}, {
						"name": "Hort Tall",
						"age": 15,
						"address": "Indonesia"
						}, {
						"name": "Ruprecht Plampeyn",
						"age": 21,
						"address": "China"
						}, {
						"name": "Erhard Liles",
						"age": 26,
						"address": "Dominican Republic"
						}, {
						"name": "Fremont Murrow",
						"age": 20,
						"address": "North Korea"
					}]
					
					import com.google.gson.Gson;
					import java.io.FileNotFoundException;
					import java.io.FileReader;
					public class Main {
						public static void main(String[] args) {
							//Tạo đối tượng Gson
							Gson gson = new Gson();
							//Chuyển đổi từ JSON sang mảng
							Person[] persons = null;
							try {
								FileReader reader = new FileReader("person.json");
								persons = gson.fromJson(reader, Person[].class);
							} catch (FileNotFoundException e) {
								e.printStackTrace();
							}
							for (Person p : persons){
								System.out.println(p);
							}
						}
					}
					
					Kết quả trả về:
					
						Jimmy Buncom - 30 - Indonesia
						Lucille Pollastrone - 24 - Poland
						Hort Tall - 15 - Indonesia
						Ruprecht Plampeyn - 21 - China
						Erhard Liles - 26 - Dominican Republic
						
			Chuyển đổi từ mảng sang JSON
			
				import com.google.gson.Gson;
				public class Main {
					public static void main(String[] args) {
						//Tạo đối tượng Gson
						Gson gson = new Gson();
						//Chuyển đổi từ mảng sang JSON
						Person arr[] = new Person[5];
						arr[0] = new Person("John", 25, "American");
						arr[1] = new Person("Chris", 30, "France");
						arr[2] = new Person("Madeline", 19, "Colombia");
						arr[3] = new Person("Anna", 21, "Russia");
						arr[4] = new Person("Hoàng", 27, "Việt Nam");
						String rs = gson.toJson(arr);
						System.out.println(rs);
					}
				}
				
				Kết quả
					[
						{"name": "John","age": 25,"address": "American"},
						{"name": "Chris","age": 30,"address": "France"},
						{"name": "Madeline","age": 19,"address": "Colombia"},
						{"name": "Anna","age": 21,"address": "Russia"},
						{"name": "Hoàng","age": 27,"address": "Việt Nam"}
					]
		
		Chuyển đổi qua lại giữa JSON và Collection--GSON Java:
		
			Với Collection mình sẽ sử dụng ArrayList để thực hiện ví dụ. Mình vẫn sử dụng file JSON ban nãy
			
			Chuyển đổi từ JSON sang ArrayList
			
				Để Gson hiểu được cấu trúc của ArrayList đó ta cần chỉ tới kiểu của nó. Thật may mắn khi Gson có một lớp để giúp ra tìm đúng kiểu dữ liệu đó là TypeToken
					
					import com.google.gson.Gson;
					import com.google.gson.reflect.TypeToken;
					import java.io.FileNotFoundException;
					import java.io.FileReader;
					import java.lang.reflect.Type;
					import java.util.ArrayList;
					public class Main {
						public static void main(String[] args) {
							//Tạo đối tượng Gson
							Gson gson = new Gson();
							//Chuyển đổi từ JSON sang ArrayList
							ArrayList<Person> list = new ArrayList<>();
							try {
								FileReader reader = new FileReader("person.json");
								Type type = new TypeToken<ArrayList<Person>>(){}.getType();
								list = gson.fromJson(reader, type);
							} catch (FileNotFoundException e) {
								e.printStackTrace();
							}
							for(Person p : list){
								System.out.println(p);
							}
						}
					}
					
					Kết quả:
					
						Jimmy Buncom - 30 - Indonesia
						Lucille Pollastrone - 24 - Poland
						Hort Tall - 15 - Indonesia
						Ruprecht Plampeyn - 21 - China
						Erhard Liles - 26 - Dominican Republic
						
				Còn đối với chuyển đổi từ ArrayList sang JSON thì cũng chỉ cần thực hiện tương tự như với chuyển đổi từ mảng sang JSON		
				
		JsonElement--GSON Java:
		
						- JsonElement trong thư viện Gson (Google's Gson) là một interface cơ bản để biểu diễn một giá trị JSON. Nó là một phần của API của Gson và được sử dụng để tương tác với dữ liệu JSON.
						
						- JsonElement có các loại cụ thể sau:
							JsonPrimitive: Đại diện cho một giá trị JSON nguyên thủy như số, boolean, hoặc string.
							JsonObject: Đại diện cho một đối tượng JSON, bao gồm tập hợp các cặp key-value.
							JsonArray: Đại diện cho một mảng JSON, bao gồm một tập hợp các giá trị.
							JsonNull: Đại diện cho giá trị JSON null.
							
						- JsonElement cung cấp các phương thức để kiểm tra và truy cập loại của giá trị JSON, chẳng hạn như:
							isJsonNull(): Kiểm tra nếu giá trị là null.
							isJsonPrimitive(): Kiểm tra nếu giá trị là một JsonPrimitive.
							isJsonObject(): Kiểm tra nếu giá trị là một JsonObject.
							isJsonArray(): Kiểm tra nếu giá trị là một JsonArray.
							getAsString(), getAsNumber(), getAsBoolean(): Truy cập giá trị của JsonPrimitive.
							getAsJsonObject(), getAsJsonArray(): Lấy giá trị dưới dạng JsonObject hoặc JsonArray.
							
						- Ví dụ:
						
							Gson gson = new Gson();
							JsonElement jsonElement = gson.fromJson("{\"name\":\"John\",\"age\":30}", JsonElement.class);
							if (jsonElement.isJsonObject()) {
								JsonObject jsonObject = jsonElement.getAsJsonObject();
								String name = jsonObject.getAsJsonPrimitive("name").getAsString();
								int age = jsonObject.getAsJsonPrimitive("age").getAsInt();
								System.out.println("Name: " + name + ", Age: " + age);
							}
							
		registerTypeAdapter--GSON Java:
		
			- Trong Spring, đặc biệt là khi sử dụng Spring Boot với Gson để xử lý JSON, bạn có thể tùy chỉnh cách mà dữ liệu JSON được chuyển đổi bằng cách sử dụng registerTypeAdapter từ thư
			viện Gson. Điều này giúp bạn định nghĩa cách mà các đối tượng Java được chuyển đổi thành JSON và ngược lại, với sự kiểm soát chi tiết hơn về quá trình chuyển đổi.
			- Tạo Adapter Tùy Chỉnh:
			
				Trước tiên, bạn cần tạo một adapter tùy chỉnh bằng cách kế thừa từ JsonSerializer hoặc JsonDeserializer (hoặc cả hai, tùy thuộc vào nhu cầu của bạn).
				
				import com.google.gson.JsonElement;
				import com.google.gson.JsonPrimitive;
				import com.google.gson.JsonSerializationContext;
				import com.google.gson.JsonSerializer;
				import java.text.SimpleDateFormat;
				import java.util.Date;
				public class DateSerializer implements JsonSerializer<Date> {
					private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
					@Override
					public JsonElement serialize(Date date, Type typeOfSrc, JsonSerializationContext context) {
						return new JsonPrimitive(dateFormat.format(date));
					}
				}
				
			- Cấu Hình Gson trong Spring Boot:
			
				Trong Spring Boot, bạn có thể cấu hình Gson bằng cách tạo một bean của Gson trong lớp cấu hình của ứng dụng. Dưới đây là cách bạn có thể làm điều đó.
				
				import com.google.gson.Gson;
				import com.google.gson.GsonBuilder;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				@Configuration
				public class GsonConfig {
					@Bean
					public Gson gson() {
						GsonBuilder gsonBuilder = new GsonBuilder();
						gsonBuilder.registerTypeAdapter(Date.class, new DateSerializer());
						return gsonBuilder.create();
					}
				}
				
			- Sử Dụng Gson Đã Cấu Hình:
			
				Khi bạn đã cấu hình Gson như trên, Spring Boot sẽ tự động sử dụng cấu hình Gson của bạn khi chuyển đổi giữa các đối tượng Java và JSON.
				
				import org.springframework.web.bind.annotation.GetMapping;
				import org.springframework.web.bind.annotation.RequestMapping;
				import org.springframework.web.bind.annotation.RestController;
				import java.util.Date;
				@RestController
				@RequestMapping("/api")
				public class MyController {
					private final Gson gson;
					public MyController(Gson gson) {
						this.gson = gson;
					}
					@GetMapping("/date")
					public String getDate() {
						Date now = new Date();
						return gson.toJson(now); // Sẽ sử dụng DateSerializer đã cấu hình
					}
				}
				
		GsonHttpMessageConverter--GSON Java:
		
			GsonHttpMessageConverter là một lớp trong Spring Framework, thuộc module spring-web và được sử dụng để chuyển đổi giữa các đối tượng Java và dữ liệu JSON trong
			các ứng dụng web sử dụng Spring MVC.
			Chuyển đổi Dữ liệu JSON: Đọc dữ liệu JSON từ yêu cầu HTTP và chuyển đổi nó thành các đối tượng Java, và ngược lại, chuyển đổi các đối tượng Java thành dữ liệu
			JSON để trả về trong phản hồi HTTP.
			Tích hợp Gson vào Spring MVC: Cung cấp cách dễ dàng để sử dụng Gson cho việc chuyển đổi JSON trong các ứng dụng Spring MVC, thay vì sử dụng Jackson (thư viện
			chuyển đổi JSON mặc định của Spring).
			
			Cấu Hình GsonHttpMessageConverter:
			
				Thêm Dependencies:
				
					<dependency>
						<groupId>org.springframework</groupId>
						<artifactId>spring-web</artifactId>
						<version>5.3.23</version> <!-- Phiên bản tương thích với Spring Framework -->
					</dependency>
					<dependency>
						<groupId>com.google.code.gson</groupId>
						<artifactId>gson</artifactId>
						<version>2.8.9</version> <!-- Phiên bản của Gson -->
					</dependency>
					
				Cấu Hình GsonHttpMessageConverter:
				
					import org.springframework.context.annotation.Configuration;
					import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
					import org.springframework.http.converter.HttpMessageConverter;
					import org.springframework.http.converter.json.GsonHttpMessageConverter;
					import java.util.List;
					import com.google.gson.Gson;
					import com.google.gson.GsonBuilder;
					@Configuration
					public class WebConfig implements WebMvcConfigurer {
						@Override
						public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
							// Tạo một instance của Gson
							Gson gson = new GsonBuilder()
											.setPrettyPrinting()  // Tùy chọn định dạng JSON đẹp
											.create();
							// Tạo và cấu hình GsonHttpMessageConverter
							GsonHttpMessageConverter gsonConverter = new GsonHttpMessageConverter();
							gsonConverter.setGson(gson);
							// Thêm GsonHttpMessageConverter vào danh sách converters
							converters.add(gsonConverter);
						}
					}
					
				Sử Dụng GsonHttpMessageConverter Trong Controller:
				
					Khi bạn đã cấu hình GsonHttpMessageConverter, bạn có thể sử dụng các phương thức xử lý yêu cầu trong Spring MVC để nhận và trả về dữ liệu JSON.
				
					import org.springframework.web.bind.annotation.GetMapping;
					import org.springframework.web.bind.annotation.RequestMapping;
					import org.springframework.web.bind.annotation.RestController;
					@RestController
					@RequestMapping("/api")
					public class ExampleController {
						@GetMapping("/example")
						public MyObject getExample() {
							MyObject obj = new MyObject("example", 123);
							return obj;
						}
					}
					
					public class MyObject {
						private String name;
						private int number;
						// Constructor, Getters and Setters
						public MyObject(String name, int number) {
							this.name = name;
							this.number = number;
						}
						public String getName() {
							return name;
						}
						public void setName(String name) {
							this.name = name;
						}
						public int getNumber() {
							return number;
						}
						public void setNumber(int number) {
							this.number = number;
						}
					}
					
				Ví dụ khác:
				
					package com.poscodx.odc.ampro015.config;
					import com.poscoict.base.share.util.json.JsonUtil;
					import org.springframework.context.annotation.Bean;
					import org.springframework.context.annotation.Configuration;
					import org.springframework.http.converter.json.GsonHttpMessageConverter;
					@Configuration
					public class GsonHttpMessageConverterConfiguration {
						@Bean
						public GsonHttpMessageConverter gsonHttpMessageConverter() {
							GsonHttpMessageConverter converter = new GsonHttpMessageConverter();
							converter.setGson(JsonUtil.getGson());
							return converter;
						}
					}
		
	OOP-JAVA:
		Abstraction:
									Data abstraction is the process of hiding certain details and showing only essential information to the user.
									Abstraction can be achieved with either abstract classes or interfaces
									The abstract keyword is a non-access modifier, used for classes and methods.
									Abstraction can also be achieved with Interfaces
			Abstract class: 		
									Is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
									An abstract class can have both abstract and regular methods.
									Một abstract class có thể có cả phương thức được triển khai và không triển khai.
									Một lớp con chỉ có thể kế thừa từ một abstract class (được biểu diễn bằng từ khóa "extends").
									Các phương thức trong abstract class có thể được đánh dấu là final hoặc static, nếu cần.
									Một interface chỉ chứa các phương thức trừu tượng (tất cả các phương thức mặc định được coi là trừu tượng).
									Một lớp con có thể triển khai nhiều interface (được biểu diễn bằng từ khóa "implements").
									Một interface không thể chứa trường (fields) hoặc biểu thức (expressions) khác ngoài các phương thức trừu tượng.
									Tất cả các phương thức trong interface đều ngầm định là public và abstract.
									
									abstract class Animal {
									  public abstract void animalSound();
									  public void sleep() {
										System.out.println("Zzz");
									  }
									}
									Animal myObj = new Animal(); // will generate an error
									
									abstract class Animal { // Abstract class							  
									  public abstract void animalSound(); // Abstract method (does not have a body)							  
									  public void sleep() { // Regular method
										System.out.println("Zzz");
									  }
									}								
									class Pig extends Animal { // Subclass (inherit from Animal)
									  public void animalSound() {
										// The body of animalSound() is provided here
										System.out.println("The pig says: wee wee");
									  }
									}
									class Main {
									  public static void main(String[] args) {
										Pig myPig = new Pig(); // Create a Pig object
										myPig.animalSound();
										myPig.sleep();
									  }
									}
			Abstract method: 	
									Can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).
		Encapsulation:
									The meaning of Encapsulation, is to make sure that "sensitive" data is hidden from users. To achieve this, you must:
											declare class variables/attributes as private
											provide public get and set methods to access and update the value of a private variable
									Private variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.
									Class attributes can be made read-only (if you only use the get method), or write-only (if you only use the set method)
									Increased security of data
									
									public class Person {
									  private String name; // private = restricted access
									  // Getter
									  public String getName() {
										return name;
									  }
									  // Setter
									  public void setName(String newName) {
										this.name = newName;
									  }
									}
		Inheritance:
									It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class.	
									In Java, it is possible to inherit attributes and methods from one class to another. We group the "inheritance concept" into two categories:
											subclass (child):		 the class that inherits from another class
											superclass (parent):	 the class being inherited from
											
									class Vehicle {
									  protected String brand = "Ford";
									  public void honk() {
										System.out.println("Tuut, tuut!");
									  }
									}
									class Car extends Vehicle {
									  private String modelName = "Mustang";
									  public static void main(String[] args) {
										Car myFastCar = new Car();
										myFastCar.honk();
										System.out.println(myFastCar.brand + " " + myFastCar.modelName);
									  }
									}
			The final Keyword:
									If you don't want other classes to inherit from a class, use the final keyword
									If you try to access a final class, Java will generate an error.
									
									final class Vehicle {
									  ...
									}
									class Car extends Vehicle { // cannot inherit from final Vehicle
									  ...
									}
		Polymorphism:
									Polymorphism means "many forms", and it occurs when we have many classes that are related to each other by inheritance.
									Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action
									in different ways.													
									Overloading là khả năng định nghĩa nhiều phương thức cùng tên trong một lớp, nhưng có số lượng hoặc kiểu dữ liệu tham số khác nhau. Khi gọi phương thức, Java sẽ xác định
									phương thức cần gọi dựa trên số lượng và kiểu dữ liệu của tham số truyền vào. Điểm đặc biệt của overloading là phương thức có thể thực hiện các chức năng tương tự nhau nhưng với các đối số
									khác nhau.
									
									class Animal {
									  public void animalSound() {
										System.out.println("The animal makes a sound");
									  }
									}
									class Pig extends Animal {
									  public void animalSound() {
										System.out.println("The pig says: wee wee");
									  }
									}
									class Dog extends Animal {
									  public void animalSound() {
										System.out.println("The dog says: bow wow");
									  }
									}
									
									class Animal {
									  public void animalSound() {
										System.out.println("The animal makes a sound");
									  }
									}
									class Pig extends Animal {
									  public void animalSound() {
										System.out.println("The pig says: wee wee");
									  }
									}
									class Dog extends Animal {
									  public void animalSound() {
										System.out.println("The dog says: bow wow");
									  }
									}
									class Main {
									  public static void main(String[] args) {
										Animal myAnimal = new Animal();
										Animal myPig = new Pig();
										Animal myDog = new Dog();															
										myAnimal.animalSound(); // The animal makes a sound
										myPig.animalSound(); // The pig says: wee wee
										myDog.animalSound(); // The dog says: bow wow
									  }
									}
	Break & Continue--JAVA:
		Break:
								public class Main {
								  public static void main(String[] args) {
									for (int i = 0; i < 10; i++) {
									  if (i == 4) {
										break;
									  }
									  System.out.println(i);
									}  
								  }
								}
		Continue:
								public class Main {
								  public static void main(String[] args) {
									for (int i = 0; i < 10; i++) {
									  if (i == 4) {
										continue;
									  }
									  System.out.println(i);
									}  
								  }
								}
	Enums--JAVA:
								An enum is a special "class" that represents a group of constants (unchangeable variables, like final variables).
		Enums:
								To create an enum, use the enum keyword (instead of class or interface), and separate the constants with a comma. Note that they should be in uppercase letters.
								
								enum Level {
								  LOW,
								  MEDIUM,
								  HIGH
								}
								public class Main { 
								  public static void main(String[] args) { 
									Level myVar = Level.MEDIUM; // khởi tạo một biến myVar kiểu Level và gán cho nó giá trị Level.MEDIUM. Điều này có nghĩa là biến myVar sẽ đại diện cho mức độ "MEDIUM".
									System.out.println(myVar); 
								  } 
								}
		Enum inside a Class:
											public class Main { 
											enum Level {
												LOW,
												MEDIUM,
												HIGH
											}
			
											public static void main(String[] args) { 
												Level myVar = Level.MEDIUM; 
												System.out.println(myVar); 
											} 
											}
		Enum in a Switch Statement:
											Enums are often used in switch statements to check for corresponding values.
		
											enum Level {
											  LOW,
											  MEDIUM,
											  HIGH
											}
											public class Main { 
											  public static void main(String[] args) {
												Level myVar = Level.MEDIUM; 
															
												switch(myVar) {
												  case LOW:
													System.out.println("Low level");
													break;
												  case MEDIUM:
													System.out.println("Medium level");
													break;
												  case HIGH:
													System.out.println("High level");
													break;
												}
											  }
											}
	Try...Catch--JAVA:
											When executing Java code, different errors can occur: coding errors made by the programmer, errors due to wrong input, or other unforeseeable things.
											When an error occurs, Java will normally stop and generate an error message. The technical term for this is: Java will throw an exception (throw an error).

											public class Main {
											  public static void main(String[] args) {
												try {
												  int[] myNumbers = {1, 2, 3};
												  System.out.println(myNumbers[10]);
												} catch (Exception e) {
												  System.out.println("Something went wrong.");
												}
											  }
											}
											
											public class Main {
											  public static void main(String[] args) {
												try {
												  int[] myNumbers = {1, 2, 3};
												  System.out.println(myNumbers[10]);
												} catch (Exception e) {
												  System.out.println("Something went wrong.");
												} finally {
												  System.out.println("The 'try catch' is finished.");
												}
											  }
											}
											
											public class Main {
											  static void checkAge(int age) { 
												if (age < 18) {
												  throw new ArithmeticException("Access denied - You must be at least 18 years old."); 
												} else {
												  System.out.println("Access granted - You are old enough!"); 
												}
											} 											 
											public static void main(String[] args) { 
											   checkAge(15); 
											 } 
											}
	If ... Else--JAVA:
											public class Main {
											  public static void main(String[] args) {
												if (20 > 18) {
												  System.out.println("20 is greater than 18"); // obviously
												}  
											  }
											}
											
											public class Main {
											  public static void main(String[] args) {
												int time = 20;
												if (time < 18) {
												  System.out.println("Good day.");
												} else {
												  System.out.println("Good evening.");
												}  
											  }
											}

											public class Main {
											  public static void main(String[] args) {
												int time = 22;
												if (time < 10) {
												  System.out.println("Good morning.");
												} else if (time < 18) {
												  System.out.println("Good day.");
												}  else {
												  System.out.println("Good evening.");
												}
											  }
											}
		Short Hand If...Else:						
											public class Main {
											  public static void main(String[] args) {   
												int time = 20;
												String result;
												result = (time < 18) ? "Good day." : "Good evening.";
												System.out.println(result);
											  }
											}

	Inner Classes--JAVA:
											In Java, it is also possible to nest classes (a class within a class). The purpose of nested classes is to group classes that belong together, which makes your code more readable
											and maintainable.
											
											class OuterClass {
											  int x = 10;
											  class InnerClass {
												int y = 5;
											  }
											}
											public class Main {
											  public static void main(String[] args) {
												OuterClass myOuter = new OuterClass();
												OuterClass.InnerClass myInner = myOuter.new InnerClass(); // To access the inner class, create an object of the outer class, and then create an object of the inner class
												System.out.println(myInner.y + myOuter.x);
											  }
											}
		Private Inner Class:
											Unlike a "regular" class, an inner class can be private or protected. If you don't want outside objects to access the inner class, declare the class as private.
											
											class OuterClass {
											  int x = 10;
											  private class InnerClass {
												int y = 5;
											  }
											}
											public class Main {
											  public static void main(String[] args) {
												OuterClass myOuter = new OuterClass();
												OuterClass.InnerClass myInner = myOuter.new InnerClass(); // OuterClass.InnerClass has private access in OuterClass
												System.out.println(myInner.y + myOuter.x); // 15
											  }
											}
		Static Inner Class:
											An inner class can also be static, which means that you can access it without creating an object of the outer class.
											
											class OuterClass {
											  int x = 10;
											  static class InnerClass {
												int y = 5;
											  }
											}
											public class Main {
											  public static void main(String[] args) {
												OuterClass.InnerClass myInner = new OuterClass.InnerClass();
												System.out.println(myInner.y); // 5
											  }
											}
		Access Outer Class From Inner Class:
												One advantage of inner classes, is that they can access attributes and methods of the outer class.
		
												class OuterClass {
												  int x = 10; 
												  class InnerClass {
													public int myInnerMethod() {
													  return x;
													}
												  }
												}
												public class Main {
												  public static void main(String[] args) {
													OuterClass myOuter = new OuterClass();
													OuterClass.InnerClass myInner = myOuter.new InnerClass();
													System.out.println(myInner.myInnerMethod()); // 10
												  }
												}
	Iterator--JAVA:
												An Iterator is an object that can be used to loop through collections, like ArrayList and HashSet. It is called an "iterator" because "iterating" is the technical term for looping.
		Getting an Iterator:
												The iterator() method can be used to get an Iterator for any collection.
												
												import java.util.ArrayList;
												import java.util.Iterator;
												public class Main {
												  public static void main(String[] args) {											  
													// Make a collection
													ArrayList<String> cars = new ArrayList<String>();
													cars.add("Volvo");
													cars.add("BMW");
													cars.add("Ford");
													cars.add("Mazda");											  
													// Get the iterator
													Iterator<String> it = cars.iterator();											  
													// Print the first item
													System.out.println(it.next()); // Volvo
												  }
												}
		Looping Through a Collection:
												import java.util.ArrayList;
												import java.util.Iterator;
												public class Main {
												  public static void main(String[] args) {										  
													// Make a collection
													ArrayList<String> cars = new ArrayList<String>();
													cars.add("Volvo");
													cars.add("BMW");
													cars.add("Ford");
													cars.add("Mazda");												  
													// Get the iterator
													Iterator<String> it = cars.iterator();													
													// Loop through a collection
													while(it.hasNext()) {
													  System.out.println(it.next()); // it.next() được sử dụng để lấy phần tử tiếp theo từ danh sách. Phương thức này trả về phần tử tiếp theo và
																					 // di chuyển con trỏ của Iterator tới phần tử tiếp theo.
													}
												  }
												}
		Removing Items from a Collection:
												Iterators are designed to easily change the collections that they loop through. The remove() method can remove items from a collection while looping.
												
												import java.util.ArrayList;
												import java.util.Iterator;
												public class Main {
												  public static void main(String[] args) {
													ArrayList<Integer> numbers = new ArrayList<Integer>();
													numbers.add(12);
													numbers.add(8);
													numbers.add(2);
													numbers.add(23);
													Iterator<Integer> it = numbers.iterator();
													while(it.hasNext()) { // Vòng lặp tiếp tục lặp lại cho đến khi không còn phần tử nào trong danh sách và it.hasNext() trả về false.
													  Integer i = it.next();
													  if(i < 10) {
														it.remove(); // Nếu giá trị của phần tử là nhỏ hơn 10, it.remove() được sử dụng để xóa phần tử hiện tại khỏi danh sách.
													  }
													}
													System.out.println(numbers);
												  }
												}
	Lambda Expressions--JAVA:
		Syntax:
												- The simplest lambda expression contains a single parameter and an expression:
												
													parameter -> expression
					
												- To use more than one parameter, wrap them in parentheses:
												
													(parameter1, parameter2) -> expression												
												
												- Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex
												operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement.
												
													(parameter1, parameter2) -> { code block }
		Using Lambda Expressions:
			Lambda expressions are usually passed as parameters to a function:
																							import java.util.ArrayList;
																							public class Main {
																							  public static void main(String[] args) {
																								ArrayList<Integer> numbers = new ArrayList<Integer>();
																								numbers.add(5);
																								numbers.add(9);
																								numbers.add(8);
																								numbers.add(1);
																								numbers.forEach( (n) -> { System.out.println(n); } ); // 5 9 8 1
																							  }
																							}
												
			Lambda expressions can be stored in variables if the variable's type
			is an interface which has only one method. The lambda expression should
			have the same number of parameters and the same return type as that method.
			Java has many of these kinds of interfaces built in, such as the Consumer
			interface (found in the java.util package) used by lists.
																							import java.util.ArrayList;
																							import java.util.function.Consumer;
																							public class Main {
																								public static void main(String[] args) {
																									ArrayList<Integer> numbers = new ArrayList<Integer>();
																									numbers.add(5);
																									numbers.add(9);
																									numbers.add(8);
																									numbers.add(1);
																									Consumer<Integer> method = (n) -> { System.out.println(n); };
																									numbers.forEach( method ); // 5 9 8 1
																								}
																							}
			To use a lambda expression in a method, the method should have a parameter
			with a single-method interface as its type. Calling the interface's method
			will run the lambda expression:
																							interface StringFunction {
																							  String run(String str);
																							}
																							public class Main {
																							  public static void main(String[] args) {
																								StringFunction exclaim = (s) -> s + "!";
																								StringFunction ask = (s) -> s + "?";
																								printFormatted("Hello", exclaim);
																								printFormatted("Hello", ask);
																							  }
																							  public static void printFormatted(String str, StringFunction format) {
																								String result = format.run(str);
																								System.out.println(result); // Hello! Hello?
																							  }
																							}
	Modifiers--JAVA:
		Access Modifiers:
											Controls the access level
			classes:
														public:
																			The class is accessible by any other class
																			
																			public class Main {
																			  public static void main(String[] args) {
																				System.out.println("Hello World"); // Hello World
																			  }
																			}
														default:
																			The class is only accessible by classes in the same package. This is used when you don't specify a modifier.
																			
																			class MyClass {
																			  public static void main(String[] args) {
																				System.out.println("Hello World"); // Hello World
																			  }
																			}
			attributes, methods and constructors:
														public:				
																			The code is accessible for all classes
												
																			public class Main {
																			  public String fname = "John";
																			  public String lname = "Doe";
																			  public String email = "john@doe.com";
																			  public int age = 24;
																			}
														private:
																			The code is only accessible within the declared class
																			
																			public class Main {
																			  private String fname = "John";
																			  private String lname = "Doe";
																			  private String email = "john@doe.com";
																			  private int age = 24;																			  
																			  public static void main(String[] args) {
																				Main myObj = new Main();
																				System.out.println("Name: " + myObj.fname + " " + myObj.lname); // Name: John Doe
																				System.out.println("Email: " + myObj.email); // Email: john@doe.com
																				System.out.println("Age: " + myObj.age); // Age: 24
																			  }
																			}
														default:
																			The code is only accessible in the same package. This is used when you don't specify a modifier.
																			
																			class Person {
																			  String fname = "John";
																			  String lname = "Doe";
																			  String email = "john@doe.com";
																			  int age = 24;																		  
																			  public static void main(String[] args) {
																				Person myObj = new Person();
																				System.out.println("Name: " + myObj.fname + " " + myObj.lname);
																				System.out.println("Email: " + myObj.email);
																				System.out.println("Age: " + myObj.age);
																			  }
																			}
														protected:
																			The code is accessible in the same package and subclasses.
																			
																			class Person {
																			  protected String fname = "John";
																			  protected String lname = "Doe";
																			  protected String email = "john@doe.com";
																			  protected int age = 24;
																			}
																			class Student extends Person {
																			  private int graduationYear = 2018;
																			  public static void main(String[] args) {
																				Student myObj = new Student();
																				System.out.println("Name: " + myObj.fname + " " + myObj.lname); // Name: John Doe
																				System.out.println("Email: " + myObj.email); // Email: john@doe.com
																				System.out.println("Age: " + myObj.age); // Age: 24
																				System.out.println("Graduation Year: " + myObj.graduationYear); // Graduation Year: 2018
																			  }
																			}
		Non-Access Modifiers:
			classes:
														final:
																			The class cannot be inherited by other classes
																			
																			final class Vehicle {
																			  protected String brand = "Ford";
																			  public void honk() {
																				System.out.println("Tuut, tuut!");
																			  }
																			}
																			class Main extends Vehicle {
																			  private String modelName = "Mustang";
																			  public static void main(String[] args) {
																				Main myFastCar = new Main();
																				myFastCar.honk();
																				System.out.println(myFastCar.brand + " " + myFastCar.modelName); // lỗi, cannot inherit from final Vehicle
																			  }
																			}
														abstract:
																			The class cannot be used to create objects (To access an abstract class, it must be inherited from another class.)
																			
																			// abstract class
																			abstract class Main {
																			  public String fname = "John";
																			  public String lname = "Doe";
																			  public String email = "john@doe.com";
																			  public int age = 24;
																			  public abstract void study(); // abstract method 
																			}
																			// Subclass
																			class Student extends Main {
																			  public int graduationYear = 2018;
																			  public void study() {
																				System.out.println("Studying all day long");
																			  }
																			}
																			class Second {
																			  public static void main(String[] args) {
																				// create an object of the Student class (which inherits attributes and methods from Main)
																				Student myObj = new Student(); 																			
																				System.out.println("Name: " + myObj.fname + " " + myObj.lname); // Name: John Doe
																				System.out.println("Email: " + myObj.email); // Email: john@doe.com
																				System.out.println("Age: " + myObj.age); // Age: 24
																				System.out.println("Graduation Year: " + myObj.graduationYear); // Graduation Year: 2018
																				myObj.study(); // call abstract method. Studying all day long
																			  }
																			}
			attributes and methods:
														
														final:
																			Attributes and methods cannot be overridden/modified
														static:
																			Attributes and methods belongs to the class, rather than an object
														abstract:
																			Can only be used in an abstract class, and can only be used on methods. The method does not have a body, for example abstract void run();. The body is
																			provided by the subclass (inherited from).
														transient
																			Attributes and methods are skipped when serializing the object containing them
														synchronized:
																			Methods can only be accessed by one thread at a time
														volatile:
																			The value of an attribute is not cached thread-locally, and is always read from the "main memory"
	
	Multi-Dimensional Arrays--JAVA:
														public class Main {
														   public static void main(String[] args) {
															 int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };
															 for (int i = 0; i < myNumbers.length; ++i) {
																for(int j = 0; j < myNumbers[i].length; ++j) {
																   System.out.println(myNumbers[i][j]);
																}
															 }
														   }
														}
	Packages--JAVA:
														A package in Java is used to group related classes. Think of it as a folder in a file directory. We use packages to avoid name conflicts, and to write a better maintainable
														code.
		Built-in Packages:
														The library is divided into packages and classes. Meaning you can either import a single class (along with its methods and attributes), or a whole package that contain all
														the classes that belong to the specified package.
														
														import package.name.Class;   // Import a single class
														import package.name.*;   // Import the whole package
														
														import java.util.Scanner; // import the Scanner class 
														class Main {
														  public static void main(String[] args) {
															Scanner myObj = new Scanner(System.in);
															String userName;														
															// Enter username and press Enter
															System.out.println("Enter username"); 
															userName = myObj.nextLine();   														   
															System.out.println("Username is: " + userName);        
														  }
														}
														
														import java.util.*; // import the java.util package 
														class Main {
														  public static void main(String[] args) {
															Scanner myObj = new Scanner(System.in);
															String userName;														
															// Enter username and press Enter
															System.out.println("Enter username"); 
															userName = myObj.nextLine();   											   
															System.out.println("Username is: " + userName);        
														  }
														}
		User-defined Packages:
														To create your own package, you need to understand that Java uses a file system directory to store them. Just like folders on your computer.
														
														To create a package, use the package keyword:
														
														package mypack;
														class MyPackageClass { 
														  public static void main(String[] args) { 
															System.out.println("This is my package!"); 
														  } 
														}
														
														Save the file as MyPackageClass.java, and compile it:
														C:\Users\Your Name>javac MyPackageClass.java
														
														Then compile the package:
														C:\Users\Your Name>javac -d . MyPackageClass.java // The -d keyword specifies the destination for where to save the class file. You can use any directory name, like
																										  // c:/user (windows), or, if you want to keep the package within the same directory, you can use the dot sign "."
																										  // When we compiled the package in the example above, a new folder was created, called "mypack".
																										  
														To run the MyPackageClass.java file, write the following:
														C:\Users\Your Name>java mypack.MyPackageClass
														
														The output will be:
														This is my package!
	Recursion--JAVA:
														Trong Java, việc gọi một phương thức trước khi nó được khai báo không gây ra lỗi bởi vì Java Compiler (trình biên dịch Java) thực hiện quá trình biên dịch hai lần.
														Khi bạn biên dịch một chương trình Java, Compiler đi qua mã nguồn và tạo ra một tệp bytecode (.class) chứa thông tin về các lớp, phương thức và biến trong chương trình.
														Trong quá trình này, Compiler chỉ quan tâm đến xác định tên và kiểu dữ liệu của các biến và phương thức mà không cần biết thực tế các phương thức được triển khai ở đâu.
														Khi chương trình được chạy (runtime), JVM (Java Virtual Machine) sẽ tải các tệp bytecode và thực thi chúng. Trước khi chạy chương trình, JVM sẽ xác định và kiểm tra sự tồn
														tại của các phương thức được gọi trong quá trình chạy.
														Do đó, trong trường hợp của bạn, mặc dù phương thức sum được gọi trước khi nó được khai báo, nhưng trong quá trình biên dịch, Compiler chỉ cần xác định rằng có một phương
														thức có tên là sum với kiểu trả về int và một tham số kiểu int. Quá trình biên dịch không yêu cầu phải biết định nghĩa thực tế của phương thức đó.
														Khi JVM thực thi chương trình, nó sẽ tìm và xác định đúng phương thức sum trong cùng một lớp và thực thi nó một cách bình thường.
														Tóm lại, trong quá trình biên dịch, việc gọi một phương thức trước khi nó được khai báo không gây ra lỗi bởi vì Compiler chỉ cần xác định kiểu và tên của phương thức, và
														quá trình tìm đúng định nghĩa phương thức xảy ra trong quá trình chạy (runtime) của chương trình.
		Recursion:
														Recursion is the technique of making a function call itself. This technique provides a way to break complicated problems down into simple problems which are easier to solve.
														
														public class Main {
														  public static void main(String[] args) {
															int result = sum(10);
															System.out.println(result);
														  }
														  public static int sum(int k) {
															if (k > 0) {
															  return k + sum(k - 1);
															} else {
															  return 0;
															}
														  }
														}
														Example Explained:
														10 + sum(9)
														10 + ( 9 + sum(8) )
														10 + ( 9 + ( 8 + sum(7) ) )
														...
														10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + sum(0)
														10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 + 0
	Switch--JAVA:
														public class Main {
														  public static void main(String[] args) {
															int day = 4;
															switch (day) {
															  case 1:
																System.out.println("Monday");
																break;
															  case 2:
																System.out.println("Tuesday");
																break;
															  case 3:
																System.out.println("Wednesday");
																break;
															  case 4:
																System.out.println("Thursday");
																break;
															  case 5:
																System.out.println("Friday");
																break;
															  case 6:
																System.out.println("Saturday");
																break;
															  case 7:
																System.out.println("Sunday");
																break;
															}
														  }
														}
														
														public class Main {
														  public static void main(String[] args) {
															int day = 4;
															switch (day) {
															  case 6:
																System.out.println("Today is Saturday");
																break;
															  case 7:
																System.out.println("Today is Sunday");
																break;
															  default:
																System.out.println("Looking forward to the Weekend");
															}    
														  }
														}
	Type Casting--JAVA:
														
														- Type casting is when you assign a value of one primitive data type to another type.
														- Ưu tiên cast từ kiểu nhỏ sang kiểu lớn để không mất mát dữ liệu
														- Cần phân biệt kiểu dữ liệu nguyên thủy, wrapper và object. Kiểu nguyên thủy có thể chuyển đổi không gây thông báo lỗi, kiểu wrapper có thể tự động chuyển thành kiểu nguyên
														thủy tương ứng, kiểu object muốn chuyển kiểu thì phải có mối quan hệ kế thừa
		
		Widening Casting:
														
														Widening Casting (automatically) - converting a smaller type to a larger type size
														
														byte -> short -> char -> int -> long -> float -> double
														
														public class Main {
														  public static void main(String[] args) {
															int myInt = 9;
															double myDouble = myInt; // Automatic casting: int to double
															System.out.println(myInt);
															System.out.println(myDouble);
														  }
														}
		
		Narrowing Casting:
														
														Narrowing Casting (manually) - converting a larger type to a smaller size type
														
														public class Main {
														  public static void main(String[] args) {
															double myDouble = 9.78d;
															int myInt = (int) myDouble; // Explicit casting: double to int
															System.out.println(myDouble);
															System.out.println(myInt);
														  }
														}
		
		Autoboxing/Unboxing:
			
			Autoboxing:
														
														- Autoboxing là quá trình tự động chuyển đổi từ một kiểu dữ liệu nguyên thủy sang một kiểu dữ liệu bao (wrapper class) tương ứng khi cần thiết.
														- Java tự động thực hiện autoboxing khi bạn sử dụng một biến kiểu dữ liệu nguyên thủy trong một ngữ cảnh yêu cầu một đối tượng của lớp bao.
														
														int numInt = 10;
														Integer objInt = numInt; // Autoboxing: tự động chuyển đổi từ int sang Integer
			
			Unboxing:
														
														- Unboxing là quá trình tự động chuyển đổi từ một kiểu dữ liệu bao (wrapper class) sang một kiểu dữ liệu nguyên thủy tương ứng khi cần thiết.
														- Java tự động thực hiện unboxing khi bạn sử dụng một đối tượng của lớp bao trong một ngữ cảnh yêu cầu một kiểu dữ liệu nguyên thủy.
														
														Integer objInt = 10;
														int numInt = objInt; // Unboxing: tự động chuyển đổi từ Integer sang int
		
		Ép kiểu từ object (tự thêm):
																					
																			- Trong cả hai trường hợp, nếu kiểu dữ liệu của biến kiểu Object không tương thích với kiểu dữ liệu bạn muốn chuyển đổi thành, hoặc nếu không thể
																			thực hiện chuyển đổi (ví dụ: khi ép kiểu từ String sang Integer nhưng chuỗi không phải là một số hợp lệ), một ngoại lệ ClassCastException sẽ
																			được ném. Do đó, bạn cần chắc chắn kiểm tra và xử lý các trường hợp ngoại lệ này khi cần thiết.
																			- Chúng ta chỉ có thể ép kiểu giữa các đối tượng của các lớp có mối quan hệ kế thừa. Nếu hai lớp không có mối quan hệ kế thừa, chúng ta không
																			thể ép kiểu chúng với nhau.
			
			Ép kiểu bằng phương thức của lớp bao (Wrapper Class Method):
																					
																					- Các lớp bao trong Java cung cấp các phương thức static để chuyển đổi từ các kiểu dữ liệu nguyên thủy hoặc các đối tượng khác sang đối tượng
																					của lớp bao.
																					
																					Object obj = "123";
																					Integer num = Integer.valueOf((String) obj); // Ép kiểu từ Object sang Integer bằng phương thức valueOf()
			
			Ép kiểu bằng kiểu ép kiểu (Casting):
																					
																					- Bạn cũng có thể sử dụng kiểu ép kiểu (casting) để ép kiểu một biến kiểu Object sang một kiểu dữ liệu cụ thể.
																					- Bạn cần chú thích kiểu dữ liệu bạn muốn chuyển đổi thành bên trái của toán tử ép kiểu và đặt biến kiểu Object bạn muốn chuyển đổi bên phải của
																					toán tử ép kiểu.
																					
																					Object obj = "123";
																					Integer num = (Integer) obj; // Ép kiểu từ Object sang Integer bằng kiểu ép kiểu (Casting)
		
		Ép kiểu trong quan hệ kế thừa (tự thêm):
		
			- Trong Java, ép kiểu trong quan hệ kế thừa được thực hiện thông qua các phương thức ép kiểu (type casting). Quan hệ kế thừa cho phép một lớp con (subclass) kế thừa các thuộc tính và phương thức
			của một lớp cha (superclass).
			- Có hai loại ép kiểu chính trong quan hệ kế thừa: ép kiểu từ lớp cha xuống lớp con (downcasting) và ép kiểu từ lớp con lên lớp cha (upcasting).
			
			Upcasting:
			
				- Upcasting là quá trình ép kiểu một đối tượng từ lớp con lên lớp cha. Upcasting không cần ép kiểu tường minh và luôn an toàn.
				
				class Animal {
					void makeSound() {
						System.out.println("Some generic animal sound");
					}
				}
				class Dog extends Animal {
					void makeSound() {
						System.out.println("Bark");
					}
					
					void fetch() {
						System.out.println("Fetching...");
					}
				}
				public class Main {
					public static void main(String[] args) {
						Dog dog = new Dog();
						Animal animal = dog; // Upcasting					
						animal.makeSound(); // Output: Bark
					}
				}
				Trong ví dụ này, đối tượng dog của lớp Dog được upcast lên kiểu Animal.
				
			Downcasting:
			
				- Downcasting là quá trình ép kiểu một đối tượng từ lớp cha xuống lớp con. Downcasting cần phải ép kiểu tường minh và có thể không an toàn nếu đối tượng thực sự không thuộc về lớp con.
				
				class Animal {
					void makeSound() {
						System.out.println("Some generic animal sound");
					}
				}
				class Dog extends Animal {
					void makeSound() {
						System.out.println("Bark");
					}
					
					void fetch() {
						System.out.println("Fetching...");
					}
				}
				public class Main {
					public static void main(String[] args) {
						Animal animal = new Dog(); // Upcasting
						Dog dog = (Dog) animal; // Downcasting						
						dog.makeSound(); // Output: Bark
						dog.fetch(); // Output: Fetching...
					}
				}
				Trong ví dụ này, đối tượng animal ban đầu được upcast từ Dog lên Animal, và sau đó được downcast trở lại Dog.
				
			Kiểm Tra An Toàn Với instanceof:
			
				- Trước khi thực hiện downcasting, nên sử dụng toán tử instanceof để đảm bảo rằng ép kiểu là an toàn.
				
				public class Main {
					public static void main(String[] args) {
						Animal animal = new Dog(); // Upcasting					
						if (animal instanceof Dog) {
							Dog dog = (Dog) animal; // Downcasting
							dog.makeSound(); // Output: Bark
							dog.fetch(); // Output: Fetching...
						} else {
							System.out.println("The object is not a Dog");
						}
					}
				}
				
				
		
	While & Do While Loop--JAVA:
		While:
														public class Main {
														  public static void main(String[] args) {
															int i = 0;
															while (i < 5) {
															  System.out.println(i); // 0 1 2 3 4
															  i++;
															}  
														  }
														}
		Do/While Loop:
														public class Main {
														  public static void main(String[] args) {
															int i = 0;
															do {
															  System.out.println(i); // 0 1 2 3 4
															  i++;
															}
															while (i < 5);  
														  }
														}
	Wrapper Classes--JAVA:
														Wrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects.
														Sometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store
														objects).
														
														import java.util.ArrayList;
														public class Main { 
														  public static void main(String[] args) { 
															ArrayList<Integer> myNumbers = new ArrayList<Integer>();
															myNumbers.add(10);
															myNumbers.add(15);
															myNumbers.add(20);
															myNumbers.add(25);
															for (int i : myNumbers) {
															  System.out.println(i);
															}
														  } 
														}
														
														public class Main { 
														  public static void main(String[] args) { 
															Integer myInt = 5; 
															Double myDouble = 5.99; 
															Character myChar = 'A'; 
															System.out.println(myInt);
															System.out.println(myDouble);
															System.out.println(myChar);
														  }
														}
														
														public class Main { 
														  public static void main(String[] args) { 
															Integer myInt = 100; 
															String myString = myInt.toString();
															System.out.println(myString.length());
														  }
														}
	So sánh equals và ==--Java:
														public class Main {
															public static void main(String[] args) {
																String str1 = new String("Hello");
																String str2 = new String("Hello");
																System.out.println(str1.equals(str2));  // true
																System.out.println(str1 == str2);       // false
																Integer num1 = new Integer(5);
																Integer num2 = new Integer(5);
																System.out.println(num1.equals(num2));  // true
																System.out.println(num1 == num2);       // false
																String str3 = "Hello";
																String str4 = "Hello";
																System.out.println(str3.equals(str4));  // true
																System.out.println(str3 == str4);       // true
																Integer num3 = 5;
																Integer num4 = 5;
																System.out.println(num3.equals(num4));  // true
																System.out.println(num3 == num4);       // true
															}
														}
		equals():
														Phương pháp equals() được sử dụng để so sánh giá trị của hai đối tượng.
														Nếu hai đối tượng có giá trị tương đương, phương pháp equals() sẽ trả về true.
														Phương pháp equals() được ghi đè từ lớp Object và có thể được ghi đè lại trong các lớp con để cung cấp việc so sánh tùy chỉnh cho đối tượng.
														Thường được sử dụng cho so sánh giá trị của các đối tượng không thuộc kiểu nguyên thủy.
		==:
														Toán tử == được sử dụng để so sánh hai đối tượng để xem liệu chúng có cùng tham chiếu hay không.
														Nếu hai đối tượng có cùng tham chiếu, tức là chúng đều trỏ đến cùng một vị trí bộ nhớ, thì toán tử == sẽ trả về true.
														Toán tử == không thể được ghi đè và chỉ hoạt động với kiểu nguyên thủy và tham chiếu.
	instanceof--JAVA:
														Trong Java, instanceof có thể được sử dụng để kiểm tra xem một đối tượng có thuộc về một lớp cụ thể hoặc một giao diện không. Do đó, kiểu dữ liệu nào cũng có thể được sử
														dụng với instanceof miễn là nó là một loại dữ liệu đối tượng (object type). Điều này bao gồm:
															Lớp (Class):						
																								Bạn có thể sử dụng instanceof để kiểm tra xem một đối tượng có phải là một thể hiện của một lớp cụ thể không.
																								Ví dụ: object instanceof MyClass.
															Giao diện (Interface):				
																								Bạn cũng có thể sử dụng instanceof để kiểm tra xem một đối tượng có thực thi một giao diện cụ thể không.
																								Ví dụ: object instanceof MyInterface.
															Lớp trừu tượng (Abstract class):
																								Tương tự như lớp cụ thể, bạn có thể sử dụng instanceof để kiểm tra xem một đối tượng có phải là một thể hiện của một lớp trừu tượng
																								cụ thể không.
															Lớp gốc (Object class):
																								Mọi đối tượng trong Java đều là thể hiện của lớp Object, vì vậy bạn có thể sử dụng instanceof để kiểm tra xem một đối tượng có phải 
																								là một thể hiện của Object hay không.
																								
															Object obj = new MyClass();
															if (obj instanceof MyClass) {
																System.out.println("obj là một thể hiện của MyClass");
															}

	Generic--JAVA:
								
								- Java Generics cho phép chúng ta viết một phương thức duy nhất có thể thực hiện các hoạt động trong nhiều loại đối tượng hỗ trợ phương thức đó. Sử dụng các lớp và phương thức Java Generic, lập
								trình viên có thể chỉ định một tập hợp các phương thức có liên quan với một khai báo phương thức chung / chung hoặc với một khai báo một lớp.
								- Một lớp Generic trong Java có thể là một  lớp tham chiếu đến bất kỳ kiểu nào. Để tạo một  lớp chung của một kiểu cụ thể, chúng ta đặt tham số kiểu T. Dấu ngoặc nhọn <> được sử dụng để chỉ
								định các kiểu tham số trong tạo lớp chung của Java.
								- Thuật ngữ Generics trong Java đại diện cho một tập hợp các tính năng trong một ngôn ngữ, liên quan đến việc xác định và sử dụng các phương thức và kiểu chung. Generics là một tính năng của
								Java giúp cho lập trình viên có thể chỉ định rõ kiểu dữ liệu mà họ muốn làm việc với một class, một interface hay một phương thức nào đó Trong Java, các phương thức và kiểu chung chung khác
								với các phương thức và kiểu thông thường. Chúng khác nhau vì các phương thức chung có tham số kiểu.
								
		Quy tắc xác định các phương thức Generics:
		
								- Nên có một phần tham số kiểu trong tất cả các khai báo phương thức chung, được phân cách bằng dấu ngoặc nhọn <> đứng trước kiểu trả về của phương thức.
								- Nếu có nhiều hơn một tham số trong danh sách tham số thì mỗi tham số kiểu phải được phân tách bằng dấu phẩy.
								- Chúng ta cũng có thể sử dụng các tham số kiểu để khai báo kiểu trả về và để chúng hoạt động như trình giữ chỗ cho các kiểu đối số được truyền cho phương thức chung, được gọi là đối số kiểu thực.
								- Phần thân phương thức của một phương thức chung được khai báo tương tự như bất kỳ phương thức không chung nào khác.
								- Tham số kiểu trong một phương thức chỉ có thể đại diện cho các kiểu tham chiếu, các kiểu không nguyên thủy như int, double và char.
		
		Cách tạo lớp Generics trong Java:
		
								Việc khai báo một lớp generic tương tự như việc khai báo lớp non-generic. Sự khác biệt duy nhất là tên lớp generic được theo sau bởi một phần tham số kiểu. Đoạn mã dưới đây cho thấy ví dụ tạo
								một lớp chung. Ở đây, kiểu T chỉ ra rằng nó có thể tham chiếu đến bất kỳ kiểu lớp nào như số nguyên, chuỗi, ký tự,...Kiểu lớp được chỉ định sẽ lưu trữ và truy xuất dữ liệu cùng.
								
								class MyGenClass<T>
								{
									   T obj;
									   void add(T obj)
									   {

											  this.obj=obj;
									   }
									   T getObj()
									   {
											  return obj;
									   }
								}
								
								package com.techvidvan.javagenerics;
								class Test<T, U>
								{
								  T obj1; // An object of type T
								  U obj2; // An object of type U
								  // constructor
								  Test(T obj1, U obj2)
								  {
									this.obj1 = obj1;
									this.obj2 = obj2;
								  }
								  // To print objects of T and U
								  public void getObject()
								  {
									System.out.println(“String value: “ +obj1);
									System.out.println(“Integer value: ” +obj2);
								  }
								}
								class Main
								{
								  public static void main (String[] args)
								  {
									Test <String, Integer> obj = new Test<String, Integer>("TechVidvan", 15);
									obj.getObject();
								  }
								}

		Quy ước đặt tên tham số:
	
								T - Type
								E - Element
								K - Key
								N - Number
								V - Value
		
		Lớp Generic trong java:
	
			Một lớp có thể tham chiếu bất kỳ kiểu đối tượng nào được gọi là lớp generic.

								package vn.viettuts.generics;
								class MyGeneric<T> {
									T obj;							
									void add(T obj) {
										this.obj = obj;
									}							 
									T get() {
										return obj;
									}
								}
								
			Ví dụ khi bạn định nghĩa MyGeneric<Integer> tức là T = Integer, lúc này bạn có thể hình dung lớp MyGeneric có dạng như sau:
		
								package vn.viettuts.generics;
								class MyGeneric {
									Integer obj;							
									void add(Integer obj) {
										this.obj = obj;
									}						 
									Integer get() {
										return obj;
									}
								}
			Trong lớp trên, tại dòng lệnh thứ 6 chúng ta khai báo như sau MyGeneric<Integer>, có nghĩa là kiểu chung T sẽ là Integer. Tại dòng lệnh thứ 11 chúng ta khai báo như sau MyGeneric<String>, có nghĩa là kiểu chung T sẽ
			là String
		
								package vn.viettuts.generics;
								public class TestGenerics3 {
									public static void main(String args[]) {
										// use Integer
										MyGeneric<Integer> m1 = new MyGeneric<Integer>();
										m1.add(2);
										System.out.println(m1.get()); // 2
										// use String
										MyGeneric<String> m2 = new MyGeneric<String>();
										m2.add("Hello");
										System.out.println(m2.get()); // hello
									}
								}
		Phương thức Generic trong java:
		
			Giống như lớp generic, chúng ta có thể tạo phương thức generic có thể chấp nhận bất kỳ kiểu đối số nào.
			
								package vn.viettuts.generics;
								public class TestGenerics4 {							 
									public static <E> void printArray(E[] elements) {
										for (E element : elements) {
											System.out.print(element + " ");
										}
										System.out.println();
									}							 
									public static void main(String args[]) {
										Integer[] intArray = { 10, 20, 30, 40, 50 };
										Character[] charArray = { 'J', 'A', 'V', 'A' };						 
										System.out.print("In mảng số nguyên: "); // In mảng số nguyên: 10 20 30 40 50 
										printArray(intArray);						 
										System.out.print("In mảng ký tự: "); // In mảng ký tự: J A V A
										printArray(charArray);
									}
								}

			Ký tự đại diện trong Java Generics:
			
								Ký tự ? (dấu chấm hỏi) tượng trưng cho phần tử ký tự đại diện. Nó có nghĩa là bất kỳ loại nào. Nếu chúng ta viết <? mở rộng Number>, nó có nghĩa là bất kỳ lớp con của Number ví dụ như Integer,
								Float, Double vv.
								
								package vn.viettuts.generics;
								import java.util.ArrayList;
								import java.util.List;							
								abstract class Shape {
									abstract void draw();
								}							 
								class Rectangle extends Shape {
									void draw() {
										System.out.println("ve hinh chu nhat.");
									}
								}						 
								class Circle extends Shape {
									void draw() {
										System.out.println("ve hinh tron.");
									}
								}							 
								public class GenericTest5 {
									// tao phuong thuc chi chap nhan tham so la lop con cua Shape
									public static void drawShapes(List<? extends Shape> lists) {
										for (Shape s : lists) {
											s.draw();// goi phuong thuc cua lop Shape boi lop con
										}
									}							 
									public static void main(String args[]) {
										List<Rectangle> list1 = new ArrayList<Rectangle>();
										list1.add(new Rectangle());			 
										List<Circle> list2 = new ArrayList<Circle>();
										list2.add(new Circle());
										list2.add(new Circle());				 
										drawShapes(list1);
										drawShapes(list2);
									}
								}
								
			Sử dụng Generics trong các đối tượng Collection:
			
								Trước Generics, chúng ta có thể lưu trữ bất kỳ loại đối tượng nào trong collection như Non-generic. Với generics, được các lập trình java áp dụng để lưu trữ các kiểu cụ thể của các đối tượng.
								Ở đây, chúng ta sử dụng lớp ArrayList, nhưng bạn có thể sử dụng bất kỳ lớp Collection khác như ArrayList, LinkedList, HashSet, TreeSet, HashMap, Comparator, vv
								
								package vn.viettuts.generics;
								import java.util.ArrayList;
								import java.util.Iterator;							 
								class TestGenerics1 {
									public static void main(String args[]) {
										ArrayList<String> list = new ArrayList<String>();
										list.add("Java");
										list.add("PHP");
										list.add("C++");
										// list.add(32);//compile time error						 
										// show list
										Iterator<String> itr = list.iterator();
										while (itr.hasNext()) {
											System.out.println(itr.next());
										}
									}
								}
								
			Lợi thế của Generics trong Java:
			
				Kiểu đối tượng an toàn:

								Chúng ta chỉ có thể lưu một kiểu đối tượng duy nhất trong generics. Nó không cho phép lưu trữ 2 đối tượng có kiểu khác nhau.

				Không cần phải ép kiểu:
				
					Trước Generics chúng ta cần phải ép kiểu, ví dụ:

								List list = new ArrayList();
								list.add("hello");
								String s = (String) list.get(0);// ép kiểu
								
					Sau Generics chúng ta không cần phải ép kiểu đối tượng, ví dụ:
					
								List<String> list = new ArrayList<String>();
								list.add("hello");
								String s = list.get(0);
								
				Kiểm tra lúc biên dịch:
					
					Nó kiểm tra lỗi khi biên dịch nên sẽ không bị lỗi lúc runtime.

								List<String> list = new ArrayList<String>();
								list.add("hello");
								list.add(32);// Compile Time Error

			Tạo class Generic với kiểu tham số generic
				
				class Dictionary<K, V> {
					private K key;
					private V value;
					public Dictionary(K key, V value) {
						this.key = key;
						this.value = value;
					}	
					public K getKey() {
						return key;
					}
					public void setKey(K key) {
						this.key = key;
					}
					public V getValue() {
						return value;
					}
					public void setValue(V value) {
						this.value = value;
					}
				}
				
				K và V được gọi là 1 kiểu tham số chiếu nào đó của Dictionary<K,V>. Khi sử dụng class này chúng ta phải xác định 1 kiểu tham số cụ thể.
					
					public class DemoGeneric {
						public static void main(String[] args) {
							Dictionary<String, String> d = new Dictionary<String, String>("Study", "hoc");
							String english = d.getKey();
							String vietnamese = d.getValue();
							System.out.println(english + ": " + vietnamese); //Ouput: Study: hoc
						}
					}
					
			Thừa kế lớp Generics
				
				Cách quy định kiểu cho tham số Generics.
					
					class Book extends Dictionary<String, String> {
						public Book(String key, String value) {
							super(key, value);
						}
					}

					public class Demo {
						public static void main(String[] args) {
							Book l = new Book("Study", "hoc");
							String english = l.getKey();
							String vietnamese = l.getValue();
							System.out.println(english + ": " + vietnamese); // Ouput: Study: hoc
						}
					}
				
				Cách quy định giữ nguyên các tham số generic.
					
					class Book<K, V> extends Dictionary<K, V> {
						public Book(K key, V value) {
							super(key, value);
						}
					}

					public class Demo {
						public static void main(String[] args) {
							Book<String, String> l = new Book<String, String>("Study", "hoc");
							String english = l.getKey();
							String vietnamese = l.getValue();
							System.out.println(english + ": " + vietnamese); // Ouput: Study: hoc
						}
					}
					
					Note: Chúng ta có thể vừa quy định trước 1 kiểu cụ thể vừa giữ nguyên tham số generic
						
					class Book<V> extends Dictionary<String, V> {
						public Book(String key, V value) {
							super(key, value);
						}
					}
					public class Demo {
						public static void main(String[] args) {
							Book<String> l = new Book<String>("Study", "hoc");
							String english = l.getKey();
							String vietnamese = l.getValue();
							System.out.println(english + ": " + vietnamese); // Ouput: Study: hoc
						}
					}
					
				Cách thêm các tham số Generics vào 1 Class generic khác.
					
					class Book<K, V, I> extends Dictionary<K, V> {
						private I info; // khởi tạo thêm tham số generic 
						public Book(K key, V value) {
							super(key, value);
						}
						public Book(K key, V value, I info) {
							super(key, value);
							this.info = info; // truyền Kiểu generic mới vào 
						}
						public I getInfo() {
							return info;
						}
						public void setInfo(I info) {
							this.info = info;
						}
					}

					public class Demo {
						public static void main(String[] args) {
							Book<String, String, Integer> l = new Book<String, String, Integer>("Study", "hoc", 123);
							String english = l.getKey();
							String vietnamese = l.getValue();
							int quanity = l.getInfo();
							System.out.println(english + ": " + vietnamese + "\nQuantity: " + quanity);
							// Ouput:
							// Study: hoc
							// Quanity: 123
						}
					}
			Generics Interface
			
					Chúng ta khởi tạo 1 interface sau đó để 1 class implements lên là chúng ta đã có thể sử dụng.
						
						interface writer<T> {
							void update(T obj);
							void delete(T obj);
							void write(T obj);
						}

						class Book<T> implements writer<T> {
							@Override
							public void update(T obj) {
								// do something
							}
							@Override
							public void delete(T obj) {
								// do something
							}
							@Override
							public void write(T obj) {
								// do something
							}
						}
						public class Demo {
							public static void main(String[] args) {
								Book<String> t = new Book<String>();
								t.write("Add data to book");
							}
						}
						
			Các thao tác trên Generic
			
				Khởi tạo phương thức generic
				
					class Store {
						// Arraylist sẽ chứa các phần tử E
						// ta sẽ trả về phần tử đầu tiền trong arr khi được gọi
						public static <E> E getFirstElement(ArrayList<E> arr) {
							if (arr.isEmpty())
								return null;
							E first = arr.get(0);
							return first;
						}
					}
					public class Demo {
						public static void main(String[] args) {
							ArrayList<String> list = new ArrayList<>();
							list.add("Codelearn.io");
							list.add("Google.com");
							list.add("Azure");
							list.add("GCF");
							System.out.println(Store.getFirstElement(list));
							// output: Codelearn.io
						}
					}
					
				Khởi tạo đối tượng Generic
				
					Chúng ta không được phép khởi tạo đối tương obj theo kiểu này.
					
						T obj = new T(); // error
					
					Vì khi khởi tạo <T> không hề tồn tại ở thời điểm java khởi chạy. Nó chỉ có ý nghĩa với trình biên dịch kiểm soát code của người lập trình. Mọi kiểu <T> đều là Object tại thời điểm chạy của Java.
						
						package Generics;
						class Codelearn {
							public Codelearn() {
							}
							public void sayHi() {
								System.out.println("chúc các bạn học tốt!");
							}
						}
						class MyGeneric<T> {
							private T obj; // khởi tạo đối tượng lưu tham số generic
							public MyGeneric(Class<T> classObject) throws InstantiationException, IllegalAccessException {
								// lấy tên Class và gán nó vào đối tượng obj
								this.obj = (T) classObject.newInstance();
							}
							public T getObj() {
								return obj; // trả về obj
							}
						}

						public class Demo {
							public static void main(String[] args) throws InstantiationException, IllegalAccessException {
								// khởi tạo đối tượng Codelearn trên myObj
								MyGeneric<Codelearn> myObj = new MyGeneric<Codelearn>(Codelearn.class);
								// bây giờ myObj đã có đối tượng Codelearn
								// t chỉ cần gọi đối tượng đó ra bằng method getObj()
								myObj.getObj().sayHi();
							}
						}
						
						Output:
							chúc các bạn học tốt!
			
			Khởi tạo mảng Mảng Generic
			
				Cũng tương tự như tạo đối tượng generic chúng ta không thể tạo theo cách thông thường, nhưng chúng ta có thể khai báo nó 1 cách bình thường.
					
					T obj[] = new T[5]; // error
					T obj[]; // ok
					
					Để khởi tạo mảng trình biên dịch của Java cần biết rõ <T> là cái gì mới có thể biên dịch (compile) new T[5]. Nếu không biết rõ nó mặc định coi <T> là Object.
						
					Các khởi tạo mảng cũng tương tự như khi tạo đối tượng.
							
						class MyArrayGeneric<T> {
							private T[] array; // khởi tạo mảng
							public MyArrayGeneric(T[] array) {
								this.array = array;
							}
							public T[] getArray() {
								return array;
							}
							public T getFirstElement() {
								if (this.array.length == 0) {
									return null;
								}
								return this.array[0];
							}
							public T getLastElement() {
								if (this.array.length == 0) {
									return null;
								}
								return this.array[this.array.length - 1];
							}
						}
						public class Demo {
							public static void main(String[] args) {
								String[] names = new String[] { "Dat", "Khoa", "Tin" };
								// truyền array names vào trong MyArrayGeneric để gắn mảng vào trong nó
								MyArrayGeneric<String> myArrayGeneric = new MyArrayGeneric<String>(names);
								// ta có thể dổi thành các kiểu khác như Double, Integer, ...
								System.out.println("First name: " + myArrayGeneric.getFirstElement());
								System.out.println("Last name: " + myArrayGeneric.getLastElement());
							}
						}
						
			Generics với ký tự đại diện Generic method (wildcard):
				
				Trong Generic, dấu chấm hỏi (?) được gọi là một đại diện (wildcard), nó là kiểu không xác định.
				
				Wildcard có thể được sử dụng cho rất nhiều tính huống ví dụ như kiểu tham số, trường hoặc biến cục bộ; đôi khi là một kiểu trả về.
				
				Tùy vào ví trí của Wildcard mà nó sẽ có những ý nghĩa khác nhau:
					
					Collection<?>: mô tả một tập hợp chấp nhận tất cả các loại đối số (chứa mọi kiểu đối tượng).
					List<? extends Number>: mô tả một danh sách, nơi mà các phần tử là kiểu Number hoặc kiểu con của Number.
					Comparator<? super String>: Mô tả một bộ so sánh (Comparator) mà thông số phải là String hoặc cha của String.
				
				Ví dụ:
					
					package Generics;
					import java.util.ArrayList;
					import java.util.List;
					abstract class Shape {
						abstract void draw();
					}
					class Circle extends Shape {
						void draw() {
							System.out.println("ve hinh tron");
						}
					}
					class Square extends Shape {
						void draw() {
							System.out.println("ve hinh Vuong");
						}
					}
					public class Demo {
						// drawShapes chỉ chấp nhận các kiểu thuộc lớp Shape hoặc con của nó
						public static void drawShapes(List<? extends Shape> lists) {
							for (Shape s : lists) {
								s.draw(); // call method của lớp Shape từ lớp con
							}
						}
						public static void main(String args[]) {
							List<Square> list1 = new ArrayList<Square>();
							list1.add(new Square());
							List<Circle> list2 = new ArrayList<Circle>();
							list2.add(new Circle());
							list2.add(new Circle());
							drawShapes(list1);
							drawShapes(list2);
						}
					}
					Output:
						ve hinh Vuong
						ve hinh tron
						ve hinh tron						
	
	Gson TypeAdapter--JAVA:
	
		Giới thiệu
		
			Trong bài viết Gson Custom Serialization và Deserialization, tôi đã hướng dẫn cách custom dữ liệu được chuyển đổi sang/ từ chuỗi JSON sử dụng thư viện GSON. Tuy nhiên, các lớp JsonSerializer và
			JsonDeserializer sử dụng một lớp trung gian của các đối tượng. Các đối tượng Java hoặc JSON lần đầu tiên được chuyển thành JsonElement (lớp trung gian) và sau đó chuyển sang chuỗi Java hoặc JSON
			như được hiển thị trong hình ảnh sau:
			
				Lớp trung gian này có thể tránh được bằng cách sử dụng TypeAdapter thay vì JsonSerializer hoặc JsonDeserializer. TypeAdapter hiệu quả hơn JsonSerializer và JsonDeserializer khi nó bỏ qua lớp trung gian.
			
			Với JsonSerializer và JsonDeserializer cung cấp đệm an toàn rất tiện lợi vì nó làm giảm nguy cơ tạo chuỗi JSON không hợp lệ. Hình ảnh được hiển thị ở trên cho thấy cách các đối tượng được tuần tự hóa
			bằng cách sử dụng JsonSerializer. Đầu tiên các đối tượng Java được chuyển sang JsonElements, và sau đó chuyển sang chuỗi JSON. Quá trình này tạo ra một tập hợp các đối tượng tạm thời, sau đó được chuyển
			đổi thành chuỗi JSON. Các đối tượng này được chuyển thành chuỗi JSON sử dụng một thực hiện nội bộ của TypeAdapter. TypeAdapter có thể lấy bất kỳ đối tượng Java (bao gồm các đối tượng thuộc kiểu JsonElement)
			và chuyển nó sang chuỗi JSON như thể hiện trong hình dưới đây:
			
			TypeAdapter là một lớp trừu tượng, có hai phương thức trừu tượng:
			
				Phương thức write() lấy một thể hiện của JsonWriter và đối tượng được nối tiếp. Đối tượng được ghi vào JsonWriter một cách tương tự như một đối tượng được in tới PrintStream.
				
				Phương thức read() lấy một thể hiện của JsonReader và trả về một thể hiện của đối tượng deserialised.
			
			Tương tự như JsonSerializer và JsonDeserializer, TypeAdapter cần được đăng ký thông qua GsonBuilder trước khi nó có thể được sử dụng như sau:
				
				final GsonBuilder gsonBuilder = new GsonBuilder();
				gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
				final Gson gson = gsonBuilder.create();
			
			Trong phần dưới đây chúng ta sẽ thấy cách sử dụng TypeAdapter để chuyển các đối tượng Java sang chuỗi JSON (serialise) và ngược lại (deserialise).
		
		Ví dụ sử dụng TypeAdapter
			
			Book.java
				
				public class Book {
					private String title;
					private String[] authors;
					private String isbn10;
					private String isbn13;
					private Double price;
					private Date publishedDate;				 
						// Getters and setters ...
				}
				
			BookTypeAdapter.java
			
				package com.gpcoder.gson.adapter;
				import java.io.IOException;
				import java.text.ParseException;
				import java.text.SimpleDateFormat;
				import java.util.ArrayList;
				import java.util.Date;
				import java.util.List;
				import com.google.gson.TypeAdapter;
				import com.google.gson.stream.JsonReader;
				import com.google.gson.stream.JsonWriter;
				import com.gpcoder.gson.object.Book;
				public class BookTypeAdapter extends TypeAdapter<Book> {
					public static final SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");			 
					@Override
					public Book read(final JsonReader in) throws IOException {
						final Book book = new Book();		 
						in.beginObject();
						while (in.hasNext()) {
							switch (in.nextName()) {
							case "title":
								book.setTitle(in.nextString());
								break;
							case "isbn-10":
								book.setIsbn10(in.nextString());
								break;
							case "isbn-13":
								book.setIsbn13(in.nextString());
								break;
							case "price":
								book.setPrice(in.nextDouble());
								break;
							case "publishedDate":
								Date publishedDate = null;
								try {
									publishedDate = sdf.parse(in.nextString());
								} catch (ParseException e) {
									e.printStackTrace();
								}
								book.setPublishedDate(publishedDate);
								break;
							case "authors":
								in.beginArray();
								final List<String> authors = new ArrayList<>();
								while (in.hasNext()) {
									authors.add(in.nextString());
								}
								in.endArray();
								book.setAuthors(authors.toArray(new String[authors.size()]));
								break;
							}
						}
						in.endObject();
				 
						return book;
					}			 
					@Override
					public void write(final JsonWriter out, final Book book) throws IOException {
						out.beginObject();
						out.name("title").value(book.getTitle());
						out.name("isbn-10").value(book.getIsbn10());
						out.name("isbn-13").value(book.getIsbn13());
						out.name("price").value(book.getPrice());
						out.name("publishedDate").value(sdf.format(book.getPublishedDate()));
						out.name("authors");
						out.beginArray();
						for (final String author : book.getAuthors()) {
							out.value(author);
						}
						out.endArray();
						out.endObject();
					}
				}
				
			GsonCustomTypeAdapterExample.java
				
				package com.gpcoder.gson.adapter;	 
				import java.io.IOException;
				import java.util.Calendar;	 
				import com.google.gson.Gson;
				import com.google.gson.GsonBuilder;
				import com.gpcoder.gson.object.Book;	 
				public class GsonCustomTypeAdapterExample {	 
					public static void main(final String[] args) throws IOException {
						final GsonBuilder gsonBuilder = new GsonBuilder();
						gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
						gsonBuilder.setPrettyPrinting(); 
						final Gson gson = gsonBuilder.create(); 
						final Book book = new Book();
						book.setTitle("Head First Design Patterns");
						book.setIsbn10("0596007124");
						book.setIsbn13("978-0596007126");
						book.setPrice(52.41);	 
						Calendar c = Calendar.getInstance();
						c.set(2004, Calendar.OCTOBER, 1);
						book.setPublishedDate(c.getTime()); 
						String[] authors = new String[] { "Eric Freeman", "Bert Bates", "Kathy Sierra", "Elisabeth Robson" };
						book.setAuthors(authors); 
						System.out.println("Convert Book object to JSON string: ");
						final String json = gson.toJson(book);
						System.out.println(json); 
						System.out.println("Convert JSON String to Book object: ");
						final Book parsedBook = gson.fromJson(json, Book.class);
						System.out.println(parsedBook);
					}
				}
				
				Kết quả thực thi chương trình trên:
					Convert Book object to JSON string: 
					{
					  "title": "Head First Design Patterns",
					  "isbn-10": "0596007124",
					  "isbn-13": "978-0596007126",
					  "price": 52.41,
					  "publishedDate": "01/10/2004",
					  "authors": [
						"Eric Freeman",
						"Bert Bates",
						"Kathy Sierra",
						"Elisabeth Robson"
					  ]
					}
		 
					Convert JSON String to Book object: 
					Book [title=Head First Design Patterns, authors=[Eric Freeman, Bert Bates, Kathy Sierra, Elisabeth Robson], isbn10=0596007124, isbn13=978-0596007126, price=52.41, publishedDate=Fri Oct 01 00:00:00 ICT 2004]
		
		So sánh hiệu suất của TypeAdapter với JsonSerializer
			
			Như đã nói ở trên, hiệu suất khi sử dụng TypeAdapter tốt hơn so với JsonSerializer bởi vì nó bỏ qua lớp trung gian. Trong phần tiếp theo, tôi sẽ chứng minh cho các bạn thấy điều này.
			
			LargeData
				
				package com.gpcoder.gson.object;	 
				public class LargeData {			 
					private long[] numbers;			 
					public void create(final int length) {
						numbers = new long[length];
						for (int i = 0; i < length; i++) {
							numbers[i] = i;
						}
					}			 
					public long[] getNumbers() {
						return numbers;
					}		 
				}
			JsonSerializer
			
				LargeDataserializer.java
				
					package com.gpcoder.gson.performance;
					import java.lang.reflect.Type;			 
					import com.google.gson.JsonArray;
					import com.google.gson.JsonElement;
					import com.google.gson.JsonObject;
					import com.google.gson.JsonPrimitive;
					import com.google.gson.JsonSerializationContext;
					import com.google.gson.JsonSerializer;
					import com.gpcoder.gson.object.LargeData;			 
					public class LargeDataserializer implements JsonSerializer<LargeData> {			 
						@Override
						public JsonElement serialize(final LargeData data, final Type typeOfSrc, final JsonSerializationContext context) {
							final JsonArray jsonNumbers = new JsonArray();
							for (final long number : data.getNumbers()) {
								jsonNumbers.add(new JsonPrimitive(number));
							}			 
							final JsonObject jsonObject = new JsonObject();
							jsonObject.add("numbers", jsonNumbers);
							return jsonObject;
						}
					}
				
				LargeDataserializerTest.java
					
					package com.gpcoder.gson.performance;
					import java.io.File;
					import java.io.IOException;
					import java.io.PrintStream;				 
					import org.apache.commons.lang3.time.StopWatch;				 
					import com.google.gson.Gson;
					import com.google.gson.GsonBuilder;
					import com.gpcoder.gson.object.LargeData;
					 
					public class LargeDataserializerTest {				 
						public static void main(final String[] args) throws IOException {
							StopWatch stopWatch = new StopWatch();
							stopWatch.start();				 
							// Configure GSON
							final GsonBuilder gsonBuilder = new GsonBuilder();
							gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataserializer());
							gsonBuilder.setPrettyPrinting();				 
							final Gson gson = gsonBuilder.create();				 
							final LargeData data = new LargeData();
							data.create(10485760);				 
							final String json = gson.toJson(data);				 
							final File dir = new File("data");
							dir.mkdirs();				 
							try (PrintStream out = new PrintStream(new File(dir, "outputserializer.json"), "UTF-8")) {
								out.println(json);
							}			 
							stopWatch.stop();
							System.out.println("Done in " + stopWatch.getTime());
						}
					}
					
				Thực thi chương trình trên, bạn sẽ thấy thời gian thực thi của JsonSerializer khoảng 15950 ms. Một file outputserializer.json được tạo ra trong thư mục data có kích thước là 129 MB. Bộ nhớ sử dụng khoảng 1.1 GB.
			
			TypeAdapter
				
				LargeDataTypeAdapter.java
				
					package com.gpcoder.gson.performance;
					import java.io.IOException;		 
					import com.google.gson.TypeAdapter;
					import com.google.gson.stream.JsonReader;
					import com.google.gson.stream.JsonWriter;
					import com.gpcoder.gson.object.LargeData;
					 
					public class LargeDataTypeAdapter extends TypeAdapter<LargeData> {					 
						@Override
						public LargeData read(final JsonReader in) throws IOException {
							throw new UnsupportedOperationException("Coming soon");
						}					 
						@Override
						public void write(final JsonWriter out, final LargeData data) throws IOException {
							out.beginObject();
							out.name("numbers");
							out.beginArray();
							for (final long number : data.getNumbers()) {
								out.value(number);
							}
							out.endArray();
							out.endObject();
						}
					}
										
				LargeDataTypeAdapterTest.java
				
					package com.gpcoder.gson.performance;
					import java.io.File;
					import java.io.IOException;
					import java.io.PrintStream;		 
					import org.apache.commons.lang3.time.StopWatch;			 
					import com.google.gson.Gson;
					import com.google.gson.GsonBuilder;
					import com.gpcoder.gson.object.LargeData;
					 
					public class LargeDataTypeAdapterTest {					 
						public static void main(final String[] args) throws IOException {
							StopWatch stopWatch = new StopWatch();
							stopWatch.start();					 
							// Configure GSON
							final GsonBuilder gsonBuilder = new GsonBuilder();
							gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
							gsonBuilder.setPrettyPrinting();					 
							final Gson gson = gsonBuilder.create();					 
							final LargeData data = new LargeData();
							data.create(10485760);					 
							final String json = gson.toJson(data);				 
							final File dir = new File("data");
							dir.mkdirs();				 
							try (PrintStream out = new PrintStream(new File(dir, "outputTypeAdapter.json"), "UTF-8")) {
								out.println(json);
							}				 
							stopWatch.stop();
							System.out.println("Done in " + stopWatch.getTime());
						}
					}
					
					Thực thi chương trình trên, bạn sẽ thấy thời gian thực thi của TypeAdapter chỉ khoảng 3293 ms, nhanh hơn rất nhiều so với 15950 ms của JsonSerializer. Một file outputTypeAdapter.json được tạo ra trong
					thư mục data có kích thước là 129 MB, bằng với kích thước được tạo ra khi sử dụng JsonSerializer. Bộ nhớ sử dụng khoảng 640 MB.
			
			Kết hợp JsonSerializer và Streams
				
				package com.gpcoder.gson.performance.serializer;	 
				import java.io.BufferedWriter;
				import java.io.File;
				import java.io.FileOutputStream;
				import java.io.IOException;
				import java.io.OutputStream;
				import java.io.OutputStreamWriter;				 
				import org.apache.commons.lang3.time.StopWatch;				 
				import com.google.gson.Gson;
				import com.google.gson.GsonBuilder;
				import com.gpcoder.gson.object.LargeData;
				 
				public class LargeDataserializerStreamingTest {				 
					public static void main(final String[] args) throws IOException {
						StopWatch stopWatch = new StopWatch();
						stopWatch.start();				 
						// Configure GSON
						final GsonBuilder gsonBuilder = new GsonBuilder();
						gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataserializer());
						gsonBuilder.setPrettyPrinting();				 
						final Gson gson = gsonBuilder.create();				 
						final LargeData data = new LargeData();
						data.create(10485760);			 
						final File dir = new File("data");
						dir.mkdirs();			 
						try (OutputStream os = new FileOutputStream(new File(dir, "outputserializerStreaming.json"));
								BufferedWriter out = new BufferedWriter(new OutputStreamWriter(os, "UTF-8"))) {
							gson.toJson(data, out);
						}		 
						stopWatch.stop();
						System.out.println("Done in " + stopWatch.getTime());
					}
				}
				
				Thực thi chương trình trên, bạn sẽ thấy thời gian thực thi là 12511 ms, nhanh hơn so với 15950 ms của JsonSerializer không sử dụng Stream. Một file outputTypeAdapterStreaming.json được tạo ra trong thư
				mục data có cùng kích thước là 129 MB. Bộ nhớ sử dụng khoảng 727 MB.
			
			Kết hợp TypeAdapter và Streams
			
				package com.gpcoder.gson.performance.typeadapter;		 
				import java.io.BufferedWriter;
				import java.io.File;
				import java.io.FileOutputStream;
				import java.io.IOException;
				import java.io.OutputStream;
				import java.io.OutputStreamWriter;			 
				import org.apache.commons.lang3.time.StopWatch;			 
				import com.google.gson.Gson;
				import com.google.gson.GsonBuilder;
				import com.gpcoder.gson.object.LargeData;
				 
				public class LargeDataTypeAdapterStreamingTest {				 
					public static void main(final String[] args) throws IOException {				 
						StopWatch stopWatch = new StopWatch();
						stopWatch.start();				 
						// Configure GSON
						final GsonBuilder gsonBuilder = new GsonBuilder();
						gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
						gsonBuilder.setPrettyPrinting();				 
						final Gson gson = gsonBuilder.create();				 
						final LargeData data = new LargeData();
						data.create(10485760);				 
						final File dir = new File("data");
						dir.mkdirs();				 
						try (OutputStream os = new FileOutputStream(new File(dir, "outputTypeAdapterStreaming.json"));
								BufferedWriter out = new BufferedWriter(new OutputStreamWriter(os, "UTF-8"))) {
							gson.toJson(data, out);
						}				 
						stopWatch.stop();
						System.out.println("Done in " + stopWatch.getTime());
					}
				}
				
				Thực thi chương trình trên, bạn sẽ thấy thời gian thực thi là 2247 ms, nhanh hơn so với 3293 ms của TypeAdapter không sử dụng Stream. Một file outputTypeAdapterStreaming.json được tạo ra trong thư mục
				data có cùng kích thước là 129 MB. Bộ nhớ sử dụng khoảng 160 MB.
				
		Tóm lại, TypeAdapter tốt hơn về mặt hiệu suất so với JsonSerializer do bỏ qua lớp đệm. Tuy nhiên, với JsonSerializer và JsonDeserializer cung cấp đệm an toàn rất tiện lợi vì nó làm giảm nguy cơ tạo chuỗi JSON
		không hợp lệ. Luôn cố gắng kết hợp TypeAdapter với Stream hoặc JsonSerializer với Stream để có được hiệu suất tốt nhất.		

	ObjectMapper (Xử lý Json với Jackson ObjectMapper trong Java)--JAVA:
	
		Maven Dependency
			
			Để sử dụng Jackson trong Project Maven chúng ta cần thêm dependency sau:
				
				<dependency>
					<groupId>com.fasterxml.jackson.core</groupId>
					<artifactId>jackson-databind</artifactId>
					<version>2.9.8</version>
				</dependency>
				
		Đọc ghi Json với ObjectMapper
		
			Thao tác đọc ghi Json là 2 thao tác cơ bản mà ObjectMapper cung cấp. Chúng ta có thể sử dụng readValue() method để deserialize Json sang Java Object. Tương tự, writeValue() serialize Java Object sang Json.
			
			Giả sử có Car class chứa 2 thuộc tính color và type:
				public class Car {
					private String color;
					private String type;
					public Car(String color, String type) {
						this.color = color;
						this.type = type;
					}
					public String getColor() {
						return color;
					}
					public void setColor(String color) {
						this.color = color;
					}
					public String getType() {
						return type;
					}
					public void setType(String type) {
						this.type = type;
					}
				}
			
			Convert Java Object to Json
			
				Để serialize Java object sang Json, chúng ta cần đến writeValue() method được cung cấp bởi ObjectMapper class.
					
					import java.io.File;
					import java.io.IOException;
					import com.fasterxml.jackson.databind.ObjectMapper;
					public class Main {
						public static void main(String[] args) throws IOException {
							ObjectMapper objectMapper = new ObjectMapper();
							Car car = new Car("yellow", "renault");
							objectMapper.writeValue(new File("car.json"), car);
						}
					}
					
				Sau khi thực thi xong, chương trình sẽ tạo ra file car.json với nội dung
					
					{"color":"yellow","type":"renault"}
				
				Các method writeValueAsString() và writeValueAsBytes() của ObjectMapper sẽ tạo ra một string hoặc mảng byte tương ứng thay vì ghi vào file json.
					
					String carAsString = objectMapper.writeValueAsString(car);
			
			Convert Json to Java Object
				
				Sử dụng readValue() để convert Json String sang Java Object.
					
					String json = "{ \"color\" : \"Black\", \"type\" : \"BMW\" }";
					Car car = objectMapper.readValue(json, Car.class);
				
				readValue() method cũng cho phép chúng ta đọc file Json vào Java object theo mẫu sau
					
					Car car = objectMapper.readValue(new File("car.json"), Car.class);
				
				Hoặc thông qua URL
					
					Car car = objectMapper.readValue(new URL("file:car.json"), Car.class);
			
			Convert Json to Jackson JsonNode
				
				Jackson cũng hỗ trợ chuyển từ Json String sang JsonNode thông qua readTree() method.
					
					public class Main {
						public static void main(String[] args) throws IOException {
							ObjectMapper objectMapper = new ObjectMapper();
							String json = "{ \"color\" : \"Black\", \"type\" : \"FIAT\" }";
							JsonNode jsonNode = objectMapper.readTree(json);
							String color = jsonNode.get("color").asText(); // Black
						}
					}
					
			Convert Json Array String to Java List Object
				
				Đối với cấu trúc dạng mảng trong Json, chúng ta cũng có thể chuyển chúng sang Java List Object tương ứng với TypeReference:
					
					String jsonCarArray = 
					  "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
					List<Car> listCar = objectMapper.readValue(jsonCarArray, new TypeReference<List<Car>>(){});
			
			Convert Json Array String to Map
				
				Tương tự, sử dụng TypeReference để chuyển Json sang Map
					
					String json = "{ \"color\" : \"Black\", \"type\" : \"BMW\" }";
					Map<String, Object> map 
					  = objectMapper.readValue(json, new TypeReference<Map<String,Object>>(){});
		
		Custom Jackson
			
			Khi làm việc với Json, chúng ta hiểu được sẽ nhiều trường hợp không prefect như cấu trúc giữa file Json và Java Class không trùng khớp, file Json được lấy từ nguồn khác chứa nhiều thuộc tính hơn Java
			class cần thiết etc. Tất cả đó, Jackson cung cấp bộ công cụ cho phép chúng ta có thể custom serialization và deserialization.
			
			Configuring Serialization or Deserialization
				
				Trong khi convert Json string sang Java class, trong trường hợp nếu Json string có 1 số field mới, mặc định Jackson sẽ ném exception.
				
				Ví dụ convert Json string sang Car object, trong Json string chứa một thuộc tính year mới mà Car class không có.
					
					import java.io.IOException;
					import com.fasterxml.jackson.databind.ObjectMapper;
					public class Main {
						public static void main(String[] args) throws IOException {
							ObjectMapper objectMapper = new ObjectMapper();
							String jsonString
									= "{ \"color\" : \"Black\", \"type\" : \"Fiat\", \"year\" : \"1970\" }";
							Car car = objectMapper.readValue(jsonString, Car.class);
						}
					}
					
				Để xử lý trường hợp trên, chúng ta có thể config để Jackson bỏ qua field mới trong quá trình deserialize với FAIL_ON_UNKNOWN_PROPERTIES option.
					
					import java.io.IOException;
					import com.fasterxml.jackson.databind.DeserializationFeature;
					import com.fasterxml.jackson.databind.JsonNode;
					import com.fasterxml.jackson.databind.ObjectMapper;
					public class Main {
						public static void main(String[] args) throws IOException {
							ObjectMapper objectMapper = new ObjectMapper();
							String jsonString
									= "{ \"color\" : \"Black\", \"type\" : \"Fiat\", \"year\" : \"1970\" }";
							objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
							Car car = objectMapper.readValue(jsonString, Car.class); //
							JsonNode jsonNodeRoot = objectMapper.readTree(jsonString);
							JsonNode jsonNodeYear = jsonNodeRoot.get("year");
							String year = jsonNodeYear.asText();
						}
					}
					
				Ngoài ra, chúng ta còn một config enum khác:
					
					FAIL_ON_NULL_FOR_PRIMITIVES: giá trị null cho kiểu dữ liệu nguyên thủy được chấp nhận.
					FAIL_ON_NUMBERS_FOR_ENUM : giá trị cho enum được phép là một số.
		
		Custom Serializer or Deserializer
			
			Trong trường hợp cấu trúc Json và Java class có cấu trúc khác nhau, chúng ta có thể tạo một custom serializer và deserializer và đăng ký sử dụng chúng với Jackson.
			
			Dưới đây là một Custom Serializer cho phép chuyển giá trị type trong Car class sang car_brand trong Json.
				
				public class CustomCarSerializer extends StdSerializer<Car> {		 
					public CustomCarSerializer() {
						this(null);
					}				 
					public CustomCarSerializer(Class<Car> t) {
						super(t);
					}				 
					@Override
					public void serialize(
					  Car car, JsonGenerator jsonGenerator, SerializerProvider serializer) throws IOException {
						jsonGenerator.writeStartObject();
						jsonGenerator.writeStringField("car_brand", car.getType());
						jsonGenerator.writeEndObject();
					}
				}
				
			Đăng ký CustomCarSerializer với Jackson theo mẫu sau:
				
				ObjectMapper mapper = new ObjectMapper();
				SimpleModule module = 
				  new SimpleModule("CustomCarSerializer", new Version(1, 0, 0, null, null, null));
				module.addSerializer(Car.class, new CustomCarSerializer());
				mapper.registerModule(module);
				Car car = new Car("yellow", "renault");
				String carJson = mapper.writeValueAsString(car);
			
			Và đây là ví dụ custom deserializer
				
				public class CustomCarDeserializer extends StdDeserializer<Car> {
					public CustomCarDeserializer() {
						this(null);
					}
					public CustomCarDeserializer(Class<?> vc) {
						super(vc);
					}
					@Override
					public Car deserialize(JsonParser parser, DeserializationContext deserializer) throws IOException {
						Car car = new Car();
						ObjectCodec codec = parser.getCodec();
						JsonNode node = codec.readTree(parser);
						JsonNode colorNode = node.get("color");
						String color = colorNode.asText();
						JsonNode typeNode = node.get("car_brand");
						car.setType(typeNode.asText());
						car.setColor(color);
						return car;
					}
				}
				
			Sử dụng CustomCarDeserializer theo mẫu sau:
				
				public class Main {
					public static void main(String[] args) throws IOException {
						ObjectMapper mapper = new ObjectMapper();
						String json = "{ \"color\" : \"Black\", \"car_brand\" : \"BMW\" }";
						SimpleModule module =
								new SimpleModule("CustomCarDeserializer", new Version(1, 0, 0, null, null, null));
						module.addDeserializer(Car.class, new CustomCarDeserializer());
						mapper.registerModule(module);
						Car car = mapper.readValue(json, Car.class); // color: Black; type: BMW
					}
				}
				
		Handing Date Format
			
			Mặc định, quá trình serialization của java.util.Date sẽ cho ra một số timestamp (số mili giây kể từ 01-01-1970 UTC). Tuy nhiên giá trị này có thể gây khó hiểu cho người đọc, chúng ta có hoàn toàn có thể thay
			đổi timestamp thành các định dạng chuẩn ngày tháng như sau.
			
			Giả sử có Request class
			
				public class Request {
					private Car car;
					private Date datePurchased;
					public Request(Car car, Date datePurchased) {
						this.car = car;
						this.datePurchased = datePurchased;
					}
					public Car getCar() {
						return car;
					}
					public void setCar(Car car) {
						this.car = car;
					}
					public Date getDatePurchased() {
						return datePurchased;
					}
					public void setDatePurchased(Date datePurchased) {
						this.datePurchased = datePurchased;
					}
				}
				
			Để chuyển đổi định dạng timestamp sang date format eg yyyy-MM-dd HH:mm a z:
				
				public class Main {
					public static void main(String[] args) throws IOException {
						ObjectMapper mapper = new ObjectMapper();
						DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm a z");
						mapper.setDateFormat(df);
						Request request = new Request(new Car("White", "BMW"), Date.from(Instant.now()));
						String carAsString = mapper.writeValueAsString(request); 
						// {"car":{"color":"White","type":"BMW"},"datePurchased":"2020-04-10 14:26 PM ICT"}
					}
				}
				
		Handling Collections
			
			Ở phần trên chúng ta cũng đã được giới thiệu cách thao tác với Json chứa một mảng dữ liệu, tuy nhiên ở phần này chúng ta sẽ gợi lại một xíu, cộng thêm việc xử lý các Array thông thường trong Java.
			
			Ví dụ chuyển Json chứa mảng Car sang array trong java.
				
				String jsonCarArray = 
				  "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
				ObjectMapper objectMapper = new ObjectMapper();
				objectMapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);
				Car[] cars = objectMapper.readValue(jsonCarArray, Car[].class);
				// print cars
					
			Hoặc chuyển sang List
				
				String jsonCarArray = 
				  "[{ \"color\" : \"Black\", \"type\" : \"BMW\" }, { \"color\" : \"Red\", \"type\" : \"FIAT\" }]";
				ObjectMapper objectMapper = new ObjectMapper();
				List<Car> listCar = objectMapper.readValue(jsonCarArray, new TypeReference<List<Car>>(){});
				// print cars
				
	Export Excel--JAVA:
	
		XSSFWorkbook--Export Excel:
		
			XSSFWorkbook là một lớp trong thư viện Apache POI, cụ thể là module poi-ooxml, được sử dụng để làm việc với các tệp Excel định dạng .xlsx (Excel 2007 và các phiên bản mới hơn). Lớp này
			đại diện cho một workbook (sổ tay) trong Excel.
			Tạo và Quản Lý Workbook: XSSFWorkbook cho phép bạn tạo mới hoặc mở một workbook Excel, và quản lý các sheet, hàng, ô, và các thuộc tính khác của bảng tính.
			Chuyển Đổi Dữ Liệu: Đọc, viết, và chỉnh sửa dữ liệu trong các sheet của workbook.
			
			Các Phương Thức Quan Trọng Của XSSFWorkbook:
			
				createSheet(String sheetName): Tạo một sheet mới trong workbook với tên cụ thể.
				getSheet(String sheetName): Lấy sheet dựa trên tên của sheet.
				getSheetAt(int index): Lấy sheet dựa trên chỉ số của nó trong workbook.
				removeSheetAt(int index): Xóa sheet tại chỉ số cụ thể.
				getSheetIndex(String sheetName): Lấy chỉ số của sheet dựa trên tên của nó.
				write(OutputStream stream): Ghi workbook vào một OutputStream, chẳng hạn như một file.
				
			Tạo Workbook Mới:
			
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class XSSFWorkbookExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							// Tạo một sheet mới
							workbook.createSheet("Sheet1");
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("workbook.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Đọc Workbook Từ Tệp:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileInputStream;
				import java.io.IOException;
				public class ReadXSSFWorkbookExample {
					public static void main(String[] args) {
						try (FileInputStream fileIn = new FileInputStream("workbook.xlsx");
							 XSSFWorkbook workbook = new XSSFWorkbook(fileIn)) {
							// Lấy sheet đầu tiên
							Sheet sheet = workbook.getSheetAt(0);
							// Đọc dữ liệu từ hàng và ô
							Row row = sheet.getRow(0);
							Cell cell = row.getCell(0);
							String cellValue = cell.getStringCellValue();
							System.out.println("Cell Value: " + cellValue);
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Quản Lý Sheet:
			
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import org.apache.poi.ss.usermodel.Sheet;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class ManageSheetsExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							// Tạo các sheet mới
							workbook.createSheet("Sheet1");
							workbook.createSheet("Sheet2");
							// Xóa một sheet
							workbook.removeSheetAt(1); // Xóa sheet thứ hai
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("managedSheets.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Thiết Lập Định Dạng và Style:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class StyleExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							Sheet sheet = workbook.createSheet("StyledSheet");
							// Tạo kiểu ô
							CellStyle style = workbook.createCellStyle();
							style.setFillForegroundColor(IndexedColors.YELLOW.getIndex());
							style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
							// Tạo hàng và ô
							Row row = sheet.createRow(0);
							Cell cell = row.createCell(0);
							cell.setCellValue("Styled Cell");
							cell.setCellStyle(style);
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("styledWorkbook.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}




	
		XSSFSheet--Export Excel:
		
			Thư viện Apache POI: Apache POI là thư viện Java để làm việc với các tài liệu Microsoft Office, bao gồm Excel, Word, và PowerPoint.
			XSSFSheet: Lớp này thuộc vào org.apache.poi.xssf.usermodel và cung cấp các phương thức để thao tác với các sheet trong file Excel .xlsx.
			
			Các Phương Thức Quan Trọng của XSSFSheet:
			
				createRow(int rownum): Tạo một hàng mới tại chỉ số hàng cụ thể.
				getRow(int rownum): Lấy một hàng từ sheet theo chỉ số hàng.
				createCell(int column): Tạo một ô mới trong hàng cụ thể.
				getCell(int column): Lấy một ô từ hàng theo chỉ số cột.
				getLastRowNum(): Lấy chỉ số của hàng cuối cùng trong sheet.
				getPhysicalNumberOfRows(): Lấy số lượng hàng thực tế có dữ liệu trong sheet.
				setColumnWidth(int columnIndex, int width): Đặt độ rộng của cột.
				autoSizeColumn(int column): Tự động điều chỉnh độ rộng của cột dựa trên nội dung của nó.
				addMergedRegion(CellRangeAddress region): Hợp nhất các ô trong phạm vi được chỉ định.
				removeMergedRegion(int index): Loại bỏ phạm vi ô hợp nhất tại chỉ số cụ thể.
			
			Tạo Workbook và Sheet:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class XSSFSheetExample {
					public static void main(String[] args) {
						// Tạo workbook và sheet
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							XSSFSheet sheet = workbook.createSheet("Sheet1");
							// Tạo một hàng
							Row row = sheet.createRow(0);
							// Tạo ô và gán giá trị
							Cell cell = row.createCell(0);
							cell.setCellValue("Hello, World!");
							// Ghi workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("example.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Đọc Dữ Liệu Từ Sheet:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileInputStream;
				import java.io.IOException;
				public class XSSFSheetReadExample {
					public static void main(String[] args) {
						try (FileInputStream fileIn = new FileInputStream("example.xlsx");
							 XSSFWorkbook workbook = new XSSFWorkbook(fileIn)) {
							// Lấy sheet từ workbook
							XSSFSheet sheet = workbook.getSheetAt(0);
							// Lấy hàng đầu tiên
							Row row = sheet.getRow(0);
							// Lấy ô đầu tiên của hàng
							Cell cell = row.getCell(0);
							// Đọc giá trị từ ô
							String cellValue = cell.getStringCellValue();
							System.out.println("Cell Value: " + cellValue);
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}

		CellRangeAddress--Export Excel:
		
			CellRangeAddress là một lớp trong thư viện Apache POI, một thư viện phổ biến để làm việc với tài liệu Microsoft Office, đặc biệt là Excel trong Java. CellRangeAddress được sử dụng để định
			nghĩa một phạm vi các ô trong một bảng tính Excel.
			
			import org.apache.poi.ss.usermodel.*;
			import org.apache.poi.xssf.usermodel.XSSFWorkbook;
			import org.apache.poi.ss.util.CellRangeAddress;
			import java.io.FileOutputStream;
			import java.io.IOException;
			public class MergeCellsExample {
				public static void main(String[] args) throws IOException {
					// Tạo workbook và sheet
					Workbook workbook = new XSSFWorkbook();
					Sheet sheet = workbook.createSheet("Sheet1");
					// Tạo phạm vi các ô để merge
					CellRangeAddress cellRange = new CellRangeAddress(
						0,  // hàng bắt đầu
						1,  // hàng kết thúc
						0,  // cột bắt đầu
						2   // cột kết thúc
					);
					sheet.addMergedRegion(cellRange);
					// Thêm một ô với giá trị để thấy rõ việc merge
					Row row = sheet.createRow(0);
					Cell cell = row.createCell(0);
					cell.setCellValue("Merged Region");
					// Lưu workbook vào file
					try (FileOutputStream fileOut = new FileOutputStream("workbook.xlsx")) {
						workbook.write(fileOut);
					}
					// Đóng workbook
					workbook.close();
				}
			}
			
		RegionUtil--Export Excel:
		
			RegionUtil là một lớp tiện ích trong thư viện Apache POI, được sử dụng để thực hiện các thao tác trên các vùng ô (regions)
			trong bảng tính Excel, như là merge ô hoặc áp dụng định dạng cho một phạm vi ô.
			
			Các Phương Thức Quan Trọng:
			
				setBorderTop(BorderStyle style, CellRangeAddress region, Sheet sheet): Thiết lập đường viền trên cho phạm vi ô.
				setBorderBottom(BorderStyle style, CellRangeAddress region, Sheet sheet): Thiết lập đường viền dưới cho phạm vi ô.
				setBorderLeft(BorderStyle style, CellRangeAddress region, Sheet sheet): Thiết lập đường viền trái cho phạm vi ô.
				setBorderRight(BorderStyle style, CellRangeAddress region, Sheet sheet): Thiết lập đường viền phải cho phạm vi ô.
				setCellStyle(CellStyle style, CellRangeAddress region, Sheet sheet): Áp dụng kiểu ô cho phạm vi (được sử dụng ít hơn so với các phương thức thiết lập đường viền).

			Chức Năng Của RegionUtil:
				
				Merge Cells: Hợp nhất các ô trong một phạm vi nhất định.
				Set Border: Thiết lập đường viền cho các ô trong một phạm vi.
				Apply Cell Style: Áp dụng kiểu ô (cell style) cho các ô trong một phạm vi.
				
			Merge Cells:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import org.apache.poi.ss.util.CellRangeAddress;
				import org.apache.poi.ss.util.RegionUtil;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class MergeCellsExample {
					public static void main(String[] args) throws IOException {
						Workbook workbook = new XSSFWorkbook();
						Sheet sheet = workbook.createSheet("Sheet1");
						// Tạo phạm vi để merge
						CellRangeAddress cellRange = new CellRangeAddress(
							0,  // hàng bắt đầu
							1,  // hàng kết thúc
							0,  // cột bắt đầu
							2   // cột kết thúc
						);
						sheet.addMergedRegion(cellRange);
						// Thêm dữ liệu vào ô đầu tiên của phạm vi merge
						Row row = sheet.createRow(0);
						Cell cell = row.createCell(0);
						cell.setCellValue("Merged Region");
						// Áp dụng đường viền cho phạm vi merge
						RegionUtil.setBorderBottom(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderTop(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderLeft(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderRight(BorderStyle.THIN, cellRange, sheet);
						// Lưu workbook vào file
						try (FileOutputStream fileOut = new FileOutputStream("workbook.xlsx")) {
							workbook.write(fileOut);
						}
						workbook.close();
					}
				}
				
			Set Border:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import org.apache.poi.ss.util.CellRangeAddress;
				import org.apache.poi.ss.util.RegionUtil;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class BorderExample {
					public static void main(String[] args) throws IOException {
						Workbook workbook = new XSSFWorkbook();
						Sheet sheet = workbook.createSheet("Sheet1");
						// Tạo phạm vi ô
						CellRangeAddress cellRange = new CellRangeAddress(
							0,  // hàng bắt đầu
							1,  // hàng kết thúc
							0,  // cột bắt đầu
							2   // cột kết thúc
						);
						sheet.addMergedRegion(cellRange);
						// Áp dụng đường viền cho phạm vi ô
						RegionUtil.setBorderBottom(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderTop(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderLeft(BorderStyle.THIN, cellRange, sheet);
						RegionUtil.setBorderRight(BorderStyle.THIN, cellRange, sheet);
						// Lưu workbook vào file
						try (FileOutputStream fileOut = new FileOutputStream("borderExample.xlsx")) {
							workbook.write(fileOut);
						}
						workbook.close();
					}
				}

		CellStyle--Export Excel:
		
			CellStyle là một lớp trong thư viện Apache POI, dùng để định dạng các ô trong bảng tính Excel. Khi bạn muốn tùy chỉnh cách mà dữ liệu xuất hiện trong các ô của một bảng
			tính Excel, bạn sẽ sử dụng CellStyle để thiết lập các thuộc tính như kiểu chữ, màu sắc, đường viền, và kiểu nền của ô.
			
			Các Tính Năng Chính của CellStyle:
			
				Font: Thiết lập kiểu chữ, kích thước, màu sắc, và các thuộc tính chữ khác.
				Fill: Đặt màu nền cho ô.
				Border: Thiết lập đường viền cho các cạnh của ô.
				Alignment: Căn chỉnh nội dung của ô (trái, phải, giữa).
				Data Format: Định dạng dữ liệu trong ô, như số, ngày tháng, tiền tệ, v.v.
				
			Các Phương Thức Quan Trọng của CellStyle:
			
				setFont(Font font): Đặt kiểu chữ cho ô.
				setFillForegroundColor(short color): Đặt màu nền cho ô.
				setFillPattern(FillPatternType pattern): Đặt kiểu nền cho ô.
				setBorderBottom(BorderStyle style): Đặt đường viền dưới cho ô.
				setBorderTop(BorderStyle style): Đặt đường viền trên cho ô.
				setBorderLeft(BorderStyle style): Đặt đường viền trái cho ô.
				setBorderRight(BorderStyle style): Đặt đường viền phải cho ô.
				setAlignment(HorizontalAlignment align): Đặt căn chỉnh ngang cho nội dung ô.
				setVerticalAlignment(VerticalAlignment align): Đặt căn chỉnh dọc cho nội dung ô.
				setDataFormat(short format): Đặt định dạng dữ liệu cho ô, như số, tiền tệ, ngày tháng.
				
			Tạo CellStyle và Áp Dụng Kiểu Chữ:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class CellStyleExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							Sheet sheet = workbook.createSheet("StyledSheet");
							// Tạo kiểu chữ
							Font font = workbook.createFont();
							font.setFontHeightInPoints((short) 14);
							font.setFontName("Arial");
							font.setBold(true);
							font.setColor(IndexedColors.RED.getIndex());
							// Tạo kiểu ô
							CellStyle style = workbook.createCellStyle();
							style.setFont(font);
							// Tạo hàng và ô
							Row row = sheet.createRow(0);
							Cell cell = row.createCell(0);
							cell.setCellValue("Styled Text");
							cell.setCellStyle(style);
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("styledCell.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Đặt Màu Nền và Đường Viền:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class FillAndBorderExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							Sheet sheet = workbook.createSheet("SheetWithBorder");
							// Tạo kiểu ô với màu nền và đường viền
							CellStyle style = workbook.createCellStyle();
							style.setFillForegroundColor(IndexedColors.YELLOW.getIndex());
							style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
							// Đặt đường viền cho các cạnh của ô
							style.setBorderBottom(BorderStyle.THIN);
							style.setBorderTop(BorderStyle.THIN);
							style.setBorderLeft(BorderStyle.THIN);
							style.setBorderRight(BorderStyle.THIN);
							// Tạo hàng và ô
							Row row = sheet.createRow(0);
							Cell cell = row.createCell(0);
							cell.setCellValue("Styled Cell with Border");
							cell.setCellStyle(style);
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("filledAndBorderedCell.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}
				
			Căn Chỉnh Nội Dung và Định Dạng Dữ Liệu:
			
				import org.apache.poi.ss.usermodel.*;
				import org.apache.poi.xssf.usermodel.XSSFWorkbook;
				import java.io.FileOutputStream;
				import java.io.IOException;
				public class AlignmentAndFormatExample {
					public static void main(String[] args) {
						try (XSSFWorkbook workbook = new XSSFWorkbook()) {
							Sheet sheet = workbook.createSheet("SheetWithFormatting");
							// Tạo kiểu ô với căn chỉnh và định dạng dữ liệu
							CellStyle style = workbook.createCellStyle();
							style.setAlignment(HorizontalAlignment.CENTER);
							style.setVerticalAlignment(VerticalAlignment.CENTER);
							style.setDataFormat(workbook.createDataFormat().getFormat("#,##0.00"));
							// Tạo hàng và ô
							Row row = sheet.createRow(0);
							Cell cell = row.createCell(0);
							cell.setCellValue(12345.678);
							cell.setCellStyle(style);
							// Lưu workbook vào file
							try (FileOutputStream fileOut = new FileOutputStream("formattedCell.xlsx")) {
								workbook.write(fileOut);
							}
						} catch (IOException e) {
							e.printStackTrace();
						}
					}
				}



	
		Javascript--Export Excel:
		
			const handleExportExcel = async () => {
				try {
					await onExportExcel(searchData).then(response => {
						if (response.status === 200) {
							const blob = new Blob([response.data], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
							const link = document.createElement('a');
							link.href = window.URL.createObjectURL(blob);
							const filename = 'Project_Status_' + format(new Date(), "yyyyMMdd_HHmmss") + ".xlsx";
							link.download = filename;
							document.body.appendChild(link);
							link.click();
							document.body.removeChild(link);
							console.info('Successfully!', response)
						} else {
							console.info('Failed!')
						}
					});
				} catch (e) {
					console.info('Error!', e)
				}
			};
			
			export const onExportExcel = (data) => {
				const groups = data?.searchByGroup;
				const statuses = data?.searchByStatus;
				const name = data?.searchByProjectName;
				return instance.get(`${Constants.Api.BASE_URL}/project-status/export-excel?groups=${groups}&statuses=${statuses}&name=${name}`, { responseType: 'blob' },);
			}			

		Java--Export Excel:
		
			@GetMapping("/export-excel")
			public void exportToExcel(HttpServletResponse response,
									  Pme00ProjectStatusRequest request) throws IOException {
				response.setContentType("application/octet-stream");
				DateFormat dateFormatter = new SimpleDateFormat("yy-MM-dd_HH:mm:ss");
				String currentDateTime = dateFormatter.format(new Date());
				String headerKey = "Content-Disposition";
				String headerValue = "attachment; filename=project_status_" + currentDateTime + ".xlsx";
				response.setHeader(headerKey, headerValue);
				PosLogger.developerLog(PosLogWriterIF.INFO, "Export Excel project_status_" + currentDateTime + ".xlsx", this);
				this.serviceLifecycle.requestLevel2ProjectStatusService().exportExcel(serviceLifecycle, response, request);
			}
			
			@Data
			public class Pme00ProjectStatusRequest extends CommonPaginationRequest {
				private List<String> groups;
				private List<String> statuses;
				private String name;
			}			

			void exportExcel(ServiceLifecycle serviceLifecycle, HttpServletResponse response, Pme00ProjectStatusRequest request) throws IOException;

			@Override
			public void exportExcel(ServiceLifecycle serviceLifecycle, HttpServletResponse response, Pme00ProjectStatusRequest request) throws IOException {
				CommonPaginationResponse<Pme00ProjectStatus> Pme00ProjectStatusResponse = serviceLifecycle.requestPme00ProjectInfoService().search(request);
				List<M00Codes030> statuses = serviceLifecycle.requestM00Codes030Service().getListCategories(64, 56);
				Map<String, M00Codes030> statusByCodeMap = statuses.stream()
						.collect(Collectors.toMap(M00Codes030::getCdV, e -> e));
				Pme00ProjectStatusResponse.getList().forEach(e -> {
					e.setStatus(statusByCodeMap.get(e.getStatusCode()));
				});
				ExportExcelProjectStatus exporter = new ExportExcelProjectStatus(Pme00ProjectStatusResponse.getList());
				exporter.export(response);
			}

			package com.poscdx.odc.ampro015.domain.utils;
			import com.poscdx.odc.ampro015.domain.entity.Pme00ProjectStatus;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.ExportBodyRequest;
			import org.apache.poi.ss.usermodel.Cell;
			import org.apache.poi.ss.usermodel.CellStyle;
			import org.apache.poi.ss.usermodel.Row;
			import org.apache.poi.xssf.usermodel.XSSFFont;
			import org.apache.poi.xssf.usermodel.XSSFSheet;
			import org.apache.poi.xssf.usermodel.XSSFWorkbook;
			import javax.servlet.ServletOutputStream;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;
			import java.util.List;
			import java.util.Map;
			public class ExportExcelProjectStatus extends ReportAbstract{
				private final List<Pme00ProjectStatus> projectStatuses;
				public ExportExcelProjectStatus(List<Pme00ProjectStatus> projectStatuses) {
					this.projectStatuses = projectStatuses;
				}
				public void writeDataLines() {
					int rowCount = 2;
					for (Pme00ProjectStatus status : this.projectStatuses) {
						Row row = sheet.createRow(rowCount++);
						int columnCount = 0;
						createCell(row, columnCount++, status.getNo(), cellStyle);
						createCell(row, columnCount++, status.getGroupName(), cellStyle);
						createCell(row, columnCount++, status.getProjectCode(), cellStyle);
						createCell(row, columnCount++, status.getProjectKrName(), cellStyle);
						createCell(row, columnCount++, status.getProjectEnName(), cellStyle);
						createCell(row, columnCount++, status.getPmName(), cellStyle);
						createCell(row, columnCount++, status.getPlId() + " - " + status.getPlName(),cellStyle);
						createCell(row, columnCount++, status.getStartDate(), cellStyle);
						createCell(row, columnCount++, status.getEndDate(), cellStyle);
						createCell(row, columnCount++, status.getPeriod(), cellStyle);
						createCell(row, columnCount++, status.getMemberCount(), cellStyle);
						createCell(row, columnCount++, status.getTaskCount(), cellStyle);
						createCell(row, columnCount++, status.getProgress(), cellStyle);
						if(status.getStatus() == null) {
							createCell(row, columnCount++, "", cellStyle);
						} else {
							createCell(row, columnCount++, status.getStatus().getCdvMeaning(), cellStyle);
						}
						createCell(row, columnCount, status.getFramework(), cellStyle);
					}
				}
				public void export(HttpServletResponse response) throws IOException {
					newReportExcel();
					// response  writer to excel
					initResponseForExportExcel(response, "ProjectStatus");
					ServletOutputStream outputStream = response.getOutputStream();
					// White sheet, title & header
					String[] headers = new String[]{
					"No",
					"Group",
					"PJT Code",
					"PJT Name (Kor)",
					"PJT Name (Eng)",
					"Kor PM",
					"Leader",
					"Start Date",
					"End Date",
					"Period (Month)",
					"Members",
					"Tasks",
					"Progress (%)",
					"Status",
					"Framework"
					};
					writeTableHeaderExcel("Project Statuses", "Project Status", headers);
					// White data rows
					writeDataLines();
					workbook.write(outputStream);
					workbook.close();
					outputStream.close();
				}
				@Override
				public void export(HttpServletResponse response, ExportBodyRequest request) throws IOException {
				}
			}

			public void newReportExcel() {
				workbook = new XSSFWorkbook();
				createCellStyle();
			}

			package com.poscdx.odc.ampro015.domain.utils;
			import com.google.gson.internal.LinkedTreeMap;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.ExportBodyRequest;
			import org.apache.poi.ss.usermodel.*;
			import org.apache.poi.ss.util.CellRangeAddress;
			import org.apache.poi.xssf.usermodel.XSSFFont;
			import org.apache.poi.xssf.usermodel.XSSFSheet;
			import org.apache.poi.xssf.usermodel.XSSFWorkbook;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;
			import java.math.BigDecimal;
			import java.math.BigInteger;
			import java.text.DateFormat;
			import java.text.SimpleDateFormat;
			import java.util.Date;
			import java.util.List;
			public abstract class ReportAbstract {
				public XSSFWorkbook workbook;
				public XSSFSheet sheet;
				public CellStyle cellStyle;
				public void newReportExcel() {
					workbook = new XSSFWorkbook();
					createCellStyle();
				}
				public void createCellStyle() {
					cellStyle = workbook.createCellStyle();
					// setCentered to cell
					cellStyle.setAlignment(HorizontalAlignment.CENTER);
					cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);
					//setBorder to cell
					cellStyle.setBorderBottom(BorderStyle.THIN);
					cellStyle.setBorderTop(BorderStyle.THIN);
					cellStyle.setBorderRight(BorderStyle.THIN);
					cellStyle.setBorderLeft(BorderStyle.THIN);
					XSSFFont font = workbook.createFont();
					font.setFontHeight(14);
					cellStyle.setFont(font);
				}
				public void initResponseForExportExcel(HttpServletResponse response, String fileName) {
					response.setContentType("application/octet-stream");
					DateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd:hh:mm:ss");
					String currentDateTime = dateFormatter.format(new Date());
					String headerKey = "Content-Disposition";
					String headerValue = "attachment; filename=" + fileName + "_" + currentDateTime + ".xlsx";
					response.setHeader(headerKey, headerValue);
				}
				public void writeTableHeaderExcel(String sheetName, String titleName, String[] headers) {
					// sheet
					sheet = workbook.createSheet(sheetName);
					Row row = sheet.createRow(0);
					CellStyle style = workbook.createCellStyle();
					// setBackground to header
					style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
					style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
					// setBorder to header cell
					style.setBorderBottom(BorderStyle.THIN);
					style.setBorderTop(BorderStyle.THIN);
					style.setBorderRight(BorderStyle.THIN);
					style.setBorderLeft(BorderStyle.THIN);
					XSSFFont font = workbook.createFont();
					font.setBold(true);
					font.setFontHeight(20);
					style.setFont(font);
					style.setAlignment(HorizontalAlignment.CENTER);
					// title
					createCell(row, 0, titleName, style);
					sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, headers.length - 1));
					font.setFontHeightInPoints((short) 10);
					// header
					row = sheet.createRow(1);
					font.setBold(true);
					font.setFontHeight(16);
					style.setFont(font);
					for (int i = 0; i < headers.length; i++) {
						createCell(row, i, headers[i], style);
					}
				}
				public void writeTableHeaderExcel(String sheetName, String titleName, List<String> headers) {
					// sheet
					sheet = workbook.createSheet(sheetName);
					Row row = sheet.createRow(0);
					CellStyle style = workbook.createCellStyle();
					// ADD HEADER STYLES
					// setBackground to header
					style.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
					style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
					// setBorder to header cell
					style.setBorderBottom(BorderStyle.THIN);
					style.setBorderTop(BorderStyle.THIN);
					style.setBorderRight(BorderStyle.THIN);
					style.setBorderLeft(BorderStyle.THIN);
					XSSFFont font = workbook.createFont();
					font.setBold(true);
					font.setFontHeight(20);
					style.setFont(font);
					style.setAlignment(HorizontalAlignment.CENTER);
					// title
					createCell(row, 0, titleName, style);
					sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, headers.size() - 1));
					font.setFontHeightInPoints((short) 10);
					// header
					row = sheet.createRow(1);
					font.setBold(true);
					font.setFontHeight(16);
					style.setFont(font);
					for (int i = 0; i < headers.size(); i++) {
						createCell(row, i, headers.get(i), style);
					}
				}
				public void createCell(org.apache.poi.ss.usermodel.Row row, int columnCount, Object value, CellStyle style) {
					sheet.autoSizeColumn(columnCount);
					Cell cell = row.createCell(columnCount);
					if (value instanceof Integer) {
						cell.setCellValue((Integer) value);
					} else if (value instanceof Double) {
						cell.setCellValue((Double) value);
					} else if (value instanceof Boolean) {
						cell.setCellValue((Boolean) value);
					} else if (value instanceof Long) {
						cell.setCellValue((Long) value);
					} else if (value instanceof BigInteger) {
						cell.setCellValue(String.valueOf(value));
					} else if(value instanceof BigDecimal){
						cell.setCellValue(String.valueOf(value));
					} else {
						cell.setCellValue((String) value);
					}
					cell.setCellStyle(style);
				}
				public CellStyle getFontContentExcel() {
					CellStyle style = workbook.createCellStyle();
					XSSFFont font = workbook.createFont();
					font.setFontHeight(14);
					style.setFont(font);
					return style;
				}
				public void writeDataLines(List<String> cellIds, ExportBodyRequest request) {
					// Start row number
					int startRow = 2;
					List<LinkedTreeMap<String, String>> dataObjects = request.getExportData();

					for (LinkedTreeMap<String, String> object: dataObjects) {
						Row row = sheet.createRow(startRow++);
						int columnCount = 0;
						for (String id : cellIds) {
							createCell(row, columnCount++,  object.get(id), cellStyle);
						}
					}
				}
				public abstract void writeDataLines();
				public abstract void export(HttpServletResponse response) throws IOException;
				public abstract void export(HttpServletResponse response, ExportBodyRequest request) throws IOException;


			}

	Biểu thức Lambda trong java--JAVA:
	
		Giới thiệu Lambda Expression trong Java
		
			- Lambda Expression - Biểu thức Lambda trong java là một tính năng mới và quan trọng được thêm vào trong Java SE 8. Nó cung cấp một cách rõ ràng và ngắn ngọn để đại diện cho một phương thức interface sử dụng
			một biểu thức. Nó rất hữu ích trong thư viện collection. Nó giúp duyệt, lọc và trích xuất dữ liệu từ collection.
			
			- Biểu thức Lambda được sử dụng để cung cấp bản cài đặt của một interface mà có interface chức năng. Nó tiết kiệm rất nhiều mã. Trong trường hợp biểu thức lambda, chúng ta không cần định nghĩa lại phương thức
			để cung cấp việc thực hiện. Ở đây, chúng ta chỉ cần viết mã thực thi.
			
			- Biểu thức Java lambda được coi như là một chức năng, do đó trình biên dịch không tạo tập tin .class.
			
			- Bản chất của Lambda Expression - Biểu thức Lambda trong java là tạo ra một đối tượng nặc danh cho một Functional Interface, và cung cấp thân hàm cho phương thức trừu tượng duy nhất của Functional
			Interface. Functional Interface trong Java là một interface chỉ được chứa một hàm trừu tượng duy nhất.
			
			- Tại sao Functional Interface chỉ chứa MỘT hàm trừu tượng duy nhất? Bởi vì biểu thức Lambda chỉ chứa các tham số và thân hàm, không chỉ định tên hàm. Do vậy nếu có nhiều hơn 1 phương thức trong
			Functional Interface thì biểu thức Lambda sẽ bị bế tắc vì nó không biết cấp thân hàm cho phương thức nào.
		
		Functional Interface
			
			- Biểu thức Lambda cung cấp bản cài đặt cho Functional Interface. Một interface chỉ có MỘT phương thức trừu tượng được gọi là Functional Interface. Java cung cấp một anotation @FunctionalInterface , được
			sử dụng để khai báo một interface như functional interface.
		
		Tại sao sử dụng biểu thức Lambda
			
			- Cung cấp bản thực hiện cho interface Chức năng.
			
			- Viết ít code hơn.
			
		Cú pháp biểu thức Lambda trong java
			
			(argument-list) -> {body}
			
			Biểu thức Lambda trong java gồm có 3 thành phần sau:
				
				- Argument-list: Nó cũng có thể để trống hoặc không.
				
				- Arrow-token: Nó được sử dụng để liên kết arguments-list và body của biểu thức.
				
				- Body: Nó chứa các biểu thức và câu lệnh cho biểu thức lambda.
			
			Một biểu thức lambda có thể có không, một hoặc nhiều tham số. Số lượng tham số của biểu thức lambda phụ thuộc vào số lượng tham số của phương thức duy nhất của interface chức năng.
			
			Trong biểu thức java lambda, nếu chỉ có một câu lệnh, bạn có thể sử dụng hoặc không sử dụng từ khoá return. Bạn phải sử dụng từ khóa return khi biểu thức lambda chứa nhiều câu lệnh.
		
		Ví dụ không sử dụng biểu thức Lambda
			
			package vn.viettuts.java8;	 
			interface Drawable {
				public void draw();
			}			 
			public class LambdaExpressionExample1 {
				public static void main(String[] args) {
					int width = 10;			 
					// không sử dụng biểu thức lambda, 
					// phải sử dụng lớp nặc danh để cài đặt phương thức draw() cho Drawable
					Drawable d = new Drawable() {
						public void draw() {
							System.out.println("Drawing " + width);
						}
					};
					d.draw();
				}
			}
			Kết quả:
				Drawing 10
		
		Ví dụ sử dụng biểu thức Lambda
			
			package vn.viettuts.java8;		 
			//tùy chọn, nó đánh dấu lớp Drawable chỉ được có 1 method trừu tượng
			@FunctionalInterface
			interface Drawable {
				public void draw();
			}			 
			public class LambdaExpressionExample2 {
				public static void main(String[] args) {
					int width = 10;			 
					// sử dụng biểu thức lambda
					Drawable d2 = () -> {
						System.out.println("Drawing " + width);
					};
					d2.draw();
				}
			}
			Kết quả:
				Drawing 10
		
		Ví dụ biểu thức Lambda không có tham số
			
			package vn.viettuts.java8;		 
			interface Sayable {
				public String say();
			}		 
			public class LambdaExpressionExample3 {
				public static void main(String[] args) {
					Sayable s = () -> {
						return "I have nothing to say.";
					};
					System.out.println(s.say());
				}
			}
			Kết quả:
				I have nothing to say.
				
		Ví dụ biểu thức Lambda có một tham số duy nhất			
			
			package vn.viettuts.java8;	 
			interface Sayable {
				public String say(String word);
			}			 
			public class LambdaExpressionExample4 {
				public static void main(String[] args) {
					Sayable s = (word) -> {
						return word;
					};
					System.out.println(s.say("Meo meo!"));
				}
			}
			
			Kết quả:
				Meo meo!
		
		Ví dụ biểu thức Lambda có nhiều tham số
			
			Ví dụ: TH không cần chỉ định kiểu của tham số:
				
				package vn.viettuts.java8;	 
				interface Operation {
					public int add(int a, int b);
				}		 
				public class LambdaExpressionExample5 {
					public static void main(String[] args) {
						Operation operation = (a, b) -> {
							return a + b;
						};
						System.out.println("a + b = " + operation.add(10, 20));
					}
				}
				
				Kết quả:
					a + b = 30
			
			Ví dụ: TH chỉ định kiểu của tham số:
				
				package vn.viettuts.java8;	 
				interface Operation {
					public int add(int a, int b);
				}			 
				public class LambdaExpressionExample5 {
					public static void main(String[] args) {
						Operation operation = (int a, int b) -> {
							return a + b;
						};
						System.out.println("a + b = " + operation.add(10, 20));
					}
				}
				Kết quả:
					a + b = 30
		
		Ví dụ biểu thức Lambda: sử dụng và không sử dụng từ khóa return
			
			package vn.viettuts.java8;		 
			interface Addable {
				int add(int a, int b);
			}		 
			public class LambdaExpressionExample6 {
				public static void main(String[] args) {		 
					// không sử dụng từ khóa return
					Addable ad1 = (a, b) -> (a + b);
					System.out.println(ad1.add(10, 20));		 
					// sử dụng từ khóa return
					Addable ad2 = (int a, int b) -> {
						return (a + b);
					};
					System.out.println(ad2.add(100, 200));
				}
			}
			Kết quả:
				30
				300
				
		Ví dụ biểu thức Lambda với forEach()
			
			package vn.viettuts.java8;		 
			import java.util.ArrayList;
			import java.util.List;			 
			public class LambdaExpressionExample7 {
				public static void main(String[] args) {
					List<String> list = new ArrayList<String>();
					list.add("Java");
					list.add("PHP");
					list.add("C++");
					list.add("Python");			 
					list.forEach((element) -> {
						System.out.println(element);
					});
				}
			}
			Kết quả:
				Java
				PHP
				C++
				Python
				
		Mổ sẻ hàm ArrayList.forEach()
		
			- Chúng ta sẽ cùng tìm hiểu bản chất của biểu thức Lambda trong hàm forEarch().
			
			- Hàm forEach() có một tham số truyền vào là đối tượng Consumer với tên biến là action. Sau đó nó gọi hàm action.accept(), hàm này có tham số là các phần tử của ArrayList.
			
			- java.util.function.Consumer là một Functional Interface có duy nhất một hàm accept() được định nghĩa như sau:
			
			- Có nghĩa là chúng ta cần phải tạo một đối tượng nặc danh từ Consumer interface để cung cấp thân hàm cho accept().
			
			- java.util.function.Consumer là một Functional Interface có duy nhất một hàm accept() được định nghĩa như sau:
				
				Kết quả:
					Java
					PHP
					C++
					Python
		
		 Ví dụ biểu thức Lambda với Thread
			
			Bạn có thể sử dụng biểu thức lambda để chạy thread. Trong ví dụ sau, chúng ta đang cài đặt phương thức run() bằng cách sử dụng biểu thức lambda.
				
				package vn.viettuts.java8;		 
				public class LambdaExpressionExample9 {
					public static void main(String[] args) {				 
						// ví dụ Thread không sử dụng biểu thức lambda
						Runnable r1 = new Runnable() {
							public void run() {
								System.out.println("Thread1 is running...");
							}
						};
						Thread t1 = new Thread(r1);
						t1.start();						 
						// ví dụ Thread sử dụng biểu thức lambda
						Runnable r2 = () -> {
							System.out.println("Thread2 is running...");
						};
						Thread t2 = new Thread(r2);
						t2.start();
					}
				}
				Kết quả:
					Thread1 is running...
					Thread2 is running...
			
			Giao diện Runable được đánh dấu bởi @FunctionalInterface và chỉ có một phương thức trừu tượng, vậy nó là một giao diện chức năng nên chúng ta có thể áp dụng biểu thức lambda với giao diện Runable.
		
		Ví dụ biểu thức Lambda với Comparator
			
			- Biểu thức Java lambda có thể được sử dụng trong collection. Nó cung cấp cách hiệu quả và ngắn gọn để duyệt, lọc và lấy dữ liệu. Sau đây là một số ví dụ biểu thức lambda với Comparator.
				
				package vn.viettuts.java8;		 
				import java.util.ArrayList;
				import java.util.Collections;
				import java.util.List;			 
				class Product {
					int id;
					String name;
					float price;				 
					public Product(int id, String name, float price) {
						super();
						this.id = id;
						this.name = name;
						this.price = price;
					}
				}				 
				public class LambdaExpressionExample10 {
					public static void main(String[] args) {
						List<Product> list = new ArrayList<Product>();				 
						// Add cac san pham
						list.add(new Product(1, "Dell Laptop", 25000f));
						list.add(new Product(3, "Keyboard", 300f));
						list.add(new Product(2, "Dell Mouse", 150f));				 
						System.out.println("Sap xep cac san pham theo ten: ");			 
						// cai dat bieu thuc lambda
						Collections.sort(list, (p1, p2) -> {
							return p1.name.compareTo(p2.name);
						});
						for (Product p : list) {
							System.out.println(p.id + " " + p.name + " " + p.price);
						}
					}
				}
				Kết quả:
					Sap xep cac san pham theo ten: 
					1 Dell Laptop 25000.0
					2 Dell Mouse 150.0
					3 Keyboard 300.0
		
		Ví dụ biểu thức Lambda với Filter Collection Data
			
			Dưới đây là ví dụ biểu thức Lambda với Filter Collection Data.
				
				package vn.viettuts.java8;		 
				import java.util.ArrayList;
				import java.util.List;
				import java.util.stream.Stream;			 
				class Product {
					int id;
					String name;
					float price;			 
					public Product(int id, String name, float price) {
						super();
						this.id = id;
						this.name = name;
						this.price = price;
					}
				}			 
				public class LambdaExpressionExample11 {
					public static void main(String[] args) {
						List<Product> list = new ArrayList<Product>();
						list.add(new Product(1, "Samsung A8", 17000f));
						list.add(new Product(3, "Iphone 8X", 65000f));
						list.add(new Product(2, "Sony Xperia X8", 25000f));
						list.add(new Product(4, "Nokia L7", 15000f));
						list.add(new Product(5, "Redmi Note 7", 26000f));
						list.add(new Product(6, "Lenevo Vibe", 19000f));				 
						// sử dụng biểu thức lambda để filter data
						Stream<Product> filtered_data = list.stream()
								.filter(p -> p.price > 20000);				 
						// sử dụng lambda duyệt các phần tử của collection
						filtered_data.forEach(product -> {
							System.out.println(product.name + ": " + product.price);
						});
					}
				}
				Kết quả:
					Iphone 8X: 65000.0
					Sony Xperia X8: 25000.0
					Redmi Note 7: 26000.0	
	
	Phương thức tham chiếu trong Java--JAVA:
	
		Method References là gì?
		
			- Java cung cấp một tính năng mới gọi là Method References (phương thức tham chiếu) trong Java 8.
			
			- Method References là một tính năng khá hay và liên quan đến việc sử dụng Lambda Expression. Nó cung cấp các cú pháp (syntax) hữu ích để truy cập trực tiếp tới các constructor hoặc method đã tồn tại của các
			lớp hoặc đối tượng trong Java mà không cần thực thi chúng. Nó làm cho việc viết code của chúng ta trở nên đơn giản hơn rất nhiều và nhìn chúng đẹp hơn.
			
			- Chúng ta có thể sử dụng Method References để thay thế cho các Lambda Expression khi Lamba gọi một phương thức nào đó đã được định nghĩa sẵn.
			
			- Method References là cú pháp viết tắt của biểu thức Lambda để gọi phương thức. Ví dụ, nếu biểu thức Lamda được viết như sau:
				
				str -> System.out.println(str)
			
			- Chúng ta có thể viết lại theo cách của Method references như sau:
				
				System.out::println
			
			- Java 8 cho phép truyền một tham chiếu của một method hoặc constructor thông qua việc sử dụng từ khóa ::					
			
			- Chúng ta không thể truyền tham số cho các Method References, phải sử dụng đi kèm với Functional Interfaces.
			
			- Nó giống như biểu thức lambda. Chỉ khác nhau ở chỗ đó là toán tử :: tham chiếu đến phương thức bởi tên của phương thức.
			
			- Chú ý: khi sử dụng toán tử dấu 2 chấm (::) để tham chiếu phương thức. Lúc này phương thức trừu tượng của functional interface phải có số lượng và kiểu dữ liệu của các tham số PHẢI giống với phương thức của
			lớp được tham chiếu.
			
		Các loại Method References
		
			- Tham chiếu đến một static method – Class::staticMethod
			
			- Tham chiếu đến một instance method của một đối tượng cụ thể – object::instanceMethod
			
			- Tham chiếu đến một instance method của một đối tượng tùy ý của một kiểu cụ thể – Class::instanceMethod
			
			- Tham chiếu đến một constuctor – Class::new
			
		Tham chiếu đến một static method
		
			Cú pháp:
			
				Class::staticMethod
			
			Ví dụ:
			
				package com.gpcoder.method_reference;		 
				@FunctionalInterface
				interface ExecuteFunction {
					public int execute(int a, int b);
				}				 
				class MathUtils {
					public static int sum(int a, int b) {
						return a + b;
					}				 
					public static int minus(int a, int b) {
						return a - b;
					}
				}				 
				public class DemoMethodReference1 {
					public static void main(String[] args) {
						int a = 10;
						int b = 7;				 
						int sum = doAction(a, b, MathUtils::sum);
						System.out.println(a + " + " + b + " = " + sum); // 10 + 7 = 17				 
						int minus = doAction(a, b, MathUtils::minus);
						System.out.println(a + " - " + b + " = " + minus); // 10 - 7 = 3
					}				 
					public static int doAction(int a, int b, ExecuteFunction func) {
						return func.execute(a, b);
					}
				}
				
				Thông qua ví dụ trên, bạn có thể thấy cách thức sử dụng từ khóa :: để truyền vào tham chiếu của một method. Nếu bạn gọi một method, mà trong method đó có một tham số là Functional Interface, bạn có thể
				truyền vào một tham chiếu method có cấu trúc giống với cấu trúc method định nghĩa trong Functional interface.
				
		Tham chiếu đến một instance method của một đối tượng cụ thể
			
			Cú pháp:
			
				object::instanceMethod
			
			Ví dụ:
			
				package com.gpcoder.method_reference;
		 
				@FunctionalInterface
				interface ExecuteFunction2 {
					public int execute(int a, int b);
				}				 
				class MathUtils2 {
					public int sum(int a, int b) {
						return a + b;
					}				 
					public int minus(int a, int b) {
						return a - b;
					}
				}				 
				public class DemoMethodReference2 {
					public static void main(String[] args) {
						int a = 10;
						int b = 7;				 
						MathUtils2 obj = new MathUtils2();
						int sum = doAction(a, b, obj::sum);
						System.out.println(a + " + " + b + " = " + sum); // 10 + 7 = 17				 
						int minus = doAction(a, b, obj::minus);
						System.out.println(a + " - " + b + " = " + minus); // 10 - 7 = 3
					}				 
					public static int doAction(int a, int b, ExecuteFunction2 func) {
						return func.execute(a, b);
					}
				}
				
				Như bạn thấy cách sử dụng hoàn toàn tương tự như tham chiếu đến một static method.
		
		Tham chiếu đến một instance method của một đối tượng tùy ý của một kiểu cụ thể
		
			Cú pháp:
				
				Class::instanceMethod
			Ví dụ:
			
				package com.gpcoder.method_reference;		 
				import java.util.Arrays;				 
				public class DemoMethodReference3 {
					public static void main(String[] args) {
						String[] stringArray = { "Java", "C++", "PHP", "C#", "Javascript" };			 
						Arrays.sort(stringArray, String::compareToIgnoreCase);
						for (String str : stringArray) {
							System.out.println(str);
						}
					}
				}
		Tham chiếu đến một constuctor
		
			Cú pháp:
				Class::new
					
			Ví dụ:
			
				package com.gpcoder.method_reference;			 
				@FunctionalInterface
				interface SayHello {
					void display(String say);
				}			 
				class Hello implements SayHello {
					public Hello(String say) {
						System.out.print(say);
					}			 
					@Override
					public void display(String say) {
						System.out.println(say);
					}
				}				 
				public class DemoMethodReference4 {				 
					public static void main(String[] args) {
						SayHello ref = Hello::new;
						ref.display("Welcome to gpcoder.com");
					}				 
				}
				
		Ví dụ toán tử dấu 2 chấm (::) trong Java
			
			Tạo một FunctionalInterface chỉ có một phương thức trừu tượng accept().
				
				package vn.viettuts.lambda;		 
				@FunctionalInterface
				public interface MyFunction {
					int accept(int a, int b);
				}
					Tạo lớp MyUtils có 2 phương thức add() và minus().
						package vn.viettuts.lambda;				 
				public class MyUtils {
					public static int add(int a, int b) {
						return a + b;
					}				 
					public static int minus(int a, int b) {
						return a - b;
					}
				}
				
			Tạo lớp App có 2 phương thức action() và main() để chạy ứng dụng. Hàm action() xử lý giá trị của tham số a và b, lúc này chúng ta chưa biết hàm accept(a,b) trả về giá trị gì vì nó chỉ là một hàm trừu
			tượng chưa có thân hàm. Chúng ta sẽ cung cấp thân hàm cho phương thức MyFunction.accept() trong hàm main().
			
				package vn.viettuts.lambda;	 
				public class App {
					/**
					 * Xử lý giá trị của tham số a và b.
					 * Lúc này chúng ta chưa biết hàm accept(a,b) trả về giá trị gì, 
					 * vì nó chỉ là một hàm trừu tượng chưa có thân hàm.
					 * Chúng ta sẽ cung cấp thân hàm cho phương thức MyFunction.accept() 
					 * trong hàm main().
					 */
					public int action(int a, int b, MyFunction func) {
						return func.accept(a, b);
					}				 
					public static void main(String[] args) {
						App app = new App();
						// tạo đối tượng nặc danh addFunc và cung cấp thân hàm cho hàm accept()
						// bây giờ hàm accept() sẽ có thân hàm giống như hàm MyUtils.add().
						// nghĩa là hệ thống copy hàm MyUtils.add() như một bản cài đặt 
						// cho hàm accept()
						MyFunction addFunc = MyUtils::add;
						int c1 = app.action(10, 2, addFunc);
						System.out.println("Tổng 2 số: " + c1);						 
						MyFunction minusFunc = MyUtils::minus;
						int c2 = app.action(10, 2, minusFunc);
						System.out.println("Hiệu 2 số: " + c2);					 
						MyFunction maxFunc = Math::max;
						int c3 = app.action(10, 2, maxFunc);
						System.out.println("MAX: " + c3);					 
						MyFunction minFunc = Math::min;
						int c4 = app.action(10, 2, minFunc);
						System.out.println("MIN: " + c4);
					}
				}
				Kết quả:
					Tổng 2 số: 12
					Hiệu 2 số: 8
					MAX: 10
					MIN: 2

	JsonNode Working with Tree Model Nodes in Jackson --JAVA:
	
		We’ll use JsonNode for various conversions as well as adding, modifying, and removing nodes.
		
		Creating a Node
		
			The first step in the creation of a node is to instantiate an ObjectMapper object by using the default constructor:
				
				ObjectMapper mapper = new ObjectMapper();
			
			Since the creation of an ObjectMapper object is expensive, it’s recommended that we reuse the same one for multiple operations.
			
			Next, we have three different ways to create a tree node once we have our ObjectMapper.
			
			Construct a Node from Scratch
				
				This is the most common way to create a node out of nothing:
					
					JsonNode node = mapper.createObjectNode();
				
				Alternatively, we can also create a node via the JsonNodeFactory:
					
					JsonNode node = JsonNodeFactory.instance.objectNode();
			
			Parse from a JSON Source
				
				This method is well covered in the Jackson – Marshall String to JsonNode article. Please refer to it for more info.
			
			Convert from an Object
				
				A node may be converted from a Java object by calling the valueToTree(Object fromValue) method on the ObjectMapper:
					
					JsonNode node = mapper.valueToTree(fromValue);
				
				The convertValue API is also helpful here:
					
					JsonNode node = mapper.convertValue(fromValue, JsonNode.class);
				
				Let’s see how it works in practice.
				
				Assume we have a class named NodeBean:
					
					public class NodeBean {
						private int id;
						private String name;
						public NodeBean() {
						}
						public NodeBean(int id, String name) {
							this.id = id;
							this.name = name;
						}
						// standard getters and setters
					}
					
				Let’s write a test that makes sure that the conversion happens correctly:
					
					@Test
					public void givenAnObject_whenConvertingIntoNode_thenCorrect() {
						NodeBean fromValue = new NodeBean(2016, "baeldung.com");

						JsonNode node = mapper.valueToTree(fromValue);

						assertEquals(2016, node.get("id").intValue());
						assertEquals("baeldung.com", node.get("name").textValue());
					}
					
		Transforming a Node
		
			Write out as JSON
			
				This is the basic method to transform a tree node into a JSON string, where the destination can be a File, an OutputStream or a Writer:
					
					mapper.writeValue(destination, node);
				
				By reusing the class NodeBean declared in Section 2.3, a test makes sure this method works as expected:
					
					final String pathToTestFile = "node_to_json_test.json";
					@Test
					public void givenANode_whenModifyingIt_thenCorrect() throws IOException {
						String newString = "{\"nick\": \"cowtowncoder\"}";
						JsonNode newNode = mapper.readTree(newString);
						JsonNode rootNode = ExampleStructure.getExampleRoot();
						((ObjectNode) rootNode).set("name", newNode);
						assertFalse(rootNode.path("name").path("nick").isMissingNode());
						assertEquals("cowtowncoder", rootNode.path("name").path("nick").textValue());
					}
					
			Convert to an Object
				
				The most convenient way to convert a JsonNode into a Java object is the treeToValue API:
					
					NodeBean toValue = mapper.treeToValue(node, NodeBean.class);
				
				This is functionally equivalent to the following:
					
					NodeBean toValue = mapper.convertValue(node, NodeBean.class)
				
				We can also do that through a token stream:
					
					JsonParser parser = mapper.treeAsTokens(node);	
					NodeBean toValue = mapper.readValue(parser, NodeBean.class);
				
				Finally, let’s implement a test that verifies the conversion process:
					
					@Test
					public void givenANode_whenConvertingIntoAnObject_thenCorrect()
					  throws JsonProcessingException {
						JsonNode node = mapper.createObjectNode();
						((ObjectNode) node).put("id", 2016);
						((ObjectNode) node).put("name", "baeldung.com");
						NodeBean toValue = mapper.treeToValue(node, NodeBean.class);
						assertEquals(2016, toValue.getId());
						assertEquals("baeldung.com", toValue.getName());
					}
					
		Manipulating Tree Nodes
			
			We’ll use the following JSON elements, contained in a file named example.json, as a base structure for actions to be taken on:
				
				{
					"name": 
						{
							"first": "Tatu",
							"last": "Saloranta"
						},

					"title": "Jackson founder",
					"company": "FasterXML"
				}
				
			This JSON file, located on the classpath, is parsed into a model tree:
				
				public class ExampleStructure {
					private static ObjectMapper mapper = new ObjectMapper();
					static JsonNode getExampleRoot() throws IOException {
						InputStream exampleInput = 
						  ExampleStructure.class.getClassLoader()
						  .getResourceAsStream("example.json");				
						JsonNode rootNode = mapper.readTree(exampleInput);
						return rootNode;
					}
				}
				
			Note that the root of the tree will be used when illustrating operations on nodes in the following subsections.
			
			Locating a Node
			
				Before working on any node, the first thing we need to do is to locate and assign it to a variable.
				
				If we know the path to the node beforehand, that’s pretty easy to do.
				
				Say we want a node named last, which is under the name node:
					
					JsonNode locatedNode = rootNode.path("name").path("last");
				
				Alternatively, the get or with APIs can also be used instead of path.

				If the path isn’t known, the search will, of course, become more complex and iterative.

				We can see an example of iterating over all the nodes in Section 5 – Iterating Over the Nodes.
			
			Adding a New Node
				
				A node can be added as a child of another node:
					
					ObjectNode newNode = ((ObjectNode) locatedNode).put(fieldName, value);
				
				Many other similar methods are also available, including putArray, putObject, PutPOJO, putRawValue and putNull.
				
				Finally, let’s have a look at an example where we add an entire structure to the root node of the tree:
					
					"address":
					{
						"city": "Seattle",
						"state": "Washington",
						"country": "United States"
					}
					
				Here’s the full test going through all of these operations and verifying the results:
					
					@Test
					public void givenANode_whenAddingIntoATree_thenCorrect() throws IOException {
						JsonNode rootNode = ExampleStructure.getExampleRoot();
						ObjectNode addedNode = ((ObjectNode) rootNode).putObject("address");
						addedNode
						  .put("city", "Seattle")
						  .put("state", "Washington")
						  .put("country", "United States");
						assertFalse(rootNode.path("address").isMissingNode());
						assertEquals("Seattle", rootNode.path("address").path("city").textValue());
						assertEquals("Washington", rootNode.path("address").path("state").textValue());
						assertEquals(
						  "United States", rootNode.path("address").path("country").textValue();
					}
					
				Editing a Node
					
					An ObjectNode instance may be modified by invoking set(String fieldName, JsonNode value) method:
						
						JsonNode locatedNode = locatedNode.set(fieldName, value);
					
					Similar results might be achieved by using replace or setAll methods on objects of the same type.
					
					To verify that the method works as expected, we’ll change the value of the field name under root node from an object of first and last into another one consisting of only nick field in a test:
						
						@Test
						public void givenANode_whenModifyingIt_thenCorrect() throws IOException {
							String newString = "{\"nick\": \"cowtowncoder\"}";
							JsonNode newNode = mapper.readTree(newString);
							JsonNode rootNode = ExampleStructure.getExampleRoot();
							((ObjectNode) rootNode).set("name", newNode);
							assertFalse(rootNode.path("name").path("nick").isMissingNode());
							assertEquals("cowtowncoder", rootNode.path("name").path("nick").textValue());
						}
						
				Removing a Node
				
					A node can be removed by calling the remove(String fieldName) API on its parent node:
						
						JsonNode removedNode = locatedNode.remove(fieldName);
					
					In order to remove multiple nodes at once, we can invoke an overloaded method with the parameter of Collection<String> type, which returns the parent node instead of the one to be removed:
						
						ObjectNode locatedNode = locatedNode.remove(fieldNames);
					
					In the extreme case when we want to delete all subnodes of a given node, the removeAll API comes in handy.
					
					The following test will focus on the first method mentioned above, which is the most common scenario:
						
						@Test
						public void givenANode_whenRemovingFromATree_thenCorrect() throws IOException {
							JsonNode rootNode = ExampleStructure.getExampleRoot();
							((ObjectNode) rootNode).remove("company");
							assertTrue(rootNode.path("company").isMissingNode());
						}
						
			Ví dụ:
			
				package com.poscdx.odc.ampro015.domain.entity;
				import com.fasterxml.jackson.databind.JsonNode;
				import com.fasterxml.jackson.databind.ObjectMapper;
				import com.google.gson.JsonArray;
				import com.google.gson.JsonObject;
				import com.google.gson.JsonParser;
				import com.poscdx.odc.ampro015.domain.enums.LogAction;
				import com.poscdx.odc.ampro015.domain.enums.EntityType;
				import com.poscoict.base.share.util.json.JsonUtil;
				import lombok.AllArgsConstructor;
				import lombok.Builder;
				import lombok.Getter;
				import lombok.Setter;
				import java.sql.Timestamp;
				import java.time.Instant;
				import java.util.*;
				@Getter
				@Setter
				@Builder
				@AllArgsConstructor
				public class Pme00Log {
					private int id;
					private String empId;
					private Timestamp logTime;
					private String type;
					private String action;
					private String targetId;
					private String targetIdSub;
					private String content;
					private String detail;
					private EntityType entityType;
					private LogAction logAction;
					private String empName;
					private String avatar;
					private String oldDataJSON;
					private String newDataJSON;
					public Pme00Log() {
						this.logTime = Timestamp.from(Instant.now());
					}
					public void setContent() {
						this.content = logAction.getMessage() + " " + entityType.getMessage() + " ID: " + this.targetId;
						if (this.targetIdSub != null) {
							this.content += "-" + this.targetIdSub;
						}
					}
					public void setLogAction(LogAction logAction) {
						this.logAction = logAction;
						this.action = logAction.getValue();
					}
					public void setEntityType(EntityType entityType) {
						this.entityType = entityType;
						this.type = entityType.getValue();
					}
					public void setOldDataJSON(String oldDataJSON) {
						this.oldDataJSON = oldDataJSON;
						if (this.oldDataJSON != null && this.newDataJSON != null) getDetailFromData();
					}
					public void setNewDataJSON(String newDataJSON) {
						this.newDataJSON = newDataJSON;
						if (this.oldDataJSON != null && this.newDataJSON != null) getDetailFromData();
					}
					private void getDetailFromData() {
						JsonObject detailObject = new JsonObject();
						detailObject.add("oldData", JsonParser.parseString(this.oldDataJSON));
						detailObject.add("newData", JsonParser.parseString(this.newDataJSON));
						ObjectMapper mapper = new ObjectMapper();
						try {
							JsonNode node1 = mapper.readTree(this.oldDataJSON);
							JsonNode node2 = mapper.readTree(this.newDataJSON);
							Map<String, Object> changedMap = getChangeMap(node1, node2);
							this.detail = changedMap.toString();
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					private Map<String, Object> getChangeMap(JsonNode oldJSON, JsonNode newJSON) {
						Map<String, Object> oldDataMap = new HashMap<>();
						Map<String, Object> newDataMap = new HashMap<>();
						List<String> changedList = new ArrayList<>();
						Map<String, Object> result = new HashMap<>();
						compareJsonObjects(oldJSON, newJSON, oldDataMap, newDataMap, changedList);
						result.put("oldData", oldDataMap);
						result.put("newData", newDataMap);
						JsonArray detailArray = new JsonArray();
						for (String item : changedList) {
							detailArray.add(item);
						}
						result.put("changedList", detailArray);
						return result;
					}
					private void compareJsonObjects(JsonNode oldJSON, JsonNode newJSON,
													Map<String, Object> oldDataMap, Map<String, Object> newDataMap,
													List<String> changedList) {
						for (Iterator<String> it = oldJSON.fieldNames(); it.hasNext(); ) {
							String fieldName = it.next();
							JsonNode oldValue = oldJSON.get(fieldName);
							JsonNode newValue = newJSON.get(fieldName);
							if (newValue != null) {
								if (oldValue.isObject() || newValue.isObject()) {
									compareJsonObjects(oldValue, newValue, oldDataMap, newDataMap, changedList);
								} else if (oldValue == null || !oldValue.equals(newValue)) {
									changedList.add(fieldName);
									oldDataMap.put(fieldName, oldValue);
									newDataMap.put(fieldName, newValue);
								}
							}
						}
					}
					public static Pme00Log fromJson(String json) {
						return JsonUtil.fromJson(json, Pme00Log.class);
					}
					public String toJson() {
						return JsonUtil.toJson(this);
					}
				}
				
	Using Static Methods Instead of Deprecated JsonParser--JAVA:
	
		Introduction
		
			Efficient JSON parsing is one of the most important tasks in Java programming when it comes to data manipulation and communication.
			
			Efficient JSON parsing is one of the most important tasks in Java programming when it comes to data manipulation and communication.
			
			In this tutorial, we’ll delve into how to utilize the static methods instead of the deprecated JsonParser for efficient JSON parsing in Java.
		
		Deprecated JsonParser
			
			Here is an example of using the deprecated JsonParser to parse a JSON string:
				
				String jsonString = "{\"name\": \"John\", \"age\":30, \"city\":\"New York\"}";
				JsonObject jsonObject = new JsonParser().parse(jsonString).getAsJsonObject();
			
			The deprecated JsonParser instance may still function, but developers are encouraged to move on with new and improved practices.
		
		Embracing Static Methods
			
			The Gson library offers static methods as replacements for the deprecated ones. Moreover, it is a more elegant and easier-to-understand parsing way of JSON.
			
			Parse from String
				
				We can parse a JSON string directly into JsonObject without using a deprecated instance of JsonParser using the parseString() static method.
				
				Firstly, let’s set up a JSON string describing person-related data and read an associated JsonObject with given keys like name, age, and city underlying class constructor of DeprecatedJsonParserUnitTest:
					
					String jsonString = "{\"name\": \"John\", \"age\":30, \"city\":\"New York\"}";
					JsonObject expectedJsonObject = new JsonObject();
					DeprecatedJsonParserUnitTest() {
						expectedJsonObject.addProperty("name", "John");
						expectedJsonObject.addProperty("age", 30);
						expectedJsonObject.addProperty("city", "New York");
					}
					
				Now, let’s parse the jsonString directly into JsonObject:
					
					@Test
					public void givenJsonString_whenUsingParseString_thenJsonObjectIsExpected() {
						JsonObject jsonObjectAlt = JsonParser.parseString(jsonString).getAsJsonObject();
						assertEquals(expectedJsonObject, jsonObjectAlt);
					}
					
				In this test method, we verify that the parsed jsonObjectAlt matches the expectedJsonObject created earlier.
			
			Parse from StringReader
				
				There are cases when the obtained JSON data comes from a StringReader. We can use the parseReader() static method to get the same result without using obsolete components:
					
					@Test
					public void givenJsonString_whenUsingParseReader_thenJsonObjectIsExpected() {
						StringReader reader = new StringReader(jsonString);
						JsonObject jsonObject = JsonParser.parseReader(reader).getAsJsonObject();
						assertEquals(expectedJsonObject, jsonObject);
					}
					
				Here, we initialize a StringReader called reader. Then, we use the JsonParser.parseReader() method to parse the JSON data into a JsonObject.
			
			Parse from JsonReader
				
				When dealing with a JsonReader, the parseReader() static method is still an effective and contemporary decision that avoids outdated constructions. Let’s take an example:
					
					@Test
					public void givenJsonReader_whenParseUsingJsonReader_thenJsonObjectIsExpected() {
						JsonReader jsonReader = new JsonReader(new StringReader(jsonString));
						JsonObject jsonObject = JsonParser.parseReader(jsonReader).getAsJsonObject();
						assertEquals(expectedJsonObject, jsonObject);
					}
				
				In the above test method, we begin by instantiating a JsonReader named jsonReader with the contents of the JSON string. Then, we utilize the JsonParser.parseReader() method to parse such JSON data into a JsonObject.

	Java.lang.Class--JAVA:
	
		- Java provides a class with name Class in java.lang package. Instances of the class Class represent classes and interfaces in a running Java application. The primitive Java
		types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.
		
		- In Java, the java.lang.Class class is a built-in class that represents a class or interface at runtime. It contains various methods that provide information about the class or
		interface, such as its name, superclass, interfaces, fields, and methods.
		
		- Here are some commonly used methods of the Class class:
			
			getName(): Returns the name of the class or interface represented by this Class object.
			getSimpleName(): Returns the simple name of the class or interface represented by this Class object.
			getSuperclass(): Returns the superclass of the class represented by this Class object.
			getInterfaces(): Returns an array of interfaces implemented by the class or interface represented by this Class object.
			getField(String name): Returns a Field object that represents the public field with the specified name in the class or interface represented by this Class object.
			getMethod(String name, Class<?>… parameterTypes): Returns a Method object that represents the public method with the specified name and parameter types in the class or interface represented by this Class object.
			newInstance(): Creates a new instance of the class represented by this Class object using its default constructor.
			isInstance(Object obj): Returns true if the specified object is an instance of the class or interface represented by this Class object, false otherwise.
			isAssignableFrom(Class<?> cls): Returns true if this Class object is assignable from the specified Class object, false otherwise.
		
		Here’s an example of how to use some of these methods:
			
			public class Main {
				public static void main(String[] args) throws Exception {
					Class<?> myClass = String.class;
					System.out.println("Name: " + myClass.getName());
					System.out.println("Simple name: " + myClass.getSimpleName());
					System.out.println("Superclass: " + myClass.getSuperclass());
					System.out.println("Interfaces: " + Arrays.toString(myClass.getInterfaces()));
					System.out.println("Is string assignable from Object? " + String.class.isAssignableFrom(Object.class));
				}
			}
			
			Output:
				Name: java.lang.String
				Simple name: String
				Superclass: class java.lang.Object
				Interfaces: []
				Is string assignable from Object? true
		
		Creating a Class object
		
			There are three ways to create Class object :
				
				Class.forName(“className”)
					
					Since class Class doesn’t contain any constructor, there is static factory method present in class Class, which is Class.forName() , used for creating object of class Class. Below is the syntax :
						
						Class c = Class.forName(String className)
				
				Myclass.class
					
					Class c = int.class
						
						A a = new A();   // Any class A
						Class c = A.class; // No error
						Class c = a.class; // Error
				
				obj.getClass()
					A a = new A();   // Any class A
					Class c = a.getClass();
		
		Methods:
			
			Class<? super T> getSuperclass()
				// Java program to demonstrate getSuperclass() method
			 
			// base class
			class A
			{
				// methods and fields
			}			 
			// derived class
			class B extends A
			{				 
			}		 
			// Driver class
			public class Test
			{
				public static void main(String[] args) 
						throws ClassNotFoundException 				 
				{
					// returns the Class object associated with Test class
					Class myClass = Test.class;					 
					// returns the Class object for the class 
					// with the specified name 
					Class c1 = Class.forName("A");
					Class c2 = Class.forName("B");
					Class c3 = Class.forName("java.lang.Object");				 
					// getSuperclass method returns the superclass of the class represented 
					// by this class object 					 
					System.out.print("Test superclass : ");					 
					// getSuperclass method on myClass
					System.out.println(myClass.getSuperclass());					 
					System.out.print("A superclass : ");					 
					// getSuperclass method on c1
					System.out.println(c1.getSuperclass());					 
					System.out.print("B superclass : ");					 
					// getSuperclass method on c2
					System.out.println(c2.getSuperclass());				 
					System.out.print("Object superclass : ");				 
					// getSuperclass method on c3
					System.out.println(c3.getSuperclass());
				}
			}
			
			Output:
			
				Test superclass : class java.lang.Object
				A superclass : class java.lang.Object
				B superclass : class A
				Object superclass : null
				
			Class<?>[] getInterfaces()
				
				// Java program to demonstrate getInterfaces() method
				// base interface
				interface A
				{
					// methods and constant declarations
				}				 
				// derived class
				class B implements A
				{
					// methods implementations that were declared in A
				}			 
				// Driver class
				public class Test
				{
					public static void main(String[] args) 
							throws ClassNotFoundException 				 
					{
						// returns the Class object for the class 
						// with the specified name 
						Class c1 = Class.forName("B");
						Class c2 = Class.forName("java.lang.String");					 
						// getInterface method on c1
						// it returns the interfaces implemented by B class
						Class c1Interfaces[] = c1.getInterfaces();					 
						// getInterface method on c2
						// returns the interfaces implemented by String class
						Class c2Interfaces[] = c2.getInterfaces();					 					 
						System.out.println("interfaces implemented by B class : ");					 
						// iterating through B class interfaces
						for (Class class1 : c1Interfaces) 
						{
							System.out.println(class1);
						}					 					 
						System.out.println("interfaces implemented by String class : ");				 
						// iterating through String class interfaces
						for (Class class1 : c2Interfaces) 
						{
							System.out.println(class1);
						}
					}
				}
				Output:
					interfaces implemented by B class : 
					interface A
					interfaces implemented by String class : 
					interface java.io.Serializable
					interface java.lang.Comparable
					interface java.lang.CharSequence
			
			Class<?>[ ] getClasses()
				
				// Java program to demonstrate getClasses() method
				public class Test
				{
					// base interface
					public interface A
					{
						// methods and constant declarations
					}			 
					// derived class
					public class B implements A
					{
						// methods implementations that were declared in A
					}				 
					public static void main(String[] args) 
							throws ClassNotFoundException 				 
					{
						// returns the Class object associated with Test class
						Class c1 = Test.class;					 
						// getClasses method on c1
						// it returns the array of Class objects containing the all 
						// public classes and interfaces  represented by Test class
						Class[] c1Classes = c1.getClasses();				 
						System.out.println("public members of Test class : ");				 
						// iterating through all public members of Test class
						for (Class class1 : c1Classes)
						{
							System.out.println(class1);
						}				 
					}
				}
				
				Output:
					public members of Test class : 
					interface Test$A
					class Test$B
			
			Field getField(String fieldName)
				
				// Java program to demonstrate getField() method 
				import java.lang.reflect.Field;
				public class Test
				{
					public static void main(String[] args) 
							throws SecurityException,ClassNotFoundException,
								   NoSuchFieldException
					{
						// returns the Class object for the class 
						// with the specified name 
						Class c1 = Class.forName("java.lang.Integer");			 
						// getField method on c1
						// it checks a public field in Integer class with specified parameter
						Field f = c1.getField("MIN_VALUE");			 
						System.out.println("public field in Integer class with MIN_VALUE name :");
						System.out.println(f);
					}
				}
				
				Output:
					public field in Integer class with MIN_VALUE name :
					public static final int java.lang.Integer.MIN_VALUE
			
			int getModifiers()
				
				// Java program to demonstrate getModifiers() method
				import java.lang.reflect.Modifier;		 
				public abstract class Test
				{
					public static void main(String[] args) 
					{
						// returns the Class object associated with Test class
						Class c = Test.class;	 
						// returns the Modifiers of the class Test
						// getModifiers method
						int i = c.getModifiers();			 
						System.out.println(i);			 
						System.out.print("Modifiers of " + c.getName() + " class are : ");	 
						// getting decoded i using toString() method
						// of Modifier class
						System.out.println(Modifier.toString(i));
					}
				}
				
				Output:
					
					1025
					Modifiers of Test class are : public abstract
			
			Class<?>[] getDeclaredClasses()
				
				// Java program to demonstrate getDeclaredClasses() method
				public class Test
				{
					// base interface
					interface A
					{
						// methods and constant declarations
					}				  
					// derived class
					class B implements A
					{
						// methods implementations that were declared in A
					}			 				 
					public static void main(String[] args)
					{
						// returns the Class object associated with Test class
						Class myClass = Test.class;					 
						// getDeclaredClasses on myClass
						// it returns array of classes and interface declare in Test class
						Class c[] = myClass.getDeclaredClasses();					 
						System.out.println("Declared classes and interfaces present in " + 
																  myClass.getName() + " class : ");					 
						// iterating through classes and interfaces declared in Test class
						for (Class class1 : c)
						{
							System.out.println(class1);
						}
						 
					}
				}
				
				Output:
					Declared classes and interfaces present in Test class : 
					interface Test$A
					class Test$B
			
			Field getDeclaredField(String fieldName)
				
				// Java program to demonstrate getDeclaredField() method
				import java.lang.reflect.Field;		 
				public class Test
				{
					// any declared field
					int i;			 
					public static void main(String[] args) 
							throws NoSuchFieldException, SecurityException
					{
						// returns the Class object associated with Test class
						Class myClass = Test.class;				 
						// getDeclaredField on myClass
						Field f = myClass.getDeclaredField("i");				 
						System.out.println("Declared field present in " +
													 myClass.getName() + 
													 " class specified by \"i\" : ");			 
						System.out.println(f);
					}
				}
				
				Output:
					Declared field present in Test class specified by "i" : 
					int Test.i
			
			Field[] getDeclaredFields()
				
				// Java program to demonstrate getDeclaredFields() method
				import java.lang.reflect.Field;				 
				public class Test
				{
					// some declared fields
					int i;
					String str;
					boolean b;					 
					public static void main(String[] args)
					{
						// returns the Class object associated with Test class
						Class myClass = Test.class;						 
						// getDeclaredFields on myClass
						Field f[] = myClass.getDeclaredFields();					 
						System.out.println("Declared fields present in " +
															myClass.getName() + " class are : ");					 
						// iterating through declared fields of Test class
						for (Field field : f) 
						{
							System.out.println(field);
						}
					}
				}
				
				Output:
					Declared fields present in Test class are : 
					int Test.i
					java.lang.String Test.str
					boolean Test.b
			
			Method getDeclaredMethod(String methodName,Class… parameterTypes)
				
				// Java program to demonstrate getDeclaredMethod() method
				import java.lang.reflect.Method;				 
				public class Test
				{
					// any declared method
					// with a String argument
					public void m1(String str)
					{
						System.out.println(str);
					}				 
					public static void main(String[] args) 
							throws NoSuchMethodException, SecurityException, ClassNotFoundException
					{
						// returns the Class object associated with Test class
						Class myClass = Test.class;					 
						// returns the Class object for the class 
						// with the specified name 
						Class c = Class.forName("java.lang.String");					 
						// getDeclaredMethod on myClass
						Method m = myClass.getDeclaredMethod("m1",c);					 
						System.out.println("Declared method present in " +
												myClass.getName() +
												" class specified by argument : " + c.getName());				 
						System.out.println(m);
					}
				}
				
				Output:
					Declared method present in Test class specified by argument : java.lang.String
					public void Test.m1(java.lang.String)
			
			Method[] getDeclaredMethods()
				
				// Java program to demonstrate getDeclaredMethods() method
				import java.lang.reflect.Method;			 
				public class Test
				{
					// some declared Methods
					public void m1()
					{
						System.out.println("Inside m1 method");
					}
					 
					static void m2()
					{
						System.out.println("Inside m2 method");
					}
					 
					// main method
					public static void main(String[] args)
					{
						// returns the Class object associated with Test class
						Class myClass = Test.class;
						 
						// getDeclaredMethods on myClass
						Method m[] = myClass.getDeclaredMethods();
						 
						System.out.println("Declared methods present in " +
															myClass.getName() + " class are : ");
						 
						// iterating through declared Methods of Test class
						for (Method Method : m) 
						{
							System.out.println(Method);
						}
					}
				}
				
				Output:
					Declared methods present in Test class are : 
					public static void Test.main(java.lang.String[])
					public void Test.m1()
					static void Test.m2()
					
			String toString()
			
				// Java program to demonstrate toString() method
				public class Test {
					public static void main(String[] args)
						throws ClassNotFoundException
					{
						// returns the Class object for the class
						// with the specified name
						Class c1 = Class.forName("
												 java.lang.String & quot;);
						Class c2 = int.class;
						Class c3 = void.class;			 
						System.out.print(" Class represented by c1
										 : ");			 
						// toString method on c1
						System.out.println(c1.toString());			 
						System.out.print(" Class represented by c2
										 : ");		 
						// toString method on c2
						System.out.println(c2.toString());		 
						System.out.print(" Class represented by c3
										 : ");		 
						// toString method on c3
						System.out.println(c3.toString());
					}
				}
				
				Output:
				
					Class represented by c1: class java.lang.String
					Class represented by c2: int
					Class represented by c3: void
			
			Class<?> forName(String className)

				// Java program to demonstrate forName() method
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException
					{
						// forName method
						// it returns the Class object for the class 
						// with the specified name 
						Class c = Class.forName("java.lang.String");				 
						System.out.print("Class represented by c : " + c.toString());
					}
				}
				
				Output:
					
					Class represented by c : class java.lang.String
			
			Class<?> forName(String className,boolean initialize, ClassLoader loader)
				
				// Java program to demonstrate forName() method
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException
					{
						// returns the Class object for this class
						Class myClass = Class.forName("Test");			 
						ClassLoader loader = myClass.getClassLoader();			 
						// forName method
						// it returns the Class object for the class 
						// with the specified name using the given class loader
						Class c = Class.forName("java.lang.String",true,loader);			 
						System.out.print("Class represented by c : " + c.toString());
					}
				}
				
				Output:
					Class represented by c : class java.lang.String
			
			T newInstance()
				
				// Java program to demonstrate newInstance() method
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException, InstantiationException,
										 IllegalAccessException
					{
						// returns the Class object for this class
						Class myClass = Class.forName("Test");
						 
						// creating new instance of this class
						// newInstance method
						Object obj = myClass.newInstance();
						 
						// returns the runtime class of obj
						System.out.println("Class of obj : " + obj.getClass());
					}
				}
				
				Output:
					Class of obj : class Test
			
			boolean isInstance(Object obj)
				
				// Java program to demonstrate isInstance() method
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException
					{
						// returns the Class object for the class 
						// with the specified name 
						Class c = Class.forName("java.lang.String");
				 
						String s = "GeeksForGeeks";
						int i = 10;
						 
						 
						// checking for Class instance
						// isInstance method
						boolean b1 = c.isInstance(s);
						boolean b2 = c.isInstance(i);
						 
						System.out.println("is s instance of String : " + b1);
						System.out.println("is i instance of String : " + b1);
						 
					}
				}
				
				Output:
					is s instance of String : true
					is i instance of String : false
			
			boolean isAssignableFrom(Class<?> cls)
			
				// Java program to demonstrate isAssignableFrom() method
				public class Test extends Thread
				{
					public static void main(String[] args)
										 throws ClassNotFoundException, InstantiationException,
										 IllegalAccessException
					{
						// returns the Class object for this class
						Class myClass = Class.forName("Test");					 
						// returns the Class object for the class 
						// with the specified name 
						Class c1 = Class.forName("java.lang.Thread");
						Class c2 = Class.forName("java.lang.String");					 
					   // isAssignableFrom method on c1
					   // it checks whether Thread class is assignable from Test
					   boolean b1 = c1.isAssignableFrom(myClass);				
					   // isAssignableFrom method on c2
					   // it checks whether String class is assignable from Test
					   boolean b2 = c2.isAssignableFrom(myClass);				
					   System.out.println("is Thread class Assignable from Test : " + b1);
					   System.out.println("is String class Assignable from Test : " + b2);
						
					}
				}
				
				Output:
					is Thread class Assignable from Test : true
					is String class Assignable from Test : false
			
			boolean isInterface()
				
				// Java program to demonstrate isInterface() method
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException
					{
						// returns the Class object for the class 
						// with the specified name 
						Class c1 = Class.forName("java.lang.String");
						Class c2 = Class.forName("java.lang.Runnable");					 
						// checking for interface type		 
						// isInterface method on c1
						boolean b1 = c1.isInterface();		 
						// is Interface method on c2
						boolean b2 = c2.isInterface();				 
						System.out.println("is java.lang.String an interface : " + b1);
						System.out.println("is java.lang.Runnable an interface : " + b2);
					}
				}
				
				Output:
					is java.lang.String an interface : false
					is java.lang.Runnable an interface : true
			
			boolean isPrimitive()
				
				// Java program to demonstrate isPrimitive method
				public class Test
				{
					public static void main(String[] args) 
					{
						// returns the Class object associated with an integer;
						Class c1 = int.class;			 
					   // returns the Class object associated with Test class
						Class c2 = Test.class;			
						// checking for primitive type	 
						// isPrimitive method on c1
						boolean b1 = c1.isPrimitive();	 
						// isPrimitive method on c2
						boolean b2 = c2.isPrimitive();			 
						System.out.println("is "+c1.toString()+" primitive : " + b1);
						System.out.println("is "+c2.toString()+" primitive : " + b2);
					}
				}
				
				Output:
					is int primitive : true
					is class Test primitive : false
			
			boolean isArray()
				
				// Java program to demonstrate isArray method
				public class Test
				{
					public static void main(String[] args)
					{
						int a[] = new int[2];			 
						// returns the Class object for array class
						Class c1 = a.getClass();		 
						// returns the Class object for Test class
						Class c2 = Test.class;		 
						// checking for array type
						// isArray method on c1
						boolean b1 = c1.isArray();
						// is Array method on c2
						boolean b2 = c2.isArray();				 
						System.out.println("is "+c1.toString()+" an array : " + b1);
						System.out.println("is "+c2.toString()+" an array : " + b2);
						 
					}
				}
				
				Output:
					is class [I an array : true
					is class Test an array : false
			
			boolean isEnum()
				
				// Java program to demonstrate isEnum() method			 
				enum Color
				{
					RED, GREEN, BLUE;
				}			  
				public class Test
				{
					public static void main(String[] args) 
					{   
						// returns the Class object associated with Color(an enum class)
						Class c1 = Color.class;					 
						// returns the Class object associated with Test class
						Class c2 = Test.class;					 
						// checking for Enum class
						// isEnum method
						boolean b1 = c1.isEnum();
						boolean b2 = c2.isEnum();				 
						System.out.println("is "+c1.toString()+" an Enum class : " + b1);
						System.out.println("is "+c2.toString()+" an Enum class : " + b2);
					}
				}
				
				Output:
					is class Color an Enum class : true
					is class Test an Enum class : false
			
			boolean isAnnotation()
				
				// Java program to demonstrate isAnnotation() method				 
				// declaring an Annotation Type
				@interface A
				{
					 // Annotation element definitions
				}				 
				public class Test
				{
					public static void main(String[] args)
										 throws ClassNotFoundException
					{
						// returns the Class object associated with A  annotation
						Class c1 = A.class;			 
						// returns the Class object associated with Test class
						Class c2 = Test.class;					 
						// checking for annotation type
						// isAnnotation method
						boolean b1 = c1.isAnnotation();
						boolean b2 = c2.isAnnotation();					 
						System.out.println("is "+c1.toString()+" an annotation  : " + b1);
						System.out.println("is "+c2.toString()+" an annotation : " + b2);
						 
					}
				}
				
				Output:
					is interface A an annotation  : true
					is class Test an annotation : false
			
			String getName()
			
				// Java program to demonstrate getName() method
				public class Test
				{
					public static void main(String[] args) 
					{
						// returns the Class object associated with Test class
						Class c = Test.class;					 
						System.out.print("Class Name associated with c : ");			 
						// returns the name of the class
						// getName method
						System.out.println(c.getName());
					}
				}
				
				Output:
					Class Name associated with c : Test
			
			String getSimpleName()
			
				// Java program to demonstrate getSimpleName() method
				public class Test
				{
					public static void main(String[] args) 
							throws ClassNotFoundException 
					{
						// returns the Class object for the class 
						// with the specified name 
						Class c1 = Class.forName("java.lang.String");	 
						System.out.print("Class Name associated with c : ");				 
						// returns the name of the class
						// getName method
						System.out.println(c1.getName());		 
						System.out.print("Simple class Name associated with c : ");			 
						// returns the simple name of the class
						// getSimpleName method
						System.out.println(c1.getSimpleName());
					}
				}
				
				Output:
					Class Name associated with c : java.lang.String
					Simple class Name associated with c : String

	java.net.http--JAVA:
	
		HttpClient--java.net.http:
			- Dùng để gửi các yêu cầu HTTP.
			- Nó nằm trong gói java.net.http và cung cấp các công cụ mạnh mẽ để gửi và nhận các yêu cầu HTTP, hỗ trợ cả các cuộc gọi đồng bộ (synchronous) và bất đồng bộ (asynchronous).
			- HttpClient hỗ trợ cả HTTP/1.1 và HTTP/2. HTTP/2 là mặc định nếu cả client và server hỗ trợ. HTTP/2 cải thiện hiệu suất mạng với các tính năng như multiplexing, header compression, và server push.
			- Đồng bộ (Synchronous): Các phương thức như send() sẽ chờ cho đến khi yêu cầu hoàn tất và trả về kết quả.
			- Bất đồng bộ (Asynchronous): Các phương thức như sendAsync() trả về một CompletableFuture, cho phép thực hiện các thao tác khác trong khi chờ kết quả từ yêu cầu.
			
			Ví dụ:
				
				Tạo và gửi một yêu cầu HTTP GET đồng bộ
				
					import java.net.URI;
					import java.net.http.HttpClient;
					import java.net.http.HttpRequest;
					import java.net.http.HttpResponse;
					import java.time.Duration;
					public class HttpClientExample {
						public static void main(String[] args) throws Exception {
							// Tạo một HttpClient với HTTP/2 và thời gian timeout là 10 giây
							HttpClient client = HttpClient.newBuilder()
									.version(HttpClient.Version.HTTP_2)
									.connectTimeout(Duration.ofSeconds(10))
									.build();
							// Tạo một HttpRequest cho phương thức GET
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/data"))
									.header("Accept", "application/json")
									.GET()
									.build();
							// Gửi yêu cầu và nhận phản hồi đồng bộ
							HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
							// In ra mã trạng thái và nội dung phản hồi
							System.out.println("Status code: " + response.statusCode());
							System.out.println("Response body: " + response.body());
						}
					}
				
				Tạo và gửi một yêu cầu HTTP POST bất đồng bộ
				
					import java.net.URI;
					import java.net.http.HttpClient;
					import java.net.http.HttpRequest;
					import java.net.http.HttpResponse;
					import java.net.http.HttpRequest.BodyPublishers;
					import java.util.concurrent.CompletableFuture;
					public class HttpClientAsyncExample {
						public static void main(String[] args) {
							HttpClient client = HttpClient.newHttpClient();
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/post"))
									.header("Content-Type", "application/json")
									.POST(BodyPublishers.ofString("{\"name\":\"John\"}"))
									.build();
							// Gửi yêu cầu bất đồng bộ và xử lý phản hồi khi nó đến
							CompletableFuture<HttpResponse<String>> response = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());
							// Xử lý phản hồi khi hoàn tất
							response.thenApply(HttpResponse::body)
									.thenAccept(System.out::println)
									.join();  // Đợi cho đến khi quá trình hoàn tất
						}
					}
				
		HttpRequest--java.net.http:

			- HttpRequest được sử dụng để xây dựng và cấu hình các yêu cầu HTTP gửi đến máy chủ. Đây là lớp đại diện cho một yêu cầu HTTP, cho phép bạn thiết lập URI, phương thức HTTP,
			headers, và body của yêu cầu.
			- Các Thành Phần Chính của HttpRequest:
			
				URI:
					Đây là địa chỉ của tài nguyên mà bạn muốn yêu cầu. Ví dụ: https://api.example.com/data.
				
				Phương Thức HTTP:
					HttpRequest hỗ trợ các phương thức HTTP phổ biến như GET, POST, PUT, DELETE, PATCH, v.v. Bạn có thể chỉ định phương thức này khi xây dựng đối tượng HttpRequest.
				
				Headers:
					Các headers HTTP cung cấp thêm thông tin về yêu cầu, như Content-Type, Authorization, Accept, v.v.
				
				Body:
					Body của yêu cầu chứa dữ liệu được gửi đi (chỉ áp dụng cho các phương thức như POST, PUT, PATCH). Ví dụ: dữ liệu JSON hoặc form data.

			Ví dụ:
			
				Tạo HttpRequest:
				
					import java.net.URI;
					import java.net.http.HttpRequest;
					public class HttpRequestExample {
						public static void main(String[] args) {
							// Tạo một HttpRequest cho phương thức GET
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/data"))
									.header("Accept", "application/json")
									.GET() // Phương thức GET
									.build();
						}
					}
				
				
					
				Sử Dụng HttpRequest với Thay Đổi Headers và Body

					import java.net.URI;
					import java.net.http.HttpRequest;
					import java.net.http.HttpRequest.BodyPublishers;
					public class HttpRequestModifyExample {
						public static void main(String[] args) {
							// Tạo một HttpRequest với các headers và body
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/update"))
									.header("Content-Type", "application/json")
									.header("Authorization", "Bearer your-token")
									.PUT(BodyPublishers.ofString("{\"field\":\"value\"}"))
									.build();
						}
					}
					
				Ví dụ Tổng Hợp:
				
					import java.net.URI;
					import java.net.http.HttpClient;
					import java.net.http.HttpRequest;
					import java.net.http.HttpResponse;
					import java.net.http.HttpRequest.BodyPublishers;
					public class HttpClientExample {
						public static void main(String[] args) throws Exception {
							HttpClient client = HttpClient.newHttpClient();
							// Yêu cầu GET
							HttpRequest getRequest = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/data"))
									.header("Accept", "application/json")
									.GET()
									.build();
							HttpResponse<String> getResponse = client.send(getRequest, HttpResponse.BodyHandlers.ofString());
							System.out.println("GET Status Code: " + getResponse.statusCode());
							System.out.println("GET Response Body: " + getResponse.body());
							// Yêu cầu POST
							HttpRequest postRequest = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/submit"))
									.header("Content-Type", "application/json")
									.POST(BodyPublishers.ofString("{\"name\":\"John Doe\", \"age\":30}"))
									.build();
							HttpResponse<String> postResponse = client.send(postRequest, HttpResponse.BodyHandlers.ofString());
							System.out.println("POST Status Code: " + postResponse.statusCode());
							System.out.println("POST Response Body: " + postResponse.body());
						}
					}

		HttpResponse--java.net.http:
		
			- Nó đại diện cho phản hồi từ máy chủ sau khi gửi một yêu cầu HTTP. HttpResponse chứa thông tin về phản hồi từ máy chủ, bao gồm mã trạng thái HTTP, headers, và body.
			- Các Thành Phần Chính của HttpResponse:
			
				Mã Trạng Thái (Status Code):
					Đây là mã số HTTP cho biết kết quả của yêu cầu. Ví dụ: 200 cho thành công, 404 cho không tìm thấy, 500 cho lỗi máy chủ.
				Headers:
					Headers HTTP cung cấp thông tin bổ sung về phản hồi. Ví dụ: Content-Type, Content-Length, Date, Set-Cookie.
				Body:
					Body của phản hồi chứa dữ liệu trả về từ máy chủ. Ví dụ: nội dung trang web, dữ liệu JSON, XML, hoặc bất kỳ loại dữ liệu nào khác.
					
			- Các Phương Thức Chính của HttpResponse:
			
				statusCode():
					Trả về mã trạng thái HTTP của phản hồi.
				headers():
					Trả về đối tượng HttpHeaders chứa tất cả các headers của phản hồi.
				body():
					Trả về nội dung body của phản hồi dưới dạng chuỗi hoặc kiểu dữ liệu đã được chỉ định khi gửi yêu cầu.
					
			- Các Lựa Chọn Đối Tượng HttpResponse:
			
				BodyHandlers.ofString(): Xử lý body phản hồi dưới dạng chuỗi (String).
				BodyHandlers.ofByteArray(): Xử lý body phản hồi dưới dạng mảng byte (byte array).
				BodyHandlers.ofInputStream(): Xử lý body phản hồi dưới dạng InputStream.
				BodyHandlers.ofFile(Path path): Xử lý body phản hồi và lưu trực tiếp vào một tệp tin.
					
			Ví dụ:
			
				Sử dụng HttpResponse với yêu cầu GET:
				
					import java.net.URI;
					import java.net.http.HttpClient;
					import java.net.http.HttpRequest;
					import java.net.http.HttpResponse;
					public class HttpResponseExample {
						public static void main(String[] args) throws Exception {
							HttpClient client = HttpClient.newHttpClient();
							// Tạo một HttpRequest với phương thức GET
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/data"))
									.header("Accept", "application/json")
									.GET()
									.build();
							// Gửi yêu cầu và nhận phản hồi
							HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
							// In ra mã trạng thái
							System.out.println("Status code: " + response.statusCode());
							// In ra headers
							response.headers().map().forEach((k, v) -> System.out.println(k + ":" + v));
							// In ra nội dung body
							System.out.println("Response body: " + response.body());
						}
					}
					
				Sử dụng HttpResponse với yêu cầu POST:
				
					import java.net.URI;
					import java.net.http.HttpClient;
					import java.net.http.HttpRequest;
					import java.net.http.HttpRequest.BodyPublishers;
					import java.net.http.HttpResponse;
					public class HttpResponsePostExample {
						public static void main(String[] args) throws Exception {
							HttpClient client = HttpClient.newHttpClient();
							// Tạo một HttpRequest với phương thức POST
							HttpRequest request = HttpRequest.newBuilder()
									.uri(URI.create("https://api.example.com/submit"))
									.header("Content-Type", "application/json")
									.POST(BodyPublishers.ofString("{\"name\":\"John Doe\", \"age\":30}"))
									.build();
							// Gửi yêu cầu và nhận phản hồi
							HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
							// In ra mã trạng thái
							System.out.println("Status code: " + response.statusCode());
							// In ra headers
							response.headers().map().forEach((k, v) -> System.out.println(k + ":" + v));
							// In ra nội dung body
							System.out.println("Response body: " + response.body());
						}
					}
					
	CharSequence--java:
	
		- CharSequence là một interface trong Java được định nghĩa trong gói java.lang. Nó cung cấp một cách để đại diện cho một chuỗi các ký tự mà có thể được đọc
		tuần tự. Các lớp chính triển khai CharSequence bao gồm String, StringBuilder, StringBuffer, và CharBuffer.
		- Khả Năng Tương Thích: Sử dụng CharSequence giúp mã nguồn của bạn linh hoạt hơn vì bạn có thể làm việc với nhiều loại chuỗi khác nhau mà không cần quan tâm đến loại cụ thể.
		- Tăng Tính Đa Dạng: Nó cho phép các phương thức hoặc API hoạt động với nhiều loại đối tượng khác nhau triển khai CharSequence, không chỉ String.
		- Các Đặc Điểm Chính của CharSequence:
			
			Khả Năng Đọc Ký Tự: CharSequence cung cấp các phương thức để truy cập các ký tự trong chuỗi theo chỉ số, giống như các phương thức của String.
			
			Các Phương Thức Chính:
			
				char charAt(int index): Trả về ký tự tại chỉ số được chỉ định.
				int length(): Trả về độ dài của chuỗi.
				CharSequence subSequence(int start, int end): Trả về một phần con của chuỗi từ chỉ số bắt đầu đến chỉ số kết thúc.
				String toString(): Chuyển đổi CharSequence thành một String.
				
		- Các Lớp Triển Khai CharSequence:
			
			String:

				Đại diện cho một chuỗi ký tự không thay đổi.
				Cung cấp nhiều phương thức hữu ích để xử lý chuỗi.
			
			StringBuilder:

				Đại diện cho một chuỗi ký tự có thể thay đổi.
				Cung cấp khả năng tạo và thay đổi chuỗi một cách hiệu quả.
			
			StringBuffer:

				Tương tự như StringBuilder, nhưng là đồng bộ hóa, nên nó an toàn với đa luồng.
				Thường được sử dụng khi bạn cần làm việc với chuỗi trong môi trường đa luồng.
			
			CharBuffer:

				Cung cấp khả năng lưu trữ và xử lý chuỗi ký tự trong các buffer.
				
		Ví dụ:
		
			public class CharSequenceExample {
				public static void main(String[] args) {
					CharSequence cs = "Hello, World!";				
					// Sử dụng phương thức của CharSequence
					System.out.println(cs.charAt(0)); // Output: H
					System.out.println(cs.length());  // Output: 13				
					// Chuyển đổi CharSequence thành String
					String str = cs.toString();
					System.out.println(str); // Output: Hello, World!
				}
			}

	MessageDigest--Java:
	
		- MessageDigest là một lớp trong Java thuộc gói java.security, được sử dụng để thực hiện các thuật toán băm (hashing). Các thuật toán băm là các hàm toán học có thể chuyển
		đổi dữ liệu đầu vào (thường là chuỗi hoặc tệp) thành một giá trị băm có kích thước cố định. Điều này thường được sử dụng trong các tình huống bảo mật, chẳng hạn như lưu trữ
		mật khẩu một cách an toàn hoặc kiểm tra tính toàn vẹn của dữ liệu.
		- Các Thuật Toán Băm Hỗ Trợ:
			MD5 (Message Digest Algorithm 5)
			SHA-1 (Secure Hash Algorithm 1)
			SHA-256 (Secure Hash Algorithm 256-bit)
			SHA-512 (Secure Hash Algorithm 512-bit)
		- Các Phương Thức Chính
			
			static MessageDigest getInstance(String algorithm):
				
				Tạo một đối tượng MessageDigest cho thuật toán băm được chỉ định. Ví dụ, "SHA-256" hoặc "MD5".
				
				MessageDigest md = MessageDigest.getInstance("SHA-256");
			
			void update(byte input):

				Cập nhật đối tượng MessageDigest với một byte dữ liệu. Bạn có thể gọi phương thức này nhiều lần với các phần khác nhau của dữ liệu.
	
				md.update(data.getBytes());
			
			void update(byte[] input, int offset, int len):

				Cập nhật đối tượng MessageDigest với một mảng byte và chỉ định phần của mảng cần cập nhật.
			
			byte[] digest():

				Tính toán giá trị băm và trả về kết quả dưới dạng mảng byte. Sau khi gọi phương thức này, đối tượng MessageDigest không còn giữ lại trạng thái của dữ liệu trước đó.
		
				byte[] hashBytes = md.digest();
			
			void reset():

				Đặt lại đối tượng MessageDigest về trạng thái ban đầu, để nó có thể được sử dụng lại.
				
		Ví dụ:
		
			import java.security.MessageDigest;
			import java.security.NoSuchAlgorithmException;
			import java.util.Arrays;
			public class MessageDigestExample {
				public static void main(String[] args) {
					try {
						// Tạo đối tượng MessageDigest cho thuật toán SHA-256
						MessageDigest digest = MessageDigest.getInstance("SHA-256");				
						// Dữ liệu đầu vào
						String data = "Hello, World!";				
						// Cập nhật dữ liệu vào đối tượng MessageDigest
						digest.update(data.getBytes());				
						// Tính toán giá trị băm
						byte[] hashBytes = digest.digest();				
						// Chuyển đổi giá trị băm thành chuỗi hex để dễ đọc
						StringBuilder hexString = new StringBuilder();
						for (byte b : hashBytes) {
							String hex = Integer.toHexString(0xff & b);
							if (hex.length() == 1) {
								hexString.append('0');
							}
							hexString.append(hex);
						}				
						// In ra giá trị băm
						System.out.println("Hash: " + hexString.toString());				
					} catch (NoSuchAlgorithmException e) {
						e.printStackTrace();
					}
				}
			}

	MimeMessage--Java:
	
		- MimeMessage trong Spring Framework là một lớp thuộc gói javax.mail được sử dụng để tạo và quản lý các email theo định dạng MIME (Multipurpose Internet Mail Extensions). MIME là một chuẩn
		cho việc định dạng các loại dữ liệu khác nhau trong email, chẳng hạn như văn bản, hình ảnh, tệp đính kèm, và nhiều hơn nữa.
		- Trong Spring, bạn có thể sử dụng MimeMessage kết hợp với các lớp khác để gửi email. Dưới đây là một ví dụ cơ bản về cách sử dụng MimeMessage trong một ứng dụng Spring để gửi email.
		- Cấu hình Spring để gửi email:
		
			Thêm phụ thuộc vào pom.xml (nếu bạn đang sử dụng Maven):
			
				<dependency>
					<groupId>org.springframework</groupId>
					<artifactId>spring-context</artifactId>
					<version>5.3.20</version>
				</dependency>
				<dependency>
					<groupId>org.springframework</groupId>
					<artifactId>spring-context-support</artifactId>
					<version>5.3.20</version>
				</dependency>
				<dependency>
					<groupId>com.sun.mail</groupId>
					<artifactId>javax.mail</artifactId>
					<version>1.6.2</version>
				</dependency>
				
			Cấu hình Bean JavaMailSender trong file cấu hình Spring:
			
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.mail.javamail.JavaMailSender;
				import org.springframework.mail.javamail.JavaMailSenderImpl;
				@Configuration
				public class MailConfig {
					@Bean
					public JavaMailSender javaMailSender() {
						JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
						mailSender.setHost("smtp.example.com");
						mailSender.setPort(587);
						mailSender.setUsername("your-email@example.com");
						mailSender.setPassword("your-password");
						Properties props = mailSender.getJavaMailProperties();
						props.put("mail.transport.protocol", "smtp");
						props.put("mail.smtp.auth", "true");
						props.put("mail.smtp.starttls.enable", "true");
						props.put("mail.debug", "true");
						return mailSender;
					}
				}
				
			Sử dụng MimeMessage để tạo và gửi email:
			
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.mail.javamail.JavaMailSender;
				import org.springframework.mail.javamail.MimeMessageHelper;
				import org.springframework.stereotype.Service;
				import javax.mail.MessagingException;
				import javax.mail.internet.MimeMessage;
				@Service
				public class EmailService {
					@Autowired
					private JavaMailSender javaMailSender;
					public void sendEmail(String to, String subject, String text) {
						MimeMessage message = javaMailSender.createMimeMessage();
						try {
							MimeMessageHelper helper = new MimeMessageHelper(message, true);
							helper.setFrom("your-email@example.com");
							helper.setTo(to);
							helper.setSubject(subject);
							helper.setText(text, true); // true indicates HTML
							// Optional: Add attachments or inline resources here if needed
							// helper.addAttachment("filename.txt", new File("path/to/file"));
							javaMailSender.send(message);
						} catch (MessagingException e) {
							e.printStackTrace(); // Handle the exception properly in real-world scenarios
						}
					}
				}
				
			Ví dụ:
			
				    public static boolean sendEmail(Session session, String toEmail, String subject, String body){
						try
						{
							MimeMessage msg = new MimeMessage(session);
							//set message headers
							msg.addHeader("Content-type", "text/HTML; charset=UTF-8");
							msg.addHeader("format", "flowed");
							msg.addHeader("Content-Transfer-Encoding", "8bit");
							msg.setFrom(new InternetAddress(Utils.MAIL_SMTP_EMAIL_ID, Utils.MAIL_SMTP_EMAIL_ID_ALIAS));
							//msg.setReplyTo(InternetAddress.parse(ConstantUtil.MAIL_SMTP_EMAIL_ID, false));
							msg.setSubject(subject, "UTF-8");
							msg.setContent(body,"text/html; charset=utf-8");
							msg.setSentDate(new Date());
							msg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(toEmail, false));
							System.out.println("Message is ready");
							Transport.send(msg);
							System.out.println("EMail Sent Successfully!!");
							return true;
						}
						catch (Exception e) {
							e.printStackTrace();
						return false;
						}
					}

	Guide to Spring Email--Java:
	
		Maven Dependencies--Guide to Spring Email:
			
			First, we need to add the dependencies to our pom.xml.
			
			Spring
				Here is what we’ll add for use in the plain vanilla Spring framework:
					
					<dependency>
						<groupId>org.springframework</groupId>
						<artifactId>spring-context-support</artifactId>
						<version>6.1.5</version>
					</dependency>
			
			Spring Boot
				
				And for Spring Boot:
					
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-mail</artifactId>
						<version>3.1.5</version>
					</dependency>
					
		Mail Server Properties--Guide to Spring Email:
			
			The interfaces and classes for Java mail support in the Spring framework are organized as follows:
				
				MailSender interface: the top-level interface that provides basic functionality for sending simple emails
				
				JavaMailSender interface: the subinterface of the above MailSender. It supports MIME messages and is mostly used in conjunction with the MimeMessageHelper class for the
				creation of a MimeMessage. It’s recommended to use the MimeMessagePreparator mechanism with this interface.
				
				JavaMailSenderImpl class provides an implementation of the JavaMailSender interface. It supports the MimeMessage and SimpleMailMessage.
				
				SimpleMailMessage class: used to create a simple mail message including the from, to, cc, subject and text fields
				
				MimeMessagePreparator interface provides a callback interface for the preparation of MIME messages.
				
				MimeMessageHelper class: helper class for the creation of MIME messages. It offers support for images, typical mail attachments and text content in an HTML layout.
			
			Spring Mail Server Properties
				
				Mail properties that are needed to specify, for example, the SMTP server may be defined using the JavaMailSenderImpl.
				
				For Gmail, this can be configured as shown below:
					
					@Bean
					public JavaMailSender getJavaMailSender() {
						JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
						mailSender.setHost("smtp.gmail.com");
						mailSender.setPort(587);
						
						mailSender.setUsername("my.gmail@gmail.com");
						mailSender.setPassword("password");
						
						Properties props = mailSender.getJavaMailProperties();
						props.put("mail.transport.protocol", "smtp");
						props.put("mail.smtp.auth", "true");
						props.put("mail.smtp.starttls.enable", "true");
						props.put("mail.debug", "true");
						
						return mailSender;
					}
			
			Spring Boot Mail Server Properties
				
				Once the dependency is in place, the next step is to specify the mail server properties in the application.properties file using the spring.mail.* namespace.
				
				We can specify the properties for the Gmail SMTP server this way:
					
					spring.mail.host=smtp.gmail.com
					spring.mail.port=587
					spring.mail.username=<login user to smtp server>
					spring.mail.password=<login password to smtp server>
					spring.mail.properties.mail.smtp.auth=true
					spring.mail.properties.mail.smtp.starttls.enable=true
				
				Some SMTP servers require a TLS connection, so we use the property spring.mail.properties.mail.smtp.starttls.enable to enable a TLS-protected connection.
				
				Gmail SMTP Properties
					
					We can send an email via Gmail SMTP server. Have a look at the documentation to see the Gmail outgoing mail SMTP server properties.
					
					Our application.properties file is already configured to use Gmail SMTP (see the previous section).
					
					Note that the password for our account should not be an ordinary password but an application password generated for our Google account. Follow this link to see the details
					and to generate your Google App Password.
				
				SES SMTP Properties
					
					To send emails using Amazon SES, we set our application.properties:
						
						spring.mail.host=email-smtp.us-west-2.amazonaws.com
						spring.mail.username=username
						spring.mail.password=password
						spring.mail.properties.mail.transport.protocol=smtp
						spring.mail.properties.mail.smtp.port=25
						spring.mail.properties.mail.smtp.auth=true
						spring.mail.properties.mail.smtp.starttls.enable=true
						spring.mail.properties.mail.smtp.starttls.required=true
					
					Please be aware that Amazon requires us to verify our credentials before using them. Follow the link to verify your username and password.
		
		Sending Email--Guide to Spring Email:
			
			Once dependency management and configuration are in place, we can use the aforementioned JavaMailSender to send an email.
			
			Since both the plain vanilla Spring framework as well as the Boot version of it handle the composing and sending of emails in a similar way, we won’t have
			to distinguish between the two in the subsections below.
			
			Sending Simple Emails
				
				Let’s first compose and send a simple email message without any attachments:
					
					@Component
					public class EmailServiceImpl implements EmailService {
						@Autowired
						private JavaMailSender emailSender;
						public void sendSimpleMessage(
						  String to, String subject, String text) {
							...
							SimpleMailMessage message = new SimpleMailMessage(); 
							message.setFrom("noreply@baeldung.com");
							message.setTo(to); 
							message.setSubject(subject); 
							message.setText(text);
							emailSender.send(message);
							...
						}
					}
					
				Note that even though it’s not mandatory to provide the from address, many SMTP servers would reject such messages. That’s why we use the
				noreply@baeldung.com email address in our EmailService implementation.
			
			Sending Emails With Attachments
				
				Sometimes Spring’s simple messaging is not enough for our use cases.
				
				For example, we want to send an order confirmation email with an invoice attached. In this case, we should use a MIME multipart message from JavaMail
				library instead of SimpleMailMessage. Spring supports JavaMail messaging with the org.springframework.mail.javamail.MimeMessageHelper class.
				
				First of all, we’ll add a method to the EmailServiceImpl to send emails with attachments:
					
					@Override
					public void sendMessageWithAttachment(
					  String to, String subject, String text, String pathToAttachment) {
						// ...
						
						MimeMessage message = emailSender.createMimeMessage();
						 
						MimeMessageHelper helper = new MimeMessageHelper(message, true);
						
						helper.setFrom("noreply@baeldung.com");
						helper.setTo(to);
						helper.setSubject(subject);
						helper.setText(text);
							
						FileSystemResource file 
						  = new FileSystemResource(new File(pathToAttachment));
						helper.addAttachment("Invoice", file);

						emailSender.send(message);
						// ...
					}
			
			Simple Email Template
				
				SimpleMailMessage class works well with String formatting.
				
				We can create a template for emails by defining a template bean in our configuration:
					
					@Bean
					public SimpleMailMessage templateSimpleMessage() {
						SimpleMailMessage message = new SimpleMailMessage();
						message.setText(
						  "This is the test email template for your email:\n%s\n");
						return message;
					}
				
				Now we can use this bean as a template for email and only need to provide the necessary parameters to the template:
					
					@Autowired
					public SimpleMailMessage template;
					...
					String text = String.format(template.getText(), templateArgs);  
					sendSimpleMessage(to, subject, text);
		
		Handling Send Errors--Guide to Spring Email:
			
			JavaMail provides SendFailedException to handle situations when a message cannot be sent. But it is possible that we won’t get this exception while sending an email to the incorrect address. The reason is the following:
				
				The protocol specs for SMTP in RFC 821 specifies the 550 return code that the SMTP server should return when attempting to send an email to the incorrect address. But most of the public SMTP servers don’t do this. Instead, they send a “delivery failed” email or give no feedback at all.
			
			For example, Gmail SMTP server sends a “delivery failed” message. And we get no exceptions in our program.
			
			So, we have a few options to handle this case:
				
				Catch the SendFailedException, which can never be thrown.
				
				Check our sender mailbox for the “delivery failed” message for some period of time. This is not straightforward, and the time period is not determined.
				
				If our mail server gives no feedback at all, we can do nothing.
				
	yield Keyword in Java--Java:
	
		- We may often use a switch statement to convert from one value to another. In earlier versions of Java, this required us to either embed the switch in a
		separate function and use the return statement from each case or it required us to assign a temporary variable from each case for use later in the function.
		
		- The yield Keyword
			
			The yield keyword lets us exit a switch expression by returning a value that becomes the value of the switch expression.
			
			This means we can assign the value of a switch expression to a variable.
			
			Lastly, by using yield in a switch expression, we get an implicit check that we’re covering our cases, which makes our code more robust.
			
			yield with Arrow Operator
				
				To start, let’s say we have the following enum and switch statement:
					
					public enum Number {
						ONE, TWO, THREE, FOUR;
					}

					String message;
					switch (number) {
						case ONE:
							message = "Got a 1";
							break;
						case TWO:
							message = "Got a 2";
							break;
						default:
							message = "More than 2";
					}
					
				Let’s convert this to a switch expression and use the yield keyword along with the arrow operator:
					
					String message = switch (number) {
						case ONE -> {
							yield "Got a 1";
						}
						case TWO -> {
							yield "Got a 2";
						}
						default -> {
							yield "More than 2";
						}
					};
					
			yield with Colon Delimiter
				
				We can also create a switch expression using yield with the colon delimiter:
					
					String message = switch (number) {
						case ONE:
							yield "Got a 1";
						case TWO:
							yield "Got a 2";
						default:
							yield "More than 2";
					};				
					This code behaves the same as in the previous section. But the arrow operator is clearer and also less prone to forgetting yield (or break) statements.
				
				We should note that we can’t mix colon and arrow delimiters within the same switch expression.
		
		- Exhaustiveness
			
			Another nice feature of using the switch expression and yield is if we are missing case coverage, we’ll see a compile error. Let’s remove our default case from the arrow operator switch expression to check:
				
				String message = switch (number) {
					case ONE -> {
						yield "Got a 1";
					}
					case TWO -> {
						yield "Got a 2";
					}
				};			
				The above code gives us an error on number: “the switch expression does not cover all possible input values“.
			
			We could add the default case back in, or we could specifically cover the rest of the possible values of number:
				
				String message = switch (number) {
					case ONE -> {
						yield "Got a 1";
					}
					case TWO -> {
						yield "Got a 2";
					}
					case THREE, FOUR -> {
						yield "More than 2";
					}
				};				
				The switch expression forced our case coverage to be exhaustive.		

JAVASCRIPT---:	

	Array--JAVASCRIPT:			let numbers = [1, 2, 3, 4, 2, 5, 2];
		- toString:		
		- join:					
								It behaves just like toString(), but in addition you can specify the separator
								
								let joinedString = numbers.join(); // Chuyển mảng thành chuỗi, các phần tử được nối bởi dấu phẩy (mặc định) 1,2,3,4,5
		- forEach:				numbers.forEach((number, index) => {
									console.log(`Index ${index}: ${number}`); // Index 0: 1, Index 1: 2, Index 2: 3, Index 3: 4, Index 4: 2, Index 5: 5, Index 5: 2
								}); 								                                             
		- every:                let allGreaterThanZero = numbers.every(number => number > 0); // true                                                 
		- some:                 let atLeastOneEven = numbers.some(number => number % 2 === 0); // true. Kiểm tra xem có ít nhất một phần tử trong mảng thỏa mãn một điều kiện                                  
		- includes:          	let includesThree = numbers.includes(3); // true                                                      
		- length:				
								The length property provides an easy way to append a new element to an array
								
								let arrayLength = numbers.length; // 7
								
								const fruits = ["Banana", "Orange", "Apple", "Mango"];
								fruits[fruits.length] = "Kiwi"; // Banana, Orange, Apple, Mango, Kiwi
		- indexOf:				let indexOfTwo = numbers.indexOf(2); // 1
		lastIndexOf:			let lastIndexOfTwo = numbers.lastIndexOf(2); // 6
		findIndex:				let indexOfEven = numbers.findIndex(number => number % 2 === 0); // 1
		- at:					let elementAtTwo = numbers.at(2); // 3
		- find:					let firstEven = numbers.find(number => number % 2 === 0); // Trả về  giá trị của phần tử đầu tiên thỏa mãn một điều kiện, 2
		findIndex:				let firstIndexOfEven = numbers.findIndex(number => number % 2 === 0); // Trả về index của phần tử đầu tiên thỏa mãn một điều kiện, 1
		- reduce:				let sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0); // 19
		Dont mutate: 
			- filter:			let evenNumbers = numbers.filter(number => number % 2 === 0); // [2, 4, 2, 2]
			- map:				
								let tripledNumbers = numbers.map(number => number * 3); // [3, 6, 9, 12, 6, 15, 6]
								const numbers = [1, 2, 3, 4, 5];
								const doubledNumbers = numbers.map((number) => {
									return number * 2;
								});
								console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]
			- concat:			
								let moreNumbers = [6, 7, 8];
								let combinedNumbers = numbers.concat(moreNumbers); // [1, 2, 3, 4, 2, 5, 2, 6, 7, 8]
			- slice:
								slice() dựa vào index của mảng để thao tác. splice() dựa vào index và số phần tử để thao tác
			
								let slicedArray = numbers.slice(2, 5); // Tạo một mảng con từ index 2 đến index 4 (không bao gồm index 5) [3, 4, 2]
								let slicedArray = numbers.slice(2); // [3, 4, 2, 5, 2]
								let copiedArray = numbers.slice(); // [1, 2, 3, 4, 2, 5, 2]
								let slicedArray = numbers.slice(-3, -1); // Lấy một phần của mảng từ index -3 đến index -1 (đếm từ cuối mảng). [5, 2]
		Mutate:
			- splice:			
								The splice() method returns an array with the deleted items
								Khi đối số thứ 2 là 0, phương thức splice() sẽ không xóa bất kỳ phần tử nào từ mảng, nhưng nó vẫn có thể chèn các phần tử mới vào mảng tại vị trí chỉ định.
			
								numbers.splice(2, 3, 6, 7); // Loại bỏ 3 phần tử từ index 2, do đó loại bỏ các số 3, 4, và 2.
															// Thêm vào các phần tử mới 6 và 7 tại vị trí đã loại bỏ. [1, 2, 6, 7, 5, 2]
								numbers.splice(2, 0, 6); // Thêm phần tử 6 vào index 2, [1, 2, 6, 3, 4, 2, 5, 2]
								numbers.splice(2, 0, 6, 3); // Thêm phần tử 6, 3 vào index 2, [1, 2, 6, 3, 3, 4, 2, 5, 2]
								numbers.splice(1, 3); // Loại bỏ 3 phần tử từ index 1, do đó loại bỏ các số 2, 3, và 4. [1, 2, 5, 2]
								numbers.splice(2); // Loại bỏ tất cả phần tử từ index 2 đến cuối mảng, nghĩa là loại bỏ từ index có giá trị 3 trở về sau. [3, 4, 2, 5, 2]
								numbers.splice(1, 2, 10, 11); // Loại bỏ 2 phần tử từ index 1 và thêm 2 phần tử mới. [1, 10, 11, 4, 5, 2]
								
								const fruits = ["Banana", "Orange", "Apple", "Mango"];
								let removed = fruits.splice(2, 2, "Lemon", "Kiwi"); 
								document.getElementById("demo2").innerHTML = "New Array:<br>" + fruits; // Banana, Orange, Lemon, Kiwi
								document.getElementById("demo3").innerHTML = "Removed Items:<br> " + removed; // Apple, Mango
			- pop:				
								The pop() method returns the value that was "popped out"
			
								let lastElement = numbers.pop();
								console.log("After pop:", numbers, "Removed Element:", lastElement); // After pop: [1, 2, 3, 4, 2, 5] Removed Element: 2
			- shift:			
								The shift() method returns the value that was "shifted out"
			
								let firstElement = numbers.shift();
								console.log("After shift:", numbers, "Removed Element:", firstElement); // After shift: [2, 3, 4, 2, 5, 2] Removed Element: 1
			- push:				
								The push() method returns the new array length
								
								numbers.push(5, 3); // [1, 2, 3, 4, 2, 5, 2, 5, 3]
			- unshift: 			
								The unshift() method returns the new array length
								
								numbers.unshift(3, 1); // Original Array: [1, 2, 3, 4, 2, 5, 2]
													   // After unshift: [3, 1, 1, 2, 3, 4, 2, 5, 2]
			- reverse:			numbers.reverse(); // [2, 5, 2, 4, 3, 2, 1]
			- sort:				numbers.sort(); // [1, 2, 2, 3, 4, 5, 5]
			fill:				numbers.fill(0); // After fill: [0, 0, 0, 0, 0, 0, 0]
			copyWithin:			numbers.copyWithin(0, 3, 5); // copyWithin sao chép một phần của mảng và ghi đè lên chính nó.
															 // Trong ví dụ này, nó sao chép phần từ index 3 đến index 5 (không bao gồm index 5) ghi đè lên phần từ index 0.
															 // [4, 2, 5, 4, 2, 5, 2]
			flat:				let nestedArray = [numbers, [6, 7], [8, [9, 10]]];
								console.log("Original Nested Array:", nestedArray); // Original Nested Array: [[1, 2, 3, 4, 2, 5, 2], [6, 7], [8, [9, 10]]]
								let flatArray = nestedArray.flat(); // Flattened Array: [1, 2, 3, 4, 2, 5, 2, 6, 7, 8, [9, 10]]
								console.log("Flattened Array:", flatArray); // flat được sử dụng để trải phẳng mảng nestedArray, nơi mảng numbers và các mảng lồng nhau
																			// khác được chuyển thành một mảng một chiều.
																			// Điều này giúp giảm bậc của mảng và tạo ra một mảng chứa tất cả các phần tử từ mảng lồng nhau.
			flatMap:			let mappedArray = numbers.flatMap(x => [x, x * 2]); // flatMap(x => [x, x * 2]) ánh xạ mỗi phần tử x của mảng với một mảng mới chứa x và x * 2.
																					// [1, 2, 2, 4, 3, 6, 4, 8, 2, 4, 5, 10, 2, 4]
			- Array.isArray:	let isArray = Array.isArray(numbers); // true
			Array.from:			let newArray = Array.from(numbers); // Array.from(numbers) tạo ra một bản sao mới của mảng numbers.
																	// Kết quả là một mảng mới có cùng các phần tử như mảng gốc. [1, 2, 3, 4, 2, 5, 2]
			Array.of:			let newArray = Array.of(...numbers); // Array.of(...numbers) sử dụng toán tử spread (...) để truyền các giá trị từ mảng numbers vào phương thức Array.of.
																	 // Kết quả là một mảng mới có cùng các phần tử như mảng gốc.[1, 2, 3, 4, 2, 5, 2]
		
	String--JAVASCRIPT:		String originalString  = "apple,orange,banana";
		- length:			
							const str = 'Hello, world!';
							const length = str.length; // 13
		- concat:			
							let additionalFruits = "grape,kiwi";
							let concatenatedString = originalString.concat(",", additionalFruits); // concat được sử dụng để nối chuỗi originalString với chuỗi , và chuỗi additionalFruits
																								   // apple,orange,banana,grape,kiwi
		- slice:			
							let slicedString = originalString.slice(6, 11); // slice(6, 11) cắt một phần của chuỗi originalString bắt đầu từ vị trí
																			// index 6 và kết thúc tại index 11 (không bao gồm)
																			// orange
		- split:			
							let originalString = "apple,orange,banana";
							let splitArray = originalString.split(","); // Phân tách chuỗi dựa trên dấu phẩy, [ 'apple', 'orange', 'banana' ]
		- includes:			
							const str = 'Hello, world!';
							const includesHello = str.includes('Hello'); // Kết quả: true 
							const includesWorld = str.includes('World'); // Kết quả: true
							const includesGoodbye = str.includes('Goodbye'); // Kết quả: false
		- indexOf:			
							let indexOfOrange = originalString.indexOf("orange"); // indexOf("orange") trả về vị trí đầu tiên xuất hiện của chuỗi con "orange" trong chuỗi originalString. Chú ý đây là chuỗi
																				  // 6
		lastIndexOf:		let lastIndexOfOrange = originalString.lastIndexOf("orange"); // lastIndexOf("orange") trả về vị trí cuối cùng xuất hiện của chuỗi con "orange"
																						  // trong chuỗi originalString
																						  // 12
		- toLowerCase:		let lowercaseString = originalString.toLowerCase(); // apple,orange,banana
		- toUpperCase:		let uppercaseString = originalString.toUpperCase(); // APPLE,ORANGE,BANANA
		- trim:				let originalString = "   apple,orange,banana   ";
							let trimmedString = originalString.trim(); // Loại bỏ khoảng trắng ở đầu và cuối chuỗi, và trả về một chuỗi mới. apple,orange,banana
		- trimStart:		
							let trimmedStartString = originalString.trimStart(); // trimStart được áp dụng cho chuỗi originalString
																				 // loại bỏ khoảng trắng ở đầu chuỗi, và trả về một chuỗi mới
																				 // apple,orange,banana
		- trimEnd:			let trimmedEndString = originalString.trimEnd(); // apple,orange,banana
		- charAt:			let character = originalString.charAt(12); // b
		- valueOf:			
							let value = originalString.valueOf(); // valueOf không thay đổi giá trị của chuỗi và chỉ trả về chính chuỗi đó.
																  // valueOf thường được sử dụng hữu ích trên các đối tượng khác
																  // như số hoặc Date, để trả về giá trị nguyên thủy của chúng.
																  // apple,orange,banana
		- substring:		
							let substring = originalString.substring(6, 12); // substring(6, 12) trích xuất phần của chuỗi originalString từ vị trí
																			 // index 6 đến vị trí index 12 (không bao gồm)
																			 // orange
		repeat:				let repeatedString = originalString.repeat(3); // repeat(3) tạo ra một chuỗi mới bằng cách lặp lại chuỗi originalString ba lần
																		   // apple,orange,bananaapple,orange,bananaapple,orange,banana

		- replace:			let replacedString = originalString.replace("orange", "grape"); // apple,grape,banana
		- search:			
							let position = originalString.search("orange"); // search chỉ trả về vị trí của lần xuất hiện đầu tiên của chuỗi con. Nếu không tìm thấy, nó sẽ trả về -1.
																			// 6
		match:				let matches = originalString.match(/an/g); // [ 'an', 'an', 'an' ]
		matchAll:			let originalString = "apple,orange,banana";
							// Tìm tất cả các từ chứa "an" trong chuỗi sử dụng matchAll
							let matchIterator = originalString.matchAll(/an/g);
							// Lặp qua iterator và hiển thị kết quả
							for (let match of matchIterator) {
							  console.log("Match:", match[0], "at index:", match.index); // Match: an at index: 1 7 14
							}
		- endsWith:			let endsWithBanana = originalString.endsWith("banana"); // true
		- startsWith:		let startsWithApple = originalString.startsWith("apple"); // true
		padStart:			let paddedString = originalString.padStart(30, '*'); // Thêm ký tự đệm để đạt được chiều dài 30 ký tự
																				 // ********apple,orange,banana
		padEnd:				let paddedString = originalString.padEnd(30, '*'); // Thêm ký tự đệm để đạt được chiều dài 30 ký tự
																			   // apple,orange,banana********
		- substr:			
							let substrResult = originalString.substr(6, 6); // Trích xuất phần bắt đầu từ index 6 và có độ dài 6 ký tự
																			// orange																
	Data Type--JAVASCRIPT:						
		Cannot be Redeclared:
									let x = "John Doe";
									let x = 0; // SyntaxError: 'x' has already been declared
									
									var x = "John Doe";
									var x = 0;
		Block Scope:
									{
									  let x = 2;
									}
									// x can NOT be used here
							
									{
									  var x = 2;
									}
									// x CAN be used here
		Redeclaring Variables:
									<!DOCTYPE html>
									<html>
									<body>
									<h2>Redeclaring a Variable Using let</h2>
									<p id="demo"></p>
									<script>
									let  x = 10;
									// Here x is 10
									{  
									  let x = 2;
									  // Here x is 2
									}
									// Here x is 10
									document.getElementById("demo").innerHTML = x;
									</script>
									</body>
									</html>
	
									<!DOCTYPE html>
									<html>
									<body>
									<h2>Redeclaring a Variable Using var</h2>
									<p id="demo"></p>
									<script>
									var  x = 10;
									// Here x is 10
									{  
									var x = 2;
									// Here x is 2
									}
									// Here x is 2
									document.getElementById("demo").innerHTML = x;
									</script>
									</body>
									</html>
		Redeclaring:
									var x = 2;   // Allowed
									let x = 3;   // Not allowed
									{
										let x = 2;   // Allowed
										let x = 3;   // Not allowed
									}
									{
										let x = 2;   // Allowed
										var x = 3;   // Not allowed
									}
	
									<!DOCTYPE html>
									<html>
									<body>
									<h2>JavaScript let</h2>
									<p>Redeclaring a JavaScript variable with <b>var</b> is allowed anywhere in a program:</p>
									<p id="demo"></p>
									<script>
									var x = 2;
									// Now x is 2
									var x = 3;
									// Now x is 3
									document.getElementById("demo").innerHTML = x;
									</script>
									</body>
									</html>
		Let Hoisting:
									Variables defined with let are also hoisted to the top of the block, but not initialized. Meaning: Using a let variable before it is declared will result in a ReferenceError
									Variables defined with var are hoisted to the top and can be initialized at any time. Meaning: You can use the variable before it is declared
	
									// Reference error...
									<!DOCTYPE html>
									<html>
									<body>
									<h2>JavaScript Hoisting</h2>
									<p>With <b>let</b>, you cannot use a variable before it is declared.</p>
									<p id="demo"></p>
									<script>
									try {
									  carName = "Saab";
									  let carName = "Volvo";
									}
									catch(err) {
									  document.getElementById("demo").innerHTML = err;
									}
									</script>
									</body>
									</html>
	
									// No error
									<!DOCTYPE html>
									<html>
									<body>
									<h2>JavaScript Hoisting</h2>
									<p>With <b>var</b>, you can use a variable before it is declared:</p>
									<p id="demo"></p>
									<script>
									carName = "Volvo";
									document.getElementById("demo").innerHTML = carName;
									var carName;
									</script>
									</body>
									</html>
	
	Null--JAVASCRIPT:																		
							var a = null;
							console.log(a); //null

							typeof null; // 'object';
							
							var a = null;
							a === null; // true
							
							let logHi = (str = ‘Hi’) => {
								console.log(str);
							}							
							logHi(null); // null
						
																				
																			
	Undefined--JAVASCRIPT:
							let foo;
							console.log('is undefined?', foo === undefined); // true
							
							let foo = { a: 'a' };
							console.log('is undefined?', foo.b === undefined); // true
																			
																			
							function foo() { return; }
							console.log('is undefined?', foo() === undefined); // true												
																			
																			
							function foo(param) {
								console.log('is undefined?', param === undefined);
							}
							foo('a'); // false
							foo(); // true

							let logHi = (str = ‘Hi’) => {
								console.log(str);
							}							
							logHi(undefined); // Hi												
																			
							console.log(window.undefined); // undefined
							window.hasOwnProperty('undefined'); // true

							!undefined // true
							
							undefined == false // false
							
							undefined === false // false
							
							undefined == true // false
							
							undefined === true // false

							undefined == null // true
							
							undefined === null // false
							
							!undefined === !null // true



	NaN--JAVASCRIPT:
							typeof NaN; // 'number'

							NaN == NaN // false
							NaN === NaN // false

							isNaN(NaN);           // true
							isNaN(1);             // false: 1 is a number
							isNaN(-2e-4);         // false: -2e-4 is a number (-0.0002) in scientific notation
							isNaN(Infinity);      // false: Infinity is a number
							isNaN(true);          // false: converted to 1, which is a number
							isNaN(false);         // false: converted to 0, which is a number
							isNaN(null);          // false: converted to 0, which is a number
							isNaN("");            // false: converted to 0, which is a number
							isNaN(" ");           // false: converted to 0, which is a number
							isNaN("45.3");        // false: string representing a number, converted to 45.3
							isNaN("1.2e3");       // false: string representing a number, converted to 1.2e3
							isNaN("Infinity");    // false: string representing a number, converted to Infinity
							isNaN(new Date);      // false: Date object, converted to milliseconds since epoch
							isNaN("10$");         // true: conversion fails, the dollar sign is not a digit
							isNaN("hello");       // true: conversion fails, no digits at all
							isNaN(undefined);     // true: converted to NaN
							isNaN();              // true: converted to NaN (implicitly undefined)
							isNaN(function(){});  // true: conversion fails
							isNaN({});            // true: conversion fails
							isNaN([1, 2]);        // true: converted to "1, 2", which can't be converted to a number
							
							Number.isNaN(NaN);         // true
							Number.isNaN(1);           // false
							Number.isNaN(-2e-4);       // false
							Number.isNaN(Infinity);    // false
							Number.isNaN(true);        // false
							Number.isNaN(false);       // false
							Number.isNaN(null);        // false
							Number.isNaN("");          // false
							Number.isNaN(" ");         // false
							Number.isNaN("45.3");      // false
							Number.isNaN("1.2e3");     // false
							Number.isNaN("Infinity");  // false
							Number.isNaN(new Date);    // false
							Number.isNaN("10$");       // false
							Number.isNaN("hello");     // false
							Number.isNaN(undefined);   // false
							Number.isNaN();            // false
							Number.isNaN(function(){});// false
							Number.isNaN({});          // false
							Number.isNaN([]);          // false
							Number.isNaN([1]);         // false
							Number.isNaN([1, 2]);      // false
							Number.isNaN([true]);      // false												
																			
																			
	Handle undefined in JavaScript--JAVASCRIPT:
		Accessing a non-existing property:		
															let favoriteMovie = {
																title: 'Blade Runner'
															};
															console.log(favoriteMovie.actors); // => undefined
			Check the property existence:		
															obj.prop !== undefined // compare against undefined directly
															typeof obj.prop !== 'undefined' // verify the property value type
															obj.hasOwnProperty('prop') // verify whether the object has its own property
															'prop' in obj // verify whether the object has an own or inherited property
	
			Destructuring to access object properties:		
															function quote(str, config) {
															  const { char = '"', skipIfQuoted = true } = config;
															  const length = str.length;
															  if (skipIfQuoted && str[0] === char && str[length - 1] === char) {
																return str;
															  }
															  return char + str + char;
															}
															const s1 = quote('Hello World', { char: '*' }); // '*Hello World*'    
															const s2 = quote('"Welcome"', { skipIfQuoted: true }); // '"Welcome"'

			Fill the object with default properties:
															const unsafeOptions = {
															  fontSize: 18
															};
															const defaults = {
															  fontSize: 16,
															  color: 'black'
															};
															const options = {
															  ...defaults,
															  ...unsafeOptions
															};
															console.log(options.fontSize); // => 18
															console.log(options.color);    // => 'black'
			Nullish coalescing:
															const styles = {
															  fontSize: 18
															};
															console.log(styles.color ?? 'black'); // => 'black'
															console.log(styles.fontSize ?? 16);   // => 18
	
	
		Uninitialized variable:
																		let myVariable;
																		console.log(myVariable); // => undefined
			Favor const, otherwise use let, but say goodbye to var:
																		function isPalindrome(word) {
																		  const length = word.length;
																		  const half = Math.floor(length / 2);
																		  for (let index = 0; index < half; index++) {
																			if (word[index] !== word[length - index - 1]) {
																			  return false;
																			}
																		  }
																		  return true;
																		}
																		console.log(isPalindrome('madam')); // => true
																		console.log(isPalindrome('hello')); // => false
			Increase cohesion:
																		function someFunc(array) {
																		  // some code...
																		  // some code...
																		  const length = array.length;
																		  for (let index = 0; index < length; index++) {
																			const item = array[index];
																			// some 
																		  }
																		  return 'some result';
																		}
		Function parameters:		
																		function multiply(a, b) {
																		  console.log(b); // => undefined
																		  return a * b;
																		}
																		console.log(multiply(5)); // => NaN
			Use default parameter value:
																		function multiply(a, b = 2) {
																		  return a * b;
																		}

																		console.log(multiply(5));            // => 10
																		console.log(multiply(5, undefined)); // => 10
		Function return value:
																		function square(x) {
																		  const res = x * x;
																		}
																		console.log(square(2)); // => undefined
			Don't trust the automatic semicolon insertion:
																		function getPrimeNumbers() {
																		  return [ 2, 3, 5, 7, 11, 13, 17 ]
																		}
																		console.log(getPrimeNumbers()) // => undefined
																		
																		function getPrimeNumbers() {
																		  return; 
																		  [ 2, 3, 5, 7, 11, 13, 17 ];
																		}
																		console.log(getPrimeNumbers()); // => undefined
																		
																		function getPrimeNumbers() {
																		  return [2, 3, 5, 7, 11, 13, 17];
																		}
																		console.log(getPrimeNumbers()); // => [2, 3, 5, 7, 11, 13, 17]
			void operator:
																		console.log(void 1);                    // => undefined
																		console.log(void (false));              // => undefined
																		console.log(void {name: 'John Smith'}); // => undefined
																		console.log(void Math.min(1, 3));       // => undefined
		undefined in arrays:
																		const colors = ['blue', 'white', 'red'];
																		console.log(colors[5]);  // => undefined
																		console.log(colors[-1]); // => undefined
	
																		const sparse1 = new Array(3);
																		console.log(sparse1);    // => [<empty>, <empty>, <empty>]
																		console.log(sparse1[0]); // => undefined
																		console.log(sparse1[1]); // => undefined
																		const sparse2 = ['white',  ,'blue']
																		console.log(sparse2);    // => ['white', <empty>, 'blue']
																		console.log(sparse2[1]); // => undefined
	
	Upload File--JAVASCRIPT--SPRING:
											
					- Lưu file chỉ cần lưu tên xuống database, lấy lên frontend sẽ chèn thêm url để tạo thành link.
					- File được gửi riêng với FormData, backend sẽ bắt với MultipartFile. Chú ý sẽ gửi 2 data, 1 là file và 1 là tên file xuống backend
					- Tạo 1 biến cờ để khi có sự kiện onChange ở thẻ input (khi có sự kiện onChange thì chắc chắn sẽ là update file) thì bật biến cờ này lên true
					
					const [selectedFile, setSelectedFile] = useState(null); // file
					const [previewFileUrl, setPreviewFileUrl] = useState(""); // trả về một URL duy nhất đại diện cho tệp được chỉ định trong tham số file.
					const [fileName, setFileName] = useState(""); // tên của file, chỉ để hiển thị ở frontend
					const [file, setFile] = useState(""); // tên của file lấy từ backend, được gán url phía trước.
					const [isDeleteFile, setIsDeleteFile] = useState(false);
					const [isOpenFileDelete, setIsOpenFileDelete] = useState(false);
					const [fileChange, setFileChange] = useState(false);
					const uploadFileRef = useRef(null);
					useEffect(() => {
						if (isUpdate === true) {												  
						  if (row.pme00ProjectInfo.image && row.pme00ProjectInfo.image !== '') {
							setImage(row.pme00ProjectInfo.image);
							setSelectedImg(new File([""], "temp"));
							setPreviewImgUrl(row.pme00ProjectInfo.image);
						  }
						  if (row.pme00ProjectInfo.file && row.pme00ProjectInfo.file !== '') { // code block for processing file
							setFile(row.pme00ProjectInfo.file);
							setSelectedFile(new File([""], "temp"));
							setPreviewFileUrl(row.pme00ProjectInfo.file);
							const underscoreIndex = row.pme00ProjectInfo.file.indexOf("_");
							const fileName = row.pme00ProjectInfo.file.substring(underscoreIndex + 1); // add file from backend to show file name
							setFileName(fileName);
						  }
						} else {
						  setCreatorId(loginUserInfo.id);
						}
					  }, [isUpdate, row]);										 
					useEffect(() => {
						if (isDeleteFile) {
						  handleChooseAnotherFile();
						  setIsDeleteFile(false);
						}
					}, [isAlertOpen])
					const data = {
						"pme00ProjectInfo": {
						  "image": image.split(/[\\/]/).pop(),
						  "file": file.split(/[\\/]/).pop() // cắt bởi vì tên file từ backend sẽ được gán thêm đuôi url đằng trước để chỉ link của file
						},
					}	
					const handleSave = async () => {
						const formData = new FormData();
						if (selectedImg && imageChange) {
						  const nameList = applyIdentifierToFileName(selectedImg, Date.now())
						  data.pme00ProjectInfo.image = nameList[1].split(/[\\/]/).pop();
						  formData.append("imageUpload", nameList[0]);
						}
						if (selectedFile && fileChange) {
						  const nameList = applyIdentifierToFileName(selectedFile, Date.now())
						  data.pme00ProjectInfo.file = nameList[1].split(/[\\/]/).pop(); // Trong JavaScript, một biểu thức chính quy được đặt giữa hai dấu gạch chéo /.../.
																					     // Ký tự \ (backslash) là ký tự đặc biệt trong cả JavaScript và biểu thức chính quy, dùng để "escape"
																						 // các ký tự đặc biệt khác.
																						 // [ ... ] là một "character set" trong biểu thức chính quy, cho phép bạn chỉ định một tập hợp các ký tự
																						 có thể khớp với vị trí đó trong chuỗi.
						  formData.append("fileUpload", nameList[0]);
						}
						formData.append("data", JSON.stringify(data));
						if (isUpdate) {
						  await saveData(formData).then(res => {
							if (res.data[0]) {
							  SnackbarUtils.success("Update Success!!!");
							  handleClose();
							  searchAll();
							} else {
							  SnackbarUtils.error(res.data[1]);
							}
						  })
							.catch(() => {
							  SnackbarUtils.error("Network error. Please try again after!");
							});
						} else {
						  await createNewData(formData).then(res => {
							if (res.data[0]) {
							  SnackbarUtils.success("Add Success!!!");
							  handleClose();
							  searchAll();
							} else {
							  SnackbarUtils.error(res.data[1]);
							}
						  })
							.catch(() => {
							  SnackbarUtils.error("Network error. Please try again after!");
							});
						}
					}											  										  

					const handleFileChange = (event) => {
						setFileChange(true);
						const file = event.target.files[0];
						if (file.size > 50000000) {
						  SnackbarUtils.error("This file is bigger than 50MB. Please change other file!");
						  return;
						} else {
						  setFileName(file?.name)
						  setSelectedFile(file);
						  setPreviewFileUrl(URL.createObjectURL(file)); // để gán URL đại diện cho tệp vào một biến, hiển thị trước hoặc xem trước tệp trong ứng dụng, cho phép người dùng xem trước
																		// tệp trước khi tải lên hoặc lưu trữ nó.
						}
					};

					const handleChooseAnotherFile = () => {
						uploadFileRef.current.value = '';
						setSelectedFile(null);
						setPreviewFileUrl("");
						setFile("");
						setFileName("");
					};

					const handleUploadFileClick = () => {
						uploadFileRef.current.click();
					}											  
	
					<div className="textField txtFieldPop">
						<TextField className="txtPM" label="Specification File"
						  id="koreaPm"
						  value={fileName}
						  readOnly
						  size="small"
						  disabled
						  InputProps={{
							endAdornment: (
							  <>
								<IconButton
								  color="default"
								  size="small"
								  sx={{ visibility: selectedFile ? "visible" : "hidden" }}
								  onClick={() => {
									fetch(previewFileUrl)
									  .then(response => response.blob())
									  .then(blob => {
										const url = URL.createObjectURL(blob);
										const link = document.createElement('a');
										link.href = url;
										link.setAttribute('download', fileName);
										link.click();
										URL.revokeObjectURL(url);
									  });
								  }}
								>
								  <DownloadIcon fontSize="small" />
								</IconButton>
								<IconButton
								  color="default"
								  size="small"
								  sx={{ visibility: selectedFile ? "visible" : "hidden" }}
								  onClick={() => {
									setIsAlertOpen(true);
									setIsOpenFileDelete(true);
								  }}
								>
								  <Clear fontSize="small" />
								</IconButton>
							  </>
							),
						  }}
						/>
						<Button type="file" className="btnPM" variant="contained" size='medium'
						  onClick={handleUploadFileClick}
						>
						  Choose
						</Button>
						<input
						  style={{ display: "none" }}
						  type="file"
						  hidden
						  onChange={handleFileChange}
						  name="image"
						  ref={uploadFileRef}
						/>
					</div>
					
					{
						(isAlertOpen && isOpenFileDelete) && (
						  <ConfirmDialog
							open={isAlertOpen}
							onConfirm={setIsDeleteFile}
							setIsAlertOpen={setIsAlertOpen}
							title="Are you sure want to delete this file?"
							content="Make sure you think carefully before deleting."
						  />
						)
					}				
					
					@PutMapping("")
					@PreAuthorize("hasAnyAuthority('UPDATE_PROJECT,UPDATE_PROJECT_OWNER')")
					public List<Object> modify(@RequestParam ("data") String dtoString,
										  @RequestParam (value = "imageUpload", required = false) MultipartFile imageUpload,
										  @RequestParam (value = "fileUpload", required = false) MultipartFile fileUpload) throws SQLException {
						ProjectManagementDto dto = ProjectManagementDto.fromJson(dtoString);
						if (!PermissionValidation.validateUpdateProject(dto)) {
							List<Object> result = new ArrayList<>();
							result.add(false);
							result.add(Utils.NO_PERMISSION);
							return result;
						}
						return this.serviceLifecycle
								   .requestLevel2ProjectService()
								   .modifyProject(serviceLifecycle, dto, imageUpload, fileUpload);
					}	
					
					@Override
					@Transactional(rollbackFor = { SQLException.class })
					public List<Object> modifyProject(ServiceLifecycle serviceLifecycle, ProjectManagementDto dto,
												 MultipartFile imageUpload, MultipartFile fileUpload) throws SQLException {
						List<Object> resultList = new ArrayList<>();
						// Check project code exists
						if(!checkExistsM00Codes030(serviceLifecycle, Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, dto.getM00Codes030().getCdV())
								|| !checkExistsPme00ProjectInfo(serviceLifecycle, dto.getPme00ProjectInfo().getCdV())){
							resultList.add(false);
							resultList.add("Project not exists!");
							return resultList;
						}
						//  Delete old file/image
						String imageNew = dto.getPme00ProjectInfo().getImage();
						String fileNew = dto.getPme00ProjectInfo().getFile();
						if (imageUpload != null || fileUpload != null || imageNew.isEmpty() || fileNew.isEmpty()) {
							Pme00ProjectInfo projectInfo = serviceLifecycle.requestPme00ProjectInfoService().find(dto.getM00Codes030().getCdV());
							List<String> fileName = new ArrayList<>();
							if (imageUpload != null || imageNew.isEmpty()) {
								String imageString = projectInfo.getImage();
								if (imageString != null) {
									imageString = imageString.substring(imageString.lastIndexOf("/") + 1);
									fileName.add(imageString);
								}
							}
							if (fileUpload != null || fileNew.isEmpty()) {
								String fileString = projectInfo.getFile();
								if (fileString != null) {
									fileString = fileString.substring(fileString.lastIndexOf("/") + 1);
									fileName.add(fileString);
								}
							}
							boolean result = serviceLifecycle.requestLevel2Service()
									.removeFile(Utils.UPLOAD_BUCKET, "Project", fileName);
							if (!result) {
								resultList.add(false);
								resultList.add("Project updated. However, file(s) could not be saved.");
								return resultList;
							}
						}
						// Update data M00Codes030
						List<M00Codes030> lstCodes030 = new ArrayList<>();
						M00Codes030 entityCodes030 = new M00Codes030();
						entityCodes030.setCdTpId(Utils.CD_TP_ID);
						entityCodes030.setCategoryGroupId(Utils.CATEGORY_GROUP_ID);
						entityCodes030.setCdV(dto.getM00Codes030().getCdV());
						entityCodes030.setCdvMeaning(dto.getM00Codes030().getCdvMeaning());
						entityCodes030.setCdVExplain(dto.getM00Codes030().getCdVExplain());
						entityCodes030.setCdVInquirySeq(dto.getM00Codes030().getCdVInquirySeq());
						entityCodes030.setCreatedProgramId(dto.getM00Codes030().getCreatedProgramId());
						entityCodes030.setCreationTimestamp(dto.getM00Codes030().getCreationTimestamp());
						entityCodes030.setLastUpdateProgramId(dto.getM00Codes030().getLastUpdateProgramId());
						entityCodes030.setLastUpdateTimestamp(dto.getM00Codes030().getLastUpdateTimestamp());
						lstCodes030.add(entityCodes030);
						serviceLifecycle.requestM00Codes030Service().modify(lstCodes030);
						// Update data Pme00ProjectInfo
						List<Pme00ProjectInfo> lstProjectInfo = new ArrayList<>();
						Pme00ProjectInfo entityInfo = new Pme00ProjectInfo();
						entityInfo.setCdV(dto.getPme00ProjectInfo().getCdV());
						entityInfo.setPeriod(dto.getPme00ProjectInfo().getPeriod());
						entityInfo.setStartDate(dto.getPme00ProjectInfo().getStartDate());
						entityInfo.setEndDate(dto.getPme00ProjectInfo().getEndDate());
						entityInfo.setKoreaPm(dto.getPme00ProjectInfo().getKoreaPm());
						entityInfo.setVietnamPl(dto.getPme00ProjectInfo().getVietnamPl());
						entityInfo.setStatus(dto.getPme00ProjectInfo().getStatus());
						entityInfo.setFramework(dto.getPme00ProjectInfo().getFramework());
						entityInfo.setImage(dto.getPme00ProjectInfo().getImage());
						entityInfo.setFile(dto.getPme00ProjectInfo().getFile());
						lstProjectInfo.add(entityInfo);
						serviceLifecycle.requestPme00ProjectInfoService().modify(lstProjectInfo);
						// Update data Pme00Member
						// Delete old Pme00Member
						serviceLifecycle.requestPme00MemberService().deleteMemberById(dto.getPme00ProjectInfo().getCdV(), null);
						// Insert new Pme00Member
						Pme00Member entityMember;
						for (Pme00Member member : dto.getLstMember()) {
							entityMember = new Pme00Member();
							entityMember.setCdVId(dto.getM00Codes030().getCdV());
							entityMember.setEmpId(member.getEmpId());
							entityMember.setEmpName(member.getEmpName());
							entityMember.setAvatar(member.getAvatar());
							serviceLifecycle.requestPme00MemberService().register(entityMember);
						}
						if (imageUpload != null) {
							String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", imageUpload);
							if (!result.contains("Project")) {
								resultList.add(false);
								resultList.add("Project created. However, image could not be saved.");
								return resultList;
							}
						}
						if (fileUpload != null) {
							String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", fileUpload);
							if (!result.contains("Project")) {
								resultList.add(false);
								resultList.add("Project created. However, file could not be saved.");
								return resultList;
							}
						}
						resultList.add(true);
						return resultList;
					}	
					
					@Override
					public String uploadFile(String bucketName, String serviceName, MultipartFile file) {
						try {
							final String fileName = serviceName + "/" + file.getOriginalFilename();
							InputStream inputStream = file.getInputStream();
							minioClient.putObject(PutObjectArgs.builder()
									   .bucket(bucketName)
									   .object(fileName)
									   .stream(inputStream, inputStream.available(), -1)
									   .contentType(file.getContentType())
									   .build());
							return fileName;
						} catch (Exception e) {
							return "Upload unsuccessfully!";
						}
					}
					
	Arrow Function--JAVASCRIPT:
											- Arrow function sẽ phân ra là có 1 statement và nhiều statement
													Nếu là 1 statement và có return:	 		thì có thể bỏ {} và return.
													Nếu là 1 statement và nhiều statement:	 	thì không làm như này được, mục đích của cái này là mong muốn viết tất cả hàm trong 1 hàng
													Nếu chỉ có 1 parameter:						thì có thể bỏ qua dấu ()
											- Trường hợp có dấu {}, bạn cần sử dụng thêm từ khóa return để trả về giá trị của hàm.
											- Bằng cách sử dụng arrow function, chúng ta tránh được việc phải gõ từ khoá function, return và dấu ngoặc nhọn.
		
		Arrow function sử dụng kí tự =>--Arrow Function:
											let sayHi = () => {
											  console.log("Hi");
											}
											sayHi();
											// => Hi
											
		Function sử dụng từ khoá function--Arrow Function:
											
											let sayHi = function() {
											  console.log("Hi");
											}
											sayHi();
											// => Hi
											
		Arrow function có thể được sử dụng giống như function expression--Arrow Function:
		
											let isVietnamese = confirm("Bạn có phải người Việt Nam không?");
											let welcome = isVietnamese
											  ? () => console.log("Chào bạn!")
											  : () => console.log("Hello!");
											welcome();
											
		Ví dụ sử dụng arrow function làm hàm callback--Arrow Function:

											function ask(question, handleYes, handleNo) {
											  const answer = confirm(question);
											  if (answer) {
												handleYes();
											  } else {
												handleNo();
											  }
											}
											ask(
											  "Bạn muốn tiếp tục thực hiện chương trình không?",
											  () => console.log("Bạn đã chọn Yes!"),
											  () => console.log("Bạn đã chọn No!")
											);
											
		Ví dụ về một số trường hợp sử dụng phổ biến--Arrow Function:
			
			Trong trường hợp nhiều tham số:
			
											Trong trường hợp chỉ có một biểu thức thì không cần tới dấu ngoặc nhọn
											
											// ES5 
											var multiply = function(x, y) {
												return x * y;
											}; 										 
											// ES6 
											var multiply = (x, y) => { return x * y };
											
											var multiply = (x, y) => x * y ;
											
			Trong trường hợp 1 tham số:
			
											Dấu ngoặc đơn là optional khi chỉ có một tham số
											
											//ES5 
											var phraseSplitterEs5 = function phraseSplitter(phrase) { 
												return phrase.split(' '); 
											}; 										 
											//ES6 
											var phraseSplitterEs6 = phrase => phrase.split(" "); 								 
											console.log(phraseSplitterEs6("ES6 Awesomeness"));  // ["ES6", "Awesomeness"]
											
			Trong trường hợp không có tham số:
			
											Dấu ngoặc đơn là bắt buộc khi không có tham số.
											
											//ES5 
											var docLogEs5 = function docLog() { 
												console.log(document); 
											}; 										 
											//ES6 
											var docLogEs6 = () => { console.log(document); } 
											docLogEs6(); // #document... <html> ….
											
			Cú pháp với Object literal:
			
											Arrow function cũng tương tự như biểu thức function, có thể được sử dụng để trả về một object literal. Phần body của function cần được bao bọc trong ngoặc tròn, để phân biệt giữa
											object và function block (cả hai đều sử dụng dấu ngoặc nhọn).
											
											//ES5 
											var setNameIdsEs5 = function setNameIds(id, name) { 
												return { 
													id: id, 
													name: name 
												}; 
											}; 										 
											// ES6 
											var setNameIdsEs6 = (id, name) => ({ id: id, name: name }); 										 
											(setNameIdsEs6 (4, "Kyle"));   // Object {id: 4, name: "Kyle"}
											 
		Khi nào thì nên sử dụng arrow function--Arrow Function:
		
											Một usecase phổ biến áp dung arrow function là thao tác mảng, thông thường là khi dùng map hoặc reduce.
											
											var smartPhones = [ 
												{ name: 'iphone', price: 649 }, 
												{ name: 'Galaxy S6', price: 576 }, 
												{ name: 'Galaxy Note 5', price: 489 } 
											];
											// ES5 
											console.log(smartPhones.map(function(smartPhone){
												return smartPhone.price;
											}); // [649, 576, 489]
											// ES6 
											console.log(smartPhones.map(smartPhone => smartPhone.price)); // [649, 576, 489]
											
		Lưu ý trong việc sử dụng arrow function--Arrow Function:
			this:
											- Từ khóa this hoạt động khác hoàn toàn trong arrow function. Các phương thức call (), apply (), và bind () sẽ không thay đổi giá trị của this trong arrow function. (Trong thực tế, giá
											trị của this bên trong một hàm đơn giản là không thể thay đổi - nó sẽ luôn là giá trị tương tự như khi hàm được gọi) Nếu bạn cần bind đến một giá trị khác, cần sử dụng function
											expression như bình thường.
											- Arrow function không định nghĩa giá trị this của riêng nó giống như function.
					
					Ví dụ sử dụng function:
					
											Trong chế độ none-strict, function print định nghĩa this chính là đối tượng global (đối với trình duyệt thì đó là window). Do đó, this.x tương đương với window.x và bằng 0.
											var x = 0;
											function DelayPrint(x, timeout) {
											  this.x = x;
											  setTimeout(function print() {
												console.log(`The value is ${this.x}.`);
											  }, timeout);
											}
											let p = new DelayPrint(1, 1000);
											// => The value is 0.
											
											Để đoạn code trên hoạt động theo đúng mong muốn thì bạn phải sửa lại như sau:
											var x = 0;
											function DelayPrint(x, timeout) {
											  this.x = x;
											  let self = this;

											  setTimeout(function print() {
												console.log(`The value is ${self.x}.`);
											  }, timeout);
											}
											let p = new DelayPrint(1, 1000);
											// => The value is 1.
											
					Ví dụ sử dụng arrow function:
					
											Ngược lại với function, arrow function không định nghĩa lại this. Do đó, giá trị của this sẽ ứng với ngữ cảnh gần nhất của nó. Vì vậy, trong đoạn code trên this.x sẽ tương ứng với giá
											trị x được truyền vào và bằng 1.
											
											var x = 0;
											function DelayPrint(x, timeout) {
											  this.x = x;
											  setTimeout(() => {
												console.log(`The value is ${this.x}.`);
											  }, timeout);
											}
											let p = new DelayPrint(1, 1000);
											// => The value is 1.
			Constructors:
											Arrow function không thể được sử dụng làm constructor như function. Nếu khởi tạo new với arrow function, nó sẽ throw ra lỗi. Arrow function không có thuộc tính prototype hay internal
											methods. Trong trường hợp đó nên dùng cú pháp tạo class của ES6.
											
											Trước khi ES6 ra đời, người ta có thể sử dụng function làm hàm khởi tạo cho object.
											function Dog(name, color) {
											  this.name = name;
											  this.color = color;
											}
											let myDog = new Dog("Nick", "White");
											console.log(myDog.name, myDog.color);
											// => Nick White
											
											Nếu thay đoạn code trên bằng arrow function thì bạn sẽ bị lỗi: TypeError: Dog is not a constructor.
											let Dog = (name, color) => {
											  this.name = name;
											  this.color = color;
											}
											let myDog = new Dog("Nick", "White");
											console.log(myDog.name, myDog.color);
											// => TypeError: Dog is not a constructor
											
			Arrow function không phù hợp làm method cho object:
			
											- Chính vì arrow function không định nghĩa giá trị this của riêng nó, nên cũng không phù hợp là method cho object.
											- Vì vậy, nếu muốn định nghĩa method cho object thì bạn nên sử dụng function.
											
											let obj = {
											  a: 1,
											  b: () => console.log(this.a, this),
											  c: function() {
												console.log(this.a, this);
											  }
											}
											obj.b(); // prints undefined, Window {...} (or the global object)
											obj.c(); // prints 1, Object {...}
											
			Tốt nhất nên cân đối giữa việc dùng function và dùng arrow function như sau:
			
											Sử dụng function trong global scope trong Object.prototype properties
											Sử dụng class cho object constructors.
											Sử dụng => ở những chố còn lại
											
			Arrow function không bind arguments:
			
											- Tương tự như đối với this, arrow function cũng không định nghĩa giá trị arguments của riêng nó.
											- Đối tượng arguments đặc biệt hữu ích đối với những function không xác định trước số lượng tham số.
											function sum() {
											  return Array.from(arguments).reduce(
												(accumulator, currentValue) => accumulator + currentValue
											  );
											}
											console.log(sum(1, 2));         // => 3
											console.log(sum(1, 2, 3));      // => 6
											console.log(sum(1, 2, 3, 4));   // => 10
											
											- Đối với arrow function, sử dụng arguments sẽ lỗi vì biến này không được định nghĩa ở arrow function.
											let sum = () => {
											  return Array.from(arguments).reduce(
												(accumulator, currentValue) => accumulator + currentValue
											  );
											}
											console.log(sum(1, 2));
											// Uncaught ReferenceError: arguments is not defined
											
											- Tuy nhiên, bạn vẫn có thể sử dụng rest parameters để thay thế cho arguments.
											let sum = (...args) => {
											  return Array.from(args).reduce(
												(accumulator, currentValue) => accumulator + currentValue
											  );
											}
											console.log(sum(1, 2));         // => 3
											console.log(sum(1, 2, 3));      // => 6
											console.log(sum(1, 2, 3, 4));   // => 10
											
			Arrow function không có thuộc tính prototype:
			
											Về cơ bản, mọi đối tượng trong JavaScript đều có thuộc tính prototype và kế thừa cũng theo prototype.
											Tuy nhiên, nếu arrow function không thể sử dụng làm constructor thì mình cho rằng điều này cũng hợp lý.										
											let Foo = () => {};
											console.log(Foo.prototype); // undefined

											
			Arrow function không được hoisted:
			
											Về cơ bản, hoisting được hiểu là biến và hàm số được đưa lên đầu của phạm vi biến, hàm số trước khi đoạn code đó được thực hiện.
											Arrow function không được hoisted: nghĩa là bạn phải định nghĩa arrow function trước khi sử dụng nó.
											
											let myFunc1 = () => {}
											myFunc1(); // OK
											myFunc2(); // => ReferenceError: myFunc2 is not defined
											let myFunc2 = () => {}	
											
											Ngược lại, function declaration được hoisted nên bạn có thể gọi hàm trước khi định nghĩa nó.
											myFunc(); // OK
											function myFunc() {}
			
			Click handle:
			
											Đầu tiên. mình có một button lớn, có thể đặt tên cho nó là “push me”:
											<button id="pushy">Push me</button>
											<style>
												button { font-size: 100px; }
												.on { background: #ffc600; }
											</style>
											
											Khi ai đó click vào nút, mình muốn nút này chuyển (thay đổi) class thành on và nút sẽ chuyển sang màu vàng.
											const button = document.querySelector('#pushy');
											button.addEventListener('click', () => {
												this.classList.toggle('on');
											});
											
											Nhưng nếu bạn click vào nút này thì bạn sẽ nhận được lỗi trả về là:
											Uncaught TypeError: Cannot read property 'toggle' of undefined
											
											Vậy điều này có nghĩa là gì? this trong trường hợp này, nó là thuộc tính window của trình duyệt. Bạn có thể sử dụng console.log để confirm nó.
											const button = document.querySelector('#pushy');
											button.addEventListener('click', () => {
												console.log(this); // Window!
												this.classList.toggle('on');
											});
											
											Hãy nhớ rằng: Chúng ta đang nói về việc sử dụng Arrow functions, vậy nên this không bị ràng buộc bởi button này. Ngược lại, nếu chúng ta sử dụng function thông thường, this sẽ bị
											ràng buộc vào button mà bạn click vào đó.
											Hiển nhiên khi console.log(this) kết quả trả về chính là button mà chúng ta vừa click, và button ban đầu sẽ chuyển sang màu vàng như ý muốn.
											const button = document.querySelector('#pushy');
											button.addEventListener('click', function() {
												console.log(this);
												this.classList.toggle('on');
											});
	Object--JAVASCRIPT:
											let totalRow = {};
											totalRow["Id"] = res.data.length;
											totalRow["Project Name"] = "Total";
											totalRow["Task Count"] = res.data[0]["Total Tasks"];
											totalRow["Finished Count"] = res.data[0]["Total Finished Tasks"];
											totalRow["Testing Count"] = res.data[0]["Total Testing Tasks"];
											totalRow["Remain Count"] = res.data[0]["Total Remain Tasks"];
											totalRow["Delayed Count"] = res.data[0]["Total Delayed Tasks"];
											totalRow["Finished (%)"] = ((totalRow["Finished Count"]/totalRow["Task Count"]).toFixed(2)*100) + "%";
											totalRow["Testing (%)"] = ((totalRow["Testing Count"]/totalRow["Task Count"]).toFixed(2)*100) + "%";
											totalRow["Remain (%)"] = ((totalRow["Remain Count"]/totalRow["Task Count"]).toFixed(2)*100) + "%";
											totalRow["Delayed (%)"] = ((totalRow["Delayed Count"]/totalRow["Task Count"]).toFixed(2)*100) + "%";
											
	Destructuring, Rest Parameters, và Spread Syntax--JAVASCRIPT:
		Destructuring:
											Destructuring là một cú pháp cho phép bạn gán các thuộc tính của một Object hoặc một Array. Điều này có thể làm giảm đáng kể các dòng mã cần thiết để thao tác dữ liệu trong các cấu
											trúc này
			Destructuring Objects:
											Destructuring Objects cho phép bạn tạo ra một hay nhiều new variables sử dụng những property của một Objects
											
											const note = {
											   id: 1,
											   website: 'abc.com',
											   date: '17/07/2014',
											}
											const { id, website, date } = note
			Destructuring Arrays:
											Array destructuring cho phép bạn tạo ra một new variables bằng cách sử dụng giá trị mỗi index của Array.
											
											const date = ['2014', '17', '07']
											const [year, month, day] = date
		Rest Parameters:
											Cũng như Spread Syntax (...) nhưng có tác dụng ngược lại.
											Bạn có thể hiểu là 1 tính năng khai báo một hàm với số lượng tham số không xác định. Đúng như cái tên mà chúng ta có thể hiểu là tham số còn lại.
											
											function fn(...args) {
											  console.log(args)
											}
											restTest(1, 2, 3, 4, 5, 6);// [1, 2, 3, 4, 5, 6]
											
											function sum(...args) { // args is the name for the array
											  let sum = 0;
											  args.forEach((arg) => sum += arg)
											  return sum;
											}
											console.log( sum(1) ); // 1
											console.log( sum(1, 2) ); // 3
											console.log( sum(1, 2, 3) ); // 6
											
											const { name, ...rest } = props; // khi có 1 object và chỉ muốn lấy riêng ra 1 key thôi
																			 // ta sẽ tạo ra 2 const name và rest thì name chính là key/value name của props còn rest sẽ bao gồm các phần còn lại mà không có name
		Spread operator:
											- Spread có thể tạo ra một cấu trúc dữ liệu shallow copy để tăng tính thao tác dữ liệu.
											- Spread operator là ba dấu chấm ( ...), có thể chuyển đổi một mảng thành một chuỗi các tham số được phân tách bằng dấu phẩy. Nói cho dễ hiểu, nó giống như một cái xương và một
											cái xương
											sườn vậy, chia nhỏ một phần tử lớn thành những phần tử nhỏ riêng lẻ.
			Spread với Array:
			
				Ví dụ về merge các Array thì có rất nhiều cách ở đây mình dùng concat method:
				
											const array1 = ['Em', 'yêu']
											const array2 = ['Anh', 'nhưng lại hôn thằng đó']
											const result = array1.concat(array2)
											console.log(result)
											
				Nhưng thay thế bằng Spread mọi thứ lại đơn giản hơn:
				
											const result = [...array1, ...array2]
											console.log(result)
			Spread with Objects--Spread:
				
				Với Object để shallow copy một bạn có thể dùng Object.assign():
				
											const profile = {
												name: 'Nguyen Xuan A',
												age: 23,
												birthday: '01/01/1997'
											}
											const cloneProfile = Object.assign({}, profile)
											
				Chúng ta hoàn toàn có thể sử dụng Spread để copy và mở rộng một object:
				
											const user = { 
												name: 'Dung', 
												age: 25 
											}; 
											const info = { 
												email: 'khuat.van.dung@abc.xyz',
												address: 'xyz-hanoi'
											}; 
											const profile = { ...user, ...info };
											console.log(profile);
											
											let obj1 = { foo: 'bar', x: 42 };
											let obj2 = { foo: 'baz', y: 13 };
											let clonedObj = { ...obj1 }; // Object { foo: "bar", x: 42 }									
											let mergedObj = { ...obj1, ...obj2 }; // Object { foo: "baz", x: 42, y: 13 }. Trường hợp thuộc tính của đối tượng đã có trước thì sẽ thực hiện việc cập nhật thay vì add mới.								
											let updatedObj= { ...obj1, z: 19 }; // Object { foo: "bar", x: 42, z: 19 }
				
			Spread with Function Calls--Spread:
				
											// Tạo function
											function fn(a, b, c) {
											  return a * b * c
											}
											// Gọi như bth
											fn(1, 2, 3) // 6
											// Sử dụng Spread
											const numbers = [1, 2, 3]
											fn(...numbers) // 6
				
			Spread syntax with string--Spread:
											Nên thay thế việc dùng split vì split sẽ không hiểu 1 số ký tự đặc biệt như emoji nhưng dùng spread hoặc dùng from sẽ hiểu.
											
											const pizza = 'pizza';								
											const slicedPizza = pizza.split(''); // Old way
											console.log(slicedPizza); // [ 'p', 'i', 'z', 'z', 'a' ]									
											const slicedPizza2 = [...pizza]; // ES6: using Spread
											console.log(slicedPizza2); // [ 'p', 'i', 'z', 'z', 'a' ]									
											const slicedPizza3 = Array.from(pizza); // ES6: using Array.from
											console.log(slicedPizza3); // [ 'p', 'i', 'z', 'z', 'a' ]
											
			Sử dụng Spread tương tự với concat()--Spread:

											- Thay vì sử dụng concat, chúng ta có thể đạt được điều tương tự bằng cách sử dụng Spread. Mặc dù việc sử dụng Spread có thể giúp chúng ta đạt được kết quả giống với concat(), nhưng
											với dữ liệu có size lớn thì chúng ta nên sử dụng concat(), vì việc sử dụng Spread gây mất thời gian hơn so với concat().
											
											let arr = [1,2,3]; 
											let arr2 = [4,5]; 										  
											const arr3 = [...arr, ...arr2];
											console.log(arr);  // [ 1, 2, 3 ]
											console.log(arr2);  // [ 4, 5 ]
											console.log(arr3); // [ 1, 2, 3, 4, 5 ]
				
			Sử dụng Spread tương tự việc copy dữ liệu (splice)--Spread:
				
					Nếu như chúng ta thay đổi dữ liệu của newArr thì nó cũng sẽ ảnh hưởng đến arr:
								
											let arr = [1,2,3,4]; 
											let newArr = arr; 
											newArr.pop();
											console.log(newArr); // [1,2,3] 
											console.log(arr); // [1,2,3]
											
					Để tránh việc này, chúng ta hoàn toàn có thể dử dụng Spread để thực hiện copy value:
					
											let arr = [1,2,3,4]; 
											let newArr = [...arr]; 
											newArr.pop();
											console.log(newArr); // [1,2,3] 
											console.log(arr); // [1,2,3,4]
				
			Sử dụng Spread để mở rộng (expand)--Spread:
				
					Như bình thường, khi chúng ta mở rộng mảng chúng ta có thể dùng cách thông thường như dưới đây:
					
											let arr = ['a','b']; 
											let arr2 = [arr,'c','d']; 
											console.log(arr2);
											
					Bằng cách copy lần lượt các phần tử bên trong mảng arr sang mảng mới. Và lúc này đoạn code sẽ sửa như sau:
					
											let arr = ['a','b'];
											let arr2 = [...arr,'c','d']; 
											console.log(arr2);
											
			Spread với Math object--Spread:
						
											Ví dụ như nếu chúng ta có một mảng dữ liệu như sau [1,2,3,-1] . Để có thể tìm giá trị lớn nhất thì lúc này Math sẽ bị lỗi bởi vì Math không thể làm việc được với array.
											Để giải quyết vấn đề này, chúng ta cũng có thể dùng Spread.
											
											const arr = [1,2,3,-1];
											console.log(Math.max(...arr)); // "lan truyền" các phần tử của mảng arr thành các đối số độc lập với phương thức Math.max().
											
			Mặc dù thực tế rằng spread operator trải đều hoạt động trên cả array và object, bạn không thể trộn và khớp các loại dữ liệu này với nhau--Spread:
				
											let obj = {a:1, b:2, c:3}
											let copy = [...obj] // this won't work!
											
			Sử dụng phương thức push () của mảng--Spread:
				
											Push () là phương thức hỗ trợ truyền nhiều tham số không xác định. Thông thường, người ta sử dụng phương thức apply () để lấp đầy mảng, nhưng điều đó không thuận tiện. Trên thực tế,
											nó không cần quá rắc rối như vậy. Spread operator có thể giúp bạn thực hiện điều đó.
											
											const arr = [ ‘fatfish’, ‘medium’ ]
											arr.push(…[ ‘JavaScript’, ‘NodeJs’ ])
											console.log(arr) // [‘fatfish’, ‘medium’, ‘JavaScript’, ‘NodeJs’]
				
			Xóa các giá trị trùng lặp khỏi mảng--Spread:
				
											Có thể loại bỏ các mảng giá trị trùng lặp thông qua data structure đã đặt và spread operator.
											
											const arr = [ ‘fatfish’, ‘fatfish’, ‘medium’, ‘medium’ ]
											const uniqueArray = [ …new Set(arr) ]
											console.log(uniqueArray) // [‘fatfish’, ‘medium’]
											
			Chuyển đổi NodeList thành một mảng thực--Spread:
				
											Thao tác với DOM là việc các lập trình viên front-end làm hàng ngày như sử dụng document.querySelectorAll để có được NodeList. Thay vào đó, bạn có thể chuyển đổi nó thành một mảng nhờ
											spread operator. Sau đó, bạn có thể sử dụng forEach, map, v.v.
											
											
											const $divs = document.querySelectorAll(‘div’) // $divs is a NodeList									
											const $arrayDivs = [ …$divs ] // $arrayDivs is An Array
											console.log(Array.isArray($divs), Array.isArray($arrayDivs)) // false true
											
			Spread operator thường được sử dụng để hủy cấu trúc các mảng và đối tượng (Destructuring)--Spread:
					
											const [ num0, …others ] = [ 1, 2, 3, 4, 5, 6 ]
											console.log(num0) // 1
											console.log(others) // [2, 3, 4, 5, 6]
											
											const obj = { name: ‘fatfish’, age: 100, luckyNumber: 6 }
											const { name, …other } = obj
											console.log(name) // fatfish
											console.log(other) // { age: 100, luckyNumber: 6 }
				
			Chuyển đổi chuỗi thành mảng--Spread:
				
											Với spread operator, bạn có thể chuyển đổi chuỗi thành mảng một cách dễ dàng và nhanh chóng. Ví dụ:
											
											const name = ‘fatfish’
											const nameArray = [ …name ] // [‘f’, ‘a’, ‘t’, ‘f’, ‘i’, ‘s’, ‘h’]
											
			Thêm phần tử vào mảng--Spread:
					
											let arr1 = [1, 2, 3];										
											arr1 = [...arr1, 4]; // Thêm phần tử vào mảng bằng toán tử Spread
											console.log(arr1); // [1, 2, 3, 4]
											
			Thêm thuộc tính vào đối tượng--Spread:
				
											const SinhVien = {
												ten: "Ngọc Anh",
												gioiTinh: "Nữ"
											};
											const ketQua = {...SinhVien, tuoi: 18 }; // Thêm thuộc tính cho đối tượng bằng toán tử spread. { ten: "Ngọc Anh", gioiTinh: "Nữ", tuoi: 18 }
	
	Truthy và Falsy--JAVASCRIPT:
											Truthy value là những giá trị trong Javascript mà khi ép kiểu về Boolean thì sẽ cho ra giá trị là true. Ngược lại, Falsy value là những giá trị mà khi ép kiểu
											về Boolean thì cho ra giá trị là false.
		Truthy Values:
											Chuỗi khác rỗng, số khác 0 và tất cả các object. // Bao gồm cả [ ] và { } vì mảng rỗng và chuỗi rỗng vẫn là object.
		Falsy Values:
											undefined, null, false, 0, -0, 0n, NaN, ''.
	Regex--JAVASCRIPT:
		split(/[\\/]/):
											Ký tự nào là dấu gạch chéo (backslash) hoặc dấu gạch chéo chéo (forward slash). Trong biểu thức chính quy, dấu gạch chéo (\) cần được đặt trong dấu ngoặc vuông để thoát, vì dấu gạch chéo là một ký tự đặc biệt trong
											biểu thức chính quy.
											
											const str = 'path\\to\\file';
											const parts = str.split(/[\\/]/);
											console.log(parts); // Kết quả: ['path', 'to', 'file']
	FormData--JAVASCRIPT:
										- Nếu bạn đang phát triển những ứng dụng web kiểu SPA (single-page application) hay sử dụng PPE (practicing progressive enhancement), bạn sẽ thường phải chặn việc submit form và sử
										dụng ajax để xử lý dữ liệu form gửi lên. Chẳng hạn chúng ta có 2 bài toán:
													Bạn có 1 form chỉ chứa các input text, password, không có nút submit. Làm sao để submit form đó?
													Bạn có 1 form bao gồm các input text, password..., file input, không có nút submit. Làm sao để submit form đó?
													Yêu cầu thêm: cần validate form:		
																							Các input bắt buộc phải nhập.
																							Các file input bắt buộc phải chọn, upload lên server.
																							Chúng ta có thể xử lý bài toán này chẳng hạn như sử dụng jquery ajax, post, hay javascript submit.... Có rất nhiều cách hay để xử lý
																							những yêu cầu như trên.
										- Với HTML5 chúng ta có thể sử dụng FormData, nó cho phép chúng ta xây dựng các đối tượng form tự động, có thể bao gồm cả các tệp tin từ hệ thống tệp tin của người dùng và sau đó gửi
										form này thông qua AJAX.
										- Với FormData, chúng ta có thể submit dữ liệu lên server thông qua AJAX như là đang submit form bình thường.
										- jQuery ajax mặc định sẽ truyền dữ liệu lên với ContentType: application/x-www-form-urlencoded, đối với việc truyền dữ liệu có upload cả file lên, chúng ta phải ngăn không
										cho ajax truyền lên với ContentType mặc định.
										- Việc sử dụng contentType: false, khi truyền dữ liệu lên, contentType sẽ được chuyển thành: multipart/form-data. Điều đó cho phép chúng ta có thể upload file lên dễ dàng.
										- Vậy để 'nuốt gọn' bài toán đưa ra:
												Với bài 1:
																var formData = new FormData($('#formData')[0]);
																$.ajax({
																	...
																	data: formData
																	...
																});
												Với bài 2:
																var formData = new FormData($('#formData')[0]);
																$.ajax({
																	...
																	processData: false,
																	contentType: false,
																	data: formData
																	...
																});
										- Có nhiều cách để khởi tạo một FormData, nó tương tự việc bạn serialize dữ liệu của một form để gửi lên server:
													
													var formData = new FormData(); // Không cần form													
													var formData = new FormData(document.getElementById('formID')); // Sử dụng js thuần													
													var formData = new FormData($('form#formID')[0]); // Sử dụng jquery
		Phương thức append():
													Thông thường để chèn thêm một giá trị nào đó mà không có input trên form, chúng ta thường dùng js chèn thêm input hidden. Phương thức append cho phép chúng ta chèn thêm một
													cặp key => value vào trong FormData, chúng ta có thể sử dụng để chèn giá trị mới cho key có sẵn hoặc chèn mới tương tự việc update giá trị cho input hay chèn thêm input
													hidden ở trong FormData
													name: tên của input (field) sẽ chứa giá trị chèn vào.
													value: giá trị của key, có thể là USVString hoặc Blob
													filename: tên của file gửi lên server.
																										
													formData.append(name, value);
													formData.append(name, value, filename);											
		Phương thức delete():
													Phương thức delete cho phép xóa key và value của nó ra khỏi FormData.
													
													formData.delete(name);
		Phương thức get():
													Phương thức get trả về giá trị đầu tiên tương ứng với key truyền vào.
																									
													var formData = new FormData(); // init form data
													// append data
													formData.append('username', 'Chris');
													formData.append('username', 'Bob');												
													formData.get('username'); // Returns "Chris" // get data
		Phương thức getAll():
													Phương thức này trả về tất cả giá trị tương ứng với key của FormData.
													
													
													var formData = new FormData(); // init form data
													// append data
													formData.append('username', 'Chris');
													formData.append('username', 'Bob');													
													formData.get('username'); // Returns "Chris" // get first username
													formData.getAll('username'); // Returns ["Chris", "Bob"]. get all username
		Phương thức has():
													Phương thức has trả về giá trị boolean kiểm tra xem FormData có chứa key truyền vào hay không.
																									
													var formData = new FormData(); // init form data
													// Check form data has key
													formData.has('username'); // Returns false
													formData.append('username', 'Chris');
													formData.has('username'); // Returns true
		Phương thức entries():
													Phương thức entries trả về một iterator cho phép truy xuất tất cả các cặp key/value.
																									
													var formData = new FormData(); // Create a test FormData object
													formData.append('key1', 'value1');
													formData.append('key2', 'value2');
													// Display the key/value pairs
													for(var pair of formData.entries()) {
													   console.log(pair[0]+ ', '+ pair[1]); // key1, value1. key2, value2
													}
		Phương thức keys():
													Phương thức keys trả về một đối tượng Iterator chứa các key trong FormData.
																								
													var formData = new FormData(); // Create a test FormData object
													formData.append('key1', 'value1');
													formData.append('key2', 'value2');
													// Display the keys
													for (var key of formData.keys()) {
													   console.log(key); // key1 key2
													}
		Phương thức values():
													Phương thức values trả về tất cả giá trị có trong FormData. Kết quả trả về là một Iterator
																									
													var formData = new FormData(); // Create a test FormData object
													formData.append('key1', 'value1');
													formData.append('key2', 'value2');
													// Display the values
													for (var value of formData.values()) {
													   console.log(value); // value1 value2
													}
		Phương thức set():
													Phương thức set giúp chúng ta gán giá trị cho một key tương ứng trong FormData, nếu key không tồn tại sẽ tạo mới, ngược lại sẽ ghi đè tất cả giá trị cũ bằng giá trị mới của key tương ứng.
													name: tên của trường chúng ta cần gán giá trị (key).
													value: giá trị cần gán.
													filename: tên của file nếu cần.
													
													formData.set(name, value);
													formData.set(name, value, filename);
																									
													var formData = new FormData();
													formData.append('username', 'Chris');   // add new
													formData.set('username', 'Bob');   // overwrite
													formData.set('userpic', myFileInput.files[0], 'chris.jpg'); // add new
	Import và Export--JAVASCRIPT:
							
							- Trong JavaScript, có hai cách để import các thành phần từ một tệp (module) khác: import mặc định (default import) và import thông thường (named import). Cả hai cách đều cho
							phép bạn sử dụng mã từ một tệp trong tệp khác, nhưng cú pháp và cách thức sử dụng có một số điểm khác nhau quan trọng.
								Import mặc định (Default import): 		Được sử dụng khi một module xuất một giá trị duy nhất mà không cần tên, thường được sử dụng với export default. Khi bạn import một
																		module theo cách này, bạn có thể đặt tên bất kỳ cho giá trị được import.
								Import thông thường (Named import): 	Được sử dụng khi một module xuất nhiều giá trị hoặc khi bạn muốn chọn những thành phần cụ thể mà bạn muốn import.
																		Khi bạn sử dụng cách này, tên của các thành phần cần phải trùng với tên đã được export.									
								Export mà không có {} (Default export): Khi bạn sử dụng cú pháp này, bạn có thể export một giá trị duy nhất từ một module. Giá trị được export có thể là bất cứ loại dữ
																		liệu nào, bao gồm một class, một hàm, một biến hoặc một đối tượng.
								Export với {} (Named export): 			Khi bạn sử dụng cú pháp này, bạn cần chỉ định tên của thành phần cụ thể mà bạn muốn export từ module. Điều này cho phép bạn xuất
																								nhiều thành phần từ cùng một module, và khi import, bạn cũng cần chỉ định tên chính xác của thành phần đó.
		Export Default:
													// Trong tệp MyClass.js
													class MyClass {
													  // ...
													}
													export default MyClass;
													// Trong tệp khác
													import MyClass from './MyClass';
		Export Default với đối tượng chứa:
													// Trong tệp MyClass.js
													class MyClass {
													  // ...
													}
													export default { MyClass };
		Export bình thường:
													// Trong tệp MyClass.js
													export class MyClass {
													  // ...
													}
													// Trong tệp khác
													import { MyClass } from './MyClass';
		Export nhiều thành phần:
													// Trong tệp MyClass.js
													export class MyClass1 {
													  // ...
													}
													export class MyClass2 {
													  // ...
													}
													// Trong tệp khác
													import { MyClass1, MyClass2 } from './MyClass';
		Export tất cả:
													// Trong tệp MyClass.js
													class MyClass1 {
													  // ...
													}
													class MyClass2 {
													  // ...
													}
													export { MyClass1, MyClass2 };
													// Trong tệp khác
													import * as MyClass from './MyClass';
													// Sử dụng MyClass.MyClass1, MyClass.MyClass2
	
	this--JAVASCRIPT:
	
		In JavaScript, the this keyword refers to an object.

		Which object depends on how this is being invoked (used or called).

		The this keyword refers to different objects depending on how it is used:
		
			In an object method, this refers to the object.
			Alone, this refers to the global object.
			In a function, this refers to the global object.
			In a function, in strict mode, this is undefined.
			In an event, this refers to the element that received the event.
			Methods like call(), apply(), and bind() can refer this to any object.
	
	Numbers--JAVASCRIPT:
	
													With JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties.
													
		The toString() Method--Numbers Javascript:
		
													- The toString() method returns a number as a string.
													- All number methods can be used on any type of numbers (literals, variables, or expressions)
													
													<script>
													let x = 123;
													document.getElementById("demo").innerHTML =
													  x.toString() + "<br>" + // 123
													   (123).toString() + "<br>" + // 123
													   (100 + 23).toString(); // 123
													</script>
													
		The toExponential() Method--Numbers Javascript:
		
													- toExponential() returns a string, with a number rounded and written using exponential notation.
													- A parameter defines the number of characters behind the decimal point
													- The parameter is optional. If you don't specify it, JavaScript will not round the number.
													
													<script>
													let x = 9.656;
													document.getElementById("demo").innerHTML =
													  x.toExponential() + "<br>" + // 9.656e+0 // 10
													  x.toExponential(2) + "<br>" + // 9.66e+0 // 9.66
													  x.toExponential(4) + "<br>" + // 9.6560e+0 // 9.6560
													  x.toExponential(6); // 9.656000e+0 // 9.656000
													</script>															
													
		The toFixed() Method--Numbers Javascript:
		
													toFixed() returns a string, with the number written with a specified number of decimals
													
													<script>
													let x = 9.656;
													document.getElementById("demo").innerHTML =
													  x.toFixed(0) + "<br>" +
													  x.toFixed(2) + "<br>" +
													  x.toFixed(4) + "<br>" +
													  x.toFixed(6);
													</script>
													
		The toPrecision() Method--Numbers Javascript:
		
													toPrecision() returns a string, with a number written with a specified length:
													
													<script>
													let x = 9.656;
													document.getElementById("demo").innerHTML = 
													  x.toPrecision() + "<br>" + // 9.656
													  x.toPrecision(2) + "<br>" + // 9.7
													  x.toPrecision(4) + "<br>" + // 9.656
													  x.toPrecision(6); // 9.65600
													</script>
													
		The valueOf() Method--Numbers Javascript:
		
													- valueOf() returns a number as a number.
													- In JavaScript, a number can be a primitive value (typeof = number) or an object (typeof = object).
													- The valueOf() method is used internally in JavaScript to convert Number objects to primitive values.
													- There is no reason to use it in your code.
													- All JavaScript data types have a valueOf() and a toString() method.
													
													<script>
													let x = 123;
													document.getElementById("demo").innerHTML = 
													  x.valueOf() + "<br>" + // 123
													  (123).valueOf() + "<br>" + // 123
													  (100 + 23).valueOf(); // 123
													</script>
													
		The Number() Method--Numbers Javascript:
		
													- Number() can be used to convert JavaScript variables to numbers:
													- If the number cannot be converted, NaN (Not a Number) is returned.
													
													<script>
													document.getElementById("demo").innerHTML = 
													  Number(true) + "<br>" +
													  Number(false) + "<br>" +
													  Number("10") + "<br>" + 
													  Number("  10") + "<br>" +
													  Number("10  ") + "<br>" +
													  Number(" 10  ") + "<br>" +
													  Number("10.33") + "<br>" + 
													  Number("10,33") + "<br>" +
													  Number("10 33") + "<br>" +
													  Number("John");
													</script>
													
		The Number() Method Used on Dates--Numbers Javascript:
		
													- Number() can also convert a date to a number.
													- The Number() method returns the number of milliseconds since 1.1.1970.

													<script>
													let x = new Date("1970-01-01");
													document.getElementById("demo").innerHTML = Number(x); // 0
													</script>
													
													<script>
													let x = new Date("1970-01-03");
													document.getElementById("demo").innerHTML = Number(x); // 172800000
													</script>
													
		The parseInt() Method--Numbers Javascript:
		
													- parseInt() parses a string and returns a whole number. Spaces are allowed. Only the first number is returned
													- If the number cannot be converted, NaN (Not a Number) is returned.
													
													<script>
													document.getElementById("demo").innerHTML = 
													  parseInt("-10") + "<br>" + // -10
													  parseInt("-10.33") + "<br>" + // -10
													  parseInt("10") + "<br>" + // 10
													  parseInt("10.33") + "<br>" + // 10
													  parseInt("10 6") + "<br>" + // 10
													  parseInt("20 abc") + "<br>" + // 20  
													  parseInt("abc 20"); // NaN
													</script>
													
		The parseFloat() Method--Numbers Javascript:
		
													- parseFloat() parses a string and returns a number. Spaces are allowed. Only the first number is returned
													- If the number cannot be converted, NaN (Not a Number) is returned.
													
													<script>
													document.getElementById("demo").innerHTML = 
													  parseFloat("10") + "<br>" + // 10
													  parseFloat("10.33") + "<br>" + // 10.33
													  parseFloat("10 6") + "<br>" +  // 10
													  parseFloat("10 years") + "<br>" + // 10
													  parseFloat("years 10"); // NaN
													</script>
													
	Math Object--JAVASCRIPT:
	
		Math.round()--Javascript Math Object:
		
													Math.round(x) returns the nearest integer
													
													<script>
													document.getElementById("demo").innerHTML = Math.round(4.6); // 5
													document.getElementById("demo").innerHTML = Math.round(4.5); // 5
													document.getElementById("demo").innerHTML = Math.round(4.4); // 5
													</script>
													
		Math.ceil()--Javascript Math Object:
		
													Math.ceil(x) returns the value of x rounded up to its nearest integer
													
													<script>
													document.getElementById("demo").innerHTML = Math.ceil(4.4); // 5
													</script>
													
		Math.floor()--Javascript Math Object:
		
													Math.floor(x) returns the value of x rounded down to its nearest integer
													
													<script>
													document.getElementById("demo").innerHTML = Math.floor(4.7); // 4
													</script>
													
		Math.trunc()--Javascript Math Object:
		
													Math.trunc(x) returns the integer part of x
													
													<script>
													document.getElementById("demo").innerHTML = Math.trunc(4.7); // 4
													</script>
													
		Math.sign()--Javascript Math Object:
		
													Math.sign(x) returns if x is negative, null or positive
													
													<script>
													document.getElementById("demo").innerHTML = Math.sign(4); // 1
													document.getElementById("demo").innerHTML = Math.sign(0); // 0
													document.getElementById("demo").innerHTML = Math.sign(-4); // -1
													</script>
													
		Math.pow()--Javascript Math Object:
		
													Math.pow(x, y) returns the value of x to the power of y
													
													<script>
													document.getElementById("demo").innerHTML = Math.pow(8,2); // 64
													</script>
													
		Math.sqrt()--Javascript Math Object:

													Math.sqrt(x) returns the square root of x
													
													<script>
													document.getElementById("demo").innerHTML = Math.sqrt(64); // 8
													</script>
													
		Math.abs()--Javascript Math Object:
		
													Math.abs(x) returns the absolute (positive) value of x
													
													<script>
													document.getElementById("demo").innerHTML = Math.abs(-4.7); // 4.7
													</script>
													
		Math.sin()--Javascript Math Object:
		
													- If you want to use degrees instead of radians, you have to convert degrees to radians
													- Angle in radians = Angle in degrees x PI / 180.
													
													<script>
													document.getElementById("demo").innerHTML = "The sine value of 90 degrees is " + Math.sin(90 * Math.PI / 180); // 1
													</script>
													
		Math.cos()--Javascript Math Object:
		
													- If you want to use degrees instead of radians, you have to convert degrees to radians
													- Angle in radians = Angle in degrees x PI / 180.
													
													<script>
													document.getElementById("demo").innerHTML = "The cosine value of 0 degrees is " + Math.cos(0 * Math.PI / 180); // 1
													</script>
													
		Math.min() and Math.max()--Javascript Math Object:
		
													Math.min() and Math.max() can be used to find the lowest or highest value in a list of arguments
													
													<script>
													document.getElementById("demo").innerHTML = Math.min(0, 150, 30, 20, -8, -200); // -200
													document.getElementById("demo").innerHTML = Math.max(0, 150, 30, 20, -8, -200); // 150
													</script>
													
		Math.random()--Javascript Math Object:
		
													Math.random() returns a random number between 0 (inclusive), and 1 (exclusive)
													
													<script>
													document.getElementById("demo").innerHTML = Math.random(); // 0.00954...
													</script>
													
		The Math.log(), Math.log2(), Math.log10() Method--Javascript Math Object:
		
													- Math.log(x) returns the natural logarithm of x.
													- The natural logarithm returns the time needed to reach a certain level of growth
													
													<script>
													document.getElementById("demo").innerHTML = Math.log(1); // 0
													document.getElementById("demo").innerHTML = Math.log2(8); // 3
													document.getElementById("demo").innerHTML = Math.log10(1000); // 3
													</script>
													
	JavaScript Object Maps--JAVASCRIPT:
	
													- A Map holds key-value pairs where the keys can be any datatype.
													- A Map remembers the original insertion order of the keys.
													
		How to Create a Map--JavaScript Object Maps:

			Passing an Array to new Map():
			
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits.get("apples"); // 500
													</script>
			
			Create a Map and use Map.set():
			
													- You can add elements to a Map with the set() method
													- The set() method can also be used to change existing Map values
													
													<script>
													// Create a Map
													const fruits = new Map();
													// Set Map Values
													fruits.set("apples", 500);
													fruits.set("bananas", 300);
													fruits.set("oranges", 200);
													document.getElementById("demo").innerHTML = fruits.get("apples");
													</script>
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],s
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													fruits.set("apples", 200);
													document.getElementById("demo").innerHTML = fruits.get("apples"); // 200
													</script>
													
		Map.get()--JavaScript Object Maps:
		
													The get() method gets the value of a key in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits.get("apples"); // 500
													</script>
													
		Map.size--JavaScript Object Maps:
		
													The size property returns the number of elements in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits.size; // 3
													</script>
													
		Map.delete()--JavaScript Object Maps:
		
													The delete() method removes a Map element
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													// Delete an Element
													fruits.delete("apples");
													document.getElementById("demo").innerHTML = fruits.size; // 2
													</script>
													
		Map.clear()--JavaScript Object Maps:
		
													The clear() method removes all the elements from a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													// Clear the Map
													fruits.clear();
													document.getElementById("demo").innerHTML = fruits.size; // 0
													</script>
													
		Map.has()--JavaScript Object Maps:
		
													The has() method returns true if a key exists in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits.has("apples"); // true
													</script>
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits.has("apples"); // false
													</script>
													
		Maps are Objects--JavaScript Object Maps:
		
													- typeof returns object
													- instanceof Map returns true
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = typeof fruits; // object
													</script>
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													document.getElementById("demo").innerHTML = fruits instanceof Map; // true
													</script>
													
		Map.forEach()--JavaScript Object Maps:
		
													The forEach() method invokes a callback for each key/value pair in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													let text = "";
													fruits.forEach (function(value, key) {
													  text += key + ' = ' + value + "<br>"
													})
													document.getElementById("demo").innerHTML = text; // apples = 500 bananas = 300 oranges = 200
													</script>
													
		Map.entries()--JavaScript Object Maps:
		
													The entries() method returns an iterator object with the [key,values] in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													let text = "";
													for (const x of fruits.entries()) {
													  text += x + "<br>";
													}
													document.getElementById("demo").innerHTML = text; // apples,500 bananas,300 oranges,200
													</script>
													
		Map.keys()--JavaScript Object Maps:
		
													The keys() method returns an iterator object with the keys in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													let text = "";
													for (const x of fruits.keys()) {
													  text += x + "<br>";
													}
													document.getElementById("demo").innerHTML = text; // apples bananas oranges
													</script>
													
		Map.values()--JavaScript Object Maps:
		
													The values() method returns an iterator object with the values in a Map
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													let text = "";
													for (const x of fruits.values()) {
													  text += x + "<br>";
													}
													document.getElementById("demo").innerHTML = text;
													</script>
													
													<script>
													// Create a Map
													const fruits = new Map([
													  ["apples", 500],
													  ["bananas", 300],
													  ["oranges", 200]
													]);
													let total = 0;
													for (const x of fruits.values()) {
													  total += x;
													}
													document.getElementById("demo").innerHTML = total; // 1000
													</script>
													
		Objects as Keys--JavaScript Object Maps:
		
													- Being able to use objects as keys is an important Map feature.
													- Remember: The key is an object (apples), not a string ("apples")
													
													<script>
													// Create Objects
													const apples = {name: 'Apples'};
													const bananas = {name: 'Bananas'};
													const oranges = {name: 'Oranges'};
													// Create a Map
													const fruits = new Map();
													// Add the Objects to the Map
													fruits.set(apples, 500);
													fruits.set(bananas, 300);
													fruits.set(oranges, 200);
													document.getElementById("demo").innerHTML = fruits.get(apples);
													</script>
													
													<script>
													// Create Objects
													const apples = {name: 'Apples'};
													const bananas = {name: 'Bananas'};
													const oranges = {name: 'Oranges'};
													// Create a Map
													const fruits = new Map();
													// Add Elements to the Map
													fruits.set(apples, 500);
													fruits.set(bananas, 300);
													fruits.set(oranges, 200);
													document.getElementById("demo").innerHTML = fruits.get("apples");
													</script>
	
	JavaScript Object Sets--JAVASCRIPT:
	
													- A JavaScript Set is a collection of unique values.
													- Each value can only occur once in a Set.
													- A Set can hold any value of any data type.
													
		How to Create a Set--JAVASCRIPT Object Sets:
		
													Passing an Array to new Set()
													Create a new Set and use add() to add values
													Create a new Set and use add() to add variables
													
		The new Set() Method--JAVASCRIPT Object Sets:
		
			Pass an Array to the new Set() constructor:

													<script>
													// Create a Set
													const letters = new Set(["a","b","c"]);
													// Display set.size
													document.getElementById("demo").innerHTML = letters.size; // 3
													</script>
													
			Create a Set and add literal values:
			
													<script>
													// Create a Set
													const letters = new Set();
													// Add Values to the Set
													letters.add("a");
													letters.add("b");
													letters.add("c");
													// Display set.size
													document.getElementById("demo").innerHTML = letters.size; // 3
													</script>
													
			Create a Set and add variables:
			
													<script>
													// Create a Set
													const letters = new Set();
													// Create Variables
													const a = "a";
													const b = "b";
													const c = "c";
													// Add the Variables to the Set
													letters.add(a);
													letters.add(b);
													letters.add(c);
													// Display set.size
													document.getElementById("demo").innerHTML = letters.size; // 3
													</script>
													
		The add() Method--JAVASCRIPT Object Sets:
													If you add equal elements, only the first will be saved
													
													<script>
													// Create a new Set
													const letters = new Set(["a","b","c"]);
													// Add a new Element
													letters.add("d");
													letters.add("e");
													// Display set.size
													document.getElementById("demo").innerHTML = letters.size; // 5
													</script>
													
													<script>
													// Create a Set
													const letters = new Set();
													// Add values to the Set
													letters.add("a");
													letters.add("b");
													letters.add("c");
													letters.add("c");
													letters.add("c");
													letters.add("c");
													letters.add("c");
													letters.add("c");
													// Display set.size
													document.getElementById("demo").innerHTML = letters.size; // 3
													</script>
													
		The values() Method--JAVASCRIPT Object Sets:
		
													- The values() method returns an Iterator object containing all the values in a Set
													- Now you can use the Iterator object to access the elements
													
													<script>
													// Create a Set
													const letters = new Set(["a","b","c"]);
													// Display set.size
													document.getElementById("demo").innerHTML = letters.values(); // [object Set Iterator]
													</script>
													
													<script>
													// Create a Set
													const letters = new Set(["a","b","c"]);
													// List all Elements
													let text = "";
													for (const x of letters.values()) {
													  text += x + "<br>";
													}
													document.getElementById("demo").innerHTML = text; // a b c
													</script>
													
		The keys() Method--JAVASCRIPT Object Sets:
		
													- A Set has no keys.
													- keys() returns the same as values().
													- This makes Sets compatible with Maps.
													
													<script>
													// Create a Set
													const letters = new Set(["a","b","c"]);
													// Display set.size
													document.getElementById("demo").innerHTML = letters.keys(); // [object Set Iterator]
													</script>
													
		The entries() Method--JAVASCRIPT Object Sets:
		
													- A Set has no keys.
													- entries() returns [value,value] pairs instead of [key,value] pairs.
													- This makes Sets compatible with Maps
													
													<script>
													// Create a Set
													const letters = new Set(["a","b","c"]);
													// List all entries
													const iterator = letters.entries();
													let text = "";
													for (const entry of iterator) {
													  text += entry + "<br>";
													}
													document.getElementById("demo").innerHTML = text; // a,a b,b c,c
													</script>
													
		Sets are Objects--JAVASCRIPT Object Sets:
		
													- For a Set, typeof returns object
													- For a Set, instanceof Set returns true
													
													<script>
													// Create a new Set
													const letters = new Set(["a","b","c"]);
													// Display typeof
													document.getElementById("demo").innerHTML = typeof letters; // object
													</script>
													
													<script>
													// Create a new Set
													const letters = new Set(["a","b","c"]);
													// Display typeof
													document.getElementById("demo").innerHTML = letters instanceof Set; // true
													</script>
	
	Moment--JAVASCRIPT:
	
													- Moment.js là một thư viện mạnh dùng để thao tác xử lý datetime trong javascript.
													- Moment.js được thiết kế hoạt động trong cả browser và Node.js
													
		Có thể tải moment.js tại đây Cài đặt moment.js--JAVASCRIPT Moment:
		
													npm install moment --save   # npm
													yarn add moment             # Yarn
													Install-Package Moment.js   # NuGet
													spm install moment --save   # spm
													meteor add momentjs:moment  # meteor
													bower install moment --save # bower (deprecated)
													
		Nếu bạn cài đặt bằng npm, bạn cần import thư viện moment.js ở trong code của bạn (ví dụ với ES Modules)--JAVASCRIPT Moment:
														
													import moment from 'moment'
													
		hoặc cú pháp require (sử dụng CommonJS)--JAVASCRIPT Moment:
													
													const moment = require('moment')
													
		Lấy ngày và giờ hiện tại--JAVASCRIPT Moment:
			
													const date = moment() // date là một đối tượng moment
		
		Convert một string thành đối tượng moment date--JAVASCRIPT Moment:
			
			Một đối tượng moment có thể được khởi tạo với một string đại diện cho một giá trị date:			
				
													const date = moment(string)
			
			Nó chấp nhận bất kỳ format  nào, các format được dùng để chuyển từ string thành date (theo thứ tự ưu tiên từ trên xuống dưới):
				ISO 8601
				The RFC 2822 Date Time format
				Các format được chấp nhận bởi đối tượng Date native
					ISO 8601  là tiện lợi nhất. Đây là tài liệu tham khảo định dạng theo format ISO 8601:
				Format	Meaning															Example
				YYYY	4-digits Year													2018
				YY		2-digits Year													18
				M		2-digits Month number, omits leading 0							7
				MM		2-digits Month number											07
				MMM		3-letters Month name											Jul
				MMMM	Full Month name													July
				dddd	Full day name													Sunday
				gggg	4-digits Week year												2018
				gg		2-digits Week year												18
				w		Week of the year without leading zero							18
				ww		Week of the year with leading zero								18
				e		Day of the week, starts at 0									4
				D		2-digits day number, omits leading 0							9
				DD		2-digits day number												09
				Do		Day number with ordinal											9th
				T		Indicates the start of the time part	 					
				HH		2-digits hours (24 hour time) from 0 to 23						22
				H		2-digits hours (24 hour time) from 0 to 23 without leading 0	22
				kk		2-digits hours (24 hour time) from 1 to 24	23
				k		2-digits hours (24 hour time) from 1 to 24 without leading 0	23
				a/A		am or pm														pm
				hh		2-digits hours (12 hour time)									11
				mm		2-digits minutes												22
				ss		2-digits seconds												40
				s		2-digits seconds without leading zero							40
				S		1-digits milliseconds											1
				SS		2-digits milliseconds											12
				SSS		3-digits milliseconds											123
				Z		The timezone													+02:00
				x		UNIX timestamp in milliseconds									1410432140575
			
			Ví dụ
				
				var day = moment("1995-12-25");
		
		Chuyển đối tượng moment date sang string--JAVASCRIPT Moment:
			
			Khi bạn muốn in ra một giá trị ngày tháng bằng đối tượng Date native của Javascript, bạn có rất ít tùy chọn để định dạng thông tin ngày tháng từ đối tượng Date. Bạn có thể tự xây dựng cách format đối tượng Date
			theo cách của bạn bằng cách sử dụng các phương thức có sẵn.
			
			Moment cung cấp một cách thuận tiện để định dạng ngày theo nhu cầu của bạn, sử dụng phương thức .format():
				
				date.format(string)
				
			Format được chấp nhận giống như format được mô tả ở phần “Convert một string thành đối tượng moment date” ở trên.
			
			Ví dụ:
				
				moment().format("YYYY Do MM") // "2019 3rd 06"
				
			Moment còn cung cấp một số hằng số định dạng chuẩn, bạn có thể sử dụng chúng thay vì viết định dạng của riêng bạn:
				Constant										Format							Example
				moment.HTML5_FMT.DATETIME_LOCAL					YYYY-MM-DDTHH:mm				2017-12-14T16:34
				moment.HTML5_FMT.DATETIME_LOCAL_SECONDS			YYYY-MM-DDTHH:mm:ss				2017-12-14T16:34:10
				moment.HTML5_FMT.DATETIME_LOCAL_MS				YYYY-MM-DDTHH:mm:ss.SSS			2017-12-14T16:34:10.234
				moment.HTML5_FMT.DATE							YYYY-MM-DD						2017-12-14
				moment.HTML5_FMT.TIME							HH:mm							16:34
				moment.HTML5_FMT.TIME_SECONDS					HH:mm:ss						16:34:10
				moment.HTML5_FMT.TIME_MS						HH:mm:ss.SSS					16:34:10.234
				moment.HTML5_FMT.WEEK							YYYY-[W]WW						2017-W50
				moment.HTML5_FMT.MONTH							YYYY-MM							2017-12
		
		Kiểm tra định dạng ngày tháng--JAVASCRIPT Moment:
		
			Bất kỳ ngày nào cũng có thể được kiểm tra tính hợp lệ bằng phương thức .isValid ():
				moment('2019-13-23').isValid() //false
				moment('2019-11-23').isValid() //true
		
		Khoảng thời gian từ quá khứ, tương lai (cho tới ngày)--JAVASCRIPT Moment:
			
			Phương thức .fromNow() được sử dụng để lấy ra một string cho biết thời gian được cung cấp so với thời điểm hiện tại.
				
				// today: 2019-06-03
				moment('2016-11-23').fromNow() // "3 years ago"
				moment('2019-05-23').fromNow() // "11 days ago"
				moment('2019-11-23').fromNow() // "in 6 months"
				
			Nếu bạn truyền tham số  fromNow() là true, hàm chỉ chỉ hiển thị sự khác biệt, không tham chiếu đến tương lai (in) / quá khứ(ago).
				
				moment('2016-11-23').fromNow() // "3 years"
				moment('2019-05-23').fromNow() // "11 days"
				moment('2019-11-23').fromNow() // "6 months"
				
		Thao tác tính toán với một đối tượng Moment date--JAVASCRIPT Moment:
			
			Bạn có thể thêm hoặc bớt bất kỳ khoảng thời gian nào cho một ngày:
				
				moment('2018-11-23').add(1, 'years')
				moment('2018-11-23').subtract(1, 'years')
			
			Bạn có thể sử dụng các giá trị:
				
				years, quarters, months, weeks, days, hours, minutes, seconds, milliseconds
		
		Parse--JAVASCRIPT Moment:
			
			Thay vì sửa đổi Date.prototype nguyên bản, Moment.js tạo một wrapper cho Date object. Để có được đối tượng wrapper này, chỉ cần gọi moment () với một trong các loại đầu vào được hỗ trợ.
			Moment.prototype được thể hiện qua moment.fn . Nếu bạn muốn thêm các chức năng của riêng bạn, đó là nơi bạn sẽ đặt chúng.
			Để dễ tham chiếu, bất kỳ phương pháp nào trên Moment.prototype sẽ được tham chiếu trong các tài liệu như moment#method. Nên Moment.prototype.format == moment.fn.format == moment#format.
			
			Now
				
				Cú pháp moment(); Để có được ngày và giờ hiện tại, chỉ cần gọi moment () mà không có tham số.
					var now = moment();
			
			String
				
				Cú pháp: moment(String);
					var day = moment("1995-12-25");
			
			String + Format
				
				Định dạng moment theo chuẩn quy định Cú pháp:
					moment(String, String);
					moment(String, String, String);
					moment(String, String, Boolean);
					moment(String, String, String, Boolean);
				
				Nếu bạn biết định dạng của một chuỗi đầu vào, bạn có thể sử dụng nó để phân tích một thời điểm.
					moment("12-25-1995", "MM-DD-YYYY");
			
			String + Formats
				
				Cú pháp:			
					moment(String, String[], String, Boolean);
				
				Nếu bạn không biết định dạng chính xác của một chuỗi đầu vào, nhưng biết nó có thể là một trong nhiều, bạn có thể sử dụng một mảng các định dạng.
					moment("12-25-1995", ["MM-DD-YYYY", "YYYY-MM-DD"]);
			
			Date
			
				Cú pháp: moment(Date); Bạn có thể tạo Moment với đối tượng Javascript Date native sẵn có. Ví dụ:
					var day = new Date(2011, 9, 16);
					var dayWrapper = moment(day);
			
			Array
				
				Cú pháp
					moment(Number[]);
				
				Bạn có thể tạo ra một moment với một mảng các con số phản chiếu các tham số được truyền đến new Date() [year, month, day, hour, minute, second, millisecond]
					moment([2010, 1, 14, 15, 25, 50, 125]); // February 14th, 3:25:50.125 PM
			
			UTC
				
				Cú pháp:
					moment.utc();
					
				moment.utc(Number);
				moment.utc(Number[]);
				moment.utc(String);
				moment.utc(String, String);
				moment.utc(String, String[]);
				moment.utc(String, String, String);
				moment.utc(String, String, Boolean);
				moment.utc(String, String, String, Boolean);
				moment.utc(Moment);
				moment.utc(Date);
				
				Theo mặc định, moment phân tích thời gian và hiển thị theo giờ của local. Nếu bạn muốn parse hay display moment theo UTC, bạn có thể sử dụng moment.utc().
				
		Get + Set--JAVASCRIPT Moment:
		
			Moment.js sử dụng overload getters, setters. Bạn có thể quen thuộc với pattern này từ việc sử dụng nó trong jQuery.
			
			Millisecond
				
				Cú pháp:
					moment().millisecond(Number);
					moment().millisecond(); // Number
					moment().milliseconds(Number);
					moment().milliseconds(); // Number
				
				Lấy hoặc thiết lập mili giây. Chấp nhận số từ 0 đến 999.
			
			Second
				
				Cú pháp:
					moment().second(Number);
					moment().second(); // Number
					moment().seconds(Number);
					moment().seconds(); // Number
				
				Lấy hoặc thiết lập giây. Chấp nhận số từ 0 đến 59.
			
			Minute
				
				Cú pháp:
					moment().minute(Number);
					moment().minute(); // Number
					moment().minutes(Number);
					moment().minutes(); // Number
				
				Lấy hoặc thiết lập phút. Chấp nhận số từ 0 đến 59.
			
			Hour
			
				Cú pháp:
					moment().hour(Number);
					moment().hour(); // Number
					moment().hours(Number);
					moment().hours(); // Number
				
				Lấy hoặc thiết lập giờ. Chấp nhận số từ 0 đến 23.
			
			Date of Month
				
				Cú pháp:
					moment().date(Number);
					moment().date(); // Number
					moment().dates(Number);
					moment().dates(); // Number
				
				Lấy hoặc thiết lập ngày của tháng. Chấp nhận số từ 0 đến 31.
			
			Month
			
				Cú pháp:
					moment().month(Number|String);
					moment().month(); // Number
					moment().months(Number|String);
					moment().months(); // Number
				
				Lấy hoặc thiết lập tháng. Chấp nhận số từ 0 đến 11. Tháng không được lập chỉ mục, vì vậy January là tháng 0.
			
			Year
				
				Cú pháp:
					moment().year(Number);
					moment().year(); // Number
					moment().years(Number);
					moment().years(); // Number
				
				Lấy hoặc thiết lập năm. Chấp nhận số từ -270000 đến 270000.
			
			Get
				
				Cú pháp:
					moment().get('year');
					moment().get('month');  // 0 to 11
					moment().get('date');
					moment().get('hour');
					moment().get('minute');
					moment().get('second');
					moment().get('millisecond');
			
			Set
				
				Cú pháp:
					moment().set(String, Int);
					moment().set(Object(String, Int));
				
				Ví dụ:
				
					moment().set('year', 2013);
					moment().set('month', 3);  // April
					moment().set('date', 1);
					moment().set('hour', 13);
					moment().set('minute', 20);
					moment().set('second', 30);
					moment().set('millisecond', 123);

					moment().set({'year': 2013, 'month': 3});
		
		Manipulate--JAVASCRIPT Moment:
			
			Một khi bạn đã có một moment, bạn có thể muốn thao tác nó. Có một số phương pháp để hỗ trợ thực thi.
			
			Add
			
				Cú pháp:
					moment().add(Number, String);
					moment().add(Duration);
					moment().add(Object);
				
				Đây là một chức năng khá mạnh mẽ để thêm thời gian vào một moment. Để thêm thời gian hãy thêm giá trị cùng với keys phù hợp
					Ví dụ: moment().add(7, 'days');
			
			Subtract
				
				Cú pháp:
					moment().subtract(Number, String);
					moment().subtract(Duration);
					moment().subtract(Object);
				
				Đây là chức năng cộng thêm 1 khoảng thời gian chỉ định cho moment
					Ví dụ: moment().subtract(7, 'days');
			
			Start of Time
				
				Cú pháp: moment().startOf(String); Làm biến đổi moment bằng cách thiết lập nó vào đầu của một đơn vị thời gian.
				
				Ví dụ:
				
					moment().startOf('year');    // set to January 1st, 12:00 am this year
					moment().startOf('month');   // set to the first of this month, 12:00 am
					moment().startOf('quarter');  // set to the beginning of the current quarter, 1st day of months, 12:00 am
					moment().startOf('week');    // set to the first day of this week, 12:00 am
					moment().startOf('isoWeek'); // set to the first day of this week according to ISO 8601, 12:00 am
					moment().startOf('day');     // set to 12:00 am today
					moment().startOf('date');     // set to 12:00 am today
					moment().startOf('hour');    // set to now, but with 0 mins, 0 secs, and 0 ms
					moment().startOf('minute');  // set to now, but with 0 seconds and 0 milliseconds
					moment().startOf('second');  // same as moment().milliseconds(0);
			
			End of Time
				
				Cú pháp: moment().endOf(String); Làm biến đổi moment bằng cách thiết lập nó vào cuối của một đơn vị thời gian.
				
				Ví dụ
					moment().endOf("year"); // set the moment to 12-31 23:59:59.999 this year
		
		Display--JAVASCRIPT Moment:
			
			Sau khi phân tích cú pháp và thao tác được thực hiện, bạn cần một số cách để hiển thị thời điểm.
			
			Format
			
				Cú pháp:
					moment().format();
					moment().format(String);
				
				Ví dụ:
					moment().format();                                // "2014-09-08T08:02:17-05:00" (ISO 8601)
					moment().format("dddd, MMMM Do YYYY, h:mm:ss a"); // "Sunday, February 14th 2010, 3:25:50 pm"
					moment().format("ddd, hA");                       // "Sun, 3PM"
					moment('gibberish').format('YYYY MM DD');         // "Invalid date"
			
			Difference
			
				Cú pháp:
					moment().diff(Moment|String|Number|Date|Array);
					moment().diff(Moment|String|Number|Date|Array, String);
					moment().diff(Moment|String|Number|Date|Array, String, Boolean);
				
				Để có được sự khác biệt trong mili giây, sử dụng moment#diff như bạn sẽ sử dụng moment#from. Ví dụ:
					
					var a = moment([2007, 0, 29]);
					var b = moment([2007, 0, 28]);
					a.diff(b) // 86400000
			
			Days in Month
				
				Cú pháp: moment().daysInMonth(); Get số ngày trong tháng hiện tại.
				
				Ví dụ:
				
					moment("2012-02", "YYYY-MM").daysInMonth() // 29
					moment("2012-01", "YYYY-MM").daysInMonth() // 31
			
			As Javascript Date
				
				Cú pháp: moment().toDate(); Để lấy một bản sao của đối tượng Date mà Moment.js wraps, hãy sử dụng moment # toDate.
			
			As Array
				
				Cú pháp: moment().toArray(); Điều này trả về một mảng số tham chiếu từ các tham số new Date().
				
				Ví dụ: moment().toArray(); // [2013, 1, 4, 14, 40, 16, 154];
			
			As String
				
				Cú pháp: moment().toString(); Trả về một chuỗi tiếng Anh ở định dạng tương tự như .toString () của JS Date.
				
				Ví dụ: moment().toString() // "Sat Apr 30 2016 16:59:46 GMT-0500"				
	
	super()--JAVASCRIPT:
	
			Super() để làm gì ?--super() JAVASCRIPT:
							
							Sử dụng super() trong JavaScript có ý nghĩa gì ? Về cơ bản, trong một child class (class con), bạn sử dụng super() để gọi ra constructor của parent class (class cha) của nó và sử dụng
							super.<methodName> để gọi tới các methods trong class cha của nó.

			"Kế thừa" class cha--super() JAVASCRIPT:

							Super() không phải chỉ mỗi JavaScript mới có — rất nhiều ngôn ngữ lập trình khác như Java hay Python cũng có khái niệm này. Chúng ta sử dụng super() để tạo ra một "liên kết" (reference) từ class con tới
							class cha. Tuy nhiên trong JavaScript, không sử dụng khái niệm thừa kế class (class inheritance) như trong Java hay Python, mà mở rộng thành khái niệm prototypal inheritance ( về cơ bản cũng giống như
							class inheritance thôi )
							
			
				Hãy cùng tìm hiểu chút về chúng thông qua một vài ví dụ nhé !
				
							class Fish {
							  constructor(habitat, length) {
								this.habitat = habitat
								this.length = length
							  }					 
							  renderProperties(element) {
								element.innerHTML = JSON.stringify(this)
							  }
							}
							class Trout extends Fish {
							  constructor(habitat, length, variety) {
								super(habitat, length)
								this.variety = variety
							  }					  
							   renderPropertiesWithSuper(element) {
								element.className="green" 
								super.renderProperties(element);
							  }
							}

							Ở ví dụ này chúng ta có 2 class là Fish và Trout. Tất cả fish sẽ có thông tin về 2 thuộc tính là habitat và length, và 2 thuộc tính này thuộc về Fish Class. Trout Class cũng có một thuộc tính là variety,
							và đồng thời cũng được extend (hiểu là thừa kế cho dễ nhé ) các thuộc tính của Fish (gồm habitat và length) (vì Trout cũng là một loại cá mà )
			
				Constructor của Fish class định nghĩa 2 thuộc tính là habitat và length, còn Constructor của Trout Class định nghĩa thuộc tính variety. Vậy tại sao ta phải gọi super() trong constructor của trout class vậy ? Nếu chúng
				ta thử xóa dòng đó đi sẽ gặp lỗi không thể gán giá trị cho this.variety ! Vì sao vậy ?
			
				Đó là vì trong 1 dòng của code định nghĩa Class Trout ở trên, chúng ta đã báo với JavaScript rằng ta muốn Trout là 1 class con của Fish thông qua việc sử dụng keyword extends. Điều đó có nghĩa rằng this context của
				Trout Class sẽ bao gồm các thuộc tính và methods được định nghĩa trong Fish Class (habitat, length,...) và cộng thêm các thuộc tính và methods được định nghĩa cho chính nó (variety, ...). Nhờ việc sử dụng super() mà
				
				JavaScript có thể biết được Fish Class mà Trout Class muốn extend là gì, và vì vậy this context cho Trout Class mới có thể được tạo, chứa mọi thứ được "kế thừa" từ Fish Class và những thứ được định nghĩa cho chính nó.
				Còn đối với Fish Class, nó không cần tới việc gọi super() vì class cha của nó là JavaScript Object — hiển nhiên JavaScript biết nó là gì, nên không cần tới super() nữa.
			
				Nhờ việc sử dụng câu lệnh super(habitat,length) mà 2 thuộc tính được tạo ra trong this context của Trout. Tuy nhiên chúng ta vẫn có một cách khác để làm điều này. Chúng ta không cần phải gọi super() cùng với việc liệt
				kê những parameters có trong Fish. Mục đích sử dụng của super() không phải để gán cho Trout những giá trị Fish tạo ra, mà là để đảm bảo JavaScript có thể hiểu được thứ mà Trout muốn kế thừa là gì ? Vì vậy ta cũng có
				thể viết như sau :
				
							class trout extends fish {
							  constructor(habitat, length, variety) {
								super()
								this.habitat = habitat
								this.length = length
								this.variety = variety
							  }
							}
							
				Cách viết này không cần chỉ rõ thuộc tính nào được định nghĩa trong Fish, thuộc tính nào được định nghĩa trong Trout, những vẫn có kết quả giống như ví dụ trước. Điều khác nhau duy nhất đó là việc gọi super() mà không
				truyền parameters vào thì 2 thuộc tính habitat và length có trong Trout Class sẽ không có giá trị nào được gán giá trị nào khi chúng được khởi tạo. Chúng sẽ mang giá trị undefined cho tới khi được gán một giá trị mới.
				
							class trout extends fish {
							  constructor(habitat, length, variety) {
								super() // this = {habitat: undefined, length: undefined}
								this.habitat = habitat
								this.length = length
								this.variety = variety
								// this = {habitat: habitat, length: length, variety: variety}
							  }
							}
							
			Gọi method từ class cha--super() JAVASCRIPT:
			
							Chúng ta cũng có thể sử dụng super() bên ngoài Constructor để gọi tới methods của class cha.
							class fish {
							  renderProperties(el) {
								el.innerHTML = JSON.stringify(this)
							  }
							}
							class trout extends fish {
							renderPropertiesWithSuper(el) {
							  el.className="green" 
							  super.renderProperties(el);
							}
							
				Ở đây ta định nghĩa method renderProperties để hiển thị những thuộc tính của 1 class vào HTML element là el mà ta truyền vào. Class Trout cũng có một method làm điều tương tự như vậy, nhưng trước đó thêm một chút là
				sẽ thay đổi class name của el trước khi hiển thị. VÌ vậy sử dụng super() sẽ cực kì hữu dụng trong trường hợp này. Vì method của Trout có 1 phần chức năng giống như Fish, nên ta chỉ cần gọi lại method đó từ Fish là
				xong! Đó là lí do ta sử dụng super.renderProperties() ở đây.
				
				Lưu ý rằng việc chọn tên của method ở đây cũng rất quan trọng. Ở đây ta đặt tên method cho Trout Class là renderPropertiesWithSuper() vì chúng ta muốn vẫn có thể gọi trout.renderProperties() được. Nếu bạn chày cối,
				vẫn muốn đặt tên trong Trout Class là renderProperties() ? Hiển nhiên nó vẫn hợp lệ, nhưng lúc này chúng ta không thể gọi cả 2 hàm đó trực tiếp Trout được nữa - tức là gọi trout.renderProperties() sẽ chỉ gọi ra
				function được định nghĩa trong Trout mà thôi
	
	Async và Await--JAVASCRIPT:
	
		- Trong JavaScript, async và await là các từ khóa được sử dụng để làm việc với các hoạt động bất đồng bộ (asynchronous) một cách dễ dàng và trực quan hơn. Chúng được giới thiệu
		trong ECMAScript 2017 (ES8) và giúp cải thiện cú pháp khi làm việc với Promises.
		- Từ khóa async được sử dụng để khai báo một hàm bất đồng bộ.
		- Một hàm được khai báo với async sẽ tự động trả về một Promise. Nếu hàm trả về một giá trị không phải Promise, giá trị đó sẽ được bọc trong một Promise đã hoàn thành (resolved).
		- await chỉ có thể được sử dụng bên trong các hàm được khai báo với async.
		- Cách thức hoạt động:
			Khi await được sử dụng, JavaScript sẽ tạm dừng thực thi hàm cho đến khi Promise hoàn thành.
			Nếu Promise hoàn thành (resolved), await sẽ trả về giá trị của Promise.
			Nếu Promise bị từ chối (rejected), await sẽ ném ra lỗi (throw an error), và bạn có thể bắt lỗi này bằng cách sử dụng try...catch.
		- Các hàm async và await vẫn dựa trên Promises, do đó, hiểu biết cơ bản về Promises là cần thiết.
		
		async function myFunction() {
			return "Hello, World!";
		}
		// Tương đương với:
		function myFunction() {
			return Promise.resolve("Hello, World!");
		}
		myFunction().then(console.log); // "Hello, World!"
		
		async function fetchData() {
			let response = await fetch('https://api.example.com/data');
			let data = await response.json();
			return data;
		}
		fetchData().then(data => console.log(data));
		
		async function fetchData() {
			try {
				let response = await fetch('https://api.example.com/data');
				if (!response.ok) {
					throw new Error('Network response was not ok');
				}
				let data = await response.json();
				return data;
			} catch (error) {
				console.error('There has been a problem with your fetch operation:', error);
			}
		}
		fetchData().then(data => {
			if (data) {
				console.log(data);
			}
		});
		
	Date Formats--JAVASCRIPT:
	
		- Đặc điểm chung là nếu input thiếu phần nào thì output sẽ thiết lập giá trị mặc định cho nó là giá trị nhỏ nhất có thể
	
		- JavaScript Date Input
		
			There are generally 3 types of JavaScript date input formats:
			
				ISO Date	"2015-03-25" (The International Standard)
				Short Date	"03/25/2015"
				Long Date	"Mar 25 2015" or "25 Mar 2015"
				
		- JavaScript Date Output
		
			Independent of input format, JavaScript will (by default) output dates in full text string format:
			
				Sat Jul 27 2024 08:16:41 GMT+0700 (Indochina Time)
				
		- ISO Dates (Date-Time)
		
			Date and time is separated with a capital T.
			UTC time is defined with a capital letter Z.
			If you want to modify the time relative to UTC, remove the Z and add +HH:MM or -HH:MM instead
			Omitting T or Z in a date-time string can give different results in different browsers.
		
			const d = new Date("2015-03-25T12:00:00Z"); // Wed Mar 25 2015 19:00:00 GMT+0700 (Indochina Time)
			
			document.getElementById("demo").innerHTML = new Date("2015-03-25T12:00:00-06:00"); // Thu Mar 26 2015 01:00:00 GMT+0700 (Indochina Time)
			
		- Time Zones
		
			When setting a date, without specifying the time zone, JavaScript will use the browser's time zone.

			When getting a date, without specifying the time zone, the result is converted to the browser's time zone.

			In other words: If a date/time is created in GMT (Greenwich Mean Time), the date/time will be converted to CDT (Central US Daylight Time) if a user browses from central US.
			
		- JavaScript Short Dates.
		
			Short dates are written with an "MM/DD/YYYY" syntax like this:
			
				const d = new Date("03/25/2015"); // Wed Mar 25 2015 00:00:00 GMT+0700 (Indochina Time)
				
		- JavaScript Long Dates.
		
			Long dates are most often written with a "MMM DD YYYY" syntax like this:
			
				const d = new Date("Mar 25 2015"); // Wed Mar 25 2015 00:00:00 GMT+0700 (Indochina Time)
				
			Month and day can be in any order:
			
				const d = new Date("25 Mar 2015"); // Wed Mar 25 2015 00:00:00 GMT+0700 (Indochina Time)
				
			Month can be written in full (January), or abbreviated (Jan):
			
				const d = new Date("January 25 2015"); // Sun Jan 25 2015 00:00:00 GMT+0700 (Indochina Time)
				const d = new Date("Jan 25 2015"); // Sun Jan 25 2015 00:00:00 GMT+0700 (Indochina Time)
				
			Commas are ignored. Names are case insensitive:
			
				const d = new Date("JANUARY, 25, 2015"); // Sun Jan 25 2015 00:00:00 GMT+0700 (Indochina Time)
				
		- WARNINGS !
		
			In some browsers, months or days with no leading zeroes may produce an error:
			
				const d = new Date("2015-3-25");
				
			The behavior of "YYYY/MM/DD" is undefined. Some browsers will try to guess the format. Some will return NaN.
			
				const d = new Date("2015/03/25");
				
			The behavior of  "DD-MM-YYYY" is also undefined. Some browsers will try to guess the format. Some will return NaN.
			
				const d = new Date("25-03-2015");
				
		- Date Input - Parsing Dates
		
			If you have a valid date string, you can use the Date.parse() method to convert it to milliseconds.

			Date.parse() returns the number of milliseconds between the date and January 1, 1970:
			
				const msec = Date.parse("March 21, 2012"); // 1332262800000
				
			You can then use the number of milliseconds to convert it to a date object:
			
				let msec = Date.parse("March 21, 2012");
				const d = new Date(msec); // Wed Mar 21 2012 00:00:00 GMT+0700 (Indochina Time)
				
	JSON--JAVASCRIPT:
	
		JSON.parse()
			Parse the data with JSON.parse(), and the data becomes a JavaScript object.
			
				const txt = '{"name":"John", "age":30, "city":"New York"}'
				const obj = JSON.parse(txt);
				document.getElementById("demo").innerHTML = obj.name + ", " + obj.age;
				
			Parsing Dates
			
				- Date objects are not allowed in JSON.
				- If you need to include a date, write it as a string.
				- You can convert it back into a date object later:
				
					const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
					const obj = JSON.parse(text);
					obj.birth = new Date(obj.birth);
					document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth;
					
				Or, you can use the second parameter, of the JSON.parse() function, called reviver.
				
					const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
					const obj = JSON.parse(text, function (key, value) {
					  if (key == "birth") {
						return new Date(value);
					  } else {
						return value;
					  }
					});
					document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth;
					
			Parsing Functions
			
				- You should avoid using functions in JSON, the functions will lose their scope, and you would have to use eval() to
				- convert them back into functions.
				- Functions are not allowed in JSON.
				- If you need to include a function, write it as a string.
				- You can convert it back into a function later:
				
					const text = '{"name":"John", "age":"function() {return 30;}", "city":"New York"}';
					const obj = JSON.parse(text);
					obj.age = eval("(" + obj.age + ")");
					document.getElementById("demo").innerHTML = obj.name + ", " + obj.age();
		
		JSON.stringify()
		
			A common use of JSON is to exchange data to/from a web server.
			When sending data to a web server, the data has to be a string.
			Convert a JavaScript object into a string with JSON.stringify().
			
			const obj = {name: "John", age: 30, city: "New York"};
			const myJSON = JSON.stringify(obj);
			document.getElementById("demo").innerHTML = myJSON;
			
			Storing Data
			
				When storing data, the data has to be a certain format, and regardless of where you choose to store it, text is always one of the
				legal formats.
				JSON makes it possible to store JavaScript objects as text.
				
				// Storing data:
				const myObj = { name: "John", age: 31, city: "New York" };
				const myJSON = JSON.stringify(myObj);
				localStorage.setItem("testJSON", myJSON);
				// Retrieving data:
				let text = localStorage.getItem("testJSON");
				let obj = JSON.parse(text);
				document.getElementById("demo").innerHTML = obj.name;
				
			Exceptions
			
				In JSON, date objects are not allowed. The JSON.stringify() function will convert any dates into strings.
				In JSON, functions are not allowed as object values.
				The JSON.stringify() function will remove any functions from a JavaScript object, both the key and the value:
				
				const obj = {name: "John", today: new Date(), city: "New York"};
				const myJSON = JSON.stringify(obj);
				document.getElementById("demo").innerHTML = myJSON;
				
	Web Storage API--JAVASCRIPT:
	
		The Web Storage API is a simple syntax for storing and retrieving data in the browser. It is very easy to use:
			<!DOCTYPE html>
			<html>
			<body>
			<p id="demo"></p>
			<script>
			localStorage.setItem("name","John Doe");
			document.getElementById("demo").innerHTML = localStorage.getItem("name");
			</script>
			</body>
			</html>
			
		The localStorage Object
			
			The localStorage object provides access to a local storage for a particular Web Site. It allows you to store, read, add, modify, and delete data items for that domain.

			The data is stored with no expiration date, and will not be deleted when the browser is closed.

			The data will be available for days, weeks, and years.
			
		The setItem() Method
			
			The localStorage.setItem() method stores a data item in a storage.

			It takes a name and a value as parameters:
					
					localStorage.setItem("name", "John Doe");
			
		The getItem() Method
				
			The localStorage.getItem() method retrieves a data item from the storage.

			It takes a name as parameter:
					
					localStorage.getItem("name");
			
		The sessionStorage Object
				
			The sessionStorage object is identical to the localStorage object.

			The difference is that the sessionStorage object stores data for one session.

			The data is deleted when the browser is closed.
			
			<!DOCTYPE html>
			<html>
			<body>
			<p id="demo"></p>
			<script>
			sessionStorage.setItem("name","John Doe");
			document.getElementById("demo").innerHTML = sessionStorage.getItem("name");
			</script>
			</body>
			</html>
			
	Blob--JAVASCRIPT
	
		- Blob (Binary Large Object) trong JavaScript là một đối tượng đại diện cho dữ liệu thô (binary data). Nó có thể chứa dữ liệu văn bản, hình ảnh, video, hoặc bất kỳ loại dữ liệu nào khác, và
		được sử dụng rộng rãi trong các ứng dụng web để xử lý tệp và dữ liệu nhị phân.
		
		- Cú pháp của new Blob:
		
			new Blob(array, options);
			
				array
					
					Một mảng chứa các phần dữ liệu mà bạn muốn đưa vào Blob.
					Mỗi phần dữ liệu trong mảng này có thể là một ArrayBuffer, TypedArray, Blob, string, hoặc một đối tượng có thể được chuyển đổi thành Blob.
					
				options (tùy chọn)
				
					Một đối tượng chứa các tùy chọn để định cấu hình Blob.
					type: MIME type của Blob, ví dụ text/plain, application/json, image/jpeg, v.v. Điều này giúp xác định loại dữ liệu mà Blob chứa.
					endings: Có thể là "transparent" hoặc "native". Điều này ảnh hưởng đến cách các ký tự ngắt dòng (\n) trong chuỗi được xử lý khi chuỗi được chuyển thành Blob. Thông thường, bạn không
					cần thay đổi giá trị mặc định "transparent".
					
		- Ví dụ sử dụng Blob:
		
			Tạo một Blob từ chuỗi văn bản:
			
				const textBlob = new Blob(["Hello, world!"], { type: "text/plain" });
				console.log(textBlob);
				
			Tạo một Blob từ dữ liệu nhị phân (binary data):
			
				const byteArray = new Uint8Array([72, 101, 108, 108, 111]); // "Hello" dưới dạng mã ASCII
				const binaryBlob = new Blob([byteArray], { type: "application/octet-stream" });
				console.log(binaryBlob);
				
			Tạo một Blob từ nhiều phần dữ liệu:
			
				const part1 = "Hello, ";
				const part2 = "world!";
				const mixedBlob = new Blob([part1, part2], { type: "text/plain" });
				console.log(mixedBlob);
				
		- Sử dụng Blob:
		
			Tải xuống một tệp:
			
				const blob = new Blob(["Download this text as a file!"], { type: "text/plain" });
				const url = URL.createObjectURL(blob);
				const a = document.createElement("a");
				a.href = url;
				a.download = "file.txt";
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
				
			Sử dụng Blob trong FormData để tải lên tệp:
			
				const blob = new Blob(["Upload this text as a file!"], { type: "text/plain" });
				const formData = new FormData();
				formData.append("file", blob, "file.txt");
				fetch("/upload", {
				  method: "POST",
				  body: formData
				}).then(response => response.json()).then(result => console.log(result));

	Các kiến thức nền tảng--JAVASCRIPT:
		Asynchronous--Các kiến thức nền tảng JAVASCRIPT:
		
			Asynchronous JavaScript:
													In the real world, callbacks are most often used with asynchronous functions.
													A typical example is JavaScript setTimeout().
			
													<!DOCTYPE html>
													<html>
													<body>
													<h2>JavaScript Callbacks</h2>
													<p>Do a calculation and then display the result.</p>
													<p id="demo"></p>
													<script>
													function myDisplayer(something) {
													  document.getElementById("demo").innerHTML = something;
													}
													function myCalculator(num1, num2, myCallback) {
													  let sum = num1 + num2;
													  myCallback(sum);
													}
													myCalculator(5, 5, myDisplayer);
													</script>
													</body>
													</html>
			Waiting for a Timeout:
													When using the JavaScript function setTimeout(), you can specify a callback function to be executed on time-out:												
													<!DOCTYPE html>
													<html>
													<body>
													<h2>JavaScript Callback</h2>
													<p>Wait 3 seconds (3000 milliseconds) for this page to change.</p>
													<h1 id="demo"></h1>
													<script>
													setTimeout(myFunction, 3000);
													function myFunction() {
													  document.getElementById("demo").innerHTML = "I love You !!";
													}
													</script>
													</body>
													</html>
													
													Instead of passing the name of a function as an argument to another function, you can always pass a whole function instead:
													<!DOCTYPE html>
													<html>
													<body>
													<h2>JavaScript SetTimeout()</h2>
													<p>Wait 3 seconds (3000 milliseconds) for this page to change.</p>
													<h1 id="demo"></h1>
													<script>
													setTimeout(function() { myFunction("I love You !!!"); }, 3000);
													function myFunction(value) {
													  document.getElementById("demo").innerHTML = value;
													}
													</script>
													</body>
													</html>
			Waiting for Intervals:
													When using the JavaScript function setInterval(), you can specify a callback function to be executed for each interval:
													
													<!DOCTYPE html>
													<html>
													<body>
													<h2>JavaScript setInterval()</h2>
													<p>Using setInterval() to display the time every second (1000 milliseconds).</p>
													<h1 id="demo"></h1>
													<script>
													setInterval(myFunction, 2000);
													function myFunction() {
													  let d = new Date();
													  document.getElementById("demo").innerHTML=
													  d.getHours() + ":" +
													  d.getMinutes() + ":" +
													  d.getSeconds();
													}
													</script>
													</body>
													</html>
			Waiting for Files:
													If you create a function to load an external resource (like a script or a file), you cannot use the content before it is fully loaded.
													This is the perfect time to use a callback.
													This example loads an HTML file (mycar.html), and displays the HTML file in a web page, after the file is fully loaded:
													
													<!DOCTYPE html>
													<html>
													<body>
													<h2>JavaScript Callbacks</h2>
													<p id="demo"></p>
													<script>
													function myDisplayer(some) {
													  document.getElementById("demo").innerHTML = some;
													}
													function getFile(myCallback) {
													  let req = new XMLHttpRequest();
													  req.open('GET', "mycar.html");
													  req.onload = function() {
														if (req.status == 200) {
														  myCallback(this.responseText);
														} else {
														  myCallback("Error: " + req.status);
														}
													  }
													  req.send();
													}
													getFile(myDisplayer); 
													</script>
													</body>
													</html>
													
		Cách thức hoạt động của Javascript--Các kiến thức nền tảng JAVASCRIPT:
		
									- Có một điều mà bạn cần phải hiểu rõ đó là bản thân JavaScript là một ngôn ngữ chạy đồng bộ, giống như Ruby, PHP, Python...Khi chạy ở Client-side hay Server-side nó đều cần một chương trình để
									thông dịch và thực thi mã và người ta gọi đó là một JavaScript Engine. Và cũng chính JavaScript Engine mới thực sự là nơi hỗ trợ cho JavaScript chạy bất đồng bộ. Có rất nhiều JavaScript
									Engine được sử dụng trên các trình duyệt hay môi trường khác nhau, tuy nhiên chúng đều có những thành phần chính đó là Memory Heap và Call Stack.
									- JavaScript là một ngôn ngữ chạy đơn luồng (single threaded), nghĩa là trong một chương trình chỉ tồn tại một Call Stack duy nhất. Với những tác vụ nặng và tốn nhiều thời gian, toàn bộ
									chương trình tại thời điểm đó sẽ bị blocking cho đến khi tác vụ đó hoàn thành. Các bạn có lẽ đã từng gặp vấn đề này khi gửi một ajax request, chạy một vòng lặp vô hạn...lúc này chúng ta không
									thể thao tác được bất cứ thứ gì trên trình duyệt nữa. Để giải quyết vấn đề này, các JavaScript Engine đã cung cấp các API để có thể chạy các đoạn code JavaScript bất đồng bộ.
									
			Memory heap:
									Có nhiệm vụ cấp phát sử dụng và giải phóng bộ nhớ cho chương trình.
			Call Stack:
									Là một cấu trúc dữ liệu chứa các task của chương trình thực thi.
			Callback queue:
									- Để có thể chạy bất đồng bộ, JavaScript sử dụng thêm một thành phần nữa gọi là Callback Queue. Bạn có thể hình dung Callback Queue giống như một phòng chờ trong nhà hàng. Với những khách hàng
									đã đặt lịch trước sẽ được ưu tiên phục vụ ngay trong Call Stack (Synchronous). Còn nếu bạn đến nhà hàng mà không báo trước, bạn có thể sẽ phải làm một vài thủ tục nào đó và ngồi đợi trước khi
									được phục vụ (Asynchronous). Tuy nhiên, trong một phòng chờ sẽ có những vị khách VIP và họ sẽ được ưu tiên phục vụ trước cho dù có thể họ không phải là người đến đầu tiên.
									- Callback Queue cũng tương tự như vậy, mỗi tác vụ sẽ có độ ưu tiên khác nhau. Tác vụ nào có độ ưu tiên cao hơn sẽ được đưa lên Call Stack trước. Thứ tự ưu tiên trong Callback Queue lần lượt
									là: Microtask > Macrotask > Render Queue. Trong đó Render Queue là các task liên quan đến việc render và update view của trình duyệt do đó trong phần này chúng ta chỉ tìm hiểu về Microtask và
									Macrotask.
				Macrotask:
									- Microtask là một cấu trúc dữ liệu dạng FIFO (First In - First Out), nó thường lưu những tác vụ được thực hiện bởi Web APIs như setTimeout, DOM events...Chúng ta hãy cùng xem qua ví dụ dưới
									đây để hiểu rõ hơn về nó.
									- Những method như setTimeout, setInterval hay các thao tác trên DOM đều là những API mà trình duyệt cung cấp cho chúng ta. Như trong ví dụ trên, getUp() và haveBreakfast() đều là những hàm
									chạy đồng bộ nên nó sẽ được đưa ngay vào Call Stack. Riêng hàm makeCoffee() do sử dụng setTimeout nên nội dung của nó sẽ được đưa vào Web APIs để thực hiện. Tại đây Web APIs sẽ xử lý và đặt
									một timer, khi hết giờ, task này sẽ được đẩy xuống Callback Queue cụ thể trong trường hợp này là Macrotask. Khi Call Stack trống thì những task dưới Callback Queue mới được lấy ra và đưa lên
									Call Stack. Một lần nữa Event loop sẽ lại là người giúp chúng ta thực hiện toàn bộ quá trình đó.
									
									function getUp() {
									  console.log('I am waking up');
									}
									function makeCoffee() {
									  setTimeout(() => {
										console.log('Making coffee in 5 minutes');
									  }, 0);
									}
									function haveBreakfast() {
									  console.log('I have my breakfast');
									}
									getUp();
									makeCoffee();
									haveBreakfast();
				Microtask:
									- Tương tự như Macrotask nhưng có độ ưu tiên cao hơn, nghĩa là các task được lưu trong Macrotask chỉ được thực thi (đưa lên Call Stack) khi nào Microtask trống. Đó thường là những tác vụ xử
									lý liên quan đến Promise hoặc khi sử dụng hàm queueMicrotask. Chúng ta có một ví dụ với sự tham gia của cả Microtask và Macrotask.
									- Đầu tiên hàm makeCoffee() được gọi và tương tự như ví dụ trên, phần xử lý của hàm này được thực hiện bởi Web APIs và ngay lập tức được đưa xuống Macrotask, hàm makeCoffee() đã xong và được
									xóa khỏi Call Stack. Hàm haveBreakFast() lập tức được đưa vào Call Stack. Hàm này chỉ thực hiện việc tạo ra và lưu một task vào trong Microtask, sau đó nó cũng được xóa khỏi CallStack. Lúc
									này getUp() mới được gọi và do đây là một hàm chạy đồng bộ nên phần xử lý của nó sẽ được đưa luôn vào trong CallStack. Sau khi hàm getUp() chạy xong, lúc này CallStack đã trống, các task trong
									Microtask sẽ được đưa ngược lên CallStack. Khi tất cả các Microtask đã được xử lý xong, Call Stask và Microtask lúc này đều trống thì đây mới là thời điểm để thực hiện các task đang được lưu
									trong Macrotask.
									
									function getUp() {
									  console.log('I am waking up');
									}
									function makeCoffee() {
									  setTimeout(() => {
										console.log('Making coffee in 5 minutes');
									  }, 0);
									}
									function haveBreakfast() {
									  Promise.resolve().then(() => {
										  console.log('I have my breakfast');
									  });
									}
									makeCoffee();
									haveBreakfast();
									getUp();
				Event loop:
									Đầu tiên nó sẽ quét qua Call Stack, nếu như Call Stack còn có các task chưa được thực thi thì nó sẽ lấy ra task trên cùng và thực thi nó đồng thời loại bỏ task đó khỏi Call Stack. Nếu như Call
									Stack rỗng, các Microtask sẽ được đưa lên Call Stack theo thứ tự khi chúng được đẩy vào. Khi tất cả các Microtask đã được thực thi thành công, đó sẽ là lúc các Macrotask được thực thi, tương
									tự như với Microtask.
		Array--Các kiến thức nền tảng JAVASCRIPT:
									
									- Trong ngôn ngữ C, khi bạn viết a, nó sẽ được hiểu là một con trỏ tới phần tử đầu tiên của mảng. Nó trỏ tới địa chỉ của a[0] trong bộ nhớ. Bạn có thể sử dụng a để truy cập và thay đổi các
									phần tử trong mảng.
									- Trong JavaScript, khi bạn viết a, nó đại diện cho toàn bộ mảng a và sẽ trả về mảng đó.
									- Trong JavaScript, mảng được xem như một đối tượng (object). Khi bạn truy cập vào biến mảng a, nó không trả về một con trỏ (pointer) đến mảng như trong C. Thay vào đó, nó trả về toàn bộ mảng
									đó là một đối tượng dữ liệu.
									- JavaScript xử lý các đối tượng dữ liệu như mảng bằng cách tham chiếu trực tiếp đến đối tượng đó. Khi bạn sử dụng biến a, bạn đang tham chiếu trực tiếp đến mảng đó và có thể truy cập và
									thay đổi các phần tử trong mảng thông qua biến a.
									- Việc JavaScript trả về toàn bộ mảng khi truy cập biến a thể hiện cách JavaScript xử lý các đối tượng dữ liệu và quy ước trong ngôn ngữ này. Một số ngôn ngữ khác có cách tiếp cận khác, như C
									trong trường hợp của bạn, nơi mảng được xử lý dưới dạng con trỏ trỏ đến phần tử đầu tiên của mảng.
									
									- In JavaScript, arrays use numbered indexes. In JavaScript, objects use named indexes.
		
			A Common Error--Javasctipt Array:
			
									Create an array with one element:
									const points = [40];
									
									Create an array with 40 undefined elements:
									const points = new Array(40);
									
									Adding elements with high indexes can create undefined "holes" in an array:
									const fruits = ["Banana", "Orange", "Apple"];
									fruits[6] = "Lemon";
									let fLen = fruits.length;
									let text = "";
									for (i = 0; i < fLen; i++) {
									  text += fruits[i] + "<br>";
									}
									document.getElementById("demo").innerHTML = text; // Banana, Orange, Apple, undefined, undefined, undefined, Lemon
			Const Array--Javasctipt Array:
				Cannot be Reassigned:
										
										An array declared with const cannot be reassigned:
										
										throw exception
										<!DOCTYPE html>
										<html>
										<body>
										<h2>JavaScript const</h2>
										<p>You can NOT reassign a constant array:</p>
										<p id="demo"></p>
										<script>
										try {
										  const cars = ["Saab", "Volvo", "BMW"];
										  cars = ["Toyota", "Volvo", "Audi"];
										}
										catch (err) {
										  document.getElementById("demo").innerHTML = err;
										}
										</script>
										</body>
										</html>
										
				Arrays are Not Constants:

										The keyword const is a little misleading.
										It does NOT define a constant array. It defines a constant reference to an array.
										Because of this, we can still change the elements of a constant array.
				
				Elements Can be Reassigned:
				
										You can change the elements of a constant array:
										
										<!DOCTYPE html>
										<html>
										<body>
										<h2>JavaScript const</h2>
										<p>Declaring a constant array does NOT make the elements unchangeable:</p>
										<p id="demo"></p>
										<script>							
										const cars = ["Saab", "Volvo", "BMW"]; // Create an Array
										cars[0] = "Toyota"; // Change an element								
										cars.push("Audi"); // Add an element								
										document.getElementById("demo").innerHTML = cars; // Display the Array
										</script>
										</body>
										</html>
										
				Assigned when Declared:

										- JavaScript const variables must be assigned a value when they are declared. Meaning: An array declared with const must be initialized when it is declared.
										- Using const without initializing the array is a syntax error
										- Arrays declared with var can be initialized at any time. You can even use the array before it is declared
										
										This will not work
										const cars;
										cars = ["Saab", "Volvo", "BMW"];
										
										<!DOCTYPE html>
										<html>
										<body>
										<h2>JavaScript Hoisting</h2>
										<p id="demo"></p>
										<script>
										cars = ["Saab", "Volvo", "BMW"];
										var cars;
										document.getElementById("demo").innerHTML = cars[0];
										</script>
										</body>
										</html>
										
				Const Block Scope:
				
										An array declared with const has Block Scope. An array declared in a block is not the same as an array declared outside the block
										An array declared with var does not have block scope
										
										<!DOCTYPE html>
										<html>
										<body>
										<h2>Declaring an Array Using const</h2>
										<p id="demo"></p>
										<script>
										const cars = ["Saab", "Volvo", "BMW"];
										// Here cars[0] is "Saab"
										{  
										  const cars = ["Toyota", "Volvo", "BMW"]; 
										  // Here cars[0] is "Toyota"
										}
										// Here cars[0] is "Saab"
										document.getElementById("demo").innerHTML = cars[0];
										</script>
										</body>
										</html>
				
				Redeclaring Arrays:
					
										Redeclaring or reassigning an array to const, in the same scope, or in the same block, is not allowed
										Redeclaring or reassigning an existing const array, in the same scope, or in the same block, is not allowed
										Redeclaring an array with const, in another scope, or in another block, is allowed
										Redeclaring an array declared with var is allowed anywhere in a program
										
										var cars = ["Volvo", "BMW"];     // Allowed
										const cars = ["Volvo", "BMW"];   // Not allowed
										{
										  var cars = ["Volvo", "BMW"];   // Allowed
										  const cars = ["Volvo", "BMW"]; // Not allowed
										}
										
										const cars = ["Volvo", "BMW"];   // Allowed
										const cars = ["Volvo", "BMW"];   // Not allowed
										var cars = ["Volvo", "BMW"];     // Not allowed
										cars = ["Volvo", "BMW"];         // Not allowed

										{
										  const cars = ["Volvo", "BMW"]; // Allowed
										  const cars = ["Volvo", "BMW"]; // Not allowed
										  var cars = ["Volvo", "BMW"];   // Not allowed
										  cars = ["Volvo", "BMW"];       // Not allowed
										}
										
										const cars = ["Volvo", "BMW"];   // Allowed
										{
										  const cars = ["Volvo", "BMW"]; // Allowed
										}
										{
										  const cars = ["Volvo", "BMW"]; // Allowed
										}
										
										var cars = ["Volvo", "BMW"];   // Allowed
										var cars = ["Toyota", "BMW"];  // Allowed
										cars = ["Volvo", "Saab"];      // Allowed
								
		Promise & Async & Await--Các kiến thức nền tảng JAVASCRIPT:
			Promise:
										- Là một đối tượng đại diện cho kết quả của một hoạt động bất đồng bộ. Sử dụng để xử lý các hoạt động bất đồng bộ và xác định cách xử lý kết quả thành công hoặc lỗi của chúng.
										- Promise có các trạng thái: "pending" (đang chờ), "fulfilled" (hoàn thành) và "rejected" (bị từ chối).  Cung cấp phương thức ".then()" để xử lý kết quả thành công và ".catch()" để xử
										lý lỗi.		
										
			Async & Await:
										- Là một cú pháp đơn giản và trực quan để xử lý Promise.
										- "async" được sử dụng để khai báo một hàm bất đồng bộ, trong đó có thể sử dụng từ khóa "await" để đợi cho kết quả của một Promise.
										- "await" được sử dụng để tạm dừng thực thi hàm async và chờ đợi cho kết quả của một Promise trước khi tiếp tục.
										- Khi sử dụng "async/await", mã có thể được viết theo cách tương tự với mã đồng bộ, làm cho nó dễ đọc và dễ hiểu hơn.
										- "async" là một từ khóa để khai báo một hàm bất đồng bộ, trong khi "Promise" là một đối tượng được sử dụng để xử lý kết quả của một hoạt động bất đồng bộ.
										- "async" và "await" thường được sử dụng cùng với Promise để xử lý kết quả của các hoạt động bất đồng bộ một cách dễ dàng và đồng bộ hơn. Bằng cách sử dụng "await" trong một hàm async, ta
										có thể đợi cho một Promise trả về kết quả trước khi tiếp tục thực hiện các lệnh tiếp theo.
				Async Syntax:
											The keyword async before a function makes the function return a promise
											Or simpler, since you expect a normal value (a normal response, not an error)
											
											myFunction().then(
											  function(value) { /* code if successful */ },
											  function(error) { /* code if some error */ }
											);
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript async / await</h2>
											<p id="demo"></p>
											<script>
											function myDisplayer(some) {
											  document.getElementById("demo").innerHTML = some;
											}
											async function myFunction() {return "Hello";}
											myFunction().then(
											  function(value) {myDisplayer(value);},
											  function(error) {myDisplayer(error);}
											);</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript async / await</h2>
											<p id="demo"></p>
											<script>
											function myDisplayer(some) {
											  document.getElementById("demo").innerHTML = some;
											}
											async function myFunction() {return "Hello";}
											myFunction().then(
											  function(value) {myDisplayer(value);}
											);
											</script>
											</body>
											</html>
				Await Syntax:
											The await keyword can only be used inside an async function.
											The await keyword makes the function pause the execution and wait for a resolved promise before it continues
											The two arguments (resolve and reject) are pre-defined by JavaScript.
											We will not create them, but call one of them when the executor function is ready.
											Very often we will not need a reject function.
									
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript async / await</h2>
											<h1 id="demo"></h1>
											<script>
											async function myDisplay() {
											  let myPromise = new Promise(function(resolve, reject) {
												resolve("I love You !!");
											  });
											  document.getElementById("demo").innerHTML = await myPromise;
											}
											myDisplay();
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript async / await</h2>
											<h1 id="demo"></h1>
											<script>
											async function myDisplay() {
											  let myPromise = new Promise(function(resolve) {
												resolve("I love You !!");
											  });
											  document.getElementById("demo").innerHTML = await myPromise;
											}
											myDisplay();
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript async / await</h2>
											<p id="demo"></p>
											<script>
											async function getFile() {
											  let myPromise = new Promise(function(resolve) {
												let req = new XMLHttpRequest();
												req.open('GET', "mycar.html");
												req.onload = function() {
												  if (req.status == 200) {
													resolve(req.response);
												  } else {
													resolve("File not Found");
												  }
												};
												req.send();
											  });
											  document.getElementById("demo").innerHTML = await myPromise;
											}
											getFile();
											</script>
											</body>
											</html>
											
		Best Practices--Các kiến thức nền tảng JAVASCRIPT:

											Avoid global variables, avoid new, avoid ==, avoid eval()
			Avoid Global Variables:
											- Minimize the use of global variables. This includes all data types, objects, and functions.
											- Global variables and functions can be overwritten by other scripts. Use local variables instead, and learn how to use closures.
			
			Always Declare Local Variables:
			
			Declarations on Top:
											- It is a good coding practice to put all declarations at the top of each script or function.
											- This will:
															Give cleaner code
															Provide a single place to look for local variables
															Make it easier to avoid unwanted (implied) global variables
															Reduce the possibility of unwanted re-declarations
											
											// Declare at the beginning
											let firstName, lastName, price, discount, fullPrice;
											// Use later
											firstName = "John";
											lastName = "Doe";
											price = 19.90;
											discount = 0.10;
											fullPrice = price - discount;
			Initialize Variables:
											- It is a good coding practice to initialize variables when you declare them.
											- Initializing variables provides an idea of the intended use (and intended data type).
											- This will:
															Give cleaner code
															Provide a single place to initialize variables
															Avoid undefined values
									
											// Declare and initiate at the beginning
											let firstName = "";
											let lastName = "";
											let price = 0;
											let discount = 0;
											let fullPrice = 0,
											const myArray = [];
											const myObject = {};
			Declare Objects with const:
											Declaring objects with const will prevent any accidental change of type:
											
											let car = {type:"Fiat", model:"500", color:"white"};
											car = "Fiat";      // Changes object to string
											
											const car = {type:"Fiat", model:"500", color:"white"};
											car = "Fiat";      // Not possible
			Declare Arrays with const:
											Declaring arrays with const will prevent any accidential change of type:
											
											let cars = ["Saab", "Volvo", "BMW"];
											cars = 3;    // Changes array to number
											
											const cars = ["Saab", "Volvo", "BMW"];
											cars = 3;    // Not possible
			Don't Use new Object():
											Use "" instead of new String()
											Use 0 instead of new Number()
											Use false instead of new Boolean()
											Use {} instead of new Object()
											Use [] instead of new Array()
											Use /()/ instead of new RegExp()
											Use function (){} instead of new Function()
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Literal Constructors</h2>
											<p id="demo"></p>
											<script>
											let x1 = "";
											let x2 = 0;
											let x3 = false;
											const x4 = {};
											const x5 = [];
											const x6 = /()/;
											const x7 = function(){};
											document.getElementById("demo").innerHTML =
											"x1: " + typeof x1 + "<br>" + // string
											"x2: " + typeof x2 + "<br>" + // number
											"x3: " + typeof x3 + "<br>" + // boolean
											"x4: " + typeof x4 + "<br>" + // object
											"x5: " + typeof x5 + "<br>" + // object
											"x6: " + typeof x6 + "<br>" + // object
											"x7: " + typeof x7 + "<br>"; // function
											</script>
											</body>
											</html>
											
			Beware of Automatic Type Conversions:

											JavaScript is loosely typed. A variable can contain all data types. A variable can change its data type.
											Beware that numbers can accidentally be converted to strings or NaN (Not a Number). When doing mathematical operations, JavaScript can convert numbers to strings
											Subtracting a string from a string, does not generate an error but returns NaN (Not a Number)
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Variables</h2>
											<p>Remove the comment (at the beginning of the lines) to test each case:</p>
											<p id="demo"></p>
											<script>
											let x = 5;
											//x = 5 + 7;    // x.valueOf() is 12, typeof x is a number
											//x = 5 + "7";  // x.valueOf() is 57, typeof x is a string
											//x = "5" + 7;  // x.valueOf() is 57, typeof x is a string
											//x = 5 - 7;    // x.valueOf() is -2, typeof x is a number
											//x = 5 - "7";  // x.valueOf() is -2, typeof x is a number
											//x = "5" - 7;  // x.valueOf() is -2, typeof x is a number
											//x = 5 - "x";  // x.valueOf() is NaN, typeof x is a number
											document.getElementById("demo").innerHTML = x.valueOf() + " " + typeof x;
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Variables</h2>
											<p>Subtracting a string from a string, does not generate an error but returns NaN (Not a Number):</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = "Hello" - "Dolly"; // NaN
											</script>
											</body>
											</html> 
				Use === Comparison:
											The == comparison operator always converts (to matching types) before comparison. The === operator forces comparison of values and type:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Comparisons</h2>
											<p>Remove the comment (at the beginning of each line) to test each case:</p>
											<p id="demo"></p>
											<script>
											let x;
											//x = (0 == "");   // true
											//x = (1 == "1");  // true
											//x = (1 == true);   // true
											//x = (0 === "");  // false
											//x = (1 === "1");   // false
											//x = (1 === true);  // false
											document.getElementById("demo").innerHTML = x;
											</script>
											</body>
											</html>
				Use Parameter Defaults:
											- If a function is called with a missing argument, the value of the missing argument is set to undefined.
											- Undefined values can break your code. It is a good habit to assign default values to arguments.
											- ECMAScript 2015 allows default parameters in the function definition
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>Setting a default value to a function parameter.</p>
											<p id="demo"></p>
											<script>
											function myFunction(x, y) {
											  if (y === undefined) {
												y = 0;
											  }  
											  return x * y;
											}
											document.getElementById("demo").innerHTML = myFunction(4);
											</script>
											</body>
											</html>
											
											function (a=1, b=1) { /*function code*/ }
				
				End Your Switches with Defaults:
				
											Always end your switch statements with a default. Even if you think there is no need for it.
											
											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo"></p>
											<script>
											let day;
											switch (new Date().getDay()) {
											  case 0:
												day = "Sunday";
												break;
											  case 1:
												day = "Monday";
												break;
											  case 2:
												day = "Tuesday";
												break;
											  case 3:
												day = "Wednesday";
												break;
											  case 4:
												day = "Thursday";
												break;
											  case 5:
												day = "Friday";
												break;
											  case  6:
												day = "Saturday";
												break;
											  default:
												 day = "unknown";
											}
											document.getElementById("demo").innerHTML = "Today is " + day;
											</script>
											</body>
											</html>
				
				Avoid Number, String, and Boolean as Objects:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript String Objects</h2>
											<p>Never create strings as objects.</p>
											<p>Strings and objects cannot be safely compared.</p>
											<p id="demo"></p>
											<script>
											let x = "John";        // x is a string
											let y = new String("John");  // y is an object
											document.getElementById("demo").innerHTML = (x === y); // false
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript String Objects</h2>
											<p>Never create strings as objects.</p>
											<p>Strings and objects cannot be safely compared.</p>
											<p id="demo"></p>
											<script>
											let x = "John";        // x is a string
											let y = new String("John");  // y is an object
											document.getElementById("demo").innerHTML = (x === y); // false
											</script>
											</body>
											</html>
		Callbacks--Các kiến thức nền tảng JAVASCRIPT:
		
											- A callback is a function passed as an argument to another function.
											- Using a callback, you could call the calculator function (myCalculator) with a callback, and let the calculator function run the callback after the calculation is finished
											- Where callbacks really shine are in asynchronous functions, where one function has to wait for another function (like waiting for a file to load).
											Nghĩa là hàm callback sẽ chạy khi thi thực trong thân hàm thay vì chạy khi khai báo đối số
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Callbacks</h2>
											<p>Do a calculation and then display the result.</p>
											<p id="demo"></p>
											<script>
											function myDisplayer(something) {
											  document.getElementById("demo").innerHTML = something;
											}
											function myCalculator(num1, num2, myCallback) {
											  let sum = num1 + num2;
											  myCallback(sum);
											}
											myCalculator(5, 5, myDisplayer);
											</script>
											</body>
											</html>
		Class Inheritance--Các kiến thức nền tảng JAVASCRIPT:
			Class Inheritance:	
											To create a class inheritance, use the extends keyword.
											The super() method refers to the parent class.
											By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Class Inheritance</h2>
											<p>Use the "extends" keyword to inherit all methods from another class.</p>
											<p>Use the "super" method to call the parent's constructor function.</p>
											<p id="demo"></p>
											<script>
											class Car {
											  constructor(brand) {
												this.carname = brand;
											  }
											  present() {
												return 'I have a ' + this.carname;
											  }
											}
											class Model extends Car {
											  constructor(brand, mod) {
												super(brand);
												this.model = mod;
											  }
											  show() {
												return this.present() + ', it is a ' + this.model;
											  }
											}
											let myCar = new Model("Ford", "Mustang");
											document.getElementById("demo").innerHTML = myCar.show();
											</script>
											</body>
											</html>
			Getters and Setters:
											Classes also allows you to use getters and setters.
											It can be smart to use getters and setters for your properties, especially if you want to do something special with the value before returning them, or before you set them.
											To add getters and setters in the class, use the get and set keywords.
											Note: even if the getter is a method, you do not use parentheses when you want to get the property value.
											The name of the getter/setter method cannot be the same as the name of the property, in this case carname.
											Many programmers use an underscore character _ before the property name to separate the getter/setter from the actual property
											To use a setter, use the same syntax as when you set a property value, without parentheses:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Class Gettter/Setter</h2>
											<p>Using an underscore character is common practice when using getters/setters in JavaScript, but not mandatory, you can name them anything you like.</p>
											<p id="demo"></p>
											<script>
											class Car {
											  constructor(brand) {
												this._carname = brand;
											  }
											  get carname() {
												return this._carname;
											  }
											  set carname(x) {
												this._carname = x;
											  }
											}
											let myCar = new Car("Ford");
											document.getElementById("demo").innerHTML = myCar.carname;
											</script>
											</body>
											</html>
			Hoisting:
											Unlike functions, and other JavaScript declarations, class declarations are not hoisted.
											That means that you must declare a class before you can use it:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Classes are not hoisted</h2>
											<p>You will get an error if you try to use a class before it is declared.</p>
											<p id="demo"></p>
											<script>
											//You cannot use the class yet.
											//myCar = new Car("Ford")
											//This would raise an error.
											class Car {
											  constructor(brand) {
												this.carname = brand;
											  }
											}
											//Now you can use the class:
											let myCar = new Car("Ford")
											</script>
											</body>
											</html>
											
		Closures--Các kiến thức nền tảng JAVASCRIPT:
		
											- Closure trong JavaScript là một khái niệm quan trọng và mạnh mẽ. Nó là khả năng của một hàm để ghi nhớ và truy cập các biến từ phạm vi ngoại của nó, ngay cả sau khi hàm đã được
											thực thi.
											- Một closure được tạo ra khi một hàm bên trong khai báo và truy cập các biến từ phạm vi của hàm bên ngoài của nó. Nói cách khác, closure bao gồm hàm và môi trường xung quanh của nó,
											bao gồm các biến nằm trong phạm vi của hàm cha, biến đóng (enclosed variables) và biến toàn cục (global variables).
											- Closure cho phép các biến bên trong hàm bên ngoài vẫn có thể được truy cập và sử dụng bởi hàm bên trong ngay cả khi hàm bên ngoài đã hoàn thành việc thực thi. Nó giúp bảo vệ các biến
											khỏi việc bị truy cập và thay đổi từ bên ngoài.
											- Closures được sử dụng rộng rãi trong JavaScript để tạo các biến riêng tư (private variables), tạo các hàm callback, xử lý bất đồng bộ, module pattern và nhiều ứng dụng khác.
											
											function counter() {
											  let count = 0;
											  function increment() {
												count++;
												console.log(count);
											  }
											  return increment;
											}
											const myCounter = counter();
											myCounter(); // Kết quả: 1
											myCounter(); // Kết quả: 2

			
			Cơ chế giữ giá trị của closure trong JavaScript hoạt động như sau:
			
											- Khi một hàm bên trong (như hàm increment trong ví dụ) được tạo ra trong một hàm bên ngoài (như hàm counter), nó tạo ra một closure. Closure bao gồm hàm bên trong và môi trường xung
											quanh của nó, bao gồm các biến và hàm trong phạm vi của hàm bên ngoài.
											- Trong closure, các biến và hàm trong phạm vi của hàm bên ngoài vẫn có thể được truy cập và sử dụng bởi hàm bên trong, ngay cả sau khi hàm bên ngoài đã hoàn thành thực thi.
											- Các biến trong closure được lưu trữ trong một bộ nhớ đặc biệt gọi là environment record (bản ghi môi trường). Mỗi closure có một environment record riêng của nó.
											- Khi một biến được sử dụng trong hàm bên trong, JavaScript sẽ tìm giá trị của biến trong environment record của closure. Nếu biến không tồn tại trong environment record hiện tại,
											JavaScript sẽ tiếp tục tìm kiếm trong các environment record khác, theo quy tắc phạm vi (lexical scope) của hàm.
											- Khi hàm bên trong được gọi, nó có thể thay đổi giá trị của các biến trong environment record của closure. Các thay đổi này sẽ được ghi nhớ và duy trì giữa các lần gọi hàm.
											- Các closure có tính độc lập và không xung đột với nhau. Mỗi lần gọi hàm bên ngoài tạo ra một closure mới, có một environment record riêng, vì vậy các closure không ảnh hưởng lẫn nhau
											và giữ được giá trị của biến riêng.
											
											Dòng cuối cùng (function () { ... })(); đại diện cho việc thực thi hàm ngay lập tức. Khi chúng ta thêm dấu ngoặc đóng () ở cuối, JavaScript sẽ thực thi hàm được khai báo bên trong dấu
											ngoặc đóng và trả về kết quả của hàm. Kết quả này được gán cho biến add.
											Nếu chúng ta không thêm dấu ngoặc đóng (), biến add sẽ chỉ được gán với hàm chưa được thực thi. Điều này có nghĩa là biến add sẽ trỏ tới một hàm, không phải kết quả của việc thực thi
											hàm đó. Do đó, để có thể sử dụng giá trị trả về của hàm ngay lập tức và gán cho biến add, chúng ta cần thêm dấu ngoặc đóng () để thực thi hàm và gán kết quả vào biến add.
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Closures</h2>
											<p>Counting with a local variable.</p>
											<button type="button" onclick="myFunction()">Count!</button>
											<p id="demo">0</p>
											<script>
											const add = (function () {
											  let counter = 0;
											  return function () {counter += 1; return counter;}
											})();

											function myFunction(){
											  document.getElementById("demo").innerHTML = add();
											}
											</script>
											</body>
											</html>
											
		Comparison and Logical Operators--Các kiến thức nền tảng JAVASCRIPT:	
		
			Conditional (Ternary) Operator:

											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Comparison</h1>
											<h2>The () ? : Ternary Operator</h2>
											<p>Input your age and click the button:</p>
											<input id="age" value="18" />
											<button onclick="myFunction()">Try it</button>
											<p id="demo"></p>
											<script>
											function myFunction() {
											  let age = document.getElementById("age").value;
											  let voteable = (age < 18) ? "Too young":"Old enough";
											  document.getElementById("demo").innerHTML = voteable + " to vote.";
											}
											</script>
											</body>
											</html>
											
			The Nullish Coalescing Operator (??):
			
											Nếu biến đó có giá trị là null hoặc undefined, toán tử sẽ trả về giá trị bên phải của nó; nếu không, nó sẽ trả về giá trị bên trái.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Operators</h1>
											<h2>The ?? Operator</h2>
											<p>The ?? operator returns the first argument if it is null or undefined. Otherwise it returns the second.</p>
											<p id="demo"></p>
											<script>
											let name = null;
											let text = "missing";
											let result = name ?? text;
											document.getElementById("demo").innerHTML = "The name is " + result; // The name is missing
											</script>
											</body>
											</html>
											
			The Optional Chaining Operator (?.):
			
											The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Operators</h1>
											<h2>The ?. Operator</h2>
											<p>The ?. operator returns undefined if an object is undefined or null (instead of throwing an error)..</p>
											<p id="demo"></p>
											<script>
											let name = null;
											let text = "missing";
											let result = name ?. text;
											document.getElementById("demo").innerHTML = "The name is " + result; // The name is undefined
											</script>

											</body>
											</html>
		Cookies--Các kiến thức nền tảng JAVASCRIPT:
		
			What are Cookies:
			
											- Cookies are data, stored in small text files, on your computer.
											- When a web server has sent a web page to a browser, the connection is shut down, and the server forgets everything about the user.
											- Cookies were invented to solve the problem "how to remember information about the user"
											- Cookies are saved in name-value pairs like:		username = John Doe
											- When a browser requests a web page from a server, cookies belonging to the page are added to the request. This way the server gets the necessary data to "remember" information about
											users.
		
			Create a Cookie with JavaScript:
			
											With JavaScript, a cookie can be created like this:
											document.cookie = "username=John Doe";
											
											You can also add an expiry date (in UTC time). By default, the cookie is deleted when the browser is closed:
											document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC";
											
											With a path parameter, you can tell the browser what path the cookie belongs to. By default, the cookie belongs to the current page.
											document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC; path=/";
			
			Read a Cookie with JavaScript:
			
											let x = document.cookie; // document.cookie will return all cookies in one string much like: cookie1=value; cookie2=value; cookie3=value;
											
			Change a Cookie with JavaScript:

											With JavaScript, you can change a cookie the same way as you create it:
											
											document.cookie = "username=John Smith; expires=Thu, 18 Dec 2013 12:00:00 UTC; path=/"; // The old cookie is overwritten.
											
			Delete a Cookie with JavaScript:
			
											You don't have to specify a cookie value when you delete a cookie. Just set the expires parameter to a past date.
											You should define the cookie path to ensure that you delete the right cookie. Some browsers will not let you delete a cookie if you don't specify the path.
											
											document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
											
			The Cookie String:
				
											- The document.cookie property looks like a normal text string. But it is not.
											- Even if you write a whole cookie string to document.cookie, when you read it out again, you can only see the name-value pair of it.
											- If you set a new cookie, older cookies are not overwritten. The new cookie is added to document.cookie
											- If you want to find the value of one specified cookie, you must write a JavaScript function that searches for the cookie value in the cookie string.
			Example:
			
				A Function to Set a Cookie:
				
											function setCookie(cname, cvalue, exdays) {
											  const d = new Date();
											  d.setTime(d.getTime() + (exdays*24*60*60*1000));
											  let expires = "expires="+ d.toUTCString();
											  document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
											}
											
				A Function to Get a Cookie:
				
											function getCookie(cname) {
											  let name = cname + "=";
											  let decodedCookie = decodeURIComponent(document.cookie);
											  let ca = decodedCookie.split(';');
											  for(let i = 0; i <ca.length; i++) {
												let c = ca[i];
												while (c.charAt(0) == ' ') {
												  c = c.substring(1);
												}
												if (c.indexOf(name) == 0) {
												  return c.substring(name.length, c.length);
												}
											  }
											return
											 
				A Function to Check a Cookie:
				
											function checkCookie() {
											  let username = getCookie("username");
											  if (username != "") {
											   alert("Welcome again " + username);
											  } else {
												username = prompt("Please enter your name:", "");
												if (username != "" && username != null) {
												  setCookie("username", username, 365);
												}
											  }
											}
											
		Data Types--Các kiến thức nền tảng JAVASCRIPT:
		
				JavaScript Types are Dynamic:
				
											let x;         // Now x is undefined
											x = 5;         // Now x is a Number
											x = "John";    // Now x is a String
											
				Undefined:
											In JavaScript, a variable without a value, has the value undefined. The type is also undefined.
											Any variable can be emptied, by setting the value to undefined. The type will also be undefined.
											
											let car = "Volvo";
											car = undefined;
											
				Empty Values:
				
											An empty value has nothing to do with undefined.
											An empty string has both a legal value and a type.
											
											let car = "";
											document.getElementById("demo").innerHTML =
											"The value is: " +
											car + "<br>" + // The value is
											"The type is: " + typeof car; //The type is: string
		ES5 Object Methods--Các kiến thức nền tảng JAVASCRIPT:
		
				
				Managing Objects:										
											Object.create() // Create object with an existing object as prototype									
											Object.defineProperty(object, property, descriptor) // Adding or changing an object property										
											Object.defineProperties(object, descriptors) // Adding or changing object properties										
											Object.getOwnPropertyDescriptor(object, property) // Accessing Properties										
											Object.getOwnPropertyNames(object) // Returns all properties as an array										
											Object.getPrototypeOf(object) // Accessing the prototype										
											Object.keys(object) // Returns enumerable properties as an array
				Protecting Objects:
											
											Object.preventExtensions(object) // Prevents adding properties to an object											
											Object.isExtensible(object) // Returns true if properties can be added to an object											
											Object.seal(object) // Prevents changes of object properties (not values)											
											Object.isSealed(object) // Returns true if object is sealed											
											Object.freeze(object) // Prevents any changes to an object											
											Object.isFrozen(object) // Returns true if object is frozen
				
				Changing a Property Value:

											Object.defineProperty(object, property, {value : value})
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Object.defineProperty()</h2>
											<p>This example changes a property value.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "EN" 
											};
											// Change a property
											Object.defineProperty(person, "language", {value:"NO"})
											document.getElementById("demo").innerHTML = person.language; // NO
											</script>
											</body>
											</html>
											
				Changing Meta Data:
				
					ES5 allows the following property meta data to be changed:
					
											writable : true      // Property value can be changed
											enumerable : true    // Property can be enumerated
											configurable : true  // Property can be reconfigured
											writable : false     // Property value can not be changed
											enumerable : false   // Property can be not enumerated
											configurable : false // Property can be not reconfigured
											
					ES5 allows getters and setters to be changed:	
					
											get: function() { return language } // Defining a getter									
											set: function(value) { language = value } // Defining a setter
											
					This example makes language read-only:
					
											Object.defineProperty(person, "language", {writable:false});
											
					This example makes language not enumerable:
					
											Object.defineProperty(person, "language", {enumerable:false});
											
				Listing All Properties:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Object.getOwnPropertyNames()</h2>
											<p>This example list the properties of an object.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "EN"
											}
											// Change Property
											Object.defineProperty(person, "language", {enumerable:false});
											// Display Properties
											document.getElementById("demo").innerHTML = Object.getOwnPropertyNames(person); // firstName,lastName,language
											</script>
											</body>
											</html>
											
				Listing Enumerable Properties:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Object.keys()</h2>
											<p>This example list the enumerable properties of an object.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "EN"
											}
											// Change Property
											Object.defineProperty(person, "language", {enumerable:false});
											// Display Properties
											document.getElementById("demo").innerHTML = Object.keys(person); // firstName,lastName
											</script>
											</body>
											</html>
											
				Adding a Property:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Object.defineProperty()</h2>
											<p>This example adds a new property to an object.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "EN"
											};
											// Add a property
											Object.defineProperty(person, "year", {value:"2008"})
											document.getElementById("demo").innerHTML = person.year; // 2008
											</script>
											</body>
											</html>
											
				Adding Getters and Setters:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Object.defineProperty()</h2>
											<p>This example uses the defineProperty() method to add a getter and a setter.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {firstName:"John", lastName:"Doe"};
											// Define a getter
											Object.defineProperty(person, "fullName", {
											  get: function () {return this.firstName + " " + this.lastName;}
											});
											// Display full name
											document.getElementById("demo").innerHTML = person.fullName;
											</script>
											</body>
											</html>
											
		Fetch API--Các kiến thức nền tảng JAVASCRIPT:
		
											Trong JavaScript, "fetch" là một hàm được sử dụng để gửi yêu cầu HTTP và lấy dữ liệu từ các nguồn tài nguyên mạng như API, tệp tin hoặc trang web. Nó giúp tương tác với các máy chủ từ
											xa và lấy thông tin cần thiết từ chúng.
											
			Cú pháp sử dụng "fetch" như sau:
			
											fetch(url [, options])
											  .then(response => {
												// Xử lý phản hồi
											  })
											  .catch(error => {
												// Xử lý lỗi
											  });
			Ví dụ:
			
											fetch('https://api.example.com/data')
											  .then(response => response.json())
											  .then(data => {
												// Xử lý dữ liệu nhận được từ API
												console.log(data);
											  })
											  .catch(error => {
												// Xử lý lỗi nếu có
												console.error(error);
											  });

		
											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo">Fetch a file to change this text.</p>
											<script>
											let file = "fetch_info.txt"
											fetch (file)
											.then(x => x.text())
											.then(y => document.getElementById("demo").innerHTML = y);
											</script>
											</body>
											</html>
											
											Hàm getText(file) được định nghĩa với từ khóa "async". Nó nhận một đối số là tên của tệp tin cần được lấy nội dung.
											Sử dụng "await" để đợi cho kết quả của hàm "fetch(file)" trả về. Hàm "fetch()" được sử dụng để gửi yêu cầu HTTP đến tệp tin được chỉ định và trả về một Promise đại diện cho phản hồi từ
											máy chủ.
											Khi Promise được giải quyết, nội dung của phản hồi được lấy bằng cách sử dụng phương thức "text()" trên đối tượng phản hồi.
											Cuối cùng, nội dung của phần tử có id "demo" được thay đổi thành nội dung của tệp tin đã được lấy.
											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo">Fetch a file to change this text.</p>
											<script>
											getText("fetch_info.txt");
											async function getText(file) {
											  let myObject = await fetch(file);
											  let myText = await myObject.text();
											  document.getElementById("demo").innerHTML = myText;
											}
											</script>
											</body>
											</html>
											
		For In Loop--Các kiến thức nền tảng JAVASCRIPT:
		
											The JavaScript for in statement loops through the properties of an Object:
											
											for (key in object) {
											  // code block to be executed
											}
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript For In Loop</h2>
											<p>The for in statement loops through the properties of an object:</p>
											<p id="demo"></p>
											<script>
											const person = {fname:"John", lname:"Doe", age:25}; 
											let txt = "";
											for (let x in person) {
											  txt += person[x] + " ";
											}
											document.getElementById("demo").innerHTML = txt;
											</script>
											</body>
											</html>
			For In Over Arrays:
											The JavaScript for in statement can also loop over the properties of an Array:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript For In</h2>
											<p>The for in statement can loops over array values:</p>
											<p id="demo"></p>
											<script>
											const numbers = [45, 4, 9, 16, 25];
											let txt = "";
											for (let x in numbers) {
											  txt += numbers[x] + "<br>"; 
											}
											document.getElementById("demo").innerHTML = txt;
											</script>
											</body>
											</html>
											
		For Of--Các kiến thức nền tảng JAVASCRIPT:
		
											The JavaScript for of statement loops through the values of an iterable object.
											It lets you loop over iterable data structures such as Arrays, Strings, Maps, NodeLists, and more:
											
											for (variable of iterable) {
											  // code block to be executed
											}
			Looping over an Array:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript For Of Loop</h2>
											<p>The for of statement loops through the values of any iterable object:</p>
											<p id="demo"></p>
											<script>
											const cars = ["BMW", "Volvo", "Mini"];
											let text = "";
											for (let x of cars) {
											  text += x + "<br>";
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
			Looping over a String:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript For Of Loop</h2>
											<p>The for of statement loops through the values of an iterable object.</p>
											<p id="demo"></p>
											<script>
											let language = "JavaScript";
											let text = "";
											for (let x of language) {
											  text += x + "<br>";
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
		Forms--Các kiến thức nền tảng JAVASCRIPT:
			JavaScript Form Validation:
											HTML form validation can be done by JavaScript.
											
				If a form field (fname) is empty, this function alerts a message, and returns false, to prevent the form from being submitted:
				
											function validateForm() {
											  let x = document.forms["myForm"]["fname"].value;
											  if (x == "") {
												alert("Name must be filled out");
												return false;
											  }
											}
											
				The function can be called when the form is submitted:	

											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function validateForm() {
											  let x = document.forms["myForm"]["fname"].value;
											  if (x == "") {
												alert("Name must be filled out");
												return false;
											  }
											}
											</script>
											</head>
											<body>
											<h2>JavaScript Validation</h2>
											<form name="myForm" action="/action_page.php" onsubmit="return validateForm()" method="post">
											  Name: <input type="text" name="fname">
											  <input type="submit" value="Submit">
											</form>
											</body>
											</html>
				
				JavaScript Can Validate Numeric Input:
											JavaScript is often used to validate numeric input:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Validation</h2>
											<p>Please input a number between 1 and 10:</p>
											<input id="numb">
											<button type="button" onclick="myFunction()">Submit</button>
											<p id="demo"></p>
											<script>
											function myFunction() {
											  // Get the value of the input field with id="numb"
											  let x = document.getElementById("numb").value;
											  // If x is Not a Number or less than one or greater than 10
											  let text;
											  if (isNaN(x) || x < 1 || x > 10) {
												text = "Input not valid";
											  } else {
												text = "Input OK";
											  }
											  document.getElementById("demo").innerHTML = text;
											}
											</script>
											</body>
											</html> 
				Automatic HTML Form Validation:
											HTML form validation can be performed automatically by the browser:
											If a form field (fname) is empty, the required attribute prevents this form from being submitted:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Validation</h2>
											<form action="/action_page.php" method="post">
											  <input type="text" name="fname" required>
											  <input type="submit" value="Submit">
											</form>
											<p>If you click submit, without filling out the text field,
											your browser will display an error message.</p>
											</body>
											</html>
											
		Function apply()--Các kiến thức nền tảng JAVASCRIPT:	
											With the apply() method, you can write a method that can be used on different objects.
											In JavaScript strict mode, if the first argument of the apply() method is not an object, it becomes the owner (object) of the invoked function. In "non-strict" mode, it becomes the
											global object.
					
			The JavaScript apply() Method:
											The apply() method is similar to the call() method
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>In this example the fulllName method of person is <b>applied</b> on person1:</p>
											<p id="demo"></p>
											<script>
											const person = {
											  fullName: function() {
												return this.firstName + " " + this.lastName;
											  }
											}
											const person1 = {
											  firstName:"John",
											  lastName: "Doe"
											}
											document.getElementById("demo").innerHTML = person.fullName.apply(person1); // John Doe
											</script>
											</body>
											</html>
											
			The Difference Between call() and apply():
			
											The call() method takes arguments separately. The apply() method takes arguments as an array.
											The apply() method is very handy if you want to use an array instead of an argument list.
					
			The apply() Method with Arguments:

				The apply() method accepts arguments in an array:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>In this example the fulllName method of person is <b>applied</b> on person1:</p>
											<p id="demo"></p>
											<script>
											const person = {
											  fullName: function(city, country) {
												return this.firstName + " " + this.lastName + "," + city + "," + country;
											  }
											}
											const person1 = {
											  firstName:"John",
											  lastName: "Doe"
											}
											document.getElementById("demo").innerHTML = person.fullName.apply(person1, ["Oslo", "Norway"]); // John Doe,Oslo,Norway
											</script>
											</body>
											</html>
				
				Compared with the call() method:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>This example calls the fullName method of person, using it on person1:
											</p>
											<p id="demo"></p>
											<script>
											const person = {
											  fullName: function(city, country) {
												return this.firstName + " " + this.lastName + "," + city + "," + country;
											  }
											}
											const person1 = {
											  firstName:"John",
											  lastName: "Doe"
											}
											const person2 = {
											  firstName:"Mary",
											  lastName: "Doe"
											}
											document.getElementById("demo").innerHTML = person.fullName.call(person1, "Oslo", "Norway"); // John Doe,Oslo,Norway
											</script>
											</body>
											</html>
			
				Simulate a Max Method on Arrays:
				
					Since JavaScript arrays do not have a max() method, you can apply the Math.max() method instead.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript apply()</h2>
											<p>This example returns the highest number in an array of numbers:</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = Math.max.apply(null, [1,2,3]); // 3. The first argument (null) does not matter. It is not used in this example.
											</script>
											</body>
											</html>
											
					These examples will give the same result:
					
											document.getElementById("demo").innerHTML = Math.max.apply(Math, [1,2,3]); // 3
											
											document.getElementById("demo").innerHTML = Math.max.apply(" ", [1,2,3]); // 3
											
											document.getElementById("demo").innerHTML = Math.max.apply(0, [1,2,3]); // 3
					
					
		Function bind()--Các kiến thức nền tảng JAVASCRIPT:
			Function Borrowing:
											With the bind() method, an object can borrow a method from another object.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Function bind()</h1>
											<p>This example creates 2 objects (person and member).</p>
											<p>The member object borrows the fullname method from person:</p> 
											<p id="demo"></p>
											<script>
											const person = {
											  firstName:"John",
											  lastName: "Doe",
											  fullName: function() {
												return this.firstName + " " + this.lastName;
											  }
											}
											const member = {
											  firstName:"Hege",
											  lastName: "Nilsen",
											}
											let fullName = person.fullName.bind(member);
											document.getElementById("demo").innerHTML = fullName(); // Hege Nilsen
											</script>
											</body>
											</html>
			Preserving this:
											- Sometimes the bind() method has to be used to prevent loosing this.
											- Khi bạn truyền một hàm như một callback cho một hàm khác như setTimeout, hàm callback được gọi trong một ngữ cảnh khác và không trực tiếp từ đối tượng gốc. Thông thường, ngữ cảnh
											this sẽ thay đổi và trở thành đối tượng khác hoặc toàn cục (global object) trong trường hợp không sử dụng strict mode.\
											- Trong JavaScript, từ khóa this thường được sử dụng để truy cập đến đối tượng mà hàm hiện tại đang được gọi trên. Tuy nhiên, khi một hàm được sử dụng như một callback, ngữ cảnh và giá
											trị của this có thể thay đổi hoặc không được xác định rõ ràng.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Function bind()</h1>
											<p>In this example, the person object has a display method:</p>
											<p id="demo"></p>
											<script>
											const person = {
											  firstName:"John",
											  lastName: "Doe",
											  display: function() {
												let x = document.getElementById("demo");
												x.innerHTML = this.firstName + " " + this.lastName; // John Doe
											  }
											}
											person.display();
											</script>
											</body>
											</html>
				
				When a function is used as a callback, this is lost:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Function bind()</h1>
											<p>This example will try to display a person name after 3 seconds.</p>
											<p id="demo"></p>
											<script>
											const person = {
											  firstName:"John",
											  lastName: "Doe",
											  display: function() {
												let x = document.getElementById("demo");
												x.innerHTML = this.firstName + " " + this.lastName; // undefined undefined. Nguyên nhân chính là việc mất mát ngữ cảnh this khi sử dụng hàm như một callback.
											  }
											}
											setTimeout(person.display, 3000);
											</script>
											</body>
											</html>
											
				The bind() method solves this problem:

											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Function bind()</h1>
											<p>This example will display a person name after 3 seconds:</p>
											<p id="demo"></p>
											<script>
											const person = {
											  firstName:"John",
											  lastName: "Doe",
											  display: function() {
												let x = document.getElementById("demo");
												x.innerHTML = this.firstName + " " + this.lastName; // John Doe
											  }
											}
											let display = person.display.bind(person);
											setTimeout(display, 3000);
											</script>
											</body>
											</html>
											
		Function call()--Các kiến thức nền tảng JAVASCRIPT:

											With the call() method, you can write a method that can be used on different objects.
											
			All Functions are Methods:
											In JavaScript all functions are object methods. If a function is not a method of a JavaScript object, it is a function of the global object
											
			The JavaScript call() Method:
											
											The call() method is a predefined JavaScript method. It can be used to invoke (call) a method with an owner object as an argument (parameter).
											With call(), an object can use a method belonging to another object.

											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>This example calls the fullName method of person, using it on person1:
											</p>
											<p id="demo"></p>
											<script>
											const person = {
											  fullName: function() {
												return this.firstName + " " + this.lastName;
											  }
											}
											const person1 = {
											  firstName:"John",
											  lastName: "Doe"
											}
											const person2 = {
											  firstName:"Mary",
											  lastName: "Doe"
											}
											document.getElementById("demo").innerHTML = person.fullName.call(person1); // John Doe
											</script>
											</body>
											</html>
											
			The call() Method with Arguments:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>This example calls the fullName method of person, using it on person1:
											</p>
											<p id="demo"></p>
											<script>
											const person = {
											  fullName: function(city, country) {
												return this.firstName + " " + this.lastName + "," + city + "," + country;
											  }
											}
											const person1 = {
											  firstName:"John",
											  lastName: "Doe"
											}
											const person2 = {
											  firstName:"Mary",
											  lastName: "Doe"
											}
											document.getElementById("demo").innerHTML = person.fullName.call(person1, "Oslo", "Norway"); // John Doe,Oslo,Norway
											</script>
											</body>
											</html>
											
		Self-Invoking Functions--Các kiến thức nền tảng JAVASCRIPT:
											Function expressions can be made "self-invoking".
											A self-invoking expression is invoked (started) automatically, without being called.
											Function expressions will execute automatically if the expression is followed by ().
											You cannot self-invoke a function declaration.
											You have to add parentheses around the function to indicate that it is a function expression:
											
											<!DOCTYPE html>
											<html>
											<body>
											<p>Functions can be invoked automatically without being called:</p>
											<p id="demo"></p> // Hello! I called myself
											<script>
											(function () {
											  document.getElementById("demo").innerHTML = "Hello! I called myself";
											})(); // 
											</script>
											</body>
											</html>
											
		Function Parameters--Các kiến thức nền tảng JAVASCRIPT:
		
			Parameter Rules:
											- JavaScript function definitions do not specify data types for parameters.
											- JavaScript functions do not perform type checking on the passed arguments.
											- JavaScript functions do not check the number of arguments received.
											- If a function is called with missing arguments (less than declared), the missing values are set to undefined.
											- In JavaScript, object references are values. Because of this, objects will behave like they are passed by reference. If a function changes an object property, it changes the original 
											value. Changes to object properties are visible (reflected) outside the function.
			Default Parameters:
											Sometimes this is acceptable, but sometimes it is better to assign a default value to the parameter:
											
											<!DOCTYPE html>
											<html>
											<body>
											<p>Setting a default value to a function parameter (y=2).</p>
											<p id="demo"></p>
											<script>
											function myFunction(x, y = 2) {
											  return x * y;
											}
											document.getElementById("demo").innerHTML = myFunction(4); // 8
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Functions</h1>
											<h2>Default Parameter Values</h2>
											<p>If y is not passed or undefined, then y = 10:</p>
											<p id="demo"></p>
											<script>
											function myFunction(x, y = 10) {
											  return x + y;
											}
											document.getElementById("demo").innerHTML = myFunction(5,6); // 11
											</script>
											</body>
											</html>
			The Arguments Object:
											JavaScript functions have a built-in object called the arguments object.
											The argument object contains an array of the arguments used when the function was called (invoked).
											If a function is called with too many arguments (more than declared), these arguments can be reached using the arguments object.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>Finding the largest number.</p>
											<p id="demo"></p>
											<script>
											function findMax() {
											  let max = -Infinity;
											  for(let i = 0; i < arguments.length; i++) {
												if (arguments[i] > max) {
												  max = arguments[i];
												}
											  }
											  return max;
											} 
											document.getElementById("demo").innerHTML = findMax(4, 5, 6); // 6
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Functions</h2>
											<p>Sum of all arguments:</p>
											<p id="demo"></p>
											<script>
											function sumAll() {
											  let sum = 0;
											  for(let i = 0; i < arguments.length; i++) {
												sum += arguments[i];
											  }
											  return sum;
											}
											document.getElementById("demo").innerHTML = sumAll(1, 123, 500, 115, 44, 88); // 871
											</script>
											</body>
											</html>
											
		Hoisting--Các kiến thức nền tảng JAVASCRIPT:
		
											Hoisting is JavaScript's default behavior of moving declarations to the top.
											
			Sự khác nhau chính giữa hoisting của var so với let và const:
			
				var:
											Khi sử dụng từ khóa var, biến được khởi tạo với giá trị mặc định là undefined trong quá trình hoisting. Điều này có nghĩa là, dù biến được khai báo ở bất kỳ đâu trong phạm vi hàm
											hoặc khối mã, nó sẽ tồn tại và có giá trị undefined từ đầu của phạm vi đó.
											
											console.log(myVar); // undefined
											var myVar = 10;
											console.log(myVar); // 10

				let và const:
											Khi sử dụng từ khóa let hoặc const, biến không được khởi tạo với giá trị mặc định trong quá trình hoisting. Thay vào đó, biến sẽ tồn tại trong phạm vi khối mã, nhưng không có giá trị
											khởi tạo. Điều này có nghĩa là ta không thể truy cập vào biến trước khi nó được khai báo.
											
											console.log(myVar); // ReferenceError: myVar is not defined
											let myVar = 20;
											console.log(myVar); // 20
											
			JavaScript Initializations are Not Hoisted:
			
											JavaScript only hoists declarations, not initializations.

											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo"></p>
											<script>
											var x = 5; // Initialize x
											var y = 7; // Initialize y
											elem = document.getElementById("demo"); // Find an element 
											elem.innerHTML = x + " " + y;       // Display x and y. 5 7
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo"></p>
											<script>
											var x = 5;  // Initialize x
											elem = document.getElementById("demo");      // Find an element 
											elem.innerHTML = "x is " + x + " and y is " + y;  // Display x and y. x is 5 and y is undefined
											var y = 7;  // Initialize y
											</script>
											</body>
											</html>
											
			Declare Your Variables At the Top:
			
											Hoisting is (to many developers) an unknown or overlooked behavior of JavaScript.
											If a developer doesn't understand hoisting, programs may contain bugs (errors).
											To avoid bugs, always declare all variables at the beginning of every scope.
											Since this is how JavaScript interprets the code, it is always a good rule.
		
		Iterables--Các kiến thức nền tảng JAVASCRIPT:
		
											Iterables are iterable objects (like Arrays). Iterables can be accessed with simple and efficient code. Iterables can be iterated over with for..of loops
			Iterating Over a String:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Iterables</h2>
											<p>Iterate over a String:</p>
											<p id="demo"></p>
											<script>
											// Create a String
											const name = "W3Schools";
											// List all Elements
											let text = ""
											for (const x of name) {
											  text += x + "<br>"; // W 3 S c h o o l s
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
			Iterating Over an Array:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Iterables</h2>
											<p>Iterate over an Array:</p>
											<p id="demo"></p>
											<script>
											// Create aa Array
											const letters = ["a","b","c"];
											// List all Elements
											let text = "";
											for (const x of letters) {
											  text += x + "<br>"; // a b c
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
			Iterating Over a Set:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Iterables</h2>
											<p>Iterate over a Set:</p>
											<p id="demo"></p>
											<script>
											// Create a Set
											const letters = new Set(["a","b","c"]);
											// List all Elements
											let text = "";
											for (const x of letters) {
											  text += x + "<br>"; // a b c
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
			Iterating Over a Map:
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Iterables</h2>
											<p>Iterate over a Map:</p>
											<p id="demo"></p>
											<script>
											// Create a Map
											const fruits = new Map([
											  ["apples", 500],
											  ["bananas", 300],
											  ["oranges", 200]
											]);
											// List all entries
											let text = "";
											for (const x of fruits) {
											  text += x + "<br>";
											}
											document.getElementById("demo").innerHTML = text; // apples, 500 bananas, 300 oranges, 200
											</script>
											</body>
											</html>
		JSON--Các kiến thức nền tảng JAVASCRIPT:
		
											- JSON is a format for storing and transporting data. JSON is often used when data is sent from a server to a web page.
											- The JSON syntax is derived from JavaScript object notation syntax, but the JSON format is text only. Code for reading and generating JSON data can be written in any programming
											language.
											- JSON (JavaScript Object Notation) không phụ thuộc vào ngôn ngữ lập trình cụ thể nào. Nó là một định dạng dữ liệu độc lập, được sử dụng rộng rãi trong việc truyền tải và lưu trữ dữ
											liệu giữa các hệ thống khác nhau.
											
											{
												"employees":[
												  {"firstName":"John", "lastName":"Doe"},
												  {"firstName":"Anna", "lastName":"Smith"},
												  {"firstName":"Peter", "lastName":"Jones"}
												]
											}
			JSON Syntax Rules:
											Data is in name/value pairs
											Data is separated by commas
											Curly braces hold objects
											Square brackets hold arrays
			
			Converting a JSON Text to a JavaScript Object:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Create Object from JSON String</h2>
											<p id="demo"></p>
											<script>
											let text = '{"employees":[' +
											'{"firstName":"John","lastName":"Doe" },' + // Dấu + được sử dụng để nối (concatenate) các chuỗi văn bản lại với nhau
											'{"firstName":"Anna","lastName":"Smith" },' +
											'{"firstName":"Peter","lastName":"Jones" }]}';
											const obj = JSON.parse(text); // convert the string into a JavaScript object
											document.getElementById("demo").innerHTML =
											obj.employees[1].firstName + " " + obj.employees[1].lastName; // Anna Smith
											</script>
											</body>
											</html>
											
		Object Accessors--Các kiến thức nền tảng JAVASCRIPT:
		
											Getters and setters allow you to define Object Accessors (Computed Properties).
											JavaScript can secure better data quality when using getters and setters.
			
			JavaScript Getter (The get Keyword):
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Getters and Setters</h2>
											<p>Getters and setters allow you to get and set object properties via methods.</p>
											<p>This example uses a lang property to get the value of the language property:</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "en",
											  get lang() {
												return this.language;
											  }
											};
											// Display data from the object using a getter:
											document.getElementById("demo").innerHTML = person.lang; // en
											</script>
											</body>
											</html>
											
			JavaScript Setter (The set Keyword):
			
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Getters and Setters</h2>
											<p>Getters and setters allow you to get and set properties via methods.</p>
											<p>This example uses a lang property to set the value of the language property.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  language: "NO",
											  set lang(value) {
												this.language = value;
											  }
											};
											// Set a property using set:
											person.lang = "en";
											// Display data from the object:
											document.getElementById("demo").innerHTML = person.language; // en
											</script>
											</body>
											</html>
											
		Output--Các kiến thức nền tảng JAVASCRIPT:
		
			Using innerHTML:
											document.getElementById("demo").innerHTML = 5 + 6;
			Using document.write():
											document.write(5 + 6);
											
											<button type="button" onclick="document.write(5 + 6)">Try it</button>
			Using window.alert():
											window.alert(5 + 6);
			Using window.print():
											<button onclick="window.print()">Print this page</button>
			Using console.log():
											console.log(5 + 6);
		
		Performance--Các kiến thức nền tảng JAVASCRIPT:
		
			Reduce Activity in Loops:
				Bad:
											for (let i = 0; i < arr.length; i++) {}
				Better Code:
											let l = arr.length;
											for (let i = 0; i < l; i++) {}
											
			Reduce DOM Access:
											Accessing the HTML DOM is very slow, compared to other JavaScript statements. If you expect to access a DOM element several times, access it once, and use it as a local variable:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Performance</h2>
											<p>If you expect to access a DOM element several times, access it once, and the use it as a local variable:</p>
											<p id="demo"></p>
											<script>
											const obj = document.getElementById("demo");
											obj.innerHTML = " Hello";
											</script>
											</body>
											</html> 
			
			Reduce DOM Size:
			
											Keep the number of elements in the HTML DOM small. This will always improve page loading, and speed up rendering (page display), especially on smaller devices.
											Every attempt to search the DOM (like getElementsByTagName) will benefit from a smaller DOM.
											
			Avoid Unnecessary Variables:
			
											Don't create new variables if you don't plan to save values.
											
				Often you can replace code like this:							
											
											let fullName = firstName + " " + lastName;
											document.getElementById("demo").innerHTML = fullName;
											
				With this:
				
											document.getElementById("demo").innerHTML = firstName + " " + lastName;
											
				Delay JavaScript Loading:

											Putting your scripts at the bottom of the page body lets the browser load the page first.
											While a script is downloading, the browser will not start any other downloads. In addition all parsing and rendering activity might be blocked.
											If possible, you can add your script to the page by code, after the page has loaded:
											
											<script>
											window.onload = function() {
											  const element = document.createElement("script");
											  element.src = "myScript.js";
											  document.body.appendChild(element);
											};
											</script>
		
		Popup Boxes--Các kiến thức nền tảng JAVASCRIPT:
		
			Alert Box:

											An alert box is often used if you want to make sure information comes through to the user.
											When an alert box pops up, the user will have to click "OK" to proceed.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Alert</h2>
											<button onclick="myFunction()">Try it</button>
											<script>
											function myFunction() {
											  alert("I am an alert box!");
											}
											</script>
											</body>
											</html>
											
			Confirm Box:
			
											A confirm box is often used if you want the user to verify or accept something. a confirm box pops up, the user will have to click either "OK" or "Cancel" to proceed.
											If the user clicks "OK", the box returns true. If the user clicks "Cancel", the box returns false.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Confirm Box</h2>
											<button onclick="myFunction()">Try it</button>
											<p id="demo"></p>
											<script>
											function myFunction() {
											  var txt;
											  if (confirm("Press a button!")) {
												txt = "You pressed OK!";
											  } else {
												txt = "You pressed Cancel!";
											  }
											  document.getElementById("demo").innerHTML = txt;
											}
											</script>
											</body>
											</html>
											
			Prompt Box:

											A prompt box is often used if you want the user to input a value before entering a page.
											When a prompt box pops up, the user will have to click either "OK" or "Cancel" to proceed after entering an input value.
											If the user clicks "OK" the box returns the input value. If the user clicks "Cancel" the box returns null.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Prompt</h2>
											<button onclick="myFunction()">Try it</button>
											<p id="demo"></p>
											<script>
											function myFunction() {
											  let text;
											  let person = prompt("Please enter your name:", "Harry Potter");
											  if (person == null || person == "") {
												text = "User cancelled the prompt.";
											  } else {
												text = "Hello " + person + "! How are you today?";
											  }
											  document.getElementById("demo").innerHTML = text;
											}
											</script>
											</body>
											</html>
			
			Line Breaks:
			
											To display line breaks inside a popup box, use a back-slash followed by the character n.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript</h2>
											<p>Line-breaks in a popup box.</p>
											<button onclick="alert('Hello\nHow are you?')">Try it</button>
											</body>
											</html>

			
		Sorting Arrays--Các kiến thức nền tảng JAVASCRIPT:
		
											The sort() method sorts an array alphabetically
											The reverse() method reverses the elements in an array.
											
			Numeric Sort:

											By default, the sort() function sorts values as strings. This works well for strings ("Apple" comes before "Banana").
											However, if numbers are sorted as strings, "25" is bigger than "100", because "2" is bigger than "1".
											Because of this, the sort() method will produce incorrect result when sorting numbers.
											You can fix this by providing a compare function
											Nếu giá trị trả về là âm, a sẽ được đặt trước b. Nếu giá trị trả về là dương, b sẽ được đặt trước a. Và nếu giá trị trả về là 0, thứ tự của a và b sẽ không thay đổi.
											Giá trị âm: Nếu a nhỏ hơn b, hàm so sánh trả về một số nguyên âm (ví dụ: -1).
											Giá trị dương: Nếu a lớn hơn b, hàm so sánh trả về một số nguyên dương (ví dụ: 1).
											Giá trị 0: Nếu a bằng b, hàm so sánh trả về 0.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Array Sort</h2>
											<p>Sort the array in ascending order:</p>
											<p id="demo1"></p>
											<p id="demo2"></p>
											<script>
											const points = [40, 100, 1, 5, 25, 10];
											document.getElementById("demo1").innerHTML = points;  
											points.sort(function(a, b){return a - b});
											document.getElementById("demo2").innerHTML = points; // 1,5,10,25,40,100
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Array Sort</h2>
											<p>Sort the array in descending order:</p>
											<p id="demo1"></p>
											<p id="demo2"></p>
											<script>
											const points = [40, 100, 1, 5, 25, 10];
											document.getElementById("demo1").innerHTML = points;
											points.sort(function(a, b){return b - a});
											document.getElementById("demo2").innerHTML = points; // 100,40,25,10,5,1
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Array Sort</h2>
											<p>Sort car objects on age:</p>
											<p id="demo"></p>
											<script>
											const cars = [
											  {type:"Volvo", year:2016},
											  {type:"Saab", year:2001},
											  {type:"BMW", year:2010}
											];
											displayCars();
											cars.sort(function(a, b){return a.year - b.year});
											displayCars();
											function displayCars() {
											  document.getElementById("demo").innerHTML =
											  cars[0].type + " " + cars[0].year + "<br>" +
											  cars[1].type + " " + cars[1].year + "<br>" +
											  cars[2].type + " " + cars[2].year;
											}
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Array Sort</h2>
											<p>Click the buttons to sort car objects on type.</p>
											<button onclick="myFunction()">Sort</button>
											<p id="demo"></p>
											<script>
											const cars = [
											  {type:"Volvo", year:2016},
											  {type:"Saab", year:2001},
											  {type:"BMW", year:2010}
											];
											displayCars();
											function myFunction() {
											  cars.sort(function(a, b){
												let x = a.type.toLowerCase();
												let y = b.type.toLowerCase();
												if (x < y) {return -1;}
												if (x > y) {return 1;}
												return 0;
											  });
											  displayCars();
											}
											function displayCars() {
											  document.getElementById("demo").innerHTML =
											  cars[0].type + " " + cars[0].year + "<br>" +
											  cars[1].type + " " + cars[1].year + "<br>" +
											  cars[2].type + " " + cars[2].year;
											}
											</script>
											</body>
											</html>
											
			Sorting an Array in Random Order:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Array Sort</h2>
											<p>Click the button (again and again) to sort the array in random order.</p>
											<button onclick="myFunction()">Try it</button>
											<p id="demo"></p>
											<script>
											const points = [40, 100, 1, 5, 25, 10];
											document.getElementById("demo").innerHTML = points;  
											function myFunction() {
											  points.sort(function(){return 0.5 - Math.random()});
											  document.getElementById("demo").innerHTML = points;
											}
											</script>
											</body>
											</html>
		
		Static Methods--Các kiến thức nền tảng JAVASCRIPT:
		
			Static class methods are defined on the class itself. You cannot call a static method on an object, only on an object class:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Class Static Methods</h2>
											<p>A static method is created with the "static" keyword, and you can only call the method on the class itself.</p>
											<p id="demo"></p>
											<script>
											class Car {
											  constructor(name) {
												this.name = name;
											  }
											  static hello() {
												return "Hello!!";
											  }
											}
											let myCar = new Car("Ford");
											//You can call 'hello()' on the Car Class:
											document.getElementById("demo").innerHTML = Car.hello(); // Hello!!
											// But NOT on  a Car Object:
											// document.getElementById("demo").innerHTML = myCar.hello();
											// this will raise an error.
											</script>
											</body>
											</html>
											
			If you want to use the myCar object inside the static method, you can send it as a parameter:

											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Class Static Methods</h2>
											<p>To use the "myCar" object inside the static method, you can send it as parameter.</p>
											<p id="demo"></p>
											<script>
											class Car {
											  constructor(name) {
												this.name = name;
											  }
											  static hello(x) {
												return "Hello " + x.name;
											  }
											}
											let myCar = new Car("Ford");
											document.getElementById("demo").innerHTML = Car.hello(myCar);
											</script>
											</body>
											</html>
		
		Timing Events--Các kiến thức nền tảng JAVASCRIPT:
		
											The window object allows execution of code at specified time intervals. These time intervals are called timing events.
											The setTimeout() and setInterval() are both methods of the HTML DOM Window object.
			
			The setTimeout() Method:
			
											Executes a function, after waiting a specified number of milliseconds.
											
											window.setTimeout(function, milliseconds);
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Timing</h2>
											<p>Click "Try it". Wait 3 seconds, and the page will alert "Hello".</p>
											<button onclick="setTimeout(myFunction, 3000);">Try it</button>
											<script>
											function myFunction() {
											  alert('Hello');
											}
											</script>
											</body>
											</html>
											
			The clearTimeout() method:

											The clearTimeout() method stops the execution of the function specified in setTimeout().
											The clearTimeout() method uses the variable returned from setTimeout()
											If the function has not already been executed, you can stop the execution by calling the clearTimeout() method
											
											window.clearTimeout(timeoutVariable)
											
											myVar = setTimeout(function, milliseconds);
											clearTimeout(myVar);
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Timing</h2>
											<p>Click "Try it". Wait 3 seconds. The page will alert "Hello".</p>
											<p>Click "Stop" to prevent the first function to execute.</p>
											<p>(You must click "Stop" before the 3 seconds are up.)</p>
											<button onclick="myVar = setTimeout(myFunction, 3000)">Try it</button>
											<button onclick="clearTimeout(myVar)">Stop it</button>
											<script>
											function myFunction() {
											  alert("Hello");
											}
											</script>
											</body>
											</html>
											
			The setInterval() Method:
			
											The setInterval() method repeats a given function at every given time-interval.
											
											window.setInterval(function, milliseconds);
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Timing</h2>
											<p>A script on this page starts this clock:</p>
											<p id="demo"></p>
											<script>
											setInterval(myTimer, 1000);
											function myTimer() {
											  const d = new Date();
											  document.getElementById("demo").innerHTML = d.toLocaleTimeString();
											}
											</script>
											</body>
											</html>
											
			The clearInterval() method:
			
											The clearInterval() method stops the executions of the function specified in the setInterval() method.
											The clearInterval() method uses the variable returned from setInterval():
											
											window.clearInterval(timerVariable)
											
											let myVar = setInterval(function, milliseconds);
											clearInterval(myVar);
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Timing</h2>
											<p>A script on this page starts this clock:</p>
											<p id="demo"></p>
											<button onclick="clearInterval(myVar)">Stop time</button>
											<script>
											let myVar = setInterval(myTimer ,1000);
											function myTimer() {
											  const d = new Date();
											  document.getElementById("demo").innerHTML = d.toLocaleTimeString();
											}
											</script>
											</body>
											</html>
		
		Type Conversion--Các kiến thức nền tảng JAVASCRIPT:
		
			Converting Strings to Numbers:
			
											The global method Number() converts a variable (or a value) into a number. A numeric string (like "3.14") converts to a number (like 3.14). An empty string (like "") converts to 0. A
											non numeric string (like "John") converts to NaN (Not a Number).
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Numbers</h1>
											<h2>The Number() Method</h2>
											<p>The Number() metod converts a variable (or value) into a number:</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML =
											Number("3.14") + "<br>" + // 3.14
											Number(Math.PI) + "<br>" + // 3.1415926
											Number("    ") + "<br>" + // 0
											Number("") + "<br>" + // 0
											Number("99 88") + "<br>" + // NaN
											Number("John") + "<br>"; // NaN
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>The JavaScript typeof Operator</h2>
											<p>The typeof operator returns the type of a variable or expression:</p>
											<p id="demo"></p>
											<script>
											let y = "5";
											let x = + y;
											document.getElementById("demo").innerHTML = typeof y + "<br>" + typeof x; // string number
											</script>
											</body>
											</html>
											
			Converting Numbers to Strings:
			
											The global method String() can convert numbers to strings. It can be used on any type of numbers, literals, variables, or expressions:
											The Number method toString() does the same.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>The JavaScript String() Method</h2>
											<p>The String() method can convert a number to a string.</p>
											<p id="demo"></p>
											<script>
											let x = 123;
											document.getElementById("demo").innerHTML =
											  String(x) + "<br>" +
											  String(123) + "<br>" +
											  String(100 + 23);
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Number Methods</h2>
											<p>The toString() method converts a number to a string.</p>
											<p id="demo"></p>
											<script>
											let x = 123;
											document.getElementById("demo").innerHTML =
											  x.toString() + "<br>" + // 123
											   (123).toString() + "<br>" + // 123
											   (100 + 23).toString(); // 123
											</script>
											</body>
											</html>
			
			Converting Dates to Numbers:

				The global method Number() can be used to convert dates to numbers:
											
											d = new Date();
											Number(d)          // returns 1404568027739
											
				The date method getTime() does the same:
				
											d = new Date();
											d.getTime()        // returns 1404568027739
											
			Converting Dates to Strings:
			
				The global method String() can convert dates to strings:

											String(Date())  // returns "Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)"
											
				The Date method toString() does the same:
				
											Date().toString()  // returns "Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)"
			
			Converting Booleans to Numbers--Các kiến thức nền tảng JAVASCRIPT:
			
											The global method Number() can also convert booleans to numbers.
											
											Number(false)     // returns 0
											Number(true)      // returns 1
											
			Converting Booleans to Strings:
			
											The global method String() can convert booleans to strings.
											The Boolean method toString() does the same.
											
											false.toString()   // returns "false"
											true.toString()    // returns "true"
											
			Automatic Type Conversion:
			
											JavaScript automatically calls the variable's toString() function when you try to "output" an object or a variable
											Numbers and booleans are also converted, but this is not very visible:
											
											document.getElementById("demo").innerHTML = myVar;
											// if myVar = {name:"Fjohn"}  // toString converts to "[object Object]"
											// if myVar = [1,2,3,4]       // toString converts to "1,2,3,4"
											// if myVar = new Date()      // toString converts to "Fri Jul 18 2014 09:08:55 GMT+0200"
											// if myVar = 123             // toString converts to "123"
											// if myVar = true            // toString converts to "true"
											// if myVar = false           // toString converts to "false"
		
		typeof--Các kiến thức nền tảng JAVASCRIPT:
		
											The data type of NaN is number
											The data type of an array is object
											The data type of a date is object
											The data type of null is object
											The data type of an undefined variable is undefined *
											The data type of a variable that has not been assigned a value is also undefined *
		
			In JavaScript there are 5 different data types that can contain values:
									
											string
											number
											boolean
											object
											function
											
			There are 6 types of objects:
			
											Object
											Date
											Array
											String
											Number
											Boolean
											
			And 2 data types that cannot contain values:
			
											null
											undefined
											
			Example:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Operators</h1>
											<h2>The typeof Operator</h2>
											<p>The typeof operator returns the type of a variable, an object, a function or an expression:</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = 
											  typeof "john" + "<br>" + // string
											  typeof 3.14 + "<br>" + // number
											  typeof NaN + "<br>" + // number
											  typeof false + "<br>" + // boolean
											  typeof [1,2,3,4] + "<br>" + //object
											  typeof {name:'john', age:34} + "<br>" + //object
											  typeof new Date() + "<br>" + //object
											  typeof function () {} + "<br>" + // function
											  typeof myCar + "<br>" + // undefined
											  typeof null; // object
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Operators</h1>
											<h2>The typeof Operator</h2>
											<p>The typeof operator returns the type of a variable or an expression.</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = 
											typeof "john" + "<br>" + // string
											typeof 3.14 + "<br>" + // number
											typeof true + "<br>" + // boolean
											typeof false + "<br>" + // boolean
											typeof x; // undefined
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Operators</h1>
											<h2>The typeof Operator</h2>
											<p>The typeof operator returns object for both objects, arrays, and null.</p>
											<p>The typeof operator does not return object for functions.</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = 
											typeof {name:'john', age:34} + "<br>" + // object
											typeof [1,2,3,4] + "<br>" + // object
											typeof null + "<br>" + // object
											typeof function myFunc(){}; // function
											</script>
											</body>
											</html>
											
											let car = "";
											document.getElementById("demo").innerHTML =
											"The value is: " +
											car + "<br>" + // The value is: 
											"The type is: " + typeof car; // The type is: string
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript</h2>
											<p>Objects can be emptied by setting the value to <b>null</b>.</p>
											<p id="demo"></p>
											<script>
											let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
											person = null;
											document.getElementById("demo").innerHTML = typeof person; // object
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Objects</h1>
											<h2>The undefined Data Type</h2>
											<p>Objects can be emptied by setting the value to <b>undefined</b>.</p>
											<p id="demo"></p>
											<script>
											let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
											person = undefined;
											document.getElementById("demo").innerHTML = person; // undefined
											</script>
											</body>
											</html> 
																						
											
		this Keyword--Các kiến thức nền tảng JAVASCRIPT:
		
											In JavaScript, the this keyword refers to an object. Which object depends on how this is being invoked (used or called).
											The this keyword refers to different objects depending on how it is used:
													In an object method, this refers to the object.
													Alone, this refers to the global object.
													In a function, this refers to the global object.
													In a function, in strict mode, this is undefined.
													In an event, this refers to the element that received the event.
													Methods like call(), apply(), and bind() can refer this to any object.
													
			this in a Method:
							
											When used in an object method, this refers to the object.
											In the example on top of this page, this refers to the person object.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example, <b>this</b> refers to the <b>person</b> object.</p>
											<p>Because <b>fullName</b> is a method of the person object.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName: "John",
											  lastName: "Doe",
											  id: 5566,
											  fullName : function() {
												return this.firstName + " " + this.lastName;
											  }
											};
											// Display data from the object:
											document.getElementById("demo").innerHTML = person.fullName(); // John Doe
											</script>
											</body>
											</html>
			this Alone:
											When used alone, this refers to the global object. Because this is running in the global scope.
											In a browser window the global object is [object Window]:
		
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example, <b>this</b> refers to the window object:</p>
											<p id="demo"></p>
											<script>
											let x = this;
											document.getElementById("demo").innerHTML = x; // [object Windown]
											</script>
											</body>
											</html>
											
				In strict mode, when used alone, this also refers to the global object:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example, <b>this</b> refers to the window object:</p>
											<p id="demo"></p>
											<script>
											"use strict";
											let x = this;
											document.getElementById("demo").innerHTML = x; // [object Windown]
											</script>
											</body>
											</html>
											
			this in a Function (Default):
			
											- In a function, the global object is the default binding for this. In a browser window the global object is [object Window]
											- Trong JavaScript, từ khóa this thường đại diện cho đối tượng hiện tại mà hàm đang được gọi trên. Tuy nhiên, khi một hàm được gọi mà không có đối tượng nào liên quan, hoặc từ khóa this
											được sử dụng bên ngoài bất kỳ hàm nào, nó sẽ được gắn kết với đối tượng toàn cục (global object).
											- Trong môi trường trình duyệt web, đối tượng toàn cục là window object. Vì vậy, khi một hàm không được gọi trên đối tượng cụ thể nào, từ khóa this sẽ được gắn kết với đối tượng window.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example, <b>this</b> refers to the the window object:</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = myFunction(); // [object Windown]
											function myFunction() {
											  return this;
											}
											</script>
											</body>
											</html>
											
			this in a Function (Strict):
			
											- JavaScript strict mode does not allow default binding. So, when used in a function, in strict mode, this is undefined.
											- Trong chế độ nghiêm ngặt (strict mode) của JavaScript, không cho phép mặc định gắn kết (default binding). Do đó, khi sử dụng từ khóa this trong một hàm ở chế độ nghiêm ngặt, giá trị
											của this sẽ là undefined.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In a function, by default, <b>this</b> refers to the global object.</p>
											<p>Strict mode does not allow default binding, so <b>this</b> is:</p>
											<p id="demo"></p>
											<script>
											"use strict";
											document.getElementById("demo").innerHTML = myFunction(); // undefined
											function myFunction() {
											  return this;
											}
											</script>
											</body>
											</html>
											
			this in Event Handlers:
			
											In HTML event handlers, this refers to the HTML element that received the event:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<button onclick="this.style.display='none'">Click to Remove Me!</button>
											</body>
											</html>
			
			Object Method Binding:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example, <b>this</b> refers to the <b>person object</b>.</p>
											<p id="demo"></p>
											<script>
											// Create an object:
											const person = {
											  firstName  : "John",
											  lastName   : "Doe",
											  id     : 5566,
											  myFunction : function() {
												return this;
											  }
											};
											// Display data from the object:
											document.getElementById("demo").innerHTML = person.myFunction(); [object Object]
											</script>
											</body>
											</html>
											
			Explicit Function Binding:
			
											The call() and apply() methods are predefined JavaScript methods. They can both be used to call an object method with another object as argument.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>The JavaScript <i>this</i> Keyword</h1>
											<p>In this example <strong>this</strong> refers to person2, even if it is a method of person1:</p>
											<p id="demo"></p>
											<script>
											const person1 = {
											  fullName: function() {
												return this.firstName + " " + this.lastName;
											  }
											}
											const person2 = {
											  firstName:"John",
											  lastName: "Doe",
											}
											let x = person1.fullName.call(person2); 
											document.getElementById("demo").innerHTML = x; // John Doe
											</script>
											</body>
											</html>
											
			Function Borrowing:
			
											With the bind() method, an object can borrow a method from another object.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1>JavaScript Function bind()</h1>
											<p>This example creates 2 objects (person and member).</p>
											<p>The member object borrows the fullname method from person:</p> 
											<p id="demo"></p>
											<script>
											const person = {
											  firstName:"John",
											  lastName: "Doe",
											  fullName: function() {
												return this.firstName + " " + this.lastName;
											  }
											}
											const member = {
											  firstName:"Hege",
											  lastName: "Nilsen",
											}
											let fullName = person.fullName.bind(member);
											document.getElementById("demo").innerHTML = fullName();
											</script>
											</body>
											</html>
											
		JSON--Các kiến thức nền tảng JAVASCRIPT:
		
											- When storing data, the data has to be a certain format, and regardless of where you choose to store it, text is always one of the legal formats.
											- JSON makes it possible to store JavaScript objects as text.
											- A common use of JSON is to exchange data to/from a web server. When receiving data from a web server, the data is always a string. Parse the data with JSON.parse(), and the data 
											becomes a JavaScript object.
		
			JSON.parse():
											
											JavaScript has a built in function for converting JSON strings into JavaScript objects
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Creating an Object from a JSON String</h2>
											<p id="demo"></p>
											<script>
											const txt = '{"name":"John", "age":30, "city":"New York"}'
											const obj = JSON.parse(txt);
											document.getElementById("demo").innerHTML = obj.name + ", " + obj.age;
											</script>
											</body>
											</html>
											
				When using the JSON.parse() on a JSON derived from an array, the method will return a JavaScript array, instead of a JavaScript object:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Parsing a JSON Array.</h2>
											<p>Data written as an JSON array will be parsed into a JavaScript array.</p>
											<p id="demo"></p>
											<script>
											const text = '[ "Ford", "BMW", "Audi", "Fiat" ]';
											const myArr = JSON.parse(text);
											document.getElementById("demo").innerHTML = myArr[0];
											</script>
											</body>
											</html>
											
				Exceptions:
					
					Parsing Dates:
					
											Date objects are not allowed in JSON.
											If you need to include a date, write it as a string.
											You can convert it back into a date object later:											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Convert a string into a date object.</h2>
											<p id="demo"></p>
											<script>
											const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
											const obj = JSON.parse(text);
											obj.birth = new Date(obj.birth);
											document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth; 
											</script>
											</body>
											</html>
											
											Or, you can use the second parameter, of the JSON.parse() function, called reviver.
											The reviver parameter is a function that checks each property, before returning the value.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Convert a string into a date object.</h2>
											<p id="demo"></p>
											<script>
											const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
											const obj = JSON.parse(text, function (key, value) {
											  if (key == "birth") {
												return new Date(value);
											  } else {
												return value;
											  }
											});
											document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth; 
											</script>
											</body>
											</html>
					
					Parsing Functions:
					
											Functions are not allowed in JSON.
											If you need to include a function, write it as a string.
											You should avoid using functions in JSON, the functions will lose their scope, and you would have to use eval() to convert them back into functions.
											You can convert it back into a function later:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Convert a string into a function.</h2>
											<p id="demo"></p>
											<script>
											const text = '{"name":"John", "age":"function() {return 30;}", "city":"New York"}';
											const obj = JSON.parse(text);
											obj.age = eval("(" + obj.age + ")");
											document.getElementById("demo").innerHTML = obj.name + ", " + obj.age(); 
											</script>
											</body>
											</html>
			JSON.stringify():
			
											JavaScript also has a built in function for converting an object into a JSON string
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Create a JSON string from a JavaScript object.</h2>
											<p id="demo"></p>
											<script>
											const obj = {name: "John", age: 30, city: "New York"};
											const myJSON = JSON.stringify(obj);
											document.getElementById("demo").innerHTML = myJSON; // {name: "John", age: 30, city: "New York"}
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Create a JSON string from a JavaScript array.</h2>
											<p id="demo"></p>
											<script>
											const arr = ["John", "Peter", "Sally", "Jane"];
											const myJSON = JSON.stringify(arr);
											document.getElementById("demo").innerHTML = myJSON;
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Store and retrieve data from local storage.</h2>
											<p id="demo"></p>
											<script>
											// Storing data:
											const myObj = { name: "John", age: 31, city: "New York" };
											const myJSON = JSON.stringify(myObj);
											localStorage.setItem("testJSON", myJSON);
											// Retrieving data:
											let text = localStorage.getItem("testJSON");
											let obj = JSON.parse(text);
											document.getElementById("demo").innerHTML = obj.name;
											</script>
											</body>
											</html>
				
				Exceptions:
				
					Stringify Dates:
					
											In JSON, date objects are not allowed. The JSON.stringify() function will convert any dates into strings.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JSON.stringify() converts date objects into strings.</h2>
											<p id="demo"></p>
											<script>
											const obj = {name: "John", today: new Date(), city: "New York"};
											const myJSON = JSON.stringify(obj);
											document.getElementById("demo").innerHTML = myJSON; // {name: "John", today: new Date(), city: "New York"}
											</script>
											</body>
											</html>
											
					Stringify Functions:
					
											In JSON, functions are not allowed as object values.
											If you send functions using JSON, the functions will lose their scope, and the receiver would have to use eval() to convert them back into functions.
											The JSON.stringify() function will remove any functions from a JavaScript object, both the key and the value:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JSON.stringify() will remove any functions from an object.</h2>
											<p id="demo"></p>
											<script>
											const obj = {name: "John", age: function () {return 30;}, city: "New York"};
											const myJSON = JSON.stringify(obj);
											document.getElementById("demo").innerHTML = myJSON;
											</script>
											</body>
											</html>
											
											This can be omitted if you convert your functions into strings before running the JSON.stringify() function.
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JSON.stringify() will remove any functions from an object.</h2>
											<p>Convert functions into strings to keep them in the JSON object.</p>
											<p id="demo"></p>
											<script>
											const obj = {name: "John", age: function () {return 30;}, city: "New York"};
											obj.age = obj.age.toString();
											const myJSON = JSON.stringify(obj);
											document.getElementById("demo").innerHTML = myJSON;
											</script>
											</body>
											</html>
											
			JSON Array Literals:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h1>Access an Array by Index</h1>
											<p id="demo"></p>
											<script>
											const myJSON = '["Ford", "BMW", "Fiat"]';
											const myArray = JSON.parse(myJSON);
											document.getElementById("demo").innerHTML = myArray[0]; // Ford
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Access Array Values</h2>
											<p id="demo"></p>
											<script>
											const myJSON = '{"name":"John", "age":30, "cars":["Ford", "BMW", "Fiat"]}';
											const myObj = JSON.parse(myJSON);
											document.getElementById("demo").innerHTML = myObj.cars[0]; // Ford
											</script>
											</body>
											</html>
			
			JSON Data Types:
			
				Valid Data Types:

					In JSON, values must be one of the following data types:

											a string
											a number
											an object (JSON object)
											an array
											a boolean
											null
											
					JSON values cannot be one of the following data types:
					
											a function
											a date
											undefined
											
				JSON Strings:
				
											Strings in JSON must be written in double quotes.
											
											{"name":"John"}
											
				JSON Numbers:
				
											Numbers in JSON must be an integer or a floating point.
											
											{"age":30}
											
				JSON Objects:
				
											{
											"employee":{"name":"John", "age":30, "city":"New York"}
											}
											
				JSON Arrays:
				
											{
											"employees":["John", "Anna", "Peter"]
											}
											
				JSON Booleans:
				
											{"sale":true}
											
				JSON null:

											{"middlename":null}
			JSON HTML:
			
											JSON can very easily be translated into JavaScript. JavaScript can be used to make HTML in your web pages.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>Make a table based on JSON data.</h2>
											<p id="demo"></p>
											<script>
											const dbParam = JSON.stringify({table:"customers",limit:20});
											const xmlhttp = new XMLHttpRequest();
											xmlhttp.onload = function() {
											  const myObj = JSON.parse(this.responseText);
											  let text = "<table border='1'>"
											  for (let x in myObj) {
												text += "<tr><td>" + myObj[x].name + "</td></tr>";
											  }
											  text += "</table>"    
											  document.getElementById("demo").innerHTML = text;
											}
											xmlhttp.open("POST", "json_demo_html_table.php");
											xmlhttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
											xmlhttp.send("x=" + dbParam);
											</script>
											</body>
											</html>
			
			JSON Syntax:
					
				JSON Syntax Rules:

											Data is in name/value pairs
											Data is separated by commas
											Curly braces hold objects
											Square brackets hold arrays
											In JSON, keys must be strings, written with double quotes
											
			JSON vs XML:
											Both JSON and XML can be used to receive data from a web server.
											
				JSON Example:
				
											{"employees":[
											  { "firstName":"John", "lastName":"Doe" },
											  { "firstName":"Anna", "lastName":"Smith" },
											  { "firstName":"Peter", "lastName":"Jones" }
											]}
											
				XML Example:
				
											<employees>
											  <employee>
												<firstName>John</firstName> <lastName>Doe</lastName>
											  </employee>
											  <employee>
												<firstName>Anna</firstName> <lastName>Smith</lastName>
											  </employee>
											  <employee>
												<firstName>Peter</firstName> <lastName>Jones</lastName>
											  </employee>
											</employees>
		
		DOM--Các kiến thức nền tảng JAVASCRIPT:
		
											- The HTML DOM can be accessed with JavaScript (and with other programming languages).
											- In the DOM, all HTML elements are defined as objects.
		
			JavaScript - HTML DOM Methods--JAVASCRIPT DOM:
			
											- HTML DOM methods are actions you can perform (on HTML Elements).
											- HTML DOM properties are values (of HTML Elements) that you can set or change.
											
			JavaScript HTML DOM Elements--JAVASCRIPT DOM:
			
				Finding HTML Elements:
				
											Often, with JavaScript, you want to manipulate HTML elements. To do so, you have to find the elements first. There are several ways to do this:
											
											Finding HTML elements by id
											Finding HTML elements by tag name
											Finding HTML elements by class name
											Finding HTML elements by CSS selectors
											Finding HTML elements by HTML object collections
											
				Finding HTML Element by Id - getElementById:
				
											If the element is found, the method will return the element as an object (in element). If the element is not found, element will contain null.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p id="intro">Finding HTML Elements by Id</p>
											<p>This example demonstrates the <b>getElementsById</b> method.</p>
											<p id="demo"></p>
											<script>
											const element = document.getElementById("intro");
											document.getElementById("demo").innerHTML = 
											"The text from the intro paragraph is: " + element.innerHTML;
											</script>
											</body>
											</html>
											
				Finding HTML Elements by Tag Name - getElementsByTagName:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Finding HTML Elements by Tag Name.</p>
											<p>This example demonstrates the <b>getElementsByTagName</b> method.</p>
											<p id="demo"></p>
											<script>
											const element = document.getElementsByTagName("p");
											document.getElementById("demo").innerHTML = 'The text in first paragraph (index 0) is: ' + element[0].innerHTML;
											</script>											
											</body>
											</html>
											
				Finding HTML Elements by Class Name - getElementsByClassName:
				
											If you want to find all HTML elements with the same class name, use getElementsByClassName().
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Finding HTML Elements by Class Name.</p>
											<p class="intro">Hello World!</p>
											<p class="intro">This example demonstrates the <b>getElementsByClassName</b> method.</p>
											<p id="demo"></p>
											<script>
											const x = document.getElementsByClassName("intro");
											document.getElementById("demo").innerHTML = 
											'The first paragraph (index 0) with class="intro" is: ' + x[1].innerHTML;
											</script>
											</body>
											</html>
											
				Finding HTML Elements by CSS Selectors - querySelectorAll:
				
											If you want to find all HTML elements that match a specified CSS selector (id, class names, types, attributes, values of attributes, etc), use the querySelectorAll() method.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Finding HTML Elements by Query Selector</p>
											<p class="intro">Hello World!.</p>
											<p class="intro">This example demonstrates the <b>querySelectorAll</b> method.</p>
											<p id="demo"></p>
											<script>
											const x = document.querySelectorAll("p.intro");
											document.getElementById("demo").innerHTML = 
											'The first paragraph (index 0) with class="intro" is: ' + x[0].innerHTML;
											</script>
											</body>
											</html>
											
				Finding HTML Elements by HTML Object Collections:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Finding HTML Elements Using <b>document.forms</b>.</p>
											<form id="frm1" action="/action_page.php">
											  First name: <input type="text" name="fname" value="Donald"><br>
											  Last name: <input type="text" name="lname" value="Duck"><br><br>
											  <input type="submit" value="Submit">
											</form> 
											<p>These are the values of each element in the form:</p>
											<p id="demo"></p>
											<script>
											const x = document.forms["frm1"];
											let text = "";
											for (let i = 0; i < x.length ;i++) {
											  text += x.elements[i].value + "<br>";
											}
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>

			JavaScript HTML DOM - Changing CSS--JAVASCRIPT DOM:
			
											The HTML DOM allows JavaScript to change the style of HTML elements.
											
				Changing HTML Style:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Changing the HTML style:</p>
											<p id="p1">Hello World!</p>
											<p id="p2">Hello World!</p>
											<script>
											document.getElementById("p2").style.color = "blue";
											document.getElementById("p2").style.fontFamily = "Arial";
											document.getElementById("p2").style.fontSize = "larger";
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1 id="id1">My Heading 1</h1>
											<button type="button" 
											onclick="document.getElementById('id1').style.color = 'red'">
											Click Me!</button>
											</body>
											</html>
			
			JavaScript HTML DOM - Changing HTML--JAVASCRIPT DOM:
			
											The HTML DOM allows JavaScript to change the content of HTML elements.
											
				Changing HTML Content:

											The easiest way to modify the content of an HTML element is by using the innerHTML property.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript can Change HTML</h2>
											<p id="p1">Hello World!</p>
											<script>
											document.getElementById("p1").innerHTML = "New text!";
											</script>
											<p>The paragraph above was changed by a script.</p>
											</body>
											</html>
			
				Changing the Value of an Attribute:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<img id="image" src="smiley.gif" width="160" height="120">
											<script>
											document.getElementById("image").src = "landscape.jpg";
											</script>
											<p>The original image was smiley.gif, but the script changed it to landscape.jpg</p>
											</body>
											</html>
											
				Dynamic HTML content:
				
											<!DOCTYPE html>
											<html>
											<body>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = "Date : " + Date();
											</script>
											</body>
											</html>
											
			JavaScript HTML DOM Collections--JAVASCRIPT DOM:
			
				The HTMLCollection Object:
				
											- The getElementsByTagName() method returns an HTMLCollection object.
											- An HTMLCollection object is an array-like list (collection) of HTML elements.
											- An HTMLCollection is NOT an array! An HTMLCollection may look like an array, but it is not.
											- You can loop through the list and refer to the elements with a number (just like an array). However, you cannot use array methods like valueOf(), pop(), push(), or join() on
											an HTMLCollection.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Hello World!</p>
											<p>Hello Norway!</p>
											<p id="demo"></p>
											<script>
											const myCollection = document.getElementsByTagName("p");
											document.getElementById("demo").innerHTML = "The innerHTML of the second paragraph is: " + myCollection[1].innerHTML; // Hello Norway!
											</script>
											</body>
											</html>
											
				HTML HTMLCollection Length:
				
											The length property defines the number of elements in an HTMLCollection:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Hello World!</p>
											<p>Hello Norway!</p>
											<p id="demo"></p>
											<script>
											const myCollection = document.getElementsByTagName("p");
											document.getElementById("demo").innerHTML = "This document contains " + myCollection.length + " paragraphs."; // 3
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Hello World!</p>
											<p>Hello Norway!</p>
											<p>Click the button to change the color of all p elements.</p>
											<button onclick="myFunction()">Try it</button>
											<script>
											function myFunction() {
											  const myCollection = document.getElementsByTagName("p");
											  for (let i = 0; i < myCollection.length; i++) {
												myCollection[i].style.color = "red";
											  }
											}
											</script>
											</body>
											</html>
											
			JavaScript HTML DOM Elements (Nodes)--JAVASCRIPT DOM:
			
				Creating New HTML Elements (Nodes):
				
											To add a new element to the HTML DOM, you must create the element (element node) first, and then append it to an existing element.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Add a new HTML Element.</p>
											<div id="div1">
												<p id="p1">This is a paragraph.</p>
												<p id="p2">This is another paragraph.</p>
											</div>
											<script>
											const para = document.createElement("p");
											const node = document.createTextNode("This is new.");
											para.appendChild(node);
											const element = document.getElementById("div1");
											element.appendChild(para);
											</script>
											</body>
											</html>
											// Result:
											// Add a new HTML Element.
											// This is a paragraph.
											// This is another paragraph.
											// This is new.
											
				Creating new HTML Elements - appendChild():
				
											The appendChild() method appended the new element as the last child of the parent.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Add a new HTML Element.</p>
											<div id="div1">
												<p id="p1">This is a paragraph.</p>
												<p id="p2">This is another paragraph.</p>
											</div>
											<script>
											const para = document.createElement("p");
											const node = document.createTextNode("This is new.");
											para.appendChild(node);
											const element = document.getElementById("div1");
											const child = document.getElementById("p2");
											element.insertBefore(para,child);
											</script>
											</body>
											</html>
											// Result:
											//Add a new HTML Element.
											// This is a paragraph.
											// This is new.
											// This is another paragraph.
											
				Removing Existing HTML Elements - remove():
				
											To remove an HTML element, use the remove() method:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<h3>Remove an HTML Element.</h3>
											<div>
												<p id="p1">This is a paragraph.</p>
												<p id="p2">This is another paragraph.</p>
											</div>
											<button onclick="myFunction()">Remove Element</button>
											<script>
											function myFunction() {
											document.getElementById("p1").remove();
											}
											</script>
											</body>
											</html>
											// Result:
											// This is another paragraph.
											
				Removing a Child Node - removeChild(child):
				
											For browsers that does not support the remove() method, you have to find the parent node to remove an element:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<p>Remove Child Element</p>
											<div id="div1">
												<p id="p1">This is a paragraph.</p>
												<p id="p2">This is another paragraph.</p>
											</div>
											<script>
											const parent = document.getElementById("div1");
											const child = document.getElementById("p1");
											parent.removeChild(child);
											</script>
											</body>
											</html>
											// Result:
											// Remove Child Element
											// This is another paragraph.
											
				Replacing HTML Elements - replaceChild(para,child):
				
											To replace an element to the HTML DOM, use the replaceChild() method:
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML DOM</h2>
											<h3>Replace an HTML Element.</h3>
											<div id="div1">
											  <p id="p1">This is a paragraph.</p>
											  <p id="p2">This is a paragraph.</p>
											</div>
											<script>
											const parent = document.getElementById("div1");
											const child = document.getElementById("p1");
											const para = document.createElement("p");
											const node = document.createTextNode("This is new.");
											para.appendChild(node);
											parent.replaceChild(para,child);
											</script>
											</body>
											</html>
											// Result:
											// Replace an HTML Element.									
											// This is new.
											// This is a paragraph.
																						
			JavaScript HTML DOM EventListener--JAVASCRIPT DOM:
			
				Syntax:
				
											The third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.
											
											element.addEventListener(event, function, useCapture);
											
				Add an Event Handler to an Element:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript addEventListener()</h2>
											<p>This example uses the addEventListener() method to attach a click event to a button.</p>
											<button id="myBtn">Try it</button>
											<script>
											document.getElementById("myBtn").addEventListener("click", function() {
											  alert("Hello World!");
											});
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript addEventListener()</h2>
											<p>This example uses the addEventListener() method to execute a function when a user clicks on a button.</p>
											<button id="myBtn">Try it</button>
											<script>
											document.getElementById("myBtn").addEventListener("click", myFunction);
											function myFunction() {
											  alert ("Hello World!");
											}
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript addEventListener()</h2>
											<p>This example uses the addEventListener() method to add two click events to the same button.</p>
											<button id="myBtn">Try it</button>
											<script>
											var x = document.getElementById("myBtn");
											x.addEventListener("click", myFunction);
											x.addEventListener("click", someOtherFunction);
											function myFunction() {
											  alert ("Hello World!");
											}
											function someOtherFunction() {
											  alert ("This function was also executed!");
											}
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript addEventListener()</h2>
											<p>This example uses the addEventListener() method to add many events on the same button.</p>
											<button id="myBtn">Try it</button>
											<p id="demo"></p>
											<script>
											var x = document.getElementById("myBtn");
											x.addEventListener("mouseover", myFunction);
											x.addEventListener("click", mySecondFunction);
											x.addEventListener("mouseout", myThirdFunction);
											function myFunction() {
											  document.getElementById("demo").innerHTML += "Moused over!<br>";
											}
											function mySecondFunction() {
											  document.getElementById("demo").innerHTML += "Clicked!<br>";
											}
											function myThirdFunction() {
											  document.getElementById("demo").innerHTML += "Moused out!<br>";
											}
											</script>
											</body>
											</html>
											
			Add an Event Handler to the window Object--JAVASCRIPT DOM:
			
											The addEventListener() method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support
											events, like the xmlHttpRequest object.
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript addEventListener()</h2>
											<p>This example uses the addEventListener() method on the window object.</p>
											<p>Try resizing this browser window to trigger the "resize" event handler.</p>
											<p id="demo"></p>
											<script>
											window.addEventListener("resize", function(){
											  document.getElementById("demo").innerHTML = Math.random();
											});
											</script>
											</body>
											</html>
											
			Event Bubbling or Event Capturing?--JAVASCRIPT DOM
			
											- There are two ways of event propagation in the HTML DOM, bubbling and capturing.
											- Event propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which
											element's "click" event should be handled first?
											- In bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.
											- In capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.
											- The default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.
											- With the addEventListener() method you can specify the propagation type by using the "useCapture" parameter:
											
											addEventListener(event, function, useCapture);
											
				Event Bubbling:
											Event Bubbling là quá trình khi một sự kiện xảy ra trên một phần tử con, sự kiện đó sẽ được truyền xuống các phần tử cha của nó cho đến phần tử gốc. Nghĩa là sự kiện sẽ lan truyền từ
											phần tử con lên đến các phần tử cha trong cấu trúc cây HTML.
											
											<div id="parent">
											  <div id="child">Click me</div>
											</div>
											<script>
											document.getElementById("parent").addEventListener("click", function() {
											  console.log("Parent clicked");
											});
											document.getElementById("child").addEventListener("click", function() {
											  console.log("Child clicked");
											});
											</script>
											// Result:
											// Child clicked
											// Parent clicked

				Event Capturing:

											Event Capturing, còn được gọi là "trình bắt sự kiện từ trên xuống", là quá trình khi một sự kiện xảy ra trên một phần tử con, sự kiện sẽ được bắt trước đó trên các phần tử cha của nó
											từ phần tử gốc xuống phần tử con. Nghĩa là sự kiện sẽ lan truyền từ phần tử cha xuống đến phần tử con trong cấu trúc cây HTML.
											
											<div id="parent">
											  <div id="child">Click me</div>
											</div>
											<script>
											document.getElementById("parent").addEventListener("click", function() {
											  console.log("Parent clicked");
											}, true);
											document.getElementById("child").addEventListener("click", function() {
											  console.log("Child clicked");
											}, true);
											</script>
											/ Result:
											// Parent clicked											
											// Child clicked

			JavaScript HTML DOM Events--JAVASCRIPT DOM:

			Input Events--JAVASCRIPT DOM:

					onblur - When a user leaves an input field:
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  var x = document.getElementById("fname");
											  x.value = x.value.toUpperCase();
											}
											</script>
											</head>
											<body>
											Enter your name: <input type="text" id="fname" onblur="myFunction()">
											<p>When you leave the input field, a function is triggered which transforms the input text to upper case.</p>
											</body>
											</html>
											
					onchange - When a user changes the content of an input field:
					
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTML Events</h2>
											Enter your name: <input type="text" id="fname" onchange="upperCase()">
											<p>When you leave the input field, a function is triggered which transforms the input text to upper case.</p>
											<script>
											function upperCase() {
											  const x = document.getElementById("fname");
											  x.value = x.value.toUpperCase();
											}
											</script>
											</body>
											</html>

					onchange - When a user selects a dropdown value:
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function preferedBrowser() {
											  prefer = document.forms[0].browsers.value;
											  alert("You prefer browsing internet with " + prefer);
											}
											</script>
											</head>
											<body>
											<form>
											Choose which browser you prefer:
											  <select id="browsers" onchange="preferedBrowser()">
												<option value="Chrome">Chrome</option>
												<option value="Internet Explorer">Internet Explorer</option>
												<option value="Firefox">Firefox</option>
											  </select>
											</form>
											</body>
											</html>
											
					onfocus - When an input field gets focus
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction(x) {
											  x.style.background = "yellow";
											}
											</script>
											</head>
											<body>
											Enter your name: <input type="text" onfocus="myFunction(this)">
											<p>When the input field gets focus, a function is triggered which changes the background-color.</p>
											</body>
											</html>

					onselect - When input text is selected
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  document.getElementById("demo").innerHTML = "You selected some text";
											}
											</script>
											</head>
											<body>
											Some text: <input type="text" value="Hello world!" onselect="myFunction()">
											<p id="demo"></p>
											</body>
											</html>
					
					onsubmit - When a user clicks the submit button
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function confirmInput() {
											  fname = document.forms[0].fname.value;
											  alert("Hello " + fname + "! You will now be redirected to www.w3Schools.com");
											}
											</script>
											</head>
											<body>
											<form onsubmit="confirmInput()" action="https://www.w3schools.com/">
											  Enter your name: <input id="fname" type="text" size="20">
											  <input type="submit">
											</form>
											</body>
											</html>
											
					onreset - When a user clicks the reset button
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function message() {
											  alert("This alert box was triggered by the onreset event handler");
											}
											</script>
											</head>
											<body>
											<form onreset="message()">
											  Enter your name: <input type="text" size="20">
											  <input type="reset">
											</form>
											</body>
											</html>

					onkeydown - When a user is pressing/holding down a key
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  alert("You pressed a key inside the input field");
											}
											</script>
											</head>
											<body>
											<p>A function is triggered when the user is pressing a key in the input field.</p>
											<input type="text" onkeydown="myFunction()">
											</body>
											</html>
											
					onkeypress - When a user is pressing/holding down a key
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  alert("You pressed a key inside the input field");
											}
											</script>
											</head>
											<body>
											<p>A function is triggered when the user is pressing a key in the input field.</p>
											<input type="text" onkeypress="myFunction()">
											</body>
											</html>

					onkeyup - When the user releases a key
					
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  var x = document.getElementById("fname");
											  x.value = x.value.toUpperCase();
											}
											</script>
											</head>
											<body>
											<p>A function is triggered when the user releases a key in the input field. The function transforms the character to upper case.</p>
											Enter your name: <input type="text" id="fname" onkeyup="myFunction()">
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function writeMessage() {
											  document.forms[0].mySecondInput.value = document.forms[0].myInput.value;
											}
											</script>
											</head>
											<body>
											<p>The onkeyup event occurs when the a keyboard key is on its way UP.</p>
											<form>
											  Enter your name:
											  <input type="text" name="myInput" onkeyup="writeMessage()" size="20">
											  <input type="text" name="mySecondInput" size="20">
											</form>
											</body>
											</html>

				onkeydown vs onkeyup - Both
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function color(color) {
											  document.forms[0].myInput.style.background = color;
											}
											</script>
											</head>
											<body>
											<form>
											Write a message:<br>
											<input 
											type="text" 
											onkeydown="color('yellow')"
											onkeyup="color('white')"
											name="myInput">
											</form>
											</body>
											</html>
			Mouse Events--JAVASCRIPT DOM:
			
				onmouseover/onmouseout - When the mouse passes over an element
				
											<!DOCTYPE html>
											<html>
											<body>
											<h1 onmouseover="style.color='red'" onmouseout="style.color='black'">Mouse over this text</h1>
											</body>
											</html>
				
				onmousedown/onmouseup - When pressing/releasing a mouse button
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction(elmnt, clr) {
											  elmnt.style.color = clr;
											}
											</script>
											</head>
											<body>
											<p onmousedown="myFunction(this,'red')" onmouseup="myFunction(this,'green')">
											Click the text to change the color. A function, with parameters, is triggered when the mouse button is pressed down, and again, with other parameters, when the mouse button is released.
											</p>
											</body>
											</html>

				onmousedown - When mouse is clicked: Alert which element<!DOCTYPE html>
				
											<html>
											<head>
											<script>
											function whichElement(e) {
											  var targ;
											  if (!e) {
												var e = window.event;
											  }
											  if (e.target) {
												targ=e.target;
											  } else if (e.srcElement) {
												targ=e.srcElement;
											  }
											  var tname;
											  tname = targ.tagName;
											  alert("You clicked on a " + tname + " element.");
											}
											</script>
											</head>
											<body onmousedown="whichElement(event)">
											<p>Click somewhere in the document. An alert box will alert the name of the element you clicked on.</p>
											<h3>This is a heading</h3>
											<img border="0" src="smiley.gif" alt="Smiley" width="32" height="32">
											<p>This is a paragraph.</p>
											</body>
											</html>

				onmousedown - When mouse is clicked: Alert which button
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function WhichButton(event) {
											  alert("You pressed button: " + event.button)
											}
											</script>
											</head>
											<body>
											<div onmousedown="WhichButton(event);">Click this text (with one of your mouse-buttons)
											<p>
											0 Specifies the left mouse-button<br>
											1 Specifies the middle mouse-button<br>
											2 Specifies the right mouse-button</p>
											<p><strong>Note:</strong> Internet Explorer 8, and earlier, returns another result:<br>
											1 Specifies the left mouse-button<br>
											4 Specifies the middle mouse-button<br>
											2 Specifies the right mouse-button</p>
											</div>
											</body>
											</html>

				onmousemove/onmouseout - When moving the mouse pointer over/out of an image
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction(e) {
											  x = e.clientX;
											  y = e.clientY;
											  coor = "Coordinates: (" + x + "," + y + ")";
											  document.getElementById("demo").innerHTML = coor
											}
											function clearCoor() {
											  document.getElementById("demo").innerHTML = "";
											}
											</script>
											</head>
											<body style="margin:0px;">
											<div id="coordiv" style="width:199px;height:99px;border:1px solid" onmousemove="myFunction(event)" onmouseout="clearCoor()"></div>
											<p>Mouse over the rectangle above, and get the coordinates of your mouse pointer.</p>
											<p id="demo"></p>
											</body>
											</html>
											
				onmouseover/onmouseout - When moving the mouse over/out of an image
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function bigImg(x) {
											  x.style.height = "64px";
											  x.style.width = "64px";
											}
											function normalImg(x) {
											  x.style.height = "32px";
											  x.style.width = "32px";
											}
											</script>
											</head>
											<body>
											<img onmouseover="bigImg(this)" onmouseout="normalImg(this)" border="0" src="smiley.gif" alt="Smiley" width="32" height="32">
											<p>The function bigImg() is triggered when the user moves the mouse pointer over the image.</p>
											<p>The function normalImg() is triggered when the mouse pointer is moved out of the image.</p>
											</body>
											</html>

				onmouseover an image map
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function writeText(txt) {
											  document.getElementById("desc").innerHTML = txt;
											}
											</script>
											</head>
											<body>
											<img src ="planets.gif" width ="145" height ="126" alt="Planets" usemap="#planetmap" />
											<map name="planetmap">
											<area shape ="rect" coords ="0,0,82,126"
											onmouseover="writeText('The Sun and the gas giant planets like Jupiter are by far the largest objects in our Solar System.')"
											href ="sun.htm" target ="_blank" alt="Sun" />
											<area shape ="circle" coords ="90,58,3"
											onmouseover="writeText('The planet Mercury is very difficult to study from the Earth because it is always so close to the Sun.')"
											href ="mercur.htm" target ="_blank" alt="Mercury" />
											<area shape ="circle" coords ="124,58,8"
											onmouseover="writeText('Until the 1960s, Venus was often considered a twin sister to the Earth because Venus is the nearest planet to us, and because the two planets seem to share many characteristics.')"
											href ="venus.htm" target ="_blank" alt="Venus" />
											</map> 
											<p id="desc">Mouse over the sun and the planets and see the different descriptions.</p>
											</body>
											</html>

			Click Events--JAVASCRIPT DOM:
			
				Acting to the onclick event:
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function displayDate() {
											  document.getElementById("demo").innerHTML = Date();
											}
											</script>
											</head>
											<body>
											<h2>My First JavaScript</h2>
											<p id="demo">This is a paragraph.</p>
											<button type="button" onclick="displayDate()">Display Date</button>
											</body>
											</html> 

				onclick - When button is clicked<!DOCTYPE html>
				
											<html>
											<head>
											<script>
											function myFunction() {
											  document.getElementById("demo").innerHTML = "Hello World";
											}
											</script>
											</head>
											<body>
											<p>Click the button to trigger a function.</p>
											<button onclick="myFunction()">Click me</button>
											<p id="demo"></p>
											</body>
											</html>
											
				ondblclick - When a text is double-clicked
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  document.getElementById("demo").innerHTML = "Hello World";
											}
											</script>
											</head>
											<body>
											<p ondblclick="myFunction()">Doubleclick this paragraph to trigger a function.</p>
											<p id="demo"></p>
											</body>
											</html>
											
			Load Events--JAVASCRIPT DOM:
			
				onload - When the page has been loaded:
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  alert("Page is loaded");
											}
											</script>
											</head>
											<body onload="myFunction()">
											<h2>Hello World!</h2>
											</body>
											</html>
				
				onload - When an image has been loaded
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function loadImage() {
											  alert("Image is loaded");
											}
											</script>
											</head>
											<body>
											<img src="w3javascript.gif" onload="loadImage()" width="100" height="132">
											</body>
											</html>
				
				onerror - When an error occurs when loading an image
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function imgError() {
											  alert('The image could not be loaded.');
											}
											</script>
											</head>
											<body>
											<img src="image.gif" onerror="imgError()">
											<p>A function is triggered if an error occurs when loading the image. The function shows an alert box with a text.
											In this example we refer to an image that does not exist, therefore the onerror event occurs.</p>
											</body>
											</html>
											
				onunload - When the browser closes the document
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  alert("Thank you for visiting W3Schools!");
											}
											</script>
											</head>
											<body onunload="myFunction()">
											<h2>Welcome to my Home Page</h2>
											<p>Close this window or press F5 to reload the page.</p>
											</body>
											</html>
											
				onresize - When the browser window is resized
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function myFunction() {
											  var w = window.outerWidth;
											  var h = window.outerHeight;
											  var txt = "Window size: width=" + w + ", height=" + h;
											  document.getElementById("demo").innerHTML = txt;
											}
											</script>
											</head>
											<body onresize="myFunction()">
											<p>Try to resize the browser window.</p>
											<p id="demo"> </p>
											<p>Note: this example will not work properly in IE8 and earlier. IE8 and earlier do not support the outerWidth/outerHeight propery of the window object.</p>
											</body>
											</html>

			JavaScript HTML DOM Navigation--JAVASCRIPT DOM:
			
											With the HTML DOM, you can navigate the node tree using node relationships.

				DOM Nodes:
				
											According to the W3C HTML DOM standard, everything in an HTML document is a node:
											The entire document is a document node
											Every HTML element is an element node
											The text inside HTML elements are text nodes
											Every HTML attribute is an attribute node (deprecated)
											All comments are comment nodes
											
											In a node tree, the top node is called the root (or root node)
											Every node has exactly one parent, except the root (which has no parent)
											A node can have a number of children
											Siblings (brothers or sisters) are nodes with the same parent

											<html>
											  <head>
												<title>DOM Tutorial</title>
											  </head>
											  <body>
												<h1>DOM Lesson one</h1>
												<p>Hello world!</p>
											  </body>
											</html>
											// <html> is the root node
											// <html> has no parents
											// <html> is the parent of <head> and <body>
											// <head> is the first child of <html>
											// <body> is the last child of <html>
											
				Navigating Between Nodes:
				
											parentNode
											childNodes[nodenumber]
											firstChild
											lastChild
											nextSibling
											previousSibling
											
				Child Nodes and Node Values:
				
											<!DOCTYPE html>
											<html>
											<body>
											<h1 id="id01">My First Page</h1>
											<p id="id02"></p>
											<script>
											document.getElementById("id02").innerHTML = document.getElementById("id01").innerHTML; // My First Page
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1 id="id01">My First Page</h1>
											<p id="id02"></p>
											<script>
											document.getElementById("id02").innerHTML = document.getElementById("id01").firstChild.nodeValue; // My First Page
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1 id="id01">My First Page</h1>
											<p id="id02"></p>
											<script>
											document.getElementById("id02").innerHTML = document.getElementById("id01").childNodes[0].nodeValue; // My First Page
											</script>
											</body>
											</html>
											
				DOM Root Nodes:
				
											There are two special properties that allow access to the full document:
													document.body - The body of the document
													document.documentElement - The full document
													
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTMLDOM</h2>
											<p>Displaying document.body</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = document.body.innerHTML; // JavaScript HTMLDOM. Displaying document.body
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript HTMLDOM</h2>
											<p>Displaying document.documentElement</p>
											<p id="demo"></p>
											<script>
											document.getElementById("demo").innerHTML = document.documentElement.innerHTML; // JavaScript HTMLDOM. Displaying document.documentElement
											</script>
											</body>
											</html>
											
				The nodeName Property:
				
											The nodeName property specifies the name of a node.
											
											nodeName is read-only
											nodeName of an element node is the same as the tag name
											nodeName of an attribute node is the attribute name
											nodeName of a text node is always #text
											nodeName of the document node is always #document
											
											<!DOCTYPE html>
											<html>
											<body>
											<h1 id="id01">My First Page</h1>
											<p id="id02"></p>
											<script>
											document.getElementById("id02").innerHTML = document.getElementById("id01").nodeName;
											</script>
											</body>
											</html>
											
				The nodeValue Property:
				
											nodeValue for element nodes is null
											nodeValue for text nodes is the text itself
											nodeValue for attribute nodes is the attribute value

			The Difference Between an HTMLCollection and a NodeList--JAVASCRIPT DOM:
			
					- A NodeList and an HTMLcollection is very much the same thing.
					- Both are array-like collections (lists) of nodes (elements) extracted from a document. The nodes can be accessed by index numbers. The index starts at 0.
					- Both have a length property that returns the number of elements in the list (collection).
					- An HTMLCollection is a collection of document elements.
					- A NodeList is a collection of document nodes (element nodes, attribute nodes, and text nodes).
					- HTMLCollection items can be accessed by their name, id, or index number.
					- NodeList items can only be accessed by their index number.
					- An HTMLCollection is always a live collection. Example: If you add a <li> element to a list in the DOM, the list in the HTMLCollection will also change.
					- A NodeList is most often a static collection. Example: If you add a <li> element to a list in the DOM, the list in NodeList will not change.
					- The getElementsByClassName() and getElementsByTagName() methods return a live HTMLCollection.
					- The querySelectorAll() method returns a static NodeList.
					- The childNodes property returns a live NodeList.
					
					- A NodeList may look like an array, but it is not.
					- You can loop through a NodeList and refer to its nodes by index.
					- But, you cannot use Array methods like push(), pop(), or join() on a NodeList.
		
			JavaScript HTML DOM Node Lists--JAVASCRIPT DOM:
			
				The HTML DOM NodeList Object
					
					- A NodeList object is a list (collection) of nodes extracted from a document.
					- A NodeList object is almost the same as an HTMLCollection object.
					- Some (older) browsers return a NodeList object instead of an HTMLCollection for methods like getElementsByClassName().
					- All browsers return a NodeList object for the property childNodes. 
					- Most browsers return a NodeList object for the method querySelectorAll().

					The following code selects all <p> nodes in a document:
						
						<!DOCTYPE html>
						<html>
						<body>
						<h2>JavaScript HTML DOM</h2>
						<p>Hello World!</p>
						<p>Hello Norway!</p>
						<p id="demo"></p>
						<script>
						const myNodelist = document.querySelectorAll("p");
						document.getElementById("demo").innerHTML = "The innerHTML of the second paragraph is: " + myNodelist[1].innerHTML;
						</script>
						</body>
						</html>
							
					Note: The index starts at 0.
				
				HTML DOM Node List Length
							
							The length property defines the number of nodes in a node list:
							
								<!DOCTYPE html>
								<html>
								<body>
								<h2>JavaScript HTML DOM</h2>
								<p>Hellow World!</p>
								<p>Hellow Norway!</p>
								<p id="demo"></p>
								<script>
								const myNodelist = document.querySelectorAll("p");
								document.getElementById("demo").innerHTML = "This document contains " + myNodelist.length + " paragraphs.";
								</script>
								</body>
								</html>
				
				The length property is useful when you want to loop through the nodes in a node list:
								
								<!DOCTYPE html>
								<html>
								<body>
								<h2>JavaScript HTML DOM</h2>
								<p>Hello World!</p>
								<p>Hello Norway!</p>
								<p>Click the button to change the color of all p elements.</p>
								<button onclick="myFunction()">Try it</button>
								<script>
								function myFunction() {
								  const myNodelist = document.querySelectorAll("p");
								  for (let i = 0; i < myNodelist.length; i++) {
									myNodelist[i].style.color = "red";
								  }
								}
								</script>
								</body>
								</html>
								
				The Difference Between an HTMLCollection and a NodeList
					
					- A NodeList and an HTMLcollection is very much the same thing.
					- Both are array-like collections (lists) of nodes (elements) extracted from a document. The nodes can be accessed by index numbers. The index starts at 0.
					- Both have a length property that returns the number of elements in the list (collection).
					- An HTMLCollection is a collection of document elements.
					- A NodeList is a collection of document nodes (element nodes, attribute nodes, and text nodes).
					- HTMLCollection items can be accessed by their name, id, or index number.
					- NodeList items can only be accessed by their index number.
					- An HTMLCollection is always a live collection. Example: If you add a <li> element to a list in the DOM, the list in the HTMLCollection will also change.
					- A NodeList is most often a static collection. Example: If you add a <li> element to a list in the DOM, the list in NodeList will not change.
					- The getElementsByClassName() and getElementsByTagName() methods return a live HTMLCollection.
					- The querySelectorAll() method returns a static NodeList.
					- The childNodes property returns a live NodeList.
				
				Not an Array!
				
					- A NodeList may look like an array, but it is not.
					- You can loop through a NodeList and refer to its nodes by index.
					- But, you cannot use Array methods like push(), pop(), or join() on a NodeList.
			
			Others--JAVASCRIPT DOM:

				What is the keycode of the key pressed?
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function whichButton(event) {
											  document.getElementById("demo").innerHTML = event.keyCode;
											}
											</script>
											</head>
											<body onkeyup="whichButton(event)">
											<p><b>Note:</b> Make sure the right frame has focus when trying this example!</p>
											<p>Click on this page, and press a key on your keyboard.</p>
											<p id="demo"></p>
											</body>
											</html>
											
				What are the coordinates of the cursor?
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function show_coords(event) {
											  document.getElementById("demo").innerHTML = "X= " + event.clientX + "<br>Y= " + event.clientY;
											}
											</script>
											</head>
											<body>
											<p onmousedown="show_coords(event)">
											Click this paragraph to display the x and y coordinates of the mouse pointer.</p>
											<p id="demo"></p>
											</body>
											</html>
											
				What are the coordinates of the cursor, relative to the screen?
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function coordinates(event) {
											  document.getElementById("demo").innerHTML = "X = " + event.screenX + "<br>Y = " + event.screenY;
											}
											</script>
											</head>
											<body>
											<p onmousedown="coordinates(event)">
											Click this paragraph, to display the x and y coordinates of the cursor, relative to the screen.
											</p>
											<p id="demo"></p>
											</body>
											</html>

				Was the shift key pressed?
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function isKeyPressed(event) {
											  var text = "The shift key was NOT pressed!";
											  if (event.shiftKey == 1) {
												text = "The shift key was pressed!";
											  }
											  document.getElementById("demo").innerHTML = text;
											}
											</script>
											</head>
											<body onmousedown="isKeyPressed(event)">
											<p>Click on this paragraph. An alert box will tell you if you pressed the shift key or not.</p>
											<p id="demo"></p>
											</body>
											</html>
											
				Which event type occurred?
				
											<!DOCTYPE html>
											<html>
											<head>
											<script>
											function getEventType(event) { 
											  document.getElementById("demo").innerHTML = event.type;
											}
											</script>
											</head>
											<body>
											<p onmousedown="getEventType(event)">
											Click on this paragraph. A message will tell what type of event was triggered.</p>
											<p id="demo"></p>
											</body>
											</html>

		JavaScript Template Literals--Các kiến thức nền tảng JAVASCRIPT:
		
			Interpolation:

											- Template literals provide an easy way to interpolate variables and expressions into strings.
											- The method is called string interpolation.
											- The syntax is: ${...}
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Template Literals</h2>
											<p>Template literals allows variables in strings:</p>
											<p id="demo"></p>
											<p>Template literals are not supported in Internet Explorer.</p>
											<script>
											let firstName = "John";
											let lastName = "Doe";
											let text = `Welcome ${firstName}, ${lastName}!`; // Welcome John, Doe!
											document.getElementById("demo").innerHTML = text;
											</script>
											</body>
											</html>
											
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Template Literals</h2>
											<p>Template literals allows variables in strings:</p>
											<p id="demo"></p
											<p>Template literals are not supported in Internet Explorer.</p>
											<script>
											let price = 10;
											let VAT = 0.25;
											let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;
											document.getElementById("demo").innerHTML = total; // Total: 12.50
											</script>
											</body>
											</html>
											
			HTML Templates:
			
											<!DOCTYPE html>
											<html>
											<body>
											<h2>JavaScript Template Literals</h2>
											<p>Template literals allows variables in strings:</p>
											<p id="demo"></p>
											<p>Template literals are not supported in Internet Explorer.</p>
											<script>
											let header = "Templates Literals";
											let tags = ["template literals", "javascript", "es6"];
											let html = `<h2>${header}</h2><ul>`; // là một chuỗi bình thường chứ không phải là jsx
											for (const x of tags) {
											  html += `<li>${x}</li>`;
											}
											html += `</ul>`;
											document.getElementById("demo").innerHTML = html;
											</script>
											</body>
											</html>
		
		AJAX--Các kiến thức nền tảng JAVASCRIPT:
				Server Response--AJAX:
					Server Response Properties:
						The responseText Property
															The responseText property returns the server response as a JavaScript string, and you can use it accordingly:
															
															<!DOCTYPE html>
															<html>
															<body>
															<div id="demo">
															<h2>The XMLHttpRequest Object</h2>
															<button type="button" onclick="loadDoc()">Change Content</button>
															</div>
															<script>
															function loadDoc() {
															  const xhttp = new XMLHttpRequest();
															  xhttp.onload = function() {
																document.getElementById("demo").innerHTML =
																this.responseText;
															  }
															  xhttp.open("GET", "ajax_info.txt");
															  xhttp.send();
															}
															</script>
															</body>
															</html>
						The responseXML Property:
															The XMLHttpRequest object has an in-built XML parser.
															The responseXML property returns the server response as an XML DOM object.
															Using this property you can parse the response as an XML DOM object
															this.responseXML: Đối tượng XMLDocument chứa dữ liệu phản hồi dưới dạng XML.
															this.responseText: Chuỗi chứa dữ liệu phản hồi dưới dạng văn bản.
															this.status: Mã trạng thái HTTP của phản hồi.
															this.statusText: Văn bản mô tả mã trạng thái HTTP.
															
															<!DOCTYPE html>
															<html>
															<body>
															<h2>The XMLHttpRequest Object</h2>
															<p id="demo"></p>													
															<script>
															const xhttp = new XMLHttpRequest();
															xhttp.onload = function() {
															  const xmlDoc = this.responseXML;
															  const x = xmlDoc.getElementsByTagName("ARTIST");
															  let txt = "";
															  for (let i = 0; i < x.length; i++) {
																txt = txt + x[i].childNodes[0].nodeValue + "<br>";
															  }
															  document.getElementById("demo").innerHTML = txt;
															}
															xhttp.open("GET", "cd_catalog.xml");
															xhttp.send();
															</script>
															</body>
															</html>
			Server Response Methods--AJAX:
				The getAllResponseHeaders() Method:
															The getAllResponseHeaders() method returns all header information from the server response.
															
															<!DOCTYPE html>
															<html>
															<body>
															<h2>The XMLHttpRequest Object</h2>
															<p>The getAllResponseHeaders() function returns all the header information of a resource, like length, server-type, content-type, last-modified, etc:</p>
															<p id="demo"></p>
															<script>
															const xhttp = new XMLHttpRequest();
															xhttp.onload = function() {
															  document.getElementById("demo").innerHTML =
															  this.getAllResponseHeaders();
															}
															xhttp.open("GET", "ajax_info.txt");
															xhttp.send();
															</script>
															</body>
															</html>
				The getResponseHeader() Method:
															The getResponseHeader() method returns specific header information from the server response.
															
															<!DOCTYPE html>
															<html>
															<body>
															<h2>The XMLHttpRequest Object</h2>
															<p>The getResponseHeader() function is used to return specific header information from a resource, like length, server-type, content-type, last-modified, etc:</p>
															<p>Last modified: <span id="demo"></span></p>
															<script>
															const xhttp=new XMLHttpRequest();
															xhttp.onload = function() {
															  document.getElementById("demo").innerHTML =
															  this.getResponseHeader("Last-Modified");
															}
															xhttp.open("GET", "ajax_info.txt");
															xhttp.send();
															</script>
															</body>
															</html>
SPRING---:	
	Các layer của Spring--SPRING:
		Controller Layer: 			
									Trong tầng Controller, bạn xác định các lớp controller (hoặc các phương thức trong các lớp controller) để xử lý các yêu cầu HTTP từ phía client.
									Chúng tiếp nhận các yêu cầu, xử lý chúng và gửi lại kết quả cho client. Controller thường là điểm bắt đầu của ứng dụng và sử dụng các service layer để xử lý logic kinh doanh.
		Service Layer:				
									Tầng Service chứa các lớp service, nơi xử lý các logic kinh doanh và nghiệp vụ của ứng dụng. Những logic này thường không thể xử lý trong controller và được trừu tượng hóa vào các service.
									Service sẽ gọi và sử dụng các thành phần DAO (Data Access Object) để truy xuất dữ liệu từ cơ sở dữ liệu.
		Repository/DAO Layer:		
									Tầng Repository hoặc DAO chứa các lớp Repository hoặc DAO, nơi thực hiện việc truy xuất và ghi dữ liệu vào cơ sở dữ liệu.
									Các lớp này cung cấp các phương thức để tương tác với cơ sở dữ liệu, bao gồm các thao tác CRUD (Create, Read, Update, Delete).
		Model Layer:				Tầng Model chứa các lớp Model hoặc Entity, đại diện cho các đối tượng dữ liệu trong ứng dụng. Đây là nơi mô tả cấu trúc dữ liệu và quan hệ giữa các đối tượng.
		View Layer:					Tầng View chứa các thành phần giao diện người dùng, ví dụ như các trang HTML, template engine (thường sử dụng trong ứng dụng web) hoặc các giao diện người dùng khác.
		Security Layer:				Tầng Security chứa các thành phần liên quan đến bảo mật trong ứng dụng, chẳng hạn như các cấu hình xác thực, ủy quyền và bảo mật truy cập tài nguyên.
		Exception Handling Layer:	
									Tầng Exception Handling chứa các thành phần xử lý các ngoại lệ (exception) xảy ra trong ứng dụng.
									Nó giúp xử lý các tình huống ngoại lệ một cách chặt chẽ và cung cấp thông báo phản hồi hợp lý cho client.
		Mapper:						Dùng để convert qua lại giữa entity và dto (không có cũng được)						
								
	Standard--SPRING:
		Standard 1:
			Domain:
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import com.poscoict.base.share.util.json.JsonUtil;
									import lombok.*;
									import java.util.Date;
									import java.util.List;
									@Getter
									@Setter
									@Builder
									@NoArgsConstructor
									@AllArgsConstructor
									public class Pme00ProjectInfo {
										private String cdV;
										private List<String> searchCdv;
										private int period;
										private String koreaPm;
										private String vietnamPl;
										private List<String> searchStatus;
										private String status;
										private String framework;
										private Date startDate;
										private Date endDate;
										private String image;
										private String file;
										private String koreaPmName;
										private String koreaPmImage;
										private String vietnamPlName;
										private String vietnamPlImage;
										public Pme00ProjectInfo(String cdV) {
											this.cdV = cdV;
										}
										public String toJson() {
											return JsonUtil.toJson(this);
										}
										public static Pme00ProjectInfo fromJson(String json) {
											return JsonUtil.fromJson(json, Pme00ProjectInfo.class);
										}
										public Pme00ProjectInfo(Object[] objects) {
											this.cdV = (String) objects[0];
											this.period = (int) objects[1];
											this.koreaPm = (String) objects[2];
											this.vietnamPl = (String) objects[3];
											this.status = (String) objects[4];
											this.framework = (String) objects[5];
											this.startDate = (Date) objects[6];
											this.endDate = (Date) objects[7];
											this.image = Utils.applyEmployeeAvatarPath((String) objects[8],"Project");
											this.file = Utils.applyEmployeeAvatarPath((String) objects[9],"Project");
											this.koreaPmName = (String) objects[10];
											this.koreaPmImage = Utils.applyEmployeeAvatarPath((String) objects[11], "Employee");
											this.vietnamPlName = (String) objects[12];
											this.vietnamPlImage = Utils.applyEmployeeAvatarPath((String) objects[13], "Employee");
										}
									}
			
									package com.poscdx.odc.ampro015.domain.entity;
									import com.google.gson.annotations.JsonAdapter;
									import com.poscdx.odc.ampro015.domain.utils.DateUtils;
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import com.poscoict.base.share.util.json.JsonUtil;
									import lombok.*;
									import java.util.Date;
									@Getter
									@Setter
									@Builder
									@NoArgsConstructor
									@AllArgsConstructor
									public class Asset  {
										private int id;
										private String token;
										private String owner;
										private int duration;
										private String qrcode;
										private int status;
										private String createBy;
										@JsonAdapter(DateUtils.DateTypeAdapter.class)
										private Date createAt;
										private String updateBy;
										@JsonAdapter(DateUtils.DateTypeAdapter.class)
										private Date updateAt;
										@JsonAdapter(DateUtils.DateTypeAdapter.class)
										private Date deleteAt;
										private String ownerName;
										private String ownerImage;
										public String toJson() {
											return JsonUtil.toJson(this);
										}
										public static Asset fromJson(String json) {
											return JsonUtil.fromJson(json, Asset.class);
										}
										public Asset(Object[] objects) {
											this.id = (int) objects[0];
											this.token = (String) objects[1];
											this.owner = (String) objects[2];
											this.duration = (int) objects[3];
											this.qrcode = (String) objects[4];
											this.status = (int) objects[5];
											this.createBy = (String) objects[6];
											this.createAt = (Date) objects[7];
											this.updateBy =(String) objects[8];
											this.updateAt = (Date) objects[9];
											this.deleteAt = (Date) objects[10];
											this.ownerName = (String) objects[11];
											this.ownerImage = Utils.applyEmployeeAvatarPath((String) objects[12], "Employee");
										}
									}
			Store-Jpo:
									package com.poscodx.odc.ampro015.store.jpo;
									import com.poscdx.odc.ampro015.domain.entity.Pme00ProjectInfo;
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import lombok.Getter;
									import lombok.NoArgsConstructor;
									import lombok.Setter;
									import org.springframework.beans.BeanUtils;
									import javax.persistence.*;
									import java.util.Date;
									import java.util.List;
									import java.util.stream.Collectors;
									import java.util.stream.StreamSupport;
									@Getter
									@Setter
									@NoArgsConstructor
									@Entity(name = "Pme00ProjectInfo")
									@Table(name = "tb_pme00_project_info", schema = "VIVA-ODC")
									public class Pme00ProjectInfoJpo {
										@Id
										@Column(name = "CD_V")
										private String cdV;
										@Column(name = "PERIOD")
										private int period;
										@Column(name = "KOREA_PM")
										private String koreaPm;
										@Column(name = "VIETNAM_PL")
										private String vietnamPl;
										@Column(name = "STATUS")
										private String status;
										@Column(name = "FRAMEWORK")
										private String framework;
										@Column(name = "START_DATE")
										private Date startDate;
										@Column(name = "END_DATE")
										private Date endDate;
										@Column(name = "IMAGE")
										private String image;
										@Column(name = "FILE")
										private String file;
										@Transient
										private String koreaPmName;
										@Transient
										private String vietnamPlName;
										public Pme00ProjectInfoJpo(Pme00ProjectInfo domainEntity) {
											BeanUtils.copyProperties(domainEntity, this);
										}
										public Pme00ProjectInfo toDomain() {
											Pme00ProjectInfo domainEntity = new Pme00ProjectInfo();
											BeanUtils.copyProperties(this, domainEntity); // chuyển 1 dto thành 1 jpo
											return domainEntity;
										}
										public static List<Pme00ProjectInfo> toDomains(Iterable<Pme00ProjectInfoJpo> jpos) {
											return StreamSupport.stream(jpos.spliterator(), false).map(Pme00ProjectInfoJpo::toDomain).collect(Collectors.toList()); // Chuyển 1 list dto thành list jpo
										}
										@PostLoad
										private void addUrlPath() {
											if (image != null && !image.isEmpty() && !image.contains(Utils.UPLOAD_URL)) {
												image = Utils.applyEmployeeAvatarPath(image, "Project");
											}
											if (file != null && !file.isEmpty() && !file.contains(Utils.UPLOAD_URL)) {
												file = Utils.applyEmployeeAvatarPath(file, "Project");
											}
										}
									}								
			Service-Resource:
									package com.poscodx.odc.ampro015.service.rest;
									import com.poscdx.odc.ampro015.domain.entity.*;
									import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import com.posco.reuse.common.logging.PosLogWriterIF;
									import com.posco.reuse.common.logging.PosLogger;
									import com.poscodx.odc.ampro015.service.PermissionValidation;
									import lombok.RequiredArgsConstructor;
									import org.springframework.security.access.prepost.PreAuthorize;
									import org.springframework.web.bind.annotation.*;
									import org.springframework.web.multipart.MultipartFile;
									import java.sql.SQLException;
									import java.util.ArrayList;
									import java.util.List;
									import java.util.Map;
									@CrossOrigin(origins = "*", allowedHeaders = "*")
									@RestController
									@RequestMapping("/project")
									@RequiredArgsConstructor
									public class Pme00ProjectResource {
										private final ServiceLifecycle serviceLifecycle;
										@PostMapping("/search-include-task")
										@PreAuthorize("hasAnyAuthority('GET_PROJECT,GET_PROJECT_OWNER')")
										public Map<String, Object> findProjectListWithTask(@RequestBody ProjectManagementDto dto,
																						   @RequestParam(required = false, defaultValue = "0", name = "pageNo") int pageNo,
																						   @RequestParam(required = false, defaultValue = "20", name = "pageSize") int pageSize) {
											PosLogger.developerLog(PosLogWriterIF.INFO, "Project -> " + dto, this);
											if (Utils.checkPermission("GET_PROJECT_OWNER")) {
												String id = Utils.getLoginUserDetail();
												if (id != null) {
													return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, id, pageNo, pageSize);
												}
											}
											return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, null, pageNo, pageSize);
										}
										@GetMapping(path = "/monitoring")
										@PreAuthorize("hasAnyAuthority('GET_PROJECT,GET_PROJECT_OWNER')")
										public Map<String, Object> findAllProjectMonitoring(@RequestParam(required = false, defaultValue = "0", name = "pageNo") int pageNo,
																							@RequestParam(required = false, defaultValue = "20", name = "pageSize") int pageSize) {
											if (Utils.checkPermission("GET_PROJECT_OWNER")) {
												String id = Utils.getLoginUserDetail();
												if (id != null) {
													return this.serviceLifecycle.requestLevel2ProjectService().getAllProjectListWithEmpId(serviceLifecycle, id, pageNo, pageSize);
												}
											}
											return this.serviceLifecycle.requestLevel2ProjectService().getAllProjectListWithEmpId(serviceLifecycle, null, pageNo, pageSize);
										}
										@PostMapping("")
										@PreAuthorize("hasAnyAuthority('ADD_PROJECT')")
										public List<Object> register(@RequestParam ("data") String dtoString,
																@RequestParam (value = "imageUpload", required = false) MultipartFile imageUpload,
																@RequestParam (value = "fileUpload", required = false) MultipartFile fileUpload) throws SQLException {
											ProjectManagementDto dto = ProjectManagementDto.fromJson(dtoString);
											return this.serviceLifecycle
													   .requestLevel2ProjectService()
													   .registerProject(serviceLifecycle, dto, imageUpload, fileUpload);
										}
										@PutMapping("")
										@PreAuthorize("hasAnyAuthority('UPDATE_PROJECT,UPDATE_PROJECT_OWNER')")
										public List<Object> modify(@RequestParam ("data") String dtoString,
															  @RequestParam (value = "imageUpload", required = false) MultipartFile imageUpload,
															  @RequestParam (value = "fileUpload", required = false) MultipartFile fileUpload) throws SQLException {
											ProjectManagementDto dto = ProjectManagementDto.fromJson(dtoString);
											if (!PermissionValidation.validateUpdateProject(dto)) {
												List<Object> result = new ArrayList<>();
												result.add(false);
												result.add(Utils.NO_PERMISSION);
												return result;
											}
											return this.serviceLifecycle
													   .requestLevel2ProjectService()
													   .modifyProject(serviceLifecycle, dto, imageUpload, fileUpload);
										}
										@DeleteMapping("")
										@PreAuthorize("hasAnyAuthority('DELETE_PROJECT,DELETE_PROJECT_OWNER')")
										public List<Object> delete(@RequestBody M00Codes030Id id) throws SQLException {
											ProjectManagementDto dto = serviceLifecycle.requestLevel2ProjectService()
																					   .findProjectById(serviceLifecycle, id);
											if (!PermissionValidation.validateDeleteProject(dto)) {
												List<Object> result = new ArrayList<>();
												result.add(false);
												result.add(Utils.NO_PERMISSION);
												return result;
											}
											return this.serviceLifecycle.requestLevel2ProjectService().deleteProject(serviceLifecycle, id);
										}
										@GetMapping("/search-pm-pl/{type}")
										public List<M00Employee> getKoreaPM (@PathVariable("type") String type,
																			 @RequestParam(value = "projectNumber", required = false) String projectNumber) {
											if (type.equals("pm")){
												return this.serviceLifecycle.requestPme00ProjectInfoService().getKoreaPM(projectNumber);
											}
											else if (type.equals("pl")) {
												return this.serviceLifecycle.requestPme00ProjectInfoService().getVietnamPL(projectNumber);
											}
											else
												return new ArrayList<>();
										}
										@GetMapping("/search-member/{cdV}")
										public List<M00Employee> findProjectMember(@PathVariable("cdV") String cdV) {
											return this.serviceLifecycle.requestLevel2ProjectService().getProjectMember(serviceLifecycle, cdV);
										}
									}
			Lifecyecle:
									package com.poscdx.odc.ampro015.domain.lifecycle;
									import com.poscdx.odc.ampro015.domain.spec.*;
									public interface ServiceLifecycle {
										Level2Service requestLevel2Service();
										Level3DashboardService requestLevel3DashboardService();
										AssetService requestAssetService();
										FieldService requestFieldService();
										ImageService requestImageService();
										M99DailyReportService requestM99DailyReportService();
										M00Codes030Service requestM00Codes030Service();
										M00TaskService requestM00TaskService();
										M00EmployeeService requestM00EmployeeService();
										Pme00EmployeeMeetingService requestPme00EmployeeMeetingService();
										Pme00MeetingService requestPme00MeetingService();
										Pme00MemberService requestPme00MemberService();
										Pme00ProjectInfoService requestPme00ProjectInfoService();
										Pme00AnnouncementService requestPme00AnnouncementService();
										Pme00DashboardSettingService requestPme00DashboardSettingService();
										Pme00EmployeeTaskService requestPme00EmployeeTaskService();
										Level2MeetingService requestBookingMeetingRoomService();
										M00Codes020Service requestM00Codes020Service();
										Level2ProjectService requestLevel2ProjectService();
										Level2QrCodeService requestLevel2QrCodeService();
										Level2TaskService requestLevel2TaskService();
										Pme00RoleService requestPme00RoleService();
										Pme00RoleUserService requestPme00RoleUserService();
										Pme00PasswordTokenService requestPasswordService();
										Pme00PermissionService requestPme00PermissionService();
										Pme00PerRoleService requestPme00PerRoleService();
										Level2EmployeeService requestLevel2EmployeeService();
										Pme00IssueManagementService requestPme00IssueManagementService();
										LogoutAccessTokenService requestLogoutAccessTokenService();
										S91MenuService requestS91MenuService();
										Pme00WorkingTimeService requestPme00WorkingTimeService();
										Cms06MenuService requestCms06MenuService();
										Cms06MediaService requestCms06MediaService();
										Cms06PostService requestCms06PostService();
										Cms06LanguageService requestCms06LanguageService();
										Cms06LanguageContentService requestCms06LanguageContentService();
										Cms06TagsService requestCms06TagsService();
										Cms06ContentTagsService requestCms06ContentTagsService();
										Level2WorkingTimeService requestLevel2WorkingTimeService();
										Pme00NotificationService requestPme00NotificationService();
										Pme00NotificationGroupService requestPme00NotificationGroupService();
										Pme00NotificationMemberService requestPme00NotificationMemberService();
										M00StandardDocumentService requestM00StandardDocumentService();
									}
			
									package com.poscodx.odc.ampro015.service.lifecycle;
									import com.poscdx.odc.ampro015.domain.spec.*;
									import com.poscdx.odc.ampro015.domain.store.Cms06ContentTagsStore;
									import lombok.RequiredArgsConstructor;
									import org.springframework.stereotype.Component;
									@Component
									@RequiredArgsConstructor
									public class ServiceLifecycle implements com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle {
										private final Level2ProjectService level2ProjectService;
										private final Level2Service level2Service;
										private final Level3DashboardService level3DashboardService;
										private final AssetService assetService;
										private final FieldService fieldService;
										private final ImageService imageService;
										private final M99DailyReportService m99DailyReportService;
										private final M00Codes030Service m00Codes030Service;
										private final M00TaskService m00TaskService;
										private final M00EmployeeService m00EmployeeService;
										private final Pme00EmployeeMeetingService pme00EmployeeMeetingService;
										private final Pme00MeetingService pme00MeetingService;
										private final Pme00MemberService pme00MemberService;
										private final Pme00ProjectInfoService pme00ProjectInfoService;
										private final Pme00AnnouncementService pme00AnnouncementService;
										private final Pme00DashboardSettingService pme00DashboardSettingService;
										private final Pme00EmployeeTaskService pme00EmployeeTaskService;
										private final Level2MeetingService bookingMeetingRoomService;
										private final M00Codes020Service m00Codes020Service;
										private final Pme00RoleService pme00RoleService;
										private final Pme00RoleUserService pme00RoleUserService;
										private final Pme00PermissionService pme00PermissionService;
										private final Pme00PasswordTokenService pme00PasswordTokenService;
										private final Pme00PerRoleService pme00PerRoleService;
										private final Level2TaskService level2TaskService;
										private final Level2QrCodeService level2QrCodeService;
										private final Level2EmployeeService level2EmployeeService;
										private final Pme00IssueManagementService pme00IssueManagementService;
										private final LogoutAccessTokenService logoutAccessTokenService;
										private final S91MenuService s91MenuService;
										private final Pme00WorkingTimeService pme00WorkingTimeService;
										private final Level2WorkingTimeService level2WorkingTimeService;
										private final Pme00NotificationService pme00NotificationService;
										private final Pme00NotificationGroupService pme00NotificationGroupService;
										private final Pme00NotificationMemberService pme00NotificationMemberService;
										private final M00StandardDocumentService m00StandardDocumentService;
										private final Cms06MenuService cms06MenuService;
										private final Cms06MediaService cms06MediaService;
										private final Cms06PostService cms06PostService;
										private final Cms06LanguageService cms06LanguageService;
										private final Cms06LanguageContentService cms06LanguageContentService;
										private final Cms06TagsService cms06TagsService;
										private final Cms06ContentTagsService cms06ContentTagsService;
										@Override
										public Level2ProjectService requestLevel2ProjectService() { return this.level2ProjectService; }
										@Override
										public Level2Service requestLevel2Service() {
											return this.level2Service;
										}
										@Override
										public Level3DashboardService requestLevel3DashboardService() {
											return this.level3DashboardService;
										}
										 @Override
										public Level2MeetingService requestBookingMeetingRoomService() {
											return this.bookingMeetingRoomService;
										}
										@Override
										public AssetService requestAssetService() {
											return this.assetService;
										}
										@Override
										public FieldService requestFieldService() {
											return this.fieldService;
										}
										@Override
										public ImageService requestImageService() {
											return this.imageService;
										}
										@Override
										public M99DailyReportService requestM99DailyReportService() {
											return this.m99DailyReportService;
										}
										@Override
										public M00Codes030Service requestM00Codes030Service(){
											return this.m00Codes030Service;
										}
										@Override
										public M00TaskService requestM00TaskService() {
											return this.m00TaskService;
										}
										@Override
										public M00EmployeeService requestM00EmployeeService() {
											return this.m00EmployeeService;
										}
										@Override
										public Pme00EmployeeMeetingService requestPme00EmployeeMeetingService() {
											return this.pme00EmployeeMeetingService;
										}
										@Override
										public Pme00MeetingService requestPme00MeetingService() {
											return this.pme00MeetingService;
										}
										@Override
										public Pme00MemberService requestPme00MemberService() {
											return this.pme00MemberService;
										}
										@Override
										public Pme00ProjectInfoService requestPme00ProjectInfoService() {
											return this.pme00ProjectInfoService;
										}
										@Override
										public Pme00EmployeeTaskService requestPme00EmployeeTaskService() {
											return this.pme00EmployeeTaskService;
										}
										@Override
										public Pme00AnnouncementService requestPme00AnnouncementService() { return this.pme00AnnouncementService; }
										@Override
										public Pme00DashboardSettingService requestPme00DashboardSettingService() {
											return this.pme00DashboardSettingService;
										}
										@Override
										public M00Codes020Service requestM00Codes020Service(){return this.m00Codes020Service;}
										@Override
										public Level2TaskService requestLevel2TaskService() {
											return this.level2TaskService;
										}
										@Override
										public Pme00RoleService requestPme00RoleService() {
											return this.pme00RoleService;
										}
										@Override
										public Pme00RoleUserService requestPme00RoleUserService() {
											return this.pme00RoleUserService;
										}
										@Override
										public Pme00PasswordTokenService requestPasswordService() {
											return this.pme00PasswordTokenService;
										}
										@Override
										public Pme00PermissionService requestPme00PermissionService() {
											return this.pme00PermissionService;
										}
										@Override
										public Pme00PerRoleService requestPme00PerRoleService() {
											return this.pme00PerRoleService;
										}
										@Override
										public LogoutAccessTokenService requestLogoutAccessTokenService() {
											return this.logoutAccessTokenService;
										}
										@Override
										public S91MenuService requestS91MenuService() {
											return this.s91MenuService;
										}
										@Override
										public Pme00WorkingTimeService requestPme00WorkingTimeService() {
											return this.pme00WorkingTimeService;
										}
										@Override
										public Level2WorkingTimeService requestLevel2WorkingTimeService() {
											return this.level2WorkingTimeService;
										}
										@Override
										public Cms06MenuService requestCms06MenuService() {
											return cms06MenuService;
										}
										@Override
										public Cms06MediaService requestCms06MediaService() {
											return cms06MediaService;
										}
										@Override
										public Cms06PostService requestCms06PostService() {
											return cms06PostService;
										}
										@Override
										public Cms06LanguageService requestCms06LanguageService() {
											return cms06LanguageService;
										}
										@Override
										public Cms06LanguageContentService requestCms06LanguageContentService() {
											return cms06LanguageContentService;
										}
										@Override
										public Cms06TagsService requestCms06TagsService() {
											return cms06TagsService;
										}
										@Override
										public Cms06ContentTagsService requestCms06ContentTagsService() {
											return cms06ContentTagsService;
										}
										@Override
										public Level2QrCodeService requestLevel2QrCodeService() {
											return this.level2QrCodeService;
										}
										@Override
										public Level2EmployeeService requestLevel2EmployeeService() {
											return this.level2EmployeeService;
										}
										@Override
										public Pme00IssueManagementService requestPme00IssueManagementService(){
											return  this.pme00IssueManagementService;
										}
										@Override
										public Pme00NotificationService requestPme00NotificationService() {
											return this.pme00NotificationService;
										}
										@Override
										public Pme00NotificationGroupService requestPme00NotificationGroupService() {
											return this.pme00NotificationGroupService;
										}
										@Override
										public Pme00NotificationMemberService requestPme00NotificationMemberService() {
											return this.pme00NotificationMemberService;
										}
										@Override
										public M00StandardDocumentService requestM00StandardDocumentService() {
											return this.m00StandardDocumentService;
										}
									}
			Domain-Logic:
									package com.poscdx.odc.ampro015.domain.logic;
									import com.poscdx.odc.ampro015.domain.entity.*;
									import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
									import com.poscdx.odc.ampro015.domain.spec.Level2ProjectService;
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import org.springframework.data.domain.PageRequest;
									import org.springframework.data.domain.Pageable;
									import org.springframework.data.domain.Sort;
									import org.springframework.transaction.annotation.Transactional;
									import org.springframework.web.multipart.MultipartFile;
									import java.sql.SQLException;
									import java.util.*;
									public class Level2ProjectLogic implements Level2ProjectService {
										@Override
										@Transactional(rollbackFor = { SQLException.class })
										public List<Object> registerProject(ServiceLifecycle serviceLifecycle, ProjectManagementDto dto,
																	   MultipartFile imageUpload, MultipartFile fileUpload) throws SQLException {
											List<Object> resultList = new ArrayList<>();
											if (dto != null) {
												// Check project code exists
												if(checkExistsM00Codes030(serviceLifecycle, Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, dto.getM00Codes030().getCdV())
														&& checkExistsPme00ProjectInfo(serviceLifecycle, dto.getPme00ProjectInfo().getCdV())){
													resultList.add(false);
													resultList.add("Project already exists!");
													return resultList;
												}
												// Insert data M00Codes030
												M00Codes030 entityCodes030 = new M00Codes030();
												int seq = serviceLifecycle.requestM00Codes030Service().getMaxSeqInquiry(Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID) + 1;
												entityCodes030.setCdTpId(Utils.CD_TP_ID);
												entityCodes030.setCategoryGroupId(Utils.CATEGORY_GROUP_ID);
												entityCodes030.setCdV(dto.getM00Codes030().getCdV());
												entityCodes030.setCdvMeaning(dto.getM00Codes030().getCdvMeaning());
												entityCodes030.setCdVExplain(dto.getM00Codes030().getCdVExplain());
												entityCodes030.setCdVInquirySeq(seq);
												entityCodes030.setCreatedProgramId(dto.getM00Codes030().getCreatedProgramId());
												entityCodes030.setCreationTimestamp(dto.getM00Codes030().getCreationTimestamp());
												entityCodes030.setLastUpdateProgramId(dto.getM00Codes030().getLastUpdateProgramId());
												entityCodes030.setLastUpdateTimestamp(dto.getM00Codes030().getLastUpdateTimestamp());
												serviceLifecycle.requestM00Codes030Service().register(entityCodes030);
												// Insert data Pme00ProjectInfo
												Pme00ProjectInfo entityInfo = new Pme00ProjectInfo();
												entityInfo.setCdV(dto.getPme00ProjectInfo().getCdV());
												entityInfo.setPeriod(dto.getPme00ProjectInfo().getPeriod());
												entityInfo.setStartDate(dto.getPme00ProjectInfo().getStartDate());
												entityInfo.setEndDate(dto.getPme00ProjectInfo().getEndDate());
												entityInfo.setKoreaPm(dto.getPme00ProjectInfo().getKoreaPm());
												entityInfo.setVietnamPl(dto.getPme00ProjectInfo().getVietnamPl());
												entityInfo.setStatus(dto.getPme00ProjectInfo().getStatus());
												entityInfo.setFramework(dto.getPme00ProjectInfo().getFramework());
												entityInfo.setImage(dto.getPme00ProjectInfo().getImage());
												entityInfo.setFile(dto.getPme00ProjectInfo().getFile());
												serviceLifecycle.requestPme00ProjectInfoService().register(entityInfo);
												// Insert data Pme00Member
												Pme00Member entityMember;
												for (Pme00Member member : dto.getLstMember()) {
													entityMember = new Pme00Member();
													entityMember.setCdVId(dto.getM00Codes030().getCdV());
													entityMember.setEmpId(member.getEmpId());
													entityMember.setEmpName(member.getEmpName());
													entityMember.setAvatar(member.getAvatar());
													serviceLifecycle.requestPme00MemberService().register(entityMember);
												}
											}
											// insert file/image
											if (imageUpload != null) {
												String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", imageUpload);
												if (!result.contains("Project")) {
													resultList.add(false);
													resultList.add("Project created. However, image could not be saved.");
													return resultList;
												}
											}
											if (fileUpload != null) {
												String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", fileUpload);
												if (!result.contains("Project")) {
													resultList.add(false);
													resultList.add("Project created. However, file could not be saved.");
													return resultList;
												}
											}
											resultList.add(true);
											return resultList;
										}
										@Override
										@Transactional(rollbackFor = { SQLException.class })
										public List<Object> modifyProject(ServiceLifecycle serviceLifecycle, ProjectManagementDto dto,
																	 MultipartFile imageUpload, MultipartFile fileUpload) throws SQLException {
											List<Object> resultList = new ArrayList<>();
											// Check project code exists
											if(!checkExistsM00Codes030(serviceLifecycle, Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, dto.getM00Codes030().getCdV())
													|| !checkExistsPme00ProjectInfo(serviceLifecycle, dto.getPme00ProjectInfo().getCdV())){
												resultList.add(false);
												resultList.add("Project already exists!");
												return resultList;
											}
											//  Delete old file/image
											String imageNew = dto.getPme00ProjectInfo().getImage();
											String fileNew = dto.getPme00ProjectInfo().getFile();
											if (imageUpload != null || fileUpload != null || imageNew.isEmpty() || fileNew.isEmpty()) {
												Pme00ProjectInfo projectInfo = serviceLifecycle.requestPme00ProjectInfoService().find(dto.getM00Codes030().getCdV());
												List<String> fileName = new ArrayList<>();
												if (imageUpload != null || imageNew.isEmpty()) {
													String imageString = projectInfo.getImage();
													if (imageString != null) {
														imageString = imageString.substring(imageString.lastIndexOf("/") + 1);
														fileName.add(imageString);
													}
												}
												if (fileUpload != null || fileNew.isEmpty()) {
													String fileString = projectInfo.getFile();
													if (fileString != null) {
														fileString = fileString.substring(fileString.lastIndexOf("/") + 1);
														fileName.add(fileString);
													}
												}
												boolean result = serviceLifecycle.requestLevel2Service()
														.removeFile(Utils.UPLOAD_BUCKET, "Project", fileName);
												if (!result) {
													resultList.add(false);
													resultList.add("Project updated. However, file(s) could not be saved.");
													return resultList;
												}
											}
											// Update data M00Codes030
											List<M00Codes030> lstCodes030 = new ArrayList<>();
											M00Codes030 entityCodes030 = new M00Codes030();
											entityCodes030.setCdTpId(Utils.CD_TP_ID);
											entityCodes030.setCategoryGroupId(Utils.CATEGORY_GROUP_ID);
											entityCodes030.setCdV(dto.getM00Codes030().getCdV());
											entityCodes030.setCdvMeaning(dto.getM00Codes030().getCdvMeaning());
											entityCodes030.setCdVExplain(dto.getM00Codes030().getCdVExplain());
											entityCodes030.setCdVInquirySeq(dto.getM00Codes030().getCdVInquirySeq());
											entityCodes030.setCreatedProgramId(dto.getM00Codes030().getCreatedProgramId());
											entityCodes030.setCreationTimestamp(dto.getM00Codes030().getCreationTimestamp());
											entityCodes030.setLastUpdateProgramId(dto.getM00Codes030().getLastUpdateProgramId());
											entityCodes030.setLastUpdateTimestamp(dto.getM00Codes030().getLastUpdateTimestamp());
											lstCodes030.add(entityCodes030);
											serviceLifecycle.requestM00Codes030Service().modify(lstCodes030);
											// Update data Pme00ProjectInfo
											List<Pme00ProjectInfo> lstProjectInfo = new ArrayList<>();
											Pme00ProjectInfo entityInfo = new Pme00ProjectInfo();
											entityInfo.setCdV(dto.getPme00ProjectInfo().getCdV());
											entityInfo.setPeriod(dto.getPme00ProjectInfo().getPeriod());
											entityInfo.setStartDate(dto.getPme00ProjectInfo().getStartDate());
											entityInfo.setEndDate(dto.getPme00ProjectInfo().getEndDate());
											entityInfo.setKoreaPm(dto.getPme00ProjectInfo().getKoreaPm());
											entityInfo.setVietnamPl(dto.getPme00ProjectInfo().getVietnamPl());
											entityInfo.setStatus(dto.getPme00ProjectInfo().getStatus());
											entityInfo.setFramework(dto.getPme00ProjectInfo().getFramework());
											entityInfo.setImage(dto.getPme00ProjectInfo().getImage());
											entityInfo.setFile(dto.getPme00ProjectInfo().getFile());
											lstProjectInfo.add(entityInfo);
											serviceLifecycle.requestPme00ProjectInfoService().modify(lstProjectInfo);
											// Update data Pme00Member
											// Delete old Pme00Member
											serviceLifecycle.requestPme00MemberService().deleteMemberById(dto.getPme00ProjectInfo().getCdV(), null);
											// Insert new Pme00Member
											Pme00Member entityMember;
											for (Pme00Member member : dto.getLstMember()) {
												entityMember = new Pme00Member();
												entityMember.setCdVId(dto.getM00Codes030().getCdV());
												entityMember.setEmpId(member.getEmpId());
												entityMember.setEmpName(member.getEmpName());
												entityMember.setAvatar(member.getAvatar());
												serviceLifecycle.requestPme00MemberService().register(entityMember);
											}
											if (imageUpload != null) {
												String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", imageUpload);
												if (!result.contains("Project")) {
													resultList.add(false);
													resultList.add("Project created. However, image could not be saved.");
													return resultList;
												}
											}
											if (fileUpload != null) {
												String result = serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, "Project", fileUpload);
												if (!result.contains("Project")) {
													resultList.add(false);
													resultList.add("Project created. However, file could not be saved.");
													return resultList;
												}
											}
											resultList.add(true);
											return resultList;
										}
										@Override
										@Transactional(rollbackFor = { SQLException.class })
										public List<Object> deleteProject(ServiceLifecycle serviceLifecycle, M00Codes030Id id) throws SQLException {
											List<Object> resultList = new ArrayList<>();
											// Check project code exists
											if(checkExistsM00Codes030(serviceLifecycle, Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, id.getCdV())
													 && checkExistsPme00ProjectInfo(serviceLifecycle, id.getCdV())){
												// Delete tasks
												List<M00Task> m00TaskDtoList = serviceLifecycle.requestM00TaskService().findAll(id.getCdV());
												Map<String, Object> requestDeleteTaskId = new HashMap<>();
												requestDeleteTaskId.put("projectNumber", id.getCdV());
												for(M00Task task : m00TaskDtoList) {
													requestDeleteTaskId.put("taskName", task.getTaskName());
													requestDeleteTaskId.put("empId", "");
													requestDeleteTaskId.put("password", "");
													serviceLifecycle.requestLevel2TaskService().remove(serviceLifecycle, requestDeleteTaskId, false);
												}
												// Delete member in Pme00Member
												serviceLifecycle.requestPme00MemberService().deleteMemberById(id.getCdV(), null);
												//  Delete old file/image
												Pme00ProjectInfo projectInfo = serviceLifecycle.requestPme00ProjectInfoService().find(id.getCdV());
												List<String> fileName = new ArrayList<>();
												String imageString = projectInfo.getImage();
												imageString = imageString.substring(imageString.lastIndexOf("/") + 1);
												fileName.add(imageString);
												String fileString = projectInfo.getFile();
												fileString = fileString.substring(fileString.lastIndexOf("/") + 1);
												fileName.add(fileString);
												boolean result = serviceLifecycle.requestLevel2Service()
														.removeFile(Utils.UPLOAD_BUCKET, "Project", fileName);
												if (!result) {
													resultList.add(false);
													resultList.add("Error occurred while attempting to delete file(s) from server.");
													return resultList;
												}
												// Delete project Pme00ProjectInfo
												serviceLifecycle.requestPme00ProjectInfoService().remove(id.getCdV());
												// Delete project M00Codes030
												id.setCdTpId(Utils.CD_TP_ID);
												id.setCategoryGroupId(Utils.CATEGORY_GROUP_ID);
												serviceLifecycle.requestM00Codes030Service().remove(id);
												resultList.add(true);
												return resultList;
											}
											resultList.add(false);
											resultList.add("Error occurred while attempting to delete project.");
											return resultList;
										}
										@Override
										public Map<String, Object> getProjectList(ServiceLifecycle serviceLifecycle, ProjectManagementDto dto, int pageNo, int pageSize) {
											List<ProjectManagementDto>  projectList = new ArrayList<>();
											List<M00Codes030> m00Codes030List =
													serviceLifecycle.requestM00Codes030Service()
															.findM00Codes030(dto.getM00Codes030().getCdV(), dto.getM00Codes030().getCdvMeaning());
											Pageable pageable;
											if(pageSize == 0){
												pageable = Pageable.unpaged();
											} else {
												pageable = PageRequest.of(pageNo, pageSize);
											}
											List<Pme00ProjectInfo> pme00ProjectInfoList =
													serviceLifecycle.requestPme00ProjectInfoService()
															.findProjectInfo(dto.getM00Codes030().getCdV(),  dto.getM00Codes030().getCdvMeaning()
																	, dto.getPme00ProjectInfo().getPeriod(), dto.getPme00ProjectInfo().getKoreaPm()
																	, dto.getPme00ProjectInfo().getVietnamPl(), dto.getPme00ProjectInfo().getFramework()
																	, dto.getPme00ProjectInfo().getSearchStatus(), dto.getFromStartDate(), dto.getToStartDate()
																	, dto.getFromEndDate(), dto.getToEndDate(), pageable);
											for (M00Codes030 project : m00Codes030List) {
												for (Pme00ProjectInfo projectInfo : pme00ProjectInfoList) {
													ProjectManagementDto rsDto = new ProjectManagementDto();
													if (project.getCdV().equals(projectInfo.getCdV())){
														rsDto.setM00Codes030(project);
														rsDto.setPme00ProjectInfo(projectInfo);
														List<Pme00Member> lstMember = new ArrayList<>();
														lstMember = serviceLifecycle.requestPme00MemberService().getListMemberByCdVId(project.getCdV());
														rsDto.setLstMember(lstMember);
														projectList.add(rsDto);
													}
												}
											}
											int total = serviceLifecycle.requestPme00ProjectInfoService().getCountProject(dto.getM00Codes030().getCdV()
													, dto.getM00Codes030().getCdvMeaning(), dto.getPme00ProjectInfo().getPeriod()
													, dto.getPme00ProjectInfo().getKoreaPm(), dto.getPme00ProjectInfo().getVietnamPl()
													, dto.getPme00ProjectInfo().getFramework(), dto.getPme00ProjectInfo().getSearchStatus()
													, dto.getFromStartDate(), dto.getToStartDate(), dto.getFromEndDate(), dto.getToEndDate());
											Map<String, Object> rs = new HashMap<>();
											rs.put("total", total);
											rs.put("info", projectList);
											return rs;
										}
										@Override
										public Map<String, Object> getProjectListWithTask(ServiceLifecycle serviceLifecycle, ProjectManagementDto dto, String empId, int pageNo, int pageSize) {
											List<ProjectManagementDto>  projectList = new ArrayList<>();
											Pageable pageable;
											if(pageSize == 0){
												pageable = Pageable.unpaged();
											} else {
												pageable = PageRequest.of(pageNo, pageSize, Sort.by("status"));
											}
											List<Pme00ProjectInfo> pme00ProjectInfoList =
													serviceLifecycle.requestPme00ProjectInfoService()
															.findProjectInfoWithEmpId(dto.getM00Codes030().getCdV(),  dto.getM00Codes030().getCdvMeaning()
																	, dto.getPme00ProjectInfo().getPeriod(), dto.getPme00ProjectInfo().getKoreaPm()
																	, dto.getPme00ProjectInfo().getVietnamPl(), dto.getPme00ProjectInfo().getFramework()
																	, dto.getPme00ProjectInfo().getSearchStatus()
																	, dto.getFromStartDate(), dto.getToStartDate()
																	, dto.getFromEndDate(), dto.getToEndDate(), empId, pageable);
											for (Pme00ProjectInfo projectInfo : pme00ProjectInfoList) {
												List<M00TaskDto> taskList = new ArrayList<>();
												try {
													HashMap<String, Object> mapTaskResponse = (HashMap<String, Object>) serviceLifecycle.requestLevel2TaskService().findTaskByConditions(serviceLifecycle,
															projectInfo.getCdV(), null, null, null, null, null, null,
															0, 20, "lastUpdateTimestamp", "ASC").getBody();
													if (!mapTaskResponse.isEmpty()) {
														taskList = (List<M00TaskDto>) mapTaskResponse.get("data");
													}
												} catch (Exception e) {
													System.out.println("TASK: " + e.getMessage());
												}
												ProjectManagementDto rsDto = new ProjectManagementDto();
												rsDto.setPme00ProjectInfo(projectInfo);
												//Set project name
												M00Codes030Id m00Codes030Id = new M00Codes030Id(Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, projectInfo.getCdV());
												String projectName = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCdvMeaning();
												String projectCode = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCdV();
												String projectDescription = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCdVExplain();
												String creatorId = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCreatedProgramId();
												M00Codes030 m00Codes030 = new M00Codes030();
												m00Codes030.setCdvMeaning(projectName);
												m00Codes030.setCdV(projectCode);
												m00Codes030.setCreatedProgramId(creatorId);
												m00Codes030.setCdVExplain(projectDescription);
												rsDto.setM00Codes030(m00Codes030);
												//Set project progress
												long completedTasks = taskList.stream()
														.filter(item -> "O".equals(item.getTask().getStatus()))
														.count();
												double completionPercentage = (completedTasks * 100.0) / taskList.size();
												int progress = (int) completionPercentage;
												rsDto.setProgress(progress);
												rsDto.setLstTask(taskList);

												List<Pme00Member> lstMember = new ArrayList<>();
												lstMember = serviceLifecycle.requestPme00MemberService().getListMemberByCdVId(projectInfo.getCdV());
												rsDto.setLstMember(lstMember);
												projectList.add(rsDto);
											}
											int total = serviceLifecycle.requestPme00ProjectInfoService().getCountProjectWithEmpId(dto.getM00Codes030().getCdV()
													, dto.getM00Codes030().getCdvMeaning(), dto.getPme00ProjectInfo().getPeriod()
													, dto.getPme00ProjectInfo().getKoreaPm(), dto.getPme00ProjectInfo().getVietnamPl()
													, dto.getPme00ProjectInfo().getFramework(), dto.getPme00ProjectInfo().getSearchStatus()
													, dto.getFromStartDate(), dto.getToStartDate(), dto.getFromEndDate(), dto.getToEndDate(), empId);
											Map<String, Object> rs = new HashMap<>();
											rs.put("total", total);
											rs.put("info", projectList);
											return rs;
										}
										@Override
										public Map<String, Object> getAllProjectListWithEmpId(ServiceLifecycle serviceLifecycle, String empId, int pageNo, int pageSize) {
											List<ProjectManagementDto> result = new ArrayList<>();
											//Get project list
											Pageable pageable;
											if(pageSize == 0){
												pageable = Pageable.unpaged();
											} else {
												pageable = PageRequest.of(pageNo, pageSize, Sort.by("status"));
											}
											List<Pme00ProjectInfo> projectList = serviceLifecycle.requestPme00ProjectInfoService().findProjectInfoWithEmpId(
													null, null, 0, null, null, null, null,
													null, null, null, null, empId, pageable);
											if (!projectList.isEmpty()) {
												for (Pme00ProjectInfo pme00ProjectInfo : projectList) {
													ProjectManagementDto newObject = new ProjectManagementDto();
													//Set project info
													newObject.setPme00ProjectInfo(pme00ProjectInfo);
													//Get task list
													List<M00TaskDto> taskList = new ArrayList<>();
													try {
														HashMap<String, Object> mapTaskResponse = (HashMap<String, Object>) serviceLifecycle.requestLevel2TaskService().findTaskByConditions(serviceLifecycle,
																pme00ProjectInfo.getCdV(), null, null, null, null, null, null,
																0, 20, "lastUpdateTimestamp", "ASC").getBody();
														if (!mapTaskResponse.isEmpty()) {
															taskList = (List<M00TaskDto>) mapTaskResponse.get("data");
														}
													} catch (Exception e) {
														System.out.println("TASK: " + e.getMessage());
													}
													newObject.setLstTask(taskList);
													//Set member list
													List<Pme00Member> listMember = serviceLifecycle.requestPme00MemberService().getListMemberByCdVId(pme00ProjectInfo.getCdV());
													newObject.setLstMember(listMember);
													//Set project name
													M00Codes030Id m00Codes030Id = new M00Codes030Id(Utils.CD_TP_ID, Utils.CATEGORY_GROUP_ID, pme00ProjectInfo.getCdV());
													String projectName = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCdvMeaning();
													String creatorId = serviceLifecycle.requestM00Codes030Service().find(m00Codes030Id).getCreatedProgramId();
													M00Codes030 m00Codes030 = new M00Codes030();
													m00Codes030.setCdvMeaning(projectName);
													m00Codes030.setCreatedProgramId(creatorId);
													newObject.setM00Codes030(m00Codes030);
													//Set project progress
													long completedTasks = taskList.stream()
															.filter(item -> "O".equals(item.getTask().getStatus()))
															.count();
													double completionPercentage = (completedTasks * 100.0) / taskList.size();
													int progress = (int) completionPercentage;
													newObject.setProgress(progress);
													System.out.println("Completion Percentage: " + completionPercentage);
													result.add(newObject);
												}
											}
											int total = serviceLifecycle.requestPme00ProjectInfoService().getCountProjectWithEmpId(null, null,0, null,
													null, null,  null, null, null, null, null, empId);
											Map<String, Object> rs = new HashMap<>();
											rs.put("total", total);
											rs.put("info", result);
											return rs;
										}
										@Override
										public List<M00Employee> getProjectMember(ServiceLifecycle serviceLifecycle, String cdV) {
											return serviceLifecycle.requestPme00ProjectInfoService().getProjectMember(cdV);
										}
										@Override
										public ProjectManagementDto findProjectById(ServiceLifecycle serviceLifecycle, M00Codes030Id id) {
											ProjectManagementDto dto = new ProjectManagementDto();
											dto.setM00Codes030(serviceLifecycle.requestM00Codes030Service().find(id));
											dto.setPme00ProjectInfo(serviceLifecycle.requestPme00ProjectInfoService().find(id.getCdV()));
											return dto;
										}
										private boolean checkExistsM00Codes030(ServiceLifecycle serviceLifecycle, int cdTpId, int cateGroupId, String cdV){
											M00Codes030Id codes030Id = new M00Codes030Id();
											codes030Id.setCdTpId(cdTpId);
											codes030Id.setCategoryGroupId(cateGroupId);
											codes030Id.setCdV(cdV);
											M00Codes030 codes030 = serviceLifecycle.requestM00Codes030Service().find(codes030Id);
											return codes030 != null;
										}
										private boolean checkExistsPme00ProjectInfo(ServiceLifecycle serviceLifecycle, String cdV){
											Pme00ProjectInfo projectInfo = new Pme00ProjectInfo();

											projectInfo = serviceLifecycle.requestPme00ProjectInfoService().find(cdV);

											return projectInfo != null;
										}
									}
			Store:
									package com.poscodx.odc.ampro015.store;
									import com.poscdx.odc.ampro015.domain.entity.Pme00ProjectInfo;
									import com.poscdx.odc.ampro015.domain.store.Pme00ProjectInfoStore;
									import com.poscodx.odc.ampro015.store.jpo.Pme00ProjectInfoJpo;
									import com.poscodx.odc.ampro015.store.repository.Pme00ProjectInfoRepository;
									import org.springframework.data.domain.Pageable;
									import org.springframework.stereotype.Repository;
									import java.util.Date;
									import java.util.List;
									import java.util.Optional;
									import java.util.Set;
									@Repository
									public class Pme00ProjectInfoJpaStore implements Pme00ProjectInfoStore {
										private final Pme00ProjectInfoRepository repository;
										public Pme00ProjectInfoJpaStore(Pme00ProjectInfoRepository repository) {
											this.repository = repository;
										}
										@Override
										public Pme00ProjectInfo retrieve(String cdVId) {
											Optional<Pme00ProjectInfoJpo> retVal = this.repository.findById(cdVId);
											return retVal.map(Pme00ProjectInfoJpo::toDomain).orElse(null);
										}
										@Override
										public List<Pme00ProjectInfo> retrieveAll() {
											return Pme00ProjectInfoJpo.toDomains(this.repository.findAll());
										}
										@Override
										public Pme00ProjectInfo update(Pme00ProjectInfo Pme00ProjectInfo) {
											Pme00ProjectInfoJpo jpoToUpdate = new Pme00ProjectInfoJpo(Pme00ProjectInfo);
											Pme00ProjectInfoJpo updatedJpo = this.repository.save(jpoToUpdate);
											return updatedJpo.toDomain();
										}
										@Override
										public Pme00ProjectInfo create(Pme00ProjectInfo entity) {
											return this.repository.save(new Pme00ProjectInfoJpo(entity)).toDomain();
										}
										@Override
										public void delete(String cdVId) {
											this.repository.deleteById(cdVId);
										}
										@Override
										public List<Object[]> findProjectInfo(boolean cdVAll, List<String> cdV, String meaning, int period, String koreaPM, String vietnamPL, String framework, boolean searchAllStatus,
																			  List<String> searchStatus, Date fromStartDate, Date toStartDate, Date fromEndDate, Date toEndDate, Pageable pageable){
											return this.repository.findProjectInfo(cdVAll, cdV, meaning, period, koreaPM, vietnamPL, framework, searchAllStatus,
													searchStatus, fromStartDate, toStartDate, fromEndDate, toEndDate, pageable);
										}
										@Override
										public List<Object[]> findProjectInfoWithEmpId(boolean cdVAll, List<String> cdV, String meaning, int period, String koreaPM, String vietnamPL, String framework, boolean searchAllStatus,
																					   List<String> searchStatus, Date fromStartDate, Date toStartDate, Date fromEndDate, Date toEndDate, String empId,
																					   Pageable pageable) {
											return this.repository.findProjectInfoWithEmpId(cdVAll, cdV, meaning, period, koreaPM, vietnamPL, framework, searchAllStatus,
													searchStatus, fromStartDate, toStartDate, fromEndDate, toEndDate, empId, pageable);
										}
										@Override
										public List<Object[]> getKoreaPM(String projectNumber) {
											return this.repository.getKoreaPM(projectNumber);
										}
										@Override
										public List<Object[]> getVietnamPL(String projectNumber) {
											return this.repository.getVietnamPL(projectNumber);
										}
										@Override
										public List<Object[]> getProjectMember(String cdV) {
											return this.repository.getMember(cdV);
										}
										@Override
										public int getCountProject(boolean cdVAll, List<String> cdV, String meaning, int period, String koreaPM, String vietnamPL, String framework, boolean searchAllStatus,
																   List<String> searchStatus, Date fromStartDate, Date toStartDate, Date fromEndDate, Date toEndDate){
											return this.repository.countProject(cdVAll, cdV, meaning, period, koreaPM, vietnamPL, framework, searchAllStatus,
																				searchStatus, fromStartDate, toStartDate, fromEndDate, toEndDate);
										}
										@Override
										public int getCountProjectWithEmpId(boolean cdVAll, List<String> cdV, String meaning, int period, String koreaPM, String vietnamPL, String framework, boolean searchAllStatus,
																			List<String> searchStatus, Date fromStartDate, Date toStartDate, Date fromEndDate, Date toEndDate, String empId) {
											return this.repository.countProjectWithEmpId(cdVAll, cdV, meaning, period, koreaPM, vietnamPL, framework, searchAllStatus,
													searchStatus, fromStartDate, toStartDate, fromEndDate, toEndDate, empId);
										}
										@Override
										public List<Object[]> getKoreaPMBySet(Set<String> projectNumber) {
											return this.repository.getKoreaPMBySet(projectNumber);
										}
										@Override
										public List<Object[]> getVietnamPLBySet(Set<String> projectNumber) {
											return this.repository.getVietnamPLBySet(projectNumber);
										}
									}
			Store-Repository:
									package com.poscodx.odc.ampro015.store.repository;
									import com.poscodx.odc.ampro015.store.jpo.Pme00ProjectInfoJpo;
									import org.springframework.data.domain.Pageable;
									import org.springframework.data.jpa.repository.JpaRepository;
									import org.springframework.data.jpa.repository.Query;
									import org.springframework.data.repository.query.Param;
									import java.util.Date;
									import java.util.List;
									import java.util.Set;
									public interface Pme00ProjectInfoRepository extends JpaRepository<Pme00ProjectInfoJpo, String> {
										@Query(value =
												"SELECT INFO.*\n" +
													", EMP1.NAME AS KOREA_PM_NAME\n" +
													", EMP1.PHOTO AS KOREA_PM_PHOTO\n" +
													", EMP2.NAME AS VIETNAM_PL_NAME\n" +
													", EMP2.PHOTO AS VIETNAM_PL_PHOTO\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO INFO\n" +
												"JOIN TB_M00_EMPLOYEE EMP1\n" +
													"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
												"JOIN TB_M00_EMPLOYEE EMP2\n" +
													"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
												"JOIN TB_M00_CODES030 CODE030\n" +
													"ON CODE030.CD_V = INFO.CD_V \n" +
												"WHERE  1 = 1 \n" +
													"AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
													"AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
													"AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
													"AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
													"AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
													"AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
													"AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
													"AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
													"AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))"
												, nativeQuery = true)
										List<Object[]> findProjectInfo(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String>  cdV, @Param("meaning") String meaning, @Param("period") int period,
																				  @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
																				  @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
																				  @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
																				  @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
																				  @Param("toEndDate") Date toEndDate, Pageable pageable);
										@Query(value =
												"SELECT DISTINCT INFO.*\n" +
													", EMP1.NAME AS KOREA_PM_NAME\n" +
													", EMP1.PHOTO AS KOREA_PM_PHOTO\n" +
													", EMP2.NAME AS VIETNAM_PL_NAME\n" +
													", EMP2.PHOTO AS VIETNAM_PL_PHOTO\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO INFO\n" +
													"JOIN TB_M00_EMPLOYEE EMP1\n" +
														"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
													"JOIN TB_M00_EMPLOYEE EMP2\n" +
														"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
													"JOIN TB_M00_CODES030 CODE030\n" +
														"ON CODE030.CD_V = INFO.CD_V \n" +
													"JOIN TB_PME00_MEMBER MEMBER\n" +
														"ON INFO.CD_V = MEMBER.CD_V_ID \n" +
												"WHERE  1 = 1 \n" +
													"AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
													"AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
													"AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
													"AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
													"AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
													"AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
													"AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
													"AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
													"AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))" +
													"AND (:empId IS NULL OR (INFO.KOREA_PM = :empId OR INFO.VIETNAM_PL = :empId OR :empId = MEMBER.EMP_ID OR :empId = CODE030.CREATED_PROGRAM_ID))\n"
												, nativeQuery = true)
										List<Object[]> findProjectInfoWithEmpId(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String> cdV, @Param("meaning") String meaning, @Param("period") int period,
																	   @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
																	   @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
																	   @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
																	   @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
																	   @Param("toEndDate") Date toEndDate, @Param("empId") String empId, Pageable pageable);
										@Query(value =
												"SELECT DISTINCT \n" +
													"EMP.EMP_ID \n" +
													", EMP.NAME \n" +
													", EMP.PHOTO \n" +
													", EMP.BIRTH_DATE\n" +
													", EMP.IP_ADDRESS\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO AS INFO\n" +
												"JOIN \n" +
													"TB_M00_EMPLOYEE AS EMP\n" +
												"ON \n" +
													"INFO.KOREA_PM = EMP.EMP_ID\n" +
												"WHERE \n" +
													"(:projectNumber IS NULL OR INFO.CD_V = :projectNumber)", nativeQuery = true)
										List<Object[]> getKoreaPM(@Param("projectNumber") String projectNumber);
										@Query(value =
												"SELECT DISTINCT \n" +
													"EMP.EMP_ID \n" +
													", EMP.NAME \n" +
													", EMP.PHOTO \n" +
													", EMP.BIRTH_DATE\n" +
													", EMP.IP_ADDRESS\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO AS INFO\n" +
												"JOIN \n" +
													"TB_M00_EMPLOYEE AS EMP\n" +
												"ON \n" +
													"INFO.VIETNAM_PL = EMP.EMP_ID\n" +
												"WHERE \n" +
													"(:projectNumber IS NULL OR INFO.CD_V = :projectNumber)", nativeQuery = true)
										List<Object[]> getVietnamPL(@Param("projectNumber") String projectNumber);
										@Query(value =
												"SELECT E.EMP_ID \n" +
														", E.NAME \n" +
														", E.PHOTO \n" +
														", E.BIRTH_DATE\n" +
														", E.IP_ADDRESS\n" +
												"FROM \n" +
														"TB_M00_EMPLOYEE AS E\n" +
												"WHERE E.EMP_ID IN \n" +
													"(SELECT M.EMP_ID \n" +
															"FROM TB_PME00_MEMBER AS M \n" +
															"WHERE M.CD_V_ID = :cdV) \n", nativeQuery = true)
										List<Object[]> getMember(@Param("cdV") String cdV);
										@Query(value =
												"SELECT Count(*)\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO AS INFO\n" +
													"JOIN TB_M00_EMPLOYEE EMP1\n" +
														"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
													"JOIN TB_M00_EMPLOYEE EMP2\n" +
														"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
													"JOIN TB_M00_CODES030 CODE030\n" +
														"ON CODE030.CD_V = INFO.CD_V \n" +
												"WHERE  1 = 1 \n" +
													"AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
													"AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
													"AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
													"AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
													"AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
													"AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
													"AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
													"AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
													"AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))"
												, nativeQuery = true)
										int countProject(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String> cdV, @Param("meaning") String meaning, @Param("period") int period,
																	   @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
																	   @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
																	   @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
																	   @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
																	   @Param("toEndDate") Date toEndDate);
										@Query(value =
												"SELECT COUNT(DISTINCT INFO.CD_V)\n" +
												"FROM \n" +
													"TB_PME00_PROJECT_INFO INFO\n" +
													"JOIN TB_M00_EMPLOYEE EMP1\n" +
														"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
													"JOIN TB_M00_EMPLOYEE EMP2\n" +
														"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
													"JOIN TB_M00_CODES030 CODE030\n" +
														"ON CODE030.CD_V = INFO.CD_V \n" +
													"JOIN TB_PME00_MEMBER MEMBER\n" +
														"ON INFO.CD_V = MEMBER.CD_V_ID \n" +
												"WHERE  1 = 1 \n" +
													 "AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
													 "AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
													 "AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
													 "AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
													 "AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
													 "AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
													 "AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
													 "AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
													 "AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))" +
													 "AND (:empId IS NULL OR (INFO.KOREA_PM = :empId OR INFO.VIETNAM_PL = :empId OR :empId = MEMBER.EMP_ID OR :empId = CODE030.CREATED_PROGRAM_ID))\n"
												, nativeQuery = true)
										int countProjectWithEmpId(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String> cdV, @Param("meaning") String meaning, @Param("period") int period,
														 @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
														 @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
														 @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
														 @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
														 @Param("toEndDate") Date toEndDate, @Param("empId") String empId);
										@Query(value =
												"SELECT DISTINCT \n" +
														"EMP.EMP_ID \n" +
														", EMP.NAME \n" +
														", EMP.PHOTO \n" +
														", EMP.BIRTH_DATE\n" +
														", EMP.IP_ADDRESS\n" +
														"FROM \n" +
														"TB_PME00_PROJECT_INFO AS INFO\n" +
														"JOIN \n" +
														"TB_M00_EMPLOYEE AS EMP\n" +
														"ON \n" +
														"INFO.KOREA_PM = EMP.EMP_ID\n" +
														"WHERE \n" +
														"(COALESCE(:projectNumber) IS NULL OR INFO.CD_V IN (:projectNumber))", nativeQuery = true)
										List<Object[]> getKoreaPMBySet(@Param("projectNumber") Set<String> projectNumber);
										@Query(value =
												"SELECT DISTINCT \n" +
														"EMP.EMP_ID \n" +
														", EMP.NAME \n" +
														", EMP.PHOTO \n" +
														", EMP.BIRTH_DATE\n" +
														", EMP.IP_ADDRESS\n" +
														"FROM \n" +
														"TB_PME00_PROJECT_INFO AS INFO\n" +
														"JOIN \n" +
														"TB_M00_EMPLOYEE AS EMP\n" +
														"ON \n" +
														"INFO.VIETNAM_PL = EMP.EMP_ID\n" +
														"WHERE \n" +
														"(COALESCE(:projectNumber) IS NULL OR INFO.CD_V IN (:projectNumber))", nativeQuery = true)
										List<Object[]> getVietnamPLBySet(@Param("projectNumber") Set<String> projectNumber);
									}								
		Standard 2:
			Entity:												
										package com.example.springbackend.entity;
										import com.fasterxml.jackson.annotation.JsonIgnore;
										import jakarta.persistence.*;
										import java.util.List;
										@Entity
										@Table(name = "user_info")
										public class UserInfo {
											@Id
											@GeneratedValue(strategy = GenerationType.IDENTITY)
											@Column(name = "id")
											private int id;
											@Column(name = "username")
											private String userName;
											@JsonIgnore
											@Column(name = "password")
											private String password;
											@Column(name = "fullname")
											private String fullName;
											@Column(name = "phone_number")
											private int phoneNumber;
											@Column(name = "authority")
											private String authority;
											@Column(name = "enabled")
											private boolean enabled;
											@JsonIgnore
											@OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
											private BankingAccount bankingAccount;
											@JsonIgnore
											@OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
											private BankingCard bankingCard;
											@JsonIgnore
											@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
											private List<TransactionHistory> transactionHistory;
											public UserInfo() {
											}
											public UserInfo(String userName, String password, String fullName, int phoneNumber, String authority, boolean enabled) {
												this.userName = userName;
												this.password = password;
												this.fullName = fullName;
												this.phoneNumber = phoneNumber;
												this.authority = authority;
												this.enabled = enabled;
											}
											public int getId() {
												return id;
											}
											public void setId(int id) {
												this.id = id;
											}
											public String getUserName() {
												return userName;
											}
											public void setUserName(String userName) {
												this.userName = userName;
											}
											public String getPassword() {
												return password;
											}
											public void setPassword(String password) {
												this.password = password;
											}
											public String getFullName() {
												return fullName;
											}
											public void setFullName(String fullName) {
												this.fullName = fullName;
											}
											public int getPhoneNumber() {
												return phoneNumber;
											}
											public void setPhoneNumber(int phoneNumber) {
												this.phoneNumber = phoneNumber;
											}
											public String getAuthority() {
												return authority;
											}
											public void setAuthority(String authority) {
												this.authority = authority;
											}
											public boolean isEnabled() {
												return enabled;
											}
											public void setEnabled(boolean enabled) {
												this.enabled = enabled;
											}
											public BankingAccount getBankingAccount() {
												return bankingAccount;
											}
											public void setBankingAccount(BankingAccount bankingAccount) {
												this.bankingAccount = bankingAccount;
											}
											public BankingCard getBankingCard() {
												return bankingCard;
											}
											public void setBankingCard(BankingCard bankingCard) {
												this.bankingCard = bankingCard;
											}
											public List<TransactionHistory> getTransactionHistory() {
												return transactionHistory;
											}
											public void setTransactionHistory(List<TransactionHistory> transactionHistory) {
												this.transactionHistory = transactionHistory;
											}
											public void addTransactionHistory(TransactionHistory tempTransactionHistory) {
												this.transactionHistory.add(tempTransactionHistory);
												tempTransactionHistory.setUser(this);
											}
											@Override
											public String toString() {
												return "UserInfo{" +
														"id=" + id +
														", userName='" + userName + '\'' +
														", password='" + password + '\'' +
														", fullName='" + fullName + '\'' +
														", phoneNumber=" + phoneNumber +
														", authority='" + authority + '\'' +
														", enabled=" + enabled +
														'}';
											}
										}
			Controller:
										package com.example.springbackend.controller;
										import com.example.springbackend.entity.UserInfo;
										import com.example.springbackend.service.EmailConfirmationService;
										import com.example.springbackend.service.UserService;
										import org.springframework.beans.factory.annotation.Autowired;
										import org.springframework.http.ResponseEntity;
										import org.springframework.security.core.Authentication;
										import org.springframework.security.core.context.SecurityContextHolder;
										import org.springframework.ui.Model;
										import org.springframework.web.bind.annotation.*;
										import java.util.List;
										@RestController
										@RequestMapping("/")
										public class UserController {
											private UserService userService;
											@Autowired
											public UserController(UserService userService) {
												this.userService = userService;
											}
											@GetMapping("/user/findById/{userId}")
											public UserInfo findUserById(@PathVariable("userId") int userId) {
												return userService.findUserById(userId);
											}
											@GetMapping("/user/findByUsername/{userName}")
											public UserInfo findUserByUserName(@PathVariable("userName") String userName) {
												return userService.findUserByUserName(userName);
											}
											@GetMapping("/user/findByPhoneNumber/{phoneNumber}")
											public UserInfo findUserByPhoneNumber(@PathVariable("phoneNumber") int phoneNumber) {
												return userService.findUserByPhoneNumber(phoneNumber);
											}
											@GetMapping("/user/getAllUsers")
											public List<UserInfo> getAllUsers() {
												return userService.findAllUsers();
											}
											@CrossOrigin(origins = "http://localhost:3000")
											@PostMapping("/user")
											public void createUser(@ModelAttribute("user") UserInfo userInfo) {
												userInfo.setAuthority("ROLE_USER");
												userInfo.setEnabled(true);
												userService.saveUser(userInfo);
											}
											@PostMapping("/user/withDraw")
											public ResponseEntity<String> withDrawMoney(@RequestParam String nameOfAccountWithDraw, @RequestParam float amount) {
												return userService.withDrawMoney(nameOfAccountWithDraw, amount);
											}
											@PostMapping("/user/payThePill")
											public ResponseEntity<String> payTheBill(@RequestParam String nameOfAccountPayTheBill, @RequestParam float amount) {
												return userService.payTheBill(nameOfAccountPayTheBill, amount);
											}
										}
	
			Service:
			
				Service Interface:	
				
										package com.example.springbackend.service;
										import com.example.springbackend.entity.UserInfo;
										import org.springframework.http.ResponseEntity;
										import org.springframework.transaction.annotation.Transactional;
										import java.util.List;
										public interface UserService {
											UserInfo findUserById(int userId);
											List<UserInfo> findAllUsers();
											@Transactional
											void saveUser(UserInfo userInfo);
											UserInfo findUserByUserName(String userName);
											UserInfo findUserByPhoneNumber(int phoneNumber);
											@Transactional
											void updateUser(UserInfo userEntity);
											void deleteUserByUserName(String userName);
											void deleteUserById(int userId);
											public ResponseEntity<String> transferMoney(String nameOfAccountSend, String nameOfAccountReceive, float amount);
											public ResponseEntity<String> withDrawMoney(String nameOfAccountWithDraw, float amount);
											public ResponseEntity<String> payTheBill(String nameOfAccountPayTheBill, float amount);
										}
				
				Service Implement:
				
										package com.example.springbackend.service.impl;
										import com.example.springbackend.dao.UserDAO;
										import com.example.springbackend.entity.BankingAccount;
										import com.example.springbackend.entity.TransactionHistory;
										import com.example.springbackend.entity.UserInfo;
										import com.example.springbackend.handler.NotFoundException;
										import com.example.springbackend.service.BankingAccountService;
										import com.example.springbackend.service.UserService;
										import org.springframework.beans.factory.annotation.Autowired;
										import org.springframework.http.ResponseEntity;
										import org.springframework.mail.SimpleMailMessage;
										import org.springframework.stereotype.Service;
										import org.springframework.transaction.annotation.Transactional;
										import java.sql.Timestamp;
										import java.time.LocalDateTime;
										import java.util.List;
										@Service
										public class UserServiceImpl implements UserService {
											private UserDAO userDao;
											@Autowired
											public UserServiceImpl(UserDAO userDAO) {
												this.userDao = userDAO;
											}
											@Override
											public UserInfo findUserById(int userId) {
												UserInfo user = userDao.findUserById(userId);
												if (user == null) {
													throw new NotFoundException("User id not found - " + userId);
												}
												return user;
											}
											@Override
											public List<UserInfo> findAllUsers() {
												return userDao.findAllUsers();
											}
											@Transactional
											@Override
											public void saveUser(UserInfo userInfo) {
												userDao.saveUser(userInfo);
											}
											@Override
											public UserInfo findUserByUserName(String userName) {

												return userDao.findUserByUserName(userName);
											}
											@Override
											public UserInfo findUserByPhoneNumber(int phoneNumber) {
												return userDao.findUserByPhoneNumber(phoneNumber);
											}
											@Override
											public void updateUser(UserInfo userEntity) {
												userDao.updateUser(userEntity);
											}

											@Transactional
											@Override
											public void deleteUserByUserName(String userName) {
												userDao.deleteUserByUserName(userName);
											}
											@Transactional
											@Override
											public void deleteUserById(int userId) {
												userDao.deleteUserById(userId);
											}
											@Transactional
											@Override
											public ResponseEntity<String> transferMoney(String nameOfAccountSend, String nameOfAccountReceive, float amount) {
												UserInfo userInfoSent = userDao.findUserByUserName(nameOfAccountSend);
												UserInfo userInfoReceive = userDao.findUserByUserName(nameOfAccountReceive);
												if (userInfoSent == null || userInfoReceive == null)
													return ResponseEntity.badRequest().body("Invalid account username");
												if (userInfoSent.getBankingAccount().getAccountBalance() < amount)
													return ResponseEntity.badRequest().body("Not enough balance");
												userInfoSent.getBankingAccount().setAccountBalance(userInfoSent.getBankingAccount().getAccountBalance() - amount);
												userInfoReceive.getBankingAccount().setAccountBalance(userInfoReceive.getBankingAccount().getAccountBalance() + amount);
												TransactionHistory tempTransactionHistorySent = new TransactionHistory("Transfer", -amount, Timestamp.valueOf(LocalDateTime.now()));
												userInfoSent.addTransactionHistory(tempTransactionHistorySent);
												TransactionHistory tempTransactionHistoryReceive = new TransactionHistory("Receive", +amount, Timestamp.valueOf(LocalDateTime.now()));
												userInfoReceive.addTransactionHistory(tempTransactionHistoryReceive);
												userDao.updateUser(userInfoSent);
												userDao.updateUser(userInfoReceive);
												return ResponseEntity.ok("Money transferred successfully");
											}
											@Transactional
											@Override
											public ResponseEntity<String> withDrawMoney(String nameOfAccountWithDraw, float amount) {
												UserInfo userInfoWithDraw = userDao.findUserByUserName(nameOfAccountWithDraw);
												if (userInfoWithDraw == null)
													return ResponseEntity.badRequest().body("Invalid account numbers");
												if (userInfoWithDraw.getBankingAccount().getAccountBalance() < amount)
													return ResponseEntity.badRequest().body("Not enough balance");
												userInfoWithDraw.getBankingAccount().setAccountBalance(userInfoWithDraw.getBankingAccount().getAccountBalance() - amount);
												TransactionHistory tempTransactionHistoryWithdraw = new TransactionHistory("Withdraw", -amount, Timestamp.valueOf(LocalDateTime.now()));
												userInfoWithDraw.addTransactionHistory(tempTransactionHistoryWithdraw);
												userDao.updateUser(userInfoWithDraw);
												return ResponseEntity.ok("Money withdrew successfully");
											}
											@Transactional
											@Override
											public ResponseEntity<String> payTheBill(String nameOfAccountPayTheBill, float amount) {
												UserInfo userInfoPayTheBill = userDao.findUserByUserName(nameOfAccountPayTheBill);
												if (userInfoPayTheBill == null)
													return ResponseEntity.badRequest().body("Invalid account numbers");
												if (userInfoPayTheBill.getBankingAccount().getAccountBalance() < amount)
													return ResponseEntity.badRequest().body("Not enough balance");
												userInfoPayTheBill.getBankingAccount().setAccountBalance(userInfoPayTheBill.getBankingAccount().getAccountBalance() - amount);
												TransactionHistory tempTransactionHistoryWithdraw = new TransactionHistory("Pay the bill", -amount, Timestamp.valueOf(LocalDateTime.now()));
												userInfoPayTheBill.addTransactionHistory(tempTransactionHistoryWithdraw);
												userDao.updateUser(userInfoPayTheBill);
												return ResponseEntity.ok("Pay the bill successfully");
											}
										}																	
			DAO:
				DAO Interface:
										package com.example.springbackend.dao;
										import com.example.springbackend.entity.UserInfo;
										import java.util.List;
										public interface UserDAO {
											UserInfo findUserById(int userId);
											List<UserInfo> findAllUsers();
											void saveUser(UserInfo userInfo);
											UserInfo findUserByUserName(String userName);
											UserInfo findUserByPhoneNumber(int phoneNumber);
											void updateUser(UserInfo userEntity);
											void deleteUserByUserName(String userName);
											void deleteUserById(int userId);
										}
				DAO Implement:
										
										Khi Spring gặp annotation @Autowired trên constructor UserDAOImpl, nó sẽ tự động chèn một instance của EntityManager vào đó. Do đó, constructor public UserDAOImpl(EntityManager
										entityManager) sẽ được chạy khi Spring cần tạo một instance mới của UserDAOImpl để sử dụng, và nó sẽ được chạy với một instance của EntityManager được chèn vào.
										
										package com.example.springbackend.dao.impl;
										import com.example.springbackend.dao.UserDAO;
										import com.example.springbackend.entity.BankingAccount;
										import com.example.springbackend.entity.BankingCard;
										import com.example.springbackend.entity.UserInfo;
										import jakarta.persistence.EntityManager;
										import jakarta.persistence.TypedQuery;
										import org.springframework.beans.factory.annotation.Autowired;
										import org.springframework.stereotype.Repository;
										import java.sql.Timestamp;
										import java.util.List;
										@Repository
										public class UserDAOImpl implements UserDAO {
											private EntityManager entityManager;
											@Autowired
											public UserDAOImpl(EntityManager entityManager) {
												this.entityManager = entityManager;
											}
											@Override
											public UserInfo findUserById(int userId) {
												UserInfo user = entityManager.find(UserInfo.class, userId);
												return user;
											}
											@Override
											public List<UserInfo> findAllUsers() {
												TypedQuery<UserInfo> theQuery = entityManager.createQuery("from UserInfo", UserInfo.class);
												List<UserInfo> userLists = theQuery.getResultList();
												return userLists;
											}
											@Override
											public void saveUser(UserInfo userInfo) {
												BankingAccount bankingAccount = new BankingAccount(1000000);
												userInfo.setBankingAccount(bankingAccount);
												bankingAccount.setUser(userInfo);
												Timestamp timestamp = Timestamp.valueOf("2030-01-01 00:00:00");
												BankingCard bankingCard = new BankingCard(true, timestamp);
												userInfo.setBankingCard(bankingCard);
												bankingCard.setUser(userInfo);
												entityManager.persist(userInfo);
											}
											@Override
											public UserInfo findUserByUserName(String userName) {
												TypedQuery<UserInfo> theQuery = entityManager.createQuery("FROM UserInfo WHERE userName=:data", UserInfo.class);
												theQuery.setParameter("data", userName);
												List<UserInfo> results = theQuery.getResultList();
												if (!results.isEmpty()) {
													return results.get(0);
												}
												return null;
											}
											@Override
											public UserInfo findUserByPhoneNumber(int phoneNumber) {
												TypedQuery<UserInfo> theQuery = entityManager.createQuery("FROM UserInfo WHERE phoneNumber=:data", UserInfo.class);
												theQuery.setParameter("data", phoneNumber);
												return theQuery.getSingleResult();
											}
											@Override
											public void updateUser(UserInfo userEntity) {
												entityManager.merge(userEntity);
											}
											@Override
											public void deleteUserByUserName(String userName) {
												int deleteCount = entityManager.createQuery("DELETE FROM UserInfo WHERE userName=:data", UserInfo.class)
																			   .setParameter("data", userName)
																			   .executeUpdate();
											}
											@Override
											public void deleteUserById(int userId) {
												UserInfo user = entityManager.find(UserInfo.class, userId);
												entityManager.remove(user);
											}
										}
			Security:
										package com.example.springbackend.security;
										import org.springframework.context.annotation.Bean;
										import org.springframework.context.annotation.Configuration;
										import org.springframework.http.HttpMethod;
										import org.springframework.security.config.Customizer;
										import org.springframework.security.config.annotation.web.builders.HttpSecurity;
										import org.springframework.security.config.annotation.web.builders.WebSecurity;
										import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
										import org.springframework.security.core.userdetails.User;
										import org.springframework.security.core.userdetails.UserDetails;
										import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
										import org.springframework.security.provisioning.InMemoryUserDetailsManager;
										import org.springframework.security.provisioning.JdbcUserDetailsManager;
										import org.springframework.security.provisioning.UserDetailsManager;
										import org.springframework.security.web.SecurityFilterChain;
										import javax.sql.DataSource;
										@Configuration
										public class SecurityConfig {
										   @Bean
										   public UserDetailsManager userDetailsManager(DataSource dataSource) {
											   JdbcUserDetailsManager theUserDetailsManager = new JdbcUserDetailsManager(dataSource);
											   theUserDetailsManager.setUsersByUsernameQuery("select username, password, enabled from user_info where username = ?");
											   theUserDetailsManager.setAuthoritiesByUsernameQuery("select username, authority from user_info where username = ?");
											   return theUserDetailsManager;
										   }
										   @Bean
										   public SecurityFilterChain filterConfig(HttpSecurity http) throws Exception {
											   http.authorizeHttpRequests(configurer ->
													   configurer
															   .requestMatchers("/").permitAll()
															   .requestMatchers("/css/**").permitAll()
															   .requestMatchers("/js/**").permitAll()
															   .requestMatchers("/img/**").permitAll()
															   .requestMatchers("/showSignUpPage").permitAll()
															   .requestMatchers("/subscribe").permitAll()
															   .requestMatchers("/user/signUpToken").permitAll()
															   .requestMatchers("/signUpTokenConfirm").permitAll()
															   .requestMatchers("/user/transferTokenCheck").permitAll()
															   .requestMatchers(HttpMethod.GET, "/showInfoPage").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/findByUserLoggedIn").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/showTransferPage").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.POST, "/user/transferMoney").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/showPaymentPage").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.POST, "/user/payTheBill").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/showChangingPassword").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.POST, "/user/changePassword").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/showTransactionHistory").hasAnyRole("USER", "EMPLOYEE", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/admin/listOfUsers").hasRole("ADMIN")
															   .requestMatchers(HttpMethod.GET, "/").hasAnyRole("USER", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/").hasAnyRole("USER", "MANAGER", "ADMIN")
															   .requestMatchers(HttpMethod.GET, "/user").hasRole("MANAGER")
															   .requestMatchers(HttpMethod.GET, "/user/**").hasRole("MANAGER")
															   .requestMatchers(HttpMethod.PUT, "/user").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/update").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/addTodo").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.DELETE, "/user/findById/**").hasRole("ADMIN")
															   .requestMatchers(HttpMethod.DELETE, "/user/findByUsername/**").hasRole("ADMIN")
															   .requestMatchers(HttpMethod.DELETE, "/user/delete/userId/**").hasRole("ADMIN")
															   .requestMatchers(HttpMethod.DELETE, "/user/delete/userName").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/transferMoney").hasRole("MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/delete/{username}").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.DELETE, "/user/delete/**").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.GET, "/user/delete/**").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.PUT, "/user/delete/**").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/delete/**").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/showUpdateUserForm").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/user/update").hasAnyRole("ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/transferMoney").hasAnyRole("USER", "EMPLOYEE" ,"ADMIN", "MANAGER")
															   .requestMatchers(HttpMethod.POST, "/checkReceiverAccountNumber").hasAnyRole("USER", "EMPLOYEE" ,"ADMIN", "MANAGER")
													   )
													   .formLogin(form -> form.loginPage("/showMyLoginPage")
																			  .loginProcessingUrl("/authenticateTheUser")
																			  .defaultSuccessUrl("/", true)
																			  .permitAll()
													   )
													   .logout(logout -> logout.logoutSuccessUrl("/")
																			   .permitAll());
										       //http.httpBasic(); // use HTTP Basic authentication
											   http.httpBasic(Customizer.withDefaults());       
											   http.csrf(csrf -> csrf.disable()); // disable Cross Site Request Forgery (CSRF)
																				  // in general, not required for stateless REST APIs that use POST, PUT, DELETE and/or PATCH
											   return http.build();
										   }
										      //@Bean
										      //public BCryptPasswordEncoder passwordEncoder() {
										          //return new BCryptPasswordEncoder();
										      //}
										}
			Handler:
										package com.example.springbackend.handler;
										import org.springframework.http.HttpStatus;
										import org.springframework.http.ResponseEntity;
										import org.springframework.web.ErrorResponse;
										import org.springframework.web.bind.annotation.ControllerAdvice;
										import org.springframework.web.bind.annotation.ExceptionHandler;
										import org.springframework.web.bind.annotation.RestControllerAdvice;
										import org.springframework.web.servlet.ModelAndView;
										@RestControllerAdvice
										public class GlobalAdvice {
											@ExceptionHandler({NotFoundException.class})
											public ResponseEntity<String> handleNotFoundException(NotFoundException ex) {
												return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
											}
										}
										
										package com.example.springbackend.handler;
										public class NotFoundException extends RuntimeException {
											public NotFoundException(String message) {
												super(message);
											}
										}			
	Chuyển đổi dữ liệu frontend thành đối tượng java--SPRING:
																	Với @RequestParam, dữ liệu thường được truyền dưới dạng chuỗi khi đến backend. Điều này đặc biệt đúng khi bạn truyền dữ liệu thông qua query string của URL
																	trong yêu cầu HTTP. Dữ liệu thường được truyền dưới dạng key=value, và trong trường hợp của chuỗi, giá trị sẽ được đưa vào trong dấu ngoặc kép. Spring sẽ tự
																	động chuyển đổi chuỗi này thành các kiểu dữ liệu Java phù hợp nếu cần thiết.
																	
																	Với @RequestBody, dữ liệu thường không được truyền dưới dạng chuỗi khi đến backend. Thay vào đó, dữ liệu thường được truyền dưới dạng một đối tượng JSON
																	(JavaScript Object Notation) từ phần thân của yêu cầu HTTP. Spring sẽ tự động chuyển đổi đối tượng JSON này thành một đối tượng Java tương ứng để bạn có thể
																	làm việc với nó trong mã backend của mình.
																	
																	@PathVariable: Dữ liệu khi mới đến backend từ @PathVariable thường là một phần của URL, được trích xuất từ mẫu đường dẫn (URL pattern). Dữ liệu này thường là
																	một giá trị cụ thể (ví dụ: số nguyên, chuỗi,..) và không phải là một chuỗi JSON hoặc bất kỳ dạng dữ liệu nào khác.
	
																	{
																	  "name": "John Doe",
																	  "age": 30,
																	  "isStudent": false, 
																	  "height": 175.5,
																	  "weight": 70.2,
																	  "address": {
																		"street": "123 Main St",
																		"city": "Springfield",
																		"zipCode": "12345"
																	  },
																	  "emails": [
																		"john@example.com",
																		"john.doe@example.com"
																	  ],
																	  "registrationDate": "2024-02-28",
																	  "lastLoginTime": "2024-02-28T09:30:00",
																	  "preferences": {
																		"theme": "dark",
																		"language": "en"
																	  }
																	}
																	import java.util.List;
																	import java.time.LocalDate;
																	import java.time.LocalDateTime;
																	public class User {
																		private String name;
																		private int age;
																		private boolean isStudent;
																		private double height;
																		private double weight;
																		private Address address;
																		private List<String> emails;
																		private LocalDate registrationDate;
																		private LocalDateTime lastLoginTime;
																		private Preferences preferences;

																		// Constructors, getters và setters
																	}
																	import org.springframework.web.bind.annotation.PostMapping;
																	import org.springframework.web.bind.annotation.RequestBody;
																	import org.springframework.web.bind.annotation.RestController;
																	@RestController
																	public class UserController {

																		@PostMapping("/users")
																		public String createUser(@RequestBody User user) {
																			...
																		}
																	}

																	@PostMapping("/search-include-task")
																	@PreAuthorize("hasAnyAuthority('GET_PROJECT,GET_PROJECT_OWNER')")
																	public Map<String, Object> findProjectListWithTask(@RequestBody ProjectManagementDto dto,
																													   @RequestParam(required = false, defaultValue = "0", name = "pageNo") int pageNo,
																													   @RequestParam(required = false, defaultValue = "20", name = "pageSize") int pageSize) {
																		PosLogger.developerLog(PosLogWriterIF.INFO, "Project -> " + dto, this);
																		if (Utils.checkPermission("GET_PROJECT_OWNER")) {
																			String id = Utils.getLoginUserDetail();
																			if (id != null) {
																				return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, id, pageNo, pageSize);
																			}
																		}
																		return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, null, pageNo, pageSize);
																	}
	
																	@GetMapping("/search/{contentId}/{type}")
																	@PreAuthorize("hasAnyAuthority('GET_TAG,GET_TAG_OWNER')")
																	public ResponseEntity<?> searchTags(@PathVariable("contentId") int contentId,
																										@PathVariable("type") int type) {
																		return this.serviceLifecycle.requestCms06TagsService().searchTags(contentId,type);
																	}
																	
																	@GetMapping("/api/foos")
																	@ResponseBody
																	public String getFoos(@RequestParam Optional<String> id){
																		return "ID: " + id.orElseGet(() -> "not provided");
																	}
																	http://localhost:8080/spring-mvc-basics/api/foos?id=abc
																	
																	@PostMapping("/api/foos")
																	@ResponseBody
																	public String updateFoos(@RequestParam Map<String,String> allParams) {
																		return "Parameters are " + allParams.entrySet();
																	}
																	curl -X POST -F 'name=abc' -F 'id=123' http://localhost:8080/spring-mvc-basics/api/foos
																	Parameters are {[name=abc], [id=123]}
																	
																	@GetMapping("/api/foos")
																	@ResponseBody
																	public String getFoos(@RequestParam List<String> id) {
																		return "IDs are " + id;
																	}
																	http://localhost:8080/spring-mvc-basics/api/foos?id=1,2,3
																	IDs are [1,2,3]
	Các Annatation tạo bean--SPRING:
		@Component: 											
													Đây là một annotation cơ bản được sử dụng để đánh dấu một class là một Spring component (bean). Nó có thể được sử dụng cho bất kỳ class nào trong ứng dụng của bạn.
		@Controller: 								
													Đây là một annotation được sử dụng để đánh dấu một class là một Spring MVC controller. Nó cho phép Spring hiểu rằng class này là một thành phần quản lý bởi Spring và có thể
													xử lý các yêu cầu HTTP.
		@Service: 									
													Đây là một annotation được sử dụng để đánh dấu một class là một Spring service. Nó thường được sử dụng để xử lý logic kinh doanh trong ứng dụng.
		@Repository: 								
													Đây là một annotation được sử dụng để đánh dấu một class là một Spring repository (hoặc DAO - Data Access Object). Nó làm nhiệm vụ tương tác với cơ sở dữ liệu và cung cấp các
													phương thức để truy vấn và thao tác dữ liệu.
		@Configuration: 							
													Đây là một annotation được sử dụng để đánh dấu một class là một Spring configuration. Nó cho phép bạn cấu hình các bean và các thành phần khác của ứng dụng thông qua các
													phương thức được đánh dấu bởi @Bean.
		@Bean: 										
													Đây là một annotation được sử dụng để đánh dấu một phương thức trong một class được đánh dấu bởi @Configuration. Phương thức được đánh dấu sẽ trả về một đối tượng, và đối
													tượng này sẽ được quản lý bởi Spring IoC container như một bean.
	Annotation--SPRING:
	
		lombok--Annotation:
									import lombok.*;
									@Data // Tạo getters, setters, toString(), equals(), hashCode() tự động cho tất cả các trường
									@NoArgsConstructor // Tạo constructor mặc định không tham số
									@AllArgsConstructor // Tạo constructor chứa tất cả các trường
									@Builder // Tạo builder pattern cho lớp
									@ToString // Tạo toString() tự động
									@EqualsAndHashCode // Tạo equals() và hashCode() tự động dựa trên tất cả các trường
									public class User {
										@NonNull // Tạo constructor với tham số bắt buộc và đảm bảo rằng trường không thể null
										private String username;
										@Setter(AccessLevel.PROTECTED) // Tạo setter protected cho trường này
										private String password;
										@Getter(AccessLevel.PACKAGE) // Tạo getter package-private cho trường này
										private int age;
										@ToString.Exclude // Không bao gồm trường này trong toString() tự động
										private String email;										
										@Builder.Default // Giá trị mặc định cho trường này khi sử dụng builder pattern
										private boolean active = true;
									}									
		@Data--Annotation:
									Annotation @Data sẽ tương đương với annotation @Getter + @Setter + @ToString + @NoArgsConstructor + @EqualsAndHashCode 
									
									import lombok.AllArgsConstructor;
									import lombok.Data;
									import lombok.ToString;
									@ToString(exclude = "address")
									@AllArgsConstructor
									@Data
									public class Person {
									  private String name;
									  private String address;
									  public static void main(String[] args) {
										Person person = new Person("kai", "Ha Noi - Viet Nam");
										System.out.println(person);
										System.out.println("Address: " + person.getAddress());
									 }

									}
		@Autowired--Annotation:
							
							- Sẽ không thể @Autowired một lớp nếu lớp đó không sử dụng @Component, @Controller, @Service hoặc @Repository
							- Cơ chế khi Spring bắt đầu chạy nó sẽ quét qua các lớp có sử dụng annotation để tạo Bean.
							- Đồng thời sẽ tìm kiếm xem trong các bean đó có khai báo @Autowire không, nó sẽ tìm kiếm các bean tương ứng để tiêm (Injection) vào bean đó.									
							- Quản lý phụ thuộc (Dependency Management): Sử dụng tiêm bean giúp quản lý phụ thuộc giữa các thành phần của ứng dụng. Thay vì tạo ra các đối tượng một cách cứng nhắc bằng cách sử dụng từ khóa
							new, bạn có thể chỉ định phụ thuộc của một đối tượng thông qua tiêm bean. Điều này giúp giảm sự ràng buộc giữa các lớp và làm cho mã trở nên linh hoạt hơn.
							- Tái sử dụng và linh hoạt: Tiêm bean cho phép bạn tái sử dụng các đối tượng trong ứng dụng của bạn. Thay vì tạo mới một đối tượng mỗi lần cần sử dụng, bạn có thể tiêm một đối tượng đã được
							khởi tạo trước đó vào trong các thành phần khác nhau của ứng dụng.
							- Kiểm soát vòng đời (Lifecycle Management): Spring Framework quản lý vòng đời của các bean, cho phép bạn cấu hình các hành vi khởi tạo, cách hủy và các quy trình khác liên quan đến vòng đời
							của các đối tượng trong ứng dụng.
																	   
							@Service
							public class BookServiceImpl implements BookService {
							  @Autowired
							  private BookDao bookDao;
							  @Autowired
							  private CustomerDao customerDao;
							  ...
							}
							
							@Component  
							public class Customer   {  
							  private Person person;  
							  @Autowired  
							  public Customer(Person person)   {   
								this.person=person;  
							  }  
							}	
							
		@Transactional--Annotation:
		
							- Được sử dụng để quản lý giao dịch trong ứng dụng Java. Khi bạn đánh dấu một phương thức hoặc một lớp với @Transactional, Spring sẽ tự động quản lý việc bắt đầu và
							kết thúc các giao dịch.
							- Transaction quản lý những thay đổi mà bạn thực hiện trong một hoặc nhiều hệ thống, nó có thể database, message brokers, hoặc bất kỳ loại hệ thống phần mềm nào khác. Mục tiêu chính của giao
							dịch là cung cấp các đặc điểm ACID để đảm bảo tính nhất quán và hợp lệ của dữ liệu của bạn.
									
			ACID transactions--@Transactional SPRING:
			
									Vốn dĩ một transaction được đặc trưng bởi 4 yếu tố (thường được gọi là ACID)
			
				Atomicity: 
										Quy định rằng tất cả các hoạt động của transaction hoặc là thực thi thành công hết hoặc là không có bất cứ hành động nào được thực thi khi có bất
										kỳ một hoạt động thực thi không thành công.
				
				Consistency: 
										Nghĩa là tất cả các ràng buộc toàn vẹn dữ liệu(constraints, key, data types, Trigger, Check) phải được thực thi thành công cho mọi transaction
										phát sinh xuống database, nhằm đảm bảo tính đúng đắn của dữ liệu.
				
				Isolation: 
				
										Đảm bảo các transaction xảy ra xen kẽ sẽ không làm ảnh hưởng đến tính nhất quán của dữ liệu. Các thay đổi dữ liệu bên trong mỗi transaction sẽ được cô
										lập, các transaction khác sẽ không thể nhìn thấy cho đến khi nó được đồng bộ xuống database.
				
				Durability: 
				
										Đảm bảo một transaction thực thi thành công thì tất cả những thay đổi trong transaction phải được đồng bộ xuống database kể cả khi hệ thống xảy ra
										lỗi hoặc bị mất điện.
													
										@Override
										@Transactional(rollbackFor = Exception.class, // rollback transaction cho tất cả các sub-class của Exception ngoại trừ EntityNotFoundException
														noRollbackFor = EntityNotFoundException.class)
										public void updateAuthorWithRollbackCustom(Long id, String name) {
											Author author = authorRepository.findById(id).orElse(null);
											author.setName(name);
										}
													
										@Transactional(isolation = Isolation.SERIALIZABLE) // Mức độ cô lập SERIALIZABLE là mức độ cô lập cao nhất trong các mức độ cô lập của giao dịch. Nó đảm bảo rằng
																						   // các giao dịch sẽ không gặp phải vấn đề về đọc/xuất cũng như mất dữ liệu, bằng cách chặn các giao dịch cùng truy
																						   // cập đến cùng một dữ liệu cùng một lúc. Điều này có nghĩa là chỉ có một giao dịch có thể thực hiện tác động đến
																						   // dữ liệu vào một thời điểm nhất định, và các giao dịch khác phải chờ đợi cho đến khi giao dịch đó hoàn thành
																						   // trước khi được phép thực hiện.
										
										@Transactional(propagation = Propagation.SUPPORTS, readOnly = true) // Thuộc tính readOnly xác định xem giao dịch có phải là chỉ đọc hay không. Trong trường hợp này,
																											// giá trị true được sử dụng, vì vậy giao dịch sẽ chỉ thực hiện các thao tác đọc trên cơ sở dữ
																											// liệu và không thực hiện bất kỳ thao tác ghi nào. Điều này có thể tối ưu hóa hiệu suất của các
																											// phương thức chỉ đọc, bởi vì nó không cần phải đảm bảo việc commit hoặc rollback các thay đổi.								
										
			Configure Transactions--@Transactional SPRING:
			
										Spring 3.1 introduces the @EnableTransactionManagement annotation that we can use in a @Configuration class to enable transactional support:
											
											@Configuration
											@EnableTransactionManagement
											public class PersistenceJPAConfig{

											   @Bean
											   public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
												   //...
											   }

											   @Bean
											   public PlatformTransactionManager transactionManager() {
												  JpaTransactionManager transactionManager = new JpaTransactionManager();
												  transactionManager.setEntityManagerFactory(entityManagerFactory().getObject());
												  return transactionManager;
											   }
											}
											
										However, if we’re using a Spring Boot project and have a spring-data-* or spring-tx dependencies on the classpath, then transaction management will be enabled by default.
						
			Configure Transactions With XML--@Transactional SPRING:
			
										For versions before 3.1, or if Java is not an option, here is the XML configuration using annotation-driven and namespace support:
											
											<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
											   <property name="entityManagerFactory" ref="myEmf" />
											</bean>
											<tx:annotation-driven transaction-manager="txManager" />
			
			The @Transactional Annotation--@Transactional SPRING:
			
										With transactions configured, we can now annotate a bean with @Transactional either at the class or method level:
											
											@Service
											@Transactional
											public class FooService {
												//...
											}
										
										The annotation supports further configuration as well:
										
											The Propagation Type of the transaction
											The Isolation Level of the transaction
											A Timeout for the operation wrapped by the transaction
											A readOnly flag – a hint for the persistence provider that the transaction should be read only
											The Rollback rules for the transaction
										
										Note that by default, rollback happens for runtime, unchecked exceptions only. The checked exception does not trigger a rollback of the transaction. We can, of course, configure
										this behavior with the rollbackFor and noRollbackFor annotation parameters.
			
			Potential Pitfalls--@Transactional SPRING:
			
				Transactions and Proxies
				
					- At a high level, Spring creates proxies for all the classes annotated with @Transactional, either on the class or on any of the methods. The proxy allows the framework to inject transactional logic
					before and after the running method, mainly for starting and committing the transaction.
					- What’s important to keep in mind is that, if the transactional bean is implementing an interface, by default the proxy will be a Java Dynamic Proxy. This means that only external method calls that come
					in through the proxy will be intercepted. Any self-invocation calls will not start any transaction, even if the method has the @Transactional annotation.
					- Another caveat of using proxies is that only public methods should be annotated with @Transactional. Methods of any other visibilities will simply ignore the annotation silently as these are not proxied.
				
				Changing the Isolation Level
				
					courseDao.createWithRuntimeException(course);
					
					We can also change the transaction isolation level:
						
						@Transactional(isolation = Isolation.SERIALIZABLE)
					
					Note that this has actually been introduced in Spring 4.1; if we run the above example before Spring 4.1, it will result in:
						
						org.springframework.transaction.InvalidIsolationLevelException: Standard JPA does not support custom isolation levels – use a special JpaDialect for your JPA implementation
				
				Read-Only Transactions
					
					The readOnly flag usually generates confusion, especially when working with JPA. From the Javadoc:
						
						This just serves as a hint for the actual transaction subsystem; it will not necessarily cause failure of write access attempts. A transaction manager which cannot interpret the read-only hint will
						not throw an exception when asked for a read-only transaction.
					
					The fact is that we can’t be sure that an insert or update won’t occur when the readOnly flag is set. This behavior is vendor-dependent, whereas JPA is vendor agnostic.
					
					It’s also important to understand that the readOnly flag is only relevant inside a transaction. If an operation occurs outside of a transactional context, the flag is simply ignored. A simple example of
					that would call a method annotated with:
						
						@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
					
					From a non-transactional context, a transaction will not be created and the readOnly flag will be ignored.
				
				Transaction Logging
					
					A helpful method to understand transactional-related issues is fine-tuning logging in the transactional packages. The relevant package in Spring is “org.springframework.transaction”, which should be
					configured with a logging level of TRACE.
				
				Transaction Rollback
					
					The @Transactional annotation is the metadata that specifies the semantics of the transactions on a method. We have two ways to rollback a transaction: declarative and programmatic.
					
					In the declarative approach, we annotate the methods with the @Transactional annotation. The @Transactional annotation makes use of the attributes rollbackFor or rollbackForClassName to rollback the
					transactions, and the attributes noRollbackFor or noRollbackForClassName to avoid rollback on listed exceptions.
					
					The default rollback behavior in the declarative approach will rollback on runtime exceptions.
					
					Let’s see a simple example using the declarative approach to rollback a transaction for runtime exceptions or errors:
						
						@Transactional
						public void createCourseDeclarativeWithRuntimeException(Course course) {
							courseDao.create(course);
							throw new DataIntegrityViolationException("Throwing exception for demoing Rollback!!!");
						}
					
					Next, we’ll use the declarative approach to rollback a transaction for the listed checked exceptions. The rollback in our example is on SQLException:
						
						@Transactional(rollbackFor = { SQLException.class })
						public void createCourseDeclarativeWithCheckedException(Course course) throws SQLException {
							courseDao.create(course);
							throw new SQLException("Throwing exception for demoing rollback");
						}
					
					Let’s see a simple use of attribute noRollbackFor in the declarative approach to prevent rollback of the transaction for the listed exception:
						
						@Transactional(noRollbackFor = { SQLException.class })
						public void createCourseDeclarativeWithNoRollBack(Course course) throws SQLException {
							courseDao.create(course);
							throw new SQLException("Throwing exception for demoing rollback");
						}
					
					In the programmatic approach, we rollback the transactions using TransactionAspectSupport:
						
						public void createCourseDefaultRatingProgramatic(Course course) {
							try {
							   courseDao.create(course);
							} catch (Exception e) {
							   TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
							}
						}
					
					Spring proxy sẽ tự động rollback transaction nếu có một RuntimeException xảy ra. Bạn có thể tùy biến bằng cách sử dụng thuộc tính rollbackFor và noRollbackFor của @Transactional annotation.
					
					Chúng ta có thể phỏng đoán ý nghĩa của chúng từ tên như thuộc tính rollbackFor cho phép bạn cung cấp một mảng các Exception class mà transaction sẽ bị rollback nếu chúng xảy ra. Và noRollbackFor được
					dùng để chỉ định một mảng các Exception class mà transaction sẽ không rollback khi chúng xảy ra.
					
					Trong ví dụ sau, mình muốn rollback transaction cho tất cả các sub-class của Exception ngoại trừ EntityNotFoundException
						
						@Override
						@Transactional
								(rollbackFor = Exception.class,
										noRollbackFor = EntityNotFoundException.class)
						public void updateAuthorWithRollbackCustom(Long id, String name) {
							Author author = authorRepository.findById(id).orElse(null);
							author.setName(name);
						}

		@Query--Annotation:
									Với cách sử dụng @Query, bạn sẽ có thể sử dụng câu truy vấn JPQL (Hibernate) hoặc raw SQL.
									
									public interface UserRepository extends JpaRepository<User, Long> {
										@Query("select u from User u where u.emailAddress = ?1") // Khi được gắn @Query, thì tên của method không còn tác dụng nữa. Đây là JPQL
										User myCustomQuery(String emailAddress);
										@Query(value = "select * from User u where u.email_address = ?1", nativeQuery = true) // Đây là Native SQL
										User myCustomQuery2(String emailAddress);
									}
									
									public interface UserRepository extends JpaRepository<User, Long> {					
										@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name") // JPQL
										User findUserByNamedParams(@Param("status") Integer status, @Param("name") String name);										
										@Query(value = "SELECT * FROM Users u WHERE u.status = :status and u.name = :name", nativeQuery = true) // Native SQL
										User findUserByNamedParamsNative(@Param("status") Integer status, @Param("name") String name);
									}
			search query:
									@Query(value =
											"SELECT DISTINCT INFO.*\n" +
												", EMP1.NAME AS KOREA_PM_NAME\n" +
												", EMP1.PHOTO AS KOREA_PM_PHOTO\n" +
												", EMP2.NAME AS VIETNAM_PL_NAME\n" +
												", EMP2.PHOTO AS VIETNAM_PL_PHOTO\n" +
											"FROM \n" +
												"TB_PME00_PROJECT_INFO INFO\n" +
												"JOIN TB_M00_EMPLOYEE EMP1\n" +
													"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
												"JOIN TB_M00_EMPLOYEE EMP2\n" +
													"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
												"JOIN TB_M00_CODES030 CODE030\n" +
													"ON CODE030.CD_V = INFO.CD_V \n" +
												"JOIN TB_PME00_MEMBER MEMBER\n" +
													"ON INFO.CD_V = MEMBER.CD_V_ID \n" +
											"WHERE  1 = 1 \n" +
												"AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
												"AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
												"AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
												"AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
												"AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
												"AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
												"AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
												"AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
												"AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))" +
												"AND (:empId IS NULL OR (INFO.KOREA_PM = :empId OR INFO.VIETNAM_PL = :empId OR :empId = MEMBER.EMP_ID OR :empId = CODE030.CREATED_PROGRAM_ID))\n"
											, nativeQuery = true)
									List<Object[]> findProjectInfoWithEmpId(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String> cdV, @Param("meaning") String meaning, @Param("period") int period,
																   @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
																   @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
																   @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
																   @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
																   @Param("toEndDate") Date toEndDate, @Param("empId") String empId, Pageable pageable);

									@Query(value = "SELECT t.PROJECT_NUMBER \n" +
											",t.TASK_NAME \n" +
											",t.CATEGORY \n" +
											",t.EMP_ID \n" +
											",t.LAST_UPDATE_ID \n" +
											",t.PASSWORD \n" +
											",t.REMARK \n" +
											",t.STATUS \n" +
											",t.TASK_EXPLAIN \n" +
											",t.WRITER \n" +
											",t.PLAN_DATE \n" +
											",t.ACTUAL_END_DATE \n" +
											",t.LAST_UPDATE_TIMESTAMP \n" +
											",t.CREATION_TIMESTAMP \n" +
											",t.START_DATE \n" +
											" FROM tb_m00_task AS t \n" +
											" WHERE 1=1 \n"+
											" AND (:projectNumber IS NULL OR t.PROJECT_NUMBER LIKE :projectNumber)\n" +
											" AND (:taskName IS NULL OR t.TASK_NAME LIKE CONCAT('%',:taskName, '%'))\n" +
											" AND (:planFrom IS NULL OR t.PLAN_DATE >= :planFrom)\n" +
											" AND (:planTo IS NULL OR t.PLAN_DATE <= :planTo)\n" +
											" AND (:actualFrom IS NULL OR t.ACTUAL_END_DATE >= :actualFrom)\n" +
											" AND (:actualTo IS NULL OR t.ACTUAL_END_DATE <= :actualTo)\n" +
											" AND (:startDateFrom IS NULL OR t.START_DATE >= :startDateFrom)\n" +
											" AND (:startDateTo IS NULL OR t.START_DATE <= :startDateTo)\n" +
											" AND (:category IS NULL OR t.CATEGORY = :category)\n" +
											" AND (:empId IS NULL OR t.EMP_ID = :empId)\n" +
											" AND (:status IS NULL OR t.STATUS = :status)\n", nativeQuery = true)
									List<M00TaskJpo> searchTask(@Param("projectNumber") String projectNumber,
																@Param("taskName") String taskName,
																@Param("planFrom") String planFrom,
																@Param("planTo") String planTo,
																@Param("actualFrom") String actualFrom,
																@Param("actualTo") String actualTo,
																@Param("startDateFrom") String startDateFrom,
																@Param("startDateTo") String startDateTo,
																@Param("status") String status,
																@Param("empId") String empId,
																@Param("category") String category);
																
			search task phân biệt giữa ON của JOIN và WHERE:	
			
										    @Query(value = "SELECT DISTINCT t.PROJECT_NUMBER \n" +
											",t.TASK_NAME \n" +
											",t.CATEGORY \n" +
											",t.EMP_ID \n" +
											",t.LAST_UPDATE_ID \n" +
											",t.PASSWORD \n" +
											",t.REMARK \n" +
											",t.STATUS \n" +
											",t.TASK_EXPLAIN \n" +
											",t.WRITER \n" +
											",t.PLAN_DATE \n" +
											",t.ACTUAL_END_DATE \n" +
											",t.LAST_UPDATE_TIMESTAMP \n" +
											",t.CREATION_TIMESTAMP \n" +
											",t.START_DATE \n" +
											",t.STATUS_APPROVE \n" +
											",t.ATTACH_FILE \n" +
											",t.ESTIMATE_DAY \n" +
											" FROM tb_m00_task AS t \n" +
											" LEFT JOIN tb_pme00_employee_task AS emp ON t.PROJECT_NUMBER = emp.PROJECT_NUMBER " + // lấy data tổng quát
											"                                        and t.TASK_NAME = emp.TASK_NAME \n"+
											" WHERE 1=1 \n"+
											" AND (COALESCE(:projectNumber) IS NULL OR t.PROJECT_NUMBER IN (:projectNumber)) \n" +
											" AND (:taskName IS NULL OR t.TASK_NAME LIKE CONCAT('%',:taskName, '%'))\n" +
											" AND (COALESCE(:category) IS NULL OR t.CATEGORY IN (:category)) \n" +
											" AND (:empId IS NULL OR emp.EMP_ID = :empId)\n" + // lấy data chi tiết

											" AND (:planFrom IS NULL OR t.PLAN_DATE >= :planFrom)\n" +
											" AND (:planTo IS NULL OR t.PLAN_DATE <= :planTo)\n" +
											" AND (:actualFrom IS NULL OR t.ACTUAL_END_DATE >= :actualFrom)\n" +
											" AND (:actualTo IS NULL OR t.ACTUAL_END_DATE <= :actualTo)\n" +
											" AND (:startDateFrom IS NULL OR t.START_DATE >= :startDateFrom)\n" +
											" AND (:startDateTo IS NULL OR t.START_DATE <= :startDateTo)\n" +

											" AND (COALESCE(:status) IS NULL OR t.STATUS IN (:status)) \n", nativeQuery = true)
									List<M00TaskJpo> findTaskByMultiConditions(@Param("projectNumber") List<String> projectNumber,
																			   @Param("taskName") String taskName,
																			   @Param("status") List<String> status,
																			   @Param("empId") String empId,
																			   @Param("category") List<String> category,
																			   @Param("planFrom") String planFrom,
																			   @Param("planTo") String planTo,
																			   @Param("actualFrom") String actualFrom,
																			   @Param("actualTo") String actualTo,
																			   @Param("startDateFrom") String startDateFrom,
																			   @Param("startDateTo") String startDateTo);

		@Id--Annotation:
									- @Id trong Spring (cụ thể là trong context của JPA - Java Persistence API) được sử dụng để đánh dấu một trường trong một lớp là khóa chính (primary key) của đối
									tượng khi được ánh xạ vào cơ sở dữ liệu.
									- Khi bạn đánh dấu một trường bằng @Id, bạn đang xác định rằng trường đó sẽ được sử dụng để định danh duy nhất cho mỗi bản ghi trong cơ sở dữ liệu.
									- Trường được đánh dấu bởi @Id là trường quan trọng để xác định mỗi bản ghi và cho phép bạn thực hiện các thao tác như tìm kiếm, cập nhật và xóa dữ liệu một cách
									chính xác.
									
									@Entity
									public class Product {
										@Id
										@GeneratedValue(strategy = GenerationType.IDENTITY)
										private Long id; // @Id được sử dụng để đánh dấu trường id trong lớp Product là khóa chính của đối tượng.
										private String name;
										private double price;
										// Constructors, getters, setters...
									}
		@IdClass--Annotation:
									- @IdClass là một annotation trong Spring được sử dụng để xác định một lớp ID tùy chỉnh cho một entity có khóa chính phức hợp (composite primary key).
									- Khi bạn có một entity với nhiều trường tạo thành khóa chính, bạn sẽ cần sử dụng @IdClass để định nghĩa một lớp ID tùy chỉnh và ánh xạ các trường của
									entity đó với các trường trong lớp ID.
									- Một số trường hợp khác khi sử dụng @IdClass:
										Quan hệ một-nhiều: Khi bạn có một entity cha chứa khóa chính phức hợp và liên kết với nhiều entity con.
										Chuyển đổi dữ liệu: Khi bạn cần chuyển đổi dữ liệu giữa các hệ thống có định nghĩa khóa chính khác nhau.
										Tích hợp dữ liệu: Khi bạn cần tích hợp dữ liệu từ nhiều nguồn có định nghĩa khóa chính khác nhau.
									- Tóm lại, @IdClass là một annotation hữu ích trong Spring khi bạn cần làm việc với các entity có khóa chính phức hợp. Nó giúp bạn định nghĩa và quản lý
									các khóa chính một cách hiệu quả.
									
									@Entity
									@Table(name = "orders")
									@IdClass(OrderId.class)
									public class Order {
										@Id
										private Long customerId;
										@Id
										private Long productId;
										private int quantity;
										// getters, setters, and other methods
									}
									public class OrderId implements Serializable {
										private Long customerId;
										private Long productId;

										// getters, setters, and hashCode/equals methods
									}
									Trong ví dụ này, customerId và productId tạo thành khóa chính phức hợp cho Order entity
									Lớp OrderId phải implement Serializable interface và cung cấp các phương thức getters, setters, hashCode() và equals() cho các trường của khóa chính.
									Sau đó, chúng ta sử dụng @IdClass(OrderId.class) để liên kết Order entity với lớp OrderId.
									Khi sử dụng @IdClass, Spring sẽ biết cách làm việc với khóa chính phức hợp của Order entity, bao gồm các hoạt động như lưu, tìm kiếm, cập nhật và xóa dữ liệu.
									
									public class AccountId implements Serializable {
										private String accountNumber;
										private String accountType;
										public AccountId(String accountNumber, String accountType) {
											this.accountNumber = accountNumber;
											this.accountType = accountType;
										}
									}									
									@Entity
									@IdClass(AccountId.class)
									public class Account {
										@Id
										private String accountNumber;
										@Id
										private String accountType;
										// other fields, getters and setters
									}
		@EmbeddedId--Annotation:
									
									- Trong JPA (Java Persistence API), @EmbeddedId là một annotation được sử dụng để chỉ định rằng một trường trong một entity class là một đối tượng nhúng
									(embedded object) đại diện cho khóa chính của entity.
									- Khi bạn có một entity class có một khóa chính được tạo ra từ một hoặc nhiều trường, và bạn muốn sử dụng một đối tượng đơn lẻ để đại diện cho các trường này,
									bạn có thể sử dụng @EmbeddedId.
									
									@Embeddable
									public class BookId implements Serializable {
										private String title;
										private String language;
										public BookId(String title, String language) {
											this.title = title;
											this.language = language;
										}
										// getters, equals() and hashCode() methods
									}								
									@Entity
									public class Book {
										@EmbeddedId
										private BookId bookId; // @EmbeddedId được sử dụng để chỉ định rằng trường bookId là một đối tượng nhúng đại diện cho khóa chính của entity Book.
										// constructors, other fields, getters and setters
									}
							
		@GeneratedValue--Annotation:
									
									- @GeneratedValue là một annotation trong JPA (Java Persistence API) được sử dụng để chỉ định cách sinh giá trị cho trường khóa chính (primary key)
									của một đối tượng khi nó được thêm vào cơ sở dữ liệu.
									
			GenerationType.IDENTITY
											- Đây là cách thông thường để sinh khóa chính cho các cơ sở dữ liệu hỗ trợ tự động tăng (auto-increment) như MySQL hoặc PostgreSQL.
											- Mỗi khi bạn thêm một bản ghi mới, giá trị của trường khóa chính sẽ tự động tăng.
											
											@Id
											@GeneratedValue(strategy = GenerationType.IDENTITY)
											private Long id;
			GenerationType.SEQUENCE
											- Sử dụng để sinh giá trị khóa chính từ một chuỗi (sequence) được quản lý bởi cơ sở dữ liệu. Một số cơ sở dữ liệu như Oracle hỗ trợ chuỗi.
											
											@Id
											@GeneratedValue(strategy = GenerationType.SEQUENCE)
											private Long id;
			GenerationType.TABLE
											- Sử dụng một bảng đặc biệt để lưu trữ các giá trị của khóa chính đã được sinh ra. Đây là cách chung chung và có thể sử dụng ở các cơ
											sở dữ liệu không hỗ trợ các loại trên.
											
											@Id
											@GeneratedValue(strategy = GenerationType.TABLE)
											private Long id;
			GenerationType.AUTO				
			
											- Cách này để cơ sở dữ liệu tự động chọn phương pháp sinh giá trị cho khóa chính dựa vào đặc điểm của cơ sở dữ liệu.
											- Nó có thể sử dụng IDENTITY, SEQUENCE hoặc bất kỳ cách nào khác được hỗ trợ.
											
											@Id
											@GeneratedValue(strategy = GenerationType.AUTO)
											private Long id;
			GenerationType.NONE				
											- Được sử dụng khi bạn muốn tạo giá trị khóa chính một cách thủ công mà không sử dụng tự động sinh giá trị.
											
											@Id
											@GeneratedValue(strategy = GenerationType.NONE)
											private Long id;
		@Column--Annotation:
									
									- @Column được sử dụng để chỉ định thông tin chi tiết của cột mà một field của entity sẽ được ánh xạ với một column trong database. Bắt buộc phải có trong sql mới có @Column, nếu không
									sẽ sinh ra lỗi.
									- Thuộc tính name được sử dụng để chỉ định tên cột nào trong database map với tên field được chú thích. Nếu không chỉ định, Hibernate sẽ lấy tên field map với
									tên cột trong database (trùng với tên trong file sql).
									- Thuộc tính length cho phép kích thước của cột. @Column không chỉ rõ phần tử length, mặc định nó là 255.
									- Thuộc tính nullable được sử dụng để chỉ định liệu cột có cho phép giá trị null hay không. Giá trị nullable mặc định là true.
									- precision và scale được sử dụng để chỉ định số chữ số toàn phần và số chữ số sau dấu thập phân của các số dấu phẩy động (floating-point).
									
									import javax.persistence.Column;
									import javax.persistence.Entity;
									import javax.persistence.Id;
									import javax.persistence.Table;
									@Entity
									@Table(name = "employees")
									public class Employee {
										@Id
										@Column(name = "employee_id", nullable = false, unique = true)
										private Long id;
										@Column(name = "full_name", length = 100, nullable = false)
										private String fullName;
										@Column(name = "email", length = 100, unique = true)
										private String email;
										@Column(name = "age", nullable = false)
										private int age;
										@Column(name = "salary", precision = 10, scale = 2)
										private double salary;
										// Getters and setters
									}
									
		@Table--Anotation:
		
									- schema trong @Table của JPA chính là tên scheme trong database
									- Trong database thì thứ tự từ lớn đến nhỏ sẽ là Database -> schema -> table -> column
									
									@Entity
									@Table(name = "users", schema = "my_database")
									public class User {
										// ...
									}
									
		@Getter và @Setter--Annotation:
									
									- @Getter và @Setter là các chú thích (annotations) của Project Lombok, một thư viện Java được sử dụng để giảm thiểu mã lặp lại và tự động sinh mã trong các lớp Java.
									- Chú thích này được sử dụng để tự động tạo các phương thức getter và setter cho các thuộc tính (fields) trong lớp, giúp bạn truy cập và thiết lập giá trị của
									thuộc tính một cách dễ dàng và an toàn mà không cần viết các phương thức getter và setter thủ công.
									
									import lombok.Getter;
									import lombok.Setter;
									@Getter
									@Setter
									public class User {
										private String username;
										private String email;
										private int age;
									}
									
									import lombok.Getter;
									import lombok.Setter;
									public class Person {
										@Getter @Setter // Tự động tạo getter và setter cho thuộc tính name
										private String name;
										@Getter @Setter // Tự động tạo getter và setter cho thuộc tính age
										private int age;
										public Person(String name, int age) {
											this.name = name;
											this.age = age;
										}
									}

		@RequestMapping--Annotation:
									
									- @RequestMapping là một annotation tổng quát được sử dụng để ánh xạ một hoặc nhiều loại request HTTP (GET, POST, PUT, DELETE, vv.) đến một phương thức xử lý trong controller.
									- Nó được sử dụng để map các request. Nó có nhiều phần tử tùy chọn như consumes, header, method, name, params, path, produces, và value.
									- Chúng tôi sử dụng nó với lớp cũng như phương thức.
									- Có nhiệm vụ ánh xạ các request (yêu cầu) người dùng vào method tương ứng trong controller.									
									
									@Controller
									public class MyController {										
										@RequestMapping(value = "/hello", method = RequestMethod.GET) // Ánh xạ các request GET đến đường dẫn "/hello"
										@ResponseBody
										public String hello() {
											return "Hello World!";
										}										
										@RequestMapping(value = "/hello", method = RequestMethod.POST) // Ánh xạ các request POST đến đường dẫn "/hello"
										@ResponseBody
										public String helloPost() {
											return "Hello World (POST)!";
										}										
										@RequestMapping(value = "/bye", method = RequestMethod.GET) // Ánh xạ các request GET đến đường dẫn "/bye"
										@ResponseBody
										public String bye() {
											return "Goodbye!";
										}
									}
									
									@RequestMapping(value = "/method2", method = RequestMethod.POST)
									public String method2() {
										return "method2";
									}
									@RequestMapping(value = "/method3", method = {RequestMethod.POST, RequestMethod.GET})
									public String method3() {
										return "method3";
									}
		@GetMapping--Annotation:
									
									- Nó là một biến thể của @RequestMapping với method được thiết lập là GET.
									- Nó dùng để tạo một điểm cuối trong web service, và nó được sử dụng thay cho @RequestMapping(method = RequestMethod.GET).

		
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {
										@GetMapping("/hello")
										public String hello() {
											return "Hello, world!";
										}
									}
		@PostMapping--Annotation:
									- Sử dụng khi gửi data tới server để tạo ra tài nguyên mới. Thay cho @RequestMapping(method = RequestMethod.POST).
									
									import org.springframework.web.bind.annotation.PostMapping;
									import org.springframework.web.bind.annotation.RequestBody;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {
										@PostMapping("/submit")
										public String submitForm(@RequestBody String formData) {
											// Xử lý dữ liệu được gửi từ form
											return "Form submitted: " + formData;
										}
									}
		@PutMapping--Annotation:
									
									- Sử dụng để thay đổi thông tin của một tài nguyên đã tồn tại trong hệ thống bằng cách sử dụng nội dung trong body của request.
									- Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.PUT).
									
									import org.springframework.web.bind.annotation.PutMapping;
									import org.springframework.web.bind.annotation.RequestBody;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {										
										@PutMapping("/update") // Sử dụng @PutMapping để xác định phương thức xử lý yêu cầu PUT đến "/update"
										public String updateData(@RequestBody String updatedData) {
											// Xử lý dữ liệu cập nhật được gửi từ yêu cầu PUT
											return "Data updated: " + updatedData;
										}
									}
									
		@DeleteMapping--Annotation:
									
									- Sử dụng để xóa một resource chỉ định. Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.DELETE).
									
									import org.springframework.web.bind.annotation.DeleteMapping;
									import org.springframework.web.bind.annotation.PathVariable;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {										
										@DeleteMapping("/delete/{id}") // Sử dụng @DeleteMapping để xác định phương thức xử lý yêu cầu DELETE đến "/delete/{id}"
										public String deleteItem(@PathVariable int id) {
											// Xử lý yêu cầu xóa với ID được cung cấp
											return "Item with ID " + id + " has been deleted.";
										}
									}
		@RequestParam--Annotation:
										
										- Chúng ta sử dụng @RequestParam để bắt các giá trị tham số mà người dùng truyền vào trên url theo định dạng key và value.
										- Mặc định, các tham số được bắt bởi @RequestParam không bắt buộc phải có giá trị, nếu không có giá trị nào được cung cấp, thì giá trị mặc định sẽ là null.
										- Thường được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP methods như GET và POST.
			
			- Gửi dữ liệu dưới dạng query parameters:	
			
															https://example.com/api/endpoint?param1=value1&param2=value2
			
			- Gửi dữ liệu dưới dạng form data:
			
															POST /api/endpoint HTTP/1.1
															Host: example.com
															Content-Type: application/x-www-form-urlencoded
															param1=value1&param2=value2
			
			Ví dụ:				
			
															const name = formData.get('name');
															const age = formData.get('age');
															axios.post('/api/example', {
																params: {
																	name: name,
																	age: age
																}
															})
															.then(function(response) {
																console.log(response.data);
															})
															.catch(function(error) {
																console.error(error);
															});
															
															@RestController
															@RequestMapping("/api")
															public class ExampleController {
																@GetMapping("/example")
																public String handleGetRequest(
																	@RequestParam String name,
																	@RequestParam int age
																) {
																	return "GET request: Name=" + name + ", Age=" + age;
																}
																@PostMapping("/example")
																public String handlePostRequest(
																	@RequestParam String name,
																	@RequestParam int age
																) {
																	return "POST request: Name=" + name + ", Age=" + age;
																}
															}
															
															@PostMapping("/search-include-task")
															@PreAuthorize("hasAnyAuthority('GET_PROJECT,GET_PROJECT_OWNER')")
															public Map<String, Object> findProjectListWithTask(@RequestBody ProjectManagementDto dto,
																											   @RequestParam(required = false, defaultValue = "0", name = "pageNo") int pageNo,
																											   @RequestParam(required = false, defaultValue = "20", name = "pageSize") int pageSize) {
																PosLogger.developerLog(PosLogWriterIF.INFO, "Project -> " + dto, this);
																if (Utils.checkPermission("GET_PROJECT_OWNER")) {
																	String id = Utils.getLoginUserDetail();
																	if (id != null) {
																		return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, id, pageNo, pageSize);
																	}
																}
																return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, null, pageNo, pageSize);
															}
															
															@PostMapping(path = "/upload/{service}")
															public String uploadFile(@PathVariable("service") String serviceName,
																					 @RequestParam ("file") MultipartFile image) {
																return this.serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, serviceName, image);
															}
																	
				- Gửi URL dưới dạng List<String>				
															
															http://localhost:9720/project/monitoring-view?projectName=ISP&projectName=TL
		
		@RequestBody--Annotation:
		
									- Có thể được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP methods như POST, PUT, PATCH và DELETE.
									- Nó được sử dụng để liên kết yêu cầu HTTP với một đối tượng trong một tham số phương thức. Bên trong nó sử dụng HTTP MessageConverters để chuyển đổi phần thân của
									yêu cầu. Khi chúng tôi chú thích một tham số phương thức với @RequestBody, Spring sẽ liên kết phần body yêu cầu HTTP đến với tham số đó.
									- Được sử dụng để lấy các giá trị mà người dùng gửi lên server mà các giá trị đó được chứa trong phần thân (body) của request.
									
									const user = {
									  name: 'John',
									  age: 30
									};
									axios.post('/example', user)
									  .then(response => {
										console.log(response.data);
									  })
									  .catch(error => {
										console.error(error);
									  });
									
									import org.springframework.web.bind.annotation.PostMapping;
									import org.springframework.web.bind.annotation.RequestBody;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {
										@PostMapping("/example")
										public String exampleEndpoint(@RequestBody User user) {
											return "Received user: " + user.getName();
										}
									}
		
		@PathVariable--Annotation:
		
									- @PathVariable được sử dụng để xử lý những URI động, có một hoặc nhiều parameter trên URI.
									- @PathVariable thường được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP GET, POST, PUT, DELETE và PATCH.
									
									@RequestMapping("/test2/{id}/{name}")
									public String test2(@PathVariable("id") int id, @PathVariable("name") String name, Model model) {
									  model.addAttribute("id", id);
									  model.addAttribute("name", name);
									  return "test2";
									}
									
		@RequestHeader--Annotation:
									
									- @RequestHeader được sử dụng khi ta muốn lấy dữ liệu được truyền bằng Header của một request (yêu cầu từ client)
									
									@GetMapping("/double")
									public ResponseEntity<String> doubleNumber(@RequestHeader("my-number") int myNumber) {
										return new ResponseEntity<String>(String.format("%d * 2 = %d", myNumber, (myNumber * 2)), HttpStatus.OK);
									}
									
		@ResponseHeader--Annotation:
		
									- Chúng ta sử dụng @ResponseHeader khi mình muốn trả về thêm dữ liệu cho client ở phần trên cùng của mỗi response
									
									public String addUser(@Valid User user, BindingResult bindingResult,HttpServletRequest request,HttpServletResponse response)
									{
									  if(bindingResult.hasErrors())
									  {
										bindingResult.getFieldError();
										return"edit";
									  }
									  response.setHeader("Cache-Control","no-cache,no-store,must-revalidate");
									  response.setHeader("Pragma","no-cache"); // ta trả thêm các giá trị ở trên phần header cho client thông qua phương thức response.setHeader
									  response.setDateHeader("Expires", 0);
									  return "redirect:/welcome/profile/"+user.getName();
									}
		@RestController--Annotation:
		
									- @RestController là một composed annotation được kết từ annotation @Controller và @ResponseBody, khi đặt một annotation @RestController trên một class controller
									thì mọi method controller trong class đó sẽ được thừa hưởng annotation @ResponseBody và response data trong controller này sẽ được trả về dưới dạng message.
									
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.RequestAttribute;
									import org.springframework.web.bind.annotation.RestController;
									import javax.servlet.http.HttpServletRequest;
									@RestController
									public class ExampleRestController {
										@GetMapping("/example")
										public String exampleHandler(HttpServletRequest request, @RequestAttribute("userId") Long userId) {											
											String attributeValue = (String) request.getAttribute("exampleAttribute"); // Truy cập thuộc tính của yêu cầu đã được đặt trong phạm vi Servlet											
											return "{\"userId\": " + userId + ", \"exampleAttribute\": \"" + attributeValue + "\"}"; // Trả về dữ liệu dưới dạng chuỗi JSON
										}
									}
		@PreDetroy và @PostConstruct--Annotation:
										
										- Đây là cách dùng khác để quản lý vòng đời của Bean. Ngoài cách sử dụng initMethod và destroyMethod.
										- Ta có thể sử dụng @PreDetroy và @PostConstruct với cùng một mục đích
										
										public class Computer {
											@PostConstruct
											public void turnOn(){
												System.out.println("Load operating system");
											}
											@PreDestroy
											public void turnOff(){
												System.out.println("Close all programs");
											}
										}
										
		@PropertySource và @Value--Annotation:
										
										- Trong Spring chúng ta sử dụng @PropertySource để cho Spring biết tìm các file properties cấu hình cho hệ thống ở đâu đồng thời sử dụng
										- @Value để lấy các giá trị trong file properties
										- @Value là một annotation trong Spring Framework, được sử dụng để tiêm các giá trị cấu hình vào các trường, phương thức hoặc tham số của một bean.
										- Ngoài việc sử dụng với các trường, @Value cũng có thể được sử dụng với các phương thức và tham số của constructor hoặc setter
			
			Ví dụ 1:
			
										import org.springframework.beans.factory.annotation.Value;
										import org.springframework.stereotype.Component;
										@Component
										public class MyService {
											@Value("${app.name}")
											private String appName;
											@Value("${app.version}")
											private String appVersion;

											publi void printAppInfo() {
												System.out.println("Application Name: " + appName);
												System.out.println("Application Version: " + appVersion);
											}
										}										
										@Value("${app.name}") sẽ lấy giá trị của app.name từ các tệp cấu hình (ví dụ: application.properties hoặc application.yml) và gán nó vào trường appName.
										@Value("${app.version}") sẽ lấy giá trị của app.version từ các tệp cấu hình và gán nó vào trường appVersion.
										
										# application.properties
										app.name=My Application
										app.version=1.0.0
										
										# application.yml
										app:
										  name: My Application
										  version: 1.0.0
			
			Ví dụ 2:
			
										import org.springframework.beans.factory.annotation.Value;
										import org.springframework.stereotype.Component;
										@Component
										public class MyService {
											private String appName;
											private String appVersion;
											public MyService(@Value("${app.name}") String appName, @Value("${app.version}") String appVersion) {
												this.appName = appName;
												this.appVersion = appVersion;
											}
											public void printAppInfo() {
												System.out.println("Application Name: " + appName);
												System.out.println("Application Version: " + appVersion);
											}
										}			
			
			Ví dụ 3:
			
										import org.springframework.beans.factory.annotation.Value;
										import org.springframework.stereotype.Component;										
										@Component
										public class AppConfig {
										    @Value("${app.name}")
										    private String appName;
										
										    @Value("${app.version}")
										    private String appVersion;
										
										    public void printAppInfo() {
										        System.out.println("Application Name: " + appName);
										        System.out.println("Application Version: " + appVersion);
										    }
										}
										app.name=MyApp
										app.version=1.0.0
										
										@Configuration
										@ComponentScan(basePackages = { "levunguyen.*" })
										@PropertySource("classpath:config.properties")
										public class AppConfigMongoDB {
											@Value("${mongodb.url}")
											private String mongodbUrl;
											@Value("${mongodb.db}")
											private String defaultDb;
										}
		@Scope--Annotation:
										- Khi bean được tạo ra thì nó có nhiều scope khác nhau. @Scope ở đây là phạm vi bean được sinh và bị phá huỷ dưới sự quản lý của Spring Container.
										- Khi bean được sinh ra nó có 5 scope (phạm vi được sử dụng):
											singleton: Đây là scope mặc định của 1 bean khi được sinh ra. Nếu ta không khai báo scope cụ thể thì bean sẽ lấy singleton scope. Singleton bean có nghĩa là bean
											chỉ tạo ra 1 lần và được sử dụng trong container. Chỉ duy nhất 1 bean tồn tại trong container.
											prototype: Ngược lại với singleton ta muốn có nhiều bean (đối tượng) thì ta sử dụng scope prototype.
											Request: Bean được sinh ra thông qua các request http (yêu cầu) từ người dùng. Chỉ được dùng trong các ứng dụng web.
											Session: Bean được sinh ra thông qua các http session.
											Global-session: Bean được sinh ra thông qua các request http (yêu cầu) từ người dùng. Chỉ được dùng trong các ứng dụng web.
										
										@Component
										@Scope("request")
										public class Contact {
											...
										}
		@Valid--Annotation:
										
										- Dùng để kiểm tra dữ liệu có đúng như mình mong muốn hay không. Ví dụ dưới đây mình mong muốn name là không được rỗng , author không được rỗng.
										- Nếu dữ liệu bị rỗng thì @Validated sẽ bắt lỗi.
										
										public class UserDTO {
											@NotBlank(message = "Username is required")
											private String username;
											@Email(message = "Invalid email")
											private String email;
											// Getters and setters
										}
										
										import org.springframework.validation.annotation.Validated;
										import org.springframework.web.bind.annotation.*;
										import javax.validation.Valid;

										@RestController
										@RequestMapping("/api/users")
										@Validated // @Validated được đặt trên class UserController để kích hoạt validation.
										public class UserController {
											@PostMapping("/register")
											public String registerUser(@Valid @RequestBody UserDTO userDTO) {
												// Xử lý đăng ký người dùng
												return "User registered successfully!";
											}
										}
		@ResponseBody--Annotation:
										
										- Chúng ta sử dụng @ResponseBody để nói cho controller biết rằng ta sẽ trả về một đối tượng Object kiểu Json cho client chứ mình không render ra một trang view.
										
										@RequestMapping(path = "/something", method = RequestMethod.PUT)
										public  @ResponseBody String helloWorld() {
											return "Hello World";
										}
										
		@Qualifier--Annotation:
										- Chú thích này được sử dụng cùng với chú thích @Autowired. Khi bạn cần kiểm soát nhiều hơn quá trình tiêm phụ thuộc, @Qualifier có thể được sử dụng.
										- @Qualifier có thể được chỉ định trên các tham số phương thức hoặc đối số phương thức khởi tạo riêng lẻ.
										- Chú thích này được sử dụng để tránh nhầm lẫn xảy ra khi bạn tạo nhiều bean cùng loại và chỉ muốn nối một trong số chúng với một thuộc tính.
										
										public interface Animal {
											void makeSound();
										}
										import org.springframework.stereotype.Component;
										@Component
										@Qualifier("dog")
										public class Dog implements Animal {
											@Override
											public void makeSound() {
												System.out.println("Woof");
											}
										}
										import org.springframework.stereotype.Component;
										@Component
										@Qualifier("cat")
										public class Cat implements Animal {
											@Override
											public void makeSound() {
												System.out.println("Meow");
											}
										}
										import org.springframework.beans.factory.annotation.Autowired;
										import org.springframework.beans.factory.annotation.Qualifier;
										import org.springframework.stereotype.Service;
										@Service
										public class AnimalService {
											private final Animal animal;
											@Autowired
											public AnimalService(@Qualifier("dog") Animal animal) {
												this.animal = animal;
											}
											public void makeAnimalSound() {
												animal.makeSound();
											}
										}
										import org.springframework.boot.CommandLineRunner;
										import org.springframework.boot.SpringApplication;
										import org.springframework.boot.autoconfigure.SpringBootApplication;
										import org.springframework.context.annotation.Bean;
										@SpringBootApplication
										public class Application {
											public static void main(String[] args) {
												SpringApplication.run(Application.class, args);
											}
											@Bean
											public CommandLineRunner commandLineRunner(AnimalService animalService) {
												return args -> {
													animalService.makeAnimalSound();
												};
											}
										}
										
										@Component
										public class AnimalService {
											private final Animal animal;
											@Autowired
											public AnimalService(@Qualifier("dog") Animal animal) {
												this.animal = animal;
											}
											public void makeSound() {
												animal.makeSound();
											}
										}
										
										@Component
										public class BeanA {
										  @Autowired
										  @Qualifier("BeanB2")
										  private BeanInterface dependency;
										  ...
										}
										
		@Lazy--Annotation:
										
										- Chú thích này được sử dụng trên các lớp thành phần. Theo mặc định, tất cả các phụ thuộc tự động mong muốn được tạo và định cấu hình khi khởi động.
										- Nhưng nếu bạn muốn khởi tạo bean một cách lười biếng, bạn có thể sử dụng chú thích @Lazy trên lớp. Điều này có nghĩa là bean sẽ chỉ được tạo và khởi tạo khi
										nó được yêu cầu lần đầu tiên. Bạn cũng có thể sử dụng chú thích này trên các lớp @Configuration. Điều này chỉ ra rằng tất cả các phương thức @Bean
										trong @Configuration đó phải được khởi tạo một cách lười biếng.
										
										@Component
										@Lazy
										public class HeavyResource {
											public HeavyResource() {
												// Thực hiện việc khởi tạo có thể tốn kém
												System.out.println("HeavyResource initialized.");
											}
											public void doSomething() {
												System.out.println("HeavyResource: Doing something.");
											}
										}
										
		@CookieValue--Annotation:
										
										- Chú thích này được sử dụng ở cấp tham số phương thức. @CookieValue được sử dụng làm đối số của phương thức ánh xạ yêu cầu.
										Cookie HTTP được liên kết với tham số @CookieValue cho một tên cookie nhất định. Chú thích này được sử dụng trong phương thức được chú thích bằng @RequestMapping.
										
										@RequestMapping("/cookieValue")
										public void getCookieValue(@CookieValue "JSESSIONID" String cookie){
											...
										}
		@ConfigurationProperties--Annotation:
		
												- Chỉ định lớp sẽ được map với các properties có prefix, ví dụ @ConfigurationProperties(prefix="app")
												
												app.name=MyApp
												app.description=This is my application
												app.version=1.0
												
												import org.springframework.boot.context.properties.ConfigurationProperties;
												import org.springframework.stereotype.Component;
												@Component
												@ConfigurationProperties("app")
												public class AppProperties {

													private String name;
													private String description;
													private String version;

													// Getters and Setters
												}
										
		@ModelAttribute--Annotation:
		
										- Chúng ta sử dụng ModelAttribute như một cầu nối giữa Controller và View. Từ Controller chúng ta truyền các dữ liệu qua cho View thông qua ModelAttribute.
										- Từ View chúng ta sẽ sử dụng Thymeleaf để đọc các dữ liệu từ model và hiển thị ra cho người dùng
										
										<form:form method="POST" action="/spring-mvc-basics/addEmployee" modelAttribute="employee">
											<form:label path="name">Name</form:label>
											<form:input path="name" />
											<form:label path="id">Id</form:label>
											<form:input path="id" />
											<input type="submit" value="Submit" />
										</form:form>
										
										@RequestMapping(value = "/addEmployee", method = RequestMethod.POST)
										public String submit( @ModelAttribute("employee") Employee employee) {
											model.addAttribute("name", employee.getName());
											model.addAttribute("id", employee.getId());
											employeeMap.put(employee.getId(), employee);
											return "employeeView";
										}
										
		@SessionAttribute--Annotation:
		
										- Chúng ta sử dụng @SessionAttribute để lưu trữ các giá trị trong một phiên làm việc.
										- Giống như mình làm một ứng dụng shopping cart . Khi người dùng chọn 1 sản phẩm thì mình dùng session mình lưu lại.
										- Khi khách hàng thanh toán giỏ hàng thì mình lấy hết tất cả các mặt hàng chứa trong session ra và tính toán
										
										@Controller
										@SessionAttributes("shoppingCart")
										public class AddToCartController {
											@PostMapping("/addToCart")
											public String addToCart(final Model model, @ModelAttribute ShoppingCart shoppingCart, final String productCode) {
												if (shoppingCart != null) {
												 //add product to the shopping cart list
												 shoppingCart.setProduct(productCode);
												 model.addAttribute("cart", shoppingCart);
												} else {
												 ShoppingCart cart = new ShoppingCart();
												 cart.setCustomerName("Super customer");
												 cart.setProduct(productCode);
												 model.addAttribute("cart", cart);
												}
												return "redirect:" + "product-detail-page";
											}
											@ModelAttribute("shoppingCart")
											public ShoppingCart shoppingCart() {
												return new ShoppingCart();
											}
										}									
								
		@Bean--Annotation:
									
									- Tạo bean một phần nữa là muốn tạo 1 đối tượng để sử dụng chung, tạo hay update 1 chỗ thì các chỗ khác cùng bị ảnh hưởng
									- @Bean dùng cho phương thức để hoàn lại đối tượng bean, phạm vi là phương thức
									- Khi bạn nói về "tiêm bean" trong Spring, bạn đang nói về việc cung cấp các đối tượng (beans) cho các thành phần khác của ứng dụng thông qua DI.
									- Nó là một annotation cho method. Nó là sự thay thế của thẻ XML <bean>. Nó cho biết method tạo ra một bean được Spring Container quản lý.
									- Chú thích @Bean hoạt động với @Configuration để tạo Spring bean, @Configuration sẽ có các phương thức để khởi tạo và cấu hình các phần phụ thuộc.
									- Các phương thức như vậy sẽ được chú thích bằng @Bean. Phương thức được chú thích với chú thích này hoạt động như là bean ID và nó tạo và trả về bean thực.
									- Tất cả các Method sử dụng annotation @Bean phải nằm trong class Configuration.
									
									@Configuration
									public class AppConfig{
									  @Bean
									  public Person person(){
										return new Person(address());
									  }
									  @Bean
									  public Address address(){
										return new Address();
									  }
									}
									
		@Configuration--Annotation:
		
									- Được sử dụng để chỉ ra rằng class khai báo sử dụng annotation @Configuration sẽ khai báo một hoặc nhiều @Bean method trong class đó.
									- Những class khai báo với @Configuration sẽ được Spring container quản lý và tạo bean trong lúc chương trình đang chạy.
									- Thông thường các bean cấu hình cho dự án ta để trong này.
									
									@Configuration  
									public class Vehicle   {  
									  @Bean Vehicle engine()  {  
										return new Vehicle();  
									  }  
									}
									
		@Component--Annotation:
		
									- Khi một class được đánh dấu là @Component thì sẽ được tạo thành 1 bean. Khi Spring start thì nó quét qua các annotation có đánh dấu là @Component thì nó sẽ tạo bean cho class đó.
									- Dùng để tạo đối tượng bean phạm vi class
									- Ví dụ ta có class Contact và ta đánh dấu nó là @Component thì Spring khi đọc qua class này nó sẽ tạo 1 bean có tên là contact trong container của nó.
									- Nếu có class nào dùng thì nó sẽ nhúng bean này vào. Dùng @component là để tạo ra một bean
									- Sẽ không thể @Autowired một lớp nếu lớp đó không sử dụng @Component, @Service, @Controller hoặc @Repository  
									
									import org.springframework.stereotype.Component;
									@Component
									public class HelloWorldService {
										public String getGreeting() {
											return "Hello, World!";
										}
									}
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.stereotype.Controller;
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.ResponseBody;
									@Controller
									public class GreetingController {
										private final HelloWorldService helloWorldService;
										@Autowired
										public GreetingController(HelloWorldService helloWorldService) {
											this.helloWorldService = helloWorldService;
										}
										@GetMapping("/greet")
										@ResponseBody
										public String greet() {
											return helloWorldService.getGreeting();
										}
									}

		@Controller--Annotation:
		
									- Là một chuyên môn hóa của @Component.
									- Là một annotation ở class. Nó đánh dấu class là một class để xử lý request web.
									- Nó thường được sử dụng để phục vụ các request từ UI. Mặc định thì nó trả về một chuỗi cho biết route nào cần redirect.
									- Nó chủ yếu được sử dụng với annotation @RequestMapping.
									
									@Controller  
									@RequestMapping("books")  
									public class BooksController   {  
									  @RequestMapping(value = "/{name}", method = RequestMethod.GET)  
									  public Employee getBooksByName()   {  
										return booksTemplate;  
									  }  
									}
									
									@Controller
									public class HomeController {
										@RequestMapping("/")
										public String homePage() {
											return "home";
										}
									}
									
		@Service--Annotation:
		
									- Nếu một class được đánh dấu là @Service thì nó là kiểu đặt biệt của @Component.
									- Nó được dùng để xử lý các nghiệp vụ của ứng dụng.									
									- Thường được sử dụng ở class. Nó cho Spring biết rằng class này chứa business logic.
									- Ví dụ như kế toán thì có nghiệp vụ là kiểm tra chi, quản lý thu.
									
									package com.hdd;  
									@Service  
									public class TestService  {  
									  public void service1()  {  
										  //business code  
									  }  
									}
									
		@Repository--Annotation:
									- Nếu một class được đánh dấu là @Repository thì nó là kiểu đặt biệt của @Component .
									- Nó được sử dụng để nói bean này dùng để truy cập và thao tác xuống cơ sở dữ liệu.
									- Chú thích này có tính năng dịch tự động. Ví dụ: khi một ngoại lệ xảy ra trong @Repository, có một trình xử lý cho ngoại lệ đó và không cần thêm khối try catch.
									
									package com.hdd;  
									@Repository   
									public class TestRepository  {  
									  public void delete()  {     
										//persistence code  
									  }  
									}
		@ComponentScan--Annotation:
		
									- Là annotation khai báo ở cấp độ class, giống như cái tên của nó, annotation @ComponentScan dùng để scan toàn bộ bean trong ứng dụng, mặc định nó sẽ scan tất cả
									bean trong package ở vị trí đặt class chứa hàm main, ngoài ra chúng ta cũng có thể tùy chỉnh package cần scan
									- Chúng ta sử dụng @ComponentScan để thông báo Spring Container biết phải vào package nào trong dự án để quét các Annotation và tạo Bean
									- Khi bạn sử dụng @ComponentScan trong một class, Spring sẽ tự động phát hiện và đăng ký các bean (component) được đánh dấu bằng các annotation như @Component, @Service,
									@Repository, @Controller, và @Configuration.
									- Một số lưu ý về @ComponentScan:
										Phạm vi quét: Bạn có thể chỉ định các package cụ thể cần được quét bằng cách sử dụng basePackages hoặc basePackageClasses.
										Loại trừ một số package: Bạn cũng có thể loại trừ một số package khỏi quá trình quét bằng cách sử dụng excludeFilters.
										Sử dụng với @SpringBootApplication: Trong Spring Boot, @SpringBootApplication đã bao gồm @ComponentScan, vì vậy bạn thường không cần
										phải sử dụng @ComponentScan một cách riêng biệt.
									
									import org.springframework.boot.SpringApplication;
									import org.springframework.boot.autoconfigure.SpringBootApplication;
									import org.springframework.context.annotation.ComponentScan;
									@SpringBootApplication
									@ComponentScan(basePackages = {"com.example.myapp"})
									public class MyAppApplication {
										public static void main(String[] args) {
											SpringApplication.run(MyAppApplication.class, args);
										}
									}
									@SpringBootApplication là một annotation phổ biến trong Spring Boot, được sử dụng để kích hoạt tất cả các tính năng cấu hình và tự động cấu hình.
									@ComponentScan(basePackages = {"com.example.myapp"}) chỉ định rằng Spring nên quét và tìm kiếm các component, service, repository,
									controller, v.v... trong package com.example.myapp và các package con của nó.
									
									@ComponentScan(basePackages = "com.javatpoint")  
									@Configuration
									public class ScanComponent  {  
									  // ...  
									}
									
			Các param trong @ComponentScan:
			
												basePackages:		dùng để chỉ ra những package cần scan, bạn có thể truyền vào một hoặc nhiều package name
												basePackageClasses:	chỉ ra những class cần scan
												excludeFilters:		dùng để filter loại trừ những bean or package không cần scan
												includeFilters: 	dùng dể filter những bean or package cần scan.
												lazyInit: 			dùng để lazy load bean, default = false
												resourcePattern: 	chỉ ra các pattern file để Spring có thể scan, default pattern "**/*.class"
												
		@EnableAutoConfiguration--Annotation:
		
												- Annotation @EnableAutoConfiguration trong Spring Boot là một trong những annotation quan trọng nhất, được sử dụng để kích hoạt tính
												năng auto-configuration của Spring Boot.
												- Khi sử dụng @EnableAutoConfiguration trong một ứng dụng Spring Boot, Spring Boot sẽ tự động cấu hình các bean cần thiết dựa trên các
												dependencies có sẵn trong classpath của ứng dụng. Điều này giúp giảm đáng kể lượng cấu hình mà nhà phát triển phải viết.
												- Ví dụ, nếu trong classpath của ứng dụng có thư viện spring-boot-starter-web, Spring Boot sẽ tự động cấu hình các bean cần thiết như DispatcherServlet,
												HandlerMapping, ViewResolver, v.v. để tạo ra một ứng dụng web hoàn chỉnh.
												- Nó tự động cấu hình bean có trong classpath và cấu hình nó để chạy các phương thức.
												- Việc sử dụng chú thích này bị giảm trong bản phát hành Spring Boot 1.2.0 vì các nhà phát triển đã cung cấp một giải pháp thay thế cho chú thích,
												tức là @SpringBootApplication.
												- Ngoài ra, @EnableAutoConfiguration còn có một số tùy chọn như:
													exclude = {...}: Loại trừ một hoặc nhiều auto-configuration classes.
													excludeName = {...}: Loại trừ các auto-configuration classes dựa trên tên.
												- Annotation @EnableAutoConfiguration là một phần quan trọng của Spring Boot, giúp đơn giản hóa quá trình cấu hình ứng dụng và tập trung vào việc phát triển các
												tính năng chính thay vì việc cài đặt các cấu hình hệ thống.
												
												@SpringBootApplication
												@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
												public class MyApplication {
													// ...
												}
												Trong ví dụ trên, auto-configuration cho DataSource sẽ bị loại trừ, giúp ngăn chặn Spring Boot tự động cấu hình DataSource nếu không mong muốn.
												
												@RestController
												@EnableAutoConfiguration
												public class ExampleController {
													@GetMapping("/")
													String home() {
														return "Hello World!";
													}
													public static void main(String[] args) {
														SpringApplication.run(ExampleController.class, args);
													}
												}
												
		@SpringBootApplication--Annotation:
		
												- Nó là sự kết hợp của ba chú thích @EnableAutoConfiguration, @ComponentScan và @Configuration.
												- Chú thích này được sử dụng trên lớp ứng dụng trong khi thiết lập một dự án Spring Boot. Lớp được chú thích bằng @SpringBootApplication phải được
												giữ trong gói cơ sở.
												- Một thứ mà @SpringBootApplication thực hiện là quét thành phần. Nhưng nó sẽ chỉ quét các gói con của nó. Ví dụ: nếu bạn đặt lớp được chú thích bằng
												@SpringBootApplication trong com.example thì @SpringBootApplication sẽ quét tất cả các gói con của nó, chẳng hạn như com.example.a, com.example.b và
												com.example.a.x.
												
												import org.springframework.boot.SpringApplication;
												import org.springframework.boot.autoconfigure.SpringBootApplication;
												import org.springframework.web.bind.annotation.GetMapping;
												import org.springframework.web.bind.annotation.RestController;
												@SpringBootApplication
												public class ExampleApplication {
													public static void main(String[] args) {
														SpringApplication.run(ExampleApplication.class, args);
													}
												}
												@RestController
												class ExampleController {
													@GetMapping("/")
													String home() {
														return "Hello World!";
													}
												}
												
		@Required--Annotation:  
									
									- Nó áp dụng cho method bean setter. Nó chỉ ra rằng bean được chú thích phải được điền vào thời điểm cấu hình với thuộc tính bắt buộc,
									nếu không nó sẽ ném một ngoại lệ BeanInitizationException.
									- Trong Spring Framework, annotation @Required được sử dụng để đánh dấu một thuộc tính của bean là bắt buộc phải được cấu hình trong tệp cấu hình (configuration file). Khi một bean được
									khởi tạo và nếu một thuộc tính được đánh dấu bằng @Required mà không có giá trị nào được cung cấp cho nó, Spring Container sẽ ném ra một ngoại lệ BeanInitializationException, báo cho
									bạn biết rằng thuộc tính đó là bắt buộc và cần phải được cung cấp.
									- Điều này hữu ích khi bạn muốn đảm bảo rằng một số thuộc tính quan trọng của bean đã được thiết lập trước khi sử dụng nó. Bằng cách này, nó giúp tránh được những lỗi logic hoặc giúp
									phát hiện sớm những thiếu sót trong cấu hình của ứng dụng Spring của bạn.
								
									import org.springframework.beans.factory.annotation.Required;
									public class Person {
										private String name;
										@Required
										public void setName(String name) {
											this.name = name;
										}
										public String getName() {
											return name;
										}
									}
									import org.springframework.context.ApplicationContext;
									import org.springframework.context.support.ClassPathXmlApplicationContext;
									public class Main {
										public static void main(String[] args) {
											ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
											Person person = (Person) context.getBean("person");
											System.out.println("Name: " + person.getName());
										}
									}
									Kết quả là: Name: John Doe		
									
									import org.springframework.beans.factory.annotation.Required;
									public class Employee {
										private String empName;
										@Required
										public void setEmpName(String empName) {
											this.empName = empName;
										}
										public String getEmpName() {
											return empName;
										}
									}
									Trong ví dụ này, thuộc tính empName được đánh dấu bằng @Required, điều này đảm bảo rằng mỗi khi một bean Employee được khởi tạo, phải cung cấp giá trị cho empName. Nếu không, Spring sẽ
									ném ra một ngoại lệ khi khởi tạo bean.
									
									public class Machine   {  
									  private Integer cost;  
									  @Required  
									  public void setCost(Integer cost)   {  
										this.cost = cost;  
									  }  
									  public Integer getCost()   {  
										return cost;  
									  }     
									}
									
		@PatchMapping--Annotation:
									
									Sử dụng để áp dụng sửa đổi 1 phần cho resource. Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.PATCH)
									
									import org.springframework.web.bind.annotation.PatchMapping;
									import org.springframework.web.bind.annotation.RequestBody;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class ExampleController {										
										@PatchMapping("/update") // Sử dụng @PatchMapping để xác định phương thức xử lý yêu cầu PATCH đến "/update"
										public String updateData(@RequestBody String updatedData) {
											// Xử lý dữ liệu cập nhật được gửi từ yêu cầu PATCH
											return "Data updated: " + updatedData;
										}
									}
									
		@RequestAttribute--Annotation:
										
										- Nó liên kết một tham số phương thức với thuộc tính yêu cầu. Nó cung cấp quyền truy cập thuận tiện vào các thuộc tính yêu cầu từ một phương thức bộ điều khiển.
										- Với sự trợ giúp của chú thích @RequestAttribute, chúng tôi có thể truy cập các đối tượng được điền ở phía máy chủ.
									
										import javax.servlet.*;
										import javax.servlet.http.HttpServletRequest;
										import java.io.IOException;
										public class MyFilter implements Filter {
											@Override
											public void init(FilterConfig filterConfig) throws ServletException {
												// initialization code
											}
											@Override
											public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
													throws IOException, ServletException {
												HttpServletRequest httpRequest = (HttpServletRequest) request;
												httpRequest.setAttribute("myAttribute", "Hello from Filter");
												chain.doFilter(request, response);
											}
											@Override
											public void destroy() {
												// cleanup code
											}
										}
										import org.springframework.boot.web.servlet.FilterRegistrationBean;
										import org.springframework.context.annotation.Bean;
										import org.springframework.context.annotation.Configuration;
										@Configuration
										public class WebConfig {
											@Bean
											public FilterRegistrationBean<MyFilter> loggingFilter() {
												FilterRegistrationBean<MyFilter> registrationBean = new FilterRegistrationBean<>();
												registrationBean.setFilter(new MyFilter());
												registrationBean.addUrlPatterns("/greet/*");

												return registrationBean;
											}
										}
										import org.springframework.web.bind.annotation.GetMapping;
										import org.springframework.web.bind.annotation.RequestAttribute;
										import org.springframework.web.bind.annotation.RequestMapping;
										import org.springframework.web.bind.annotation.RestController;
										@RestController
										@RequestMapping("/greet")
										public class GreetingController {
											@GetMapping
											public String greet(@RequestAttribute("myAttribute") String myAttribute) {
												return myAttribute;
											}
										}

										import org.springframework.stereotype.Controller;
										import org.springframework.ui.Model;
										import org.springframework.web.bind.annotation.GetMapping;
										import org.springframework.web.bind.annotation.RequestAttribute;
										import javax.servlet.http.HttpServletRequest;
										@Controller
										public class ExampleController {
											@GetMapping("/example")
											public String exampleHandler(HttpServletRequest request, @RequestAttribute("userId") Long userId, Model model) {											
												String attributeValue = (String) request.getAttribute("exampleAttribute"); // Truy cập thuộc tính của yêu cầu đã được đặt trong phạm vi Servlet																				
												model.addAttribute("userId", userId); // Thêm dữ liệu vào model để truyền đến view
												model.addAttribute("exampleAttribute", attributeValue);
												return "exampleView";
											}
										}
										
		@SneakyThrows--Annotation:
		
									- @SneakyThrows là một chú thích (annotation) của Project Lombok, một thư viện Java được sử dụng để giảm thiểu mã lặp lại và tự động sinh mã trong các lớp Java.
									- Chú thích này được sử dụng để giảm thiểu việc phải bắt và xử lý các ngoại lệ (exceptions) kiểu đã khai báo trong phạm vi của phương thức hoặc khối mã.
									- Lưu ý rằng, việc sử dụng @SneakyThrows cần được cân nhắc cẩn thận. Nó thường được sử dụng trong các tình huống đơn giản và không thể tránh được việc ném ra ngoại
									lệ checked. Tuy nhiên, nếu việc xử lý ngoại lệ phức tạp hơn, thì nên xem xét việc sử dụng mã try-catch hoặc khai báo throws rõ ràng hơn để làm mã dễ đọc và hiểu hơn.
									- @SneakyThrows là một annotation Lombok, được sử dụng để tự động thêm throws clause cho các method. Nó sẽ tự động bắt và ném các exception ở bên trong method mà không
									cần bạn phải khai báo throws clause.
									- Sử dụng @SneakyThrows có các lợi ích sau:
										Giảm code boilerplate: Bạn không cần phải khai báo throws clause cho các exception có thể xảy ra trong method.
										Tăng tính linh hoạt: Nếu method cần ném một exception mới, bạn không cần phải sửa lại method signature.
										Đơn giản hóa code: Việc không khai báo throws clause giúp code trông gọn gàng và dễ đọc hơn.
									- Tuy nhiên, việc sử dụng @SneakyThrows cũng có một số rủi ro:
										Nó làm cho code khó debug hơn vì các exception được ném mà không được khai báo.
										Nó vi phạm nguyên tắc "Fail Fast" vì các exception có thể được ném ở bất kỳ đâu trong code.
									- Vì vậy, việc sử dụng @SneakyThrows cần được cân nhắc kỹ lưỡng và chỉ áp dụng khi thực sự cần thiết. Thông thường, việc khai báo throws clause một cách rõ ràng sẽ giúp
									code dễ hiểu và bảo trì hơn.
									
									import lombok.SneakyThrows;
									public class MyClass {
										@SneakyThrows
										public void myMethod() {
											// code that may throw an exception
											throw new Exception("Something went wrong");
										}
									}
									Trong ví dụ trên, myMethod() sẽ tự động ném Exception mà không cần khai báo throws Exception trong method signature.
									
									import lombok.SneakyThrows;
									public class Example {
										@SneakyThrows
										public void doSomething() {										
											throw new Exception("Something went wrong!"); // Throwing a checked exception without a try-catch block or throws declaration
										}
									}
									
		@EnableAsync--Annotation:
									
									- Chúng ta muốn sự kiện được xử lý ở một Thread khác, đây gọi là bất đồng bộ (Asynchronous)
									- Để làm được điều này, chúng ta cần kích hoạt chức năng xử lý bất đồng bộ của Spring Boot, bằng cách bổ sung annotation @EnableAsync.
									- Spring Boot khi thấy Annotation này, sẽ kích hoạt cho phép xử lý sự kiện dưới dạng Async
									- Các Event sẽ được gửi vào một Executor (đơn giản nhất là SimpleAsyncTaskExecutor) và chờ được xử lý.
									
									@Configuration
									@EnableAsync
									public class ListenerConfiguration {
										/**
										 * Tạo ra Executor cho Async
										 * @return
										 */
										@Bean
										TaskExecutor taskExecutor() {
											return new SimpleAsyncTaskExecutor();
										}
									}

		@Async--Annotation:
									
									- Sau khi kích hoạt tính năng Async bằng @EnabelAsync, bất kỳ sự kiện nào bạn muốn nó xử lý Async thì hãy đánh dấu nó bởi @Async.
									- Là một annotation được sử dụng để xác định một phương thức là một phương thức bất đồng bộ (asynchronous). Khi bạn đánh dấu một phương thức với @Async, nó sẽ chạy
									trong một thread riêng biệt và không chặn luồng chính (main thread). Điều này cho phép phương thức thực thi mà không cần đợi cho kết quả và giúp cải thiện hiệu năng
									và thời gian phản hồi của ứng dụng.
									
									@Configuration
									@EnableAsync // Bật tính năng bất đồng bộ cho ứng dụng Spring bằng cách thêm @EnableAsync vào một configuration class hoặc class chứa các cấu hình của ứng dụng.
									public class AppConfig {
										// Các cấu hình khác...
									}
									
									@Service
									public class MyService {									
										@Async // Đánh dấu phương thức bạn muốn thực thi bất đồng bộ với @Async.
										public void asyncMethod() {
											// Các tác vụ bất đồng bộ sẽ được thực hiện ở đây
										}
									}
									
									@Component
									public class MyDog {
										@Async // @Async là cách lắng nghe sự kiện ở một Thread khác, không ảnh hưởng tới luồng chính
										@EventListener // @EventListener sẽ lắng nghe mọi sự kiện xảy ra
													   // Nếu có một sự kiện DoorBellEvent được bắn ra, nó sẽ đón lấy và đưa vào hàm để xử lý
										public void doorBellEventListener(DoorBellEvent doorBellEvent) throws InterruptedException {
											// Giả sử con chó đang ngủ, 1 giây sau mới dậy
											Thread.sleep(1000);
											// Sự kiện DoorBellEvent được lắng nghe và xử lý tại đây
											System.out.println("Chó ngủ dậy!!!");
											System.out.println(String.format("Go go!! Có người tên là %s gõ cửa!!!", doorBellEvent.getGuestName()));
										}
									}


		@PreAuthorize--Annotation:
										
										- @PreAuthorize là một annotation từ Spring Security được sử dụng để thiết lập điều kiện trước khi phương thức được thực thi									
										
										@GetMapping("/admin")
										@PreAuthorize("hasAuthority('ADMIN')") // hasAuthority() kiểm tra xem người dùng hiện tại có quyền (authority) cụ thể hay không. Quyền là một khái niệm tổng quát hơn so với vai trò (role).
										public String showAdmin() {
											return "admin";
										}
										
										import org.springframework.security.access.prepost.PreAuthorize;
										@PreAuthorize("hasAnyAuthority('CREATE_POST', 'EDIT_POST', 'DELETE_POST')") // hasAnyAuthority() kiểm tra xem người dùng hiện tại có ít nhất một trong các quyền được chỉ định hay không.
																													// Nếu người dùng có ít nhất một quyền, biểu thức sẽ trả về true.
										public void createPost(Post post) {
											// Tạo bài viết mới
										}
										
										@PreAuthorize("hasRole('ROLE_VIEWER')") // @PreAuthorize(“hasRole(‘ROLE_VIEWER’)”) has the same meaning as @Secured(“ROLE_VIEWER”)																		
										public String getUsernameInUpperCase() {
											return getUsername().toUpperCase();
										}
										
										@PreAuthorize("hasAnyRole('ROLE_ADMIN', 'ROLE_USER')") // hasAnyRole() kiểm tra xem người dùng hiện tại có ít nhất một trong các vai trò được chỉ định hay không. Nếu người dùng có ít
																							   // nhất một vai trò, biểu thức sẽ trả về true.
										public void deleteProduct(Long productId) {
											// Xóa sản phẩm
										}
										
										@PreAuthorize("hasRole('ROLE_VIEWER') or hasRole('ROLE_EDITOR')") // @Secured({“ROLE_VIEWER”,”ROLE_EDITOR”}) can be replaced with 
																										  // @PreAuthorize(“hasRole(‘ROLE_VIEWER’) or hasRole(‘ROLE_EDITOR’)”):
										public boolean isValidUsername3(String username) {
											//...
										}
										
										@PreAuthorize("#username == authentication.principal.username")
										@PostAuthorize("returnObject.username == authentication.principal.nickName")
										public CustomUser securedLoadUserDetail(String username) {
											return userRoleRepository.loadUserByUserName(username);
										}
										
										@GetMapping("/user/{username}")
										@PreAuthorize("isAuthenticated() and #username == authentication.principal.username") // Yêu cầu đăng nhập isAuthenticated()
																															  // Giá trị biến đường dẫn {username} bằng với tên đăng nhập hiện thời
																															  // #username == authentication.principal.username. Chú ý authentication.principal
																															  // là một biến mặc định mà Spring Security cung cấp để lấy thông tin về người
																															  // dùng đang đăng nhập
										public String getMyRoles(@PathVariable("username") String username) {
												SecurityContext securityContext = SecurityContextHolder.getContext();
												return securityContext.getAuthentication().getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));
										}
										
			Các phương thức chính của @PreAuthorize bao gồm:
			
				hasRole(String role):
				
										Kiểm tra xem người dùng hiện tại có vai trò cụ thể hay không.
										
										@PreAuthorize("hasRole('ROLE_ADMIN')")
										public void deleteProduct(int productId) {
											// Xóa sản phẩm
										}
			
				hasAnyRole(String... roles):
				
										Kiểm tra xem người dùng hiện tại có ít nhất một trong các vai trò được chỉ định hay không.
										
										@PreAuthorize("hasAnyRole('ROLE_USER', 'ROLE_ADMIN')")
										public void getProduct(int productId) {
											// Lấy thông tin sản phẩm
										}
			
				hasAuthority(String authority):
				
										Kiểm tra xem người dùng hiện tại có quyền cụ thể hay không.
										
										@PreAuthorize("hasAuthority('DELETE_PRODUCT')")
										public void deleteProduct(int productId) {
											// Xóa sản phẩm
										}

				hasAnyAuthority(String... authorities):
				
										@PreAuthorize("hasAnyAuthority('READ_PRODUCT', 'WRITE_PRODUCT')")
										public void getProduct(int productId) {
											// Lấy thông tin sản phẩm
										}
										
				hasPermission(Object target, String permission):
				
										Kiểm tra xem người dùng hiện tại có quyền cụ thể trên một đối tượng cụ thể hay không.
										
										@PreAuthorize("hasPermission(#product, 'write')")
										public void updateProduct(Product product) {
											// Cập nhật thông tin sản phẩm
										}
			
			Các thuộc tính chính của @PreAuthorize bao gồm:
			
				value (hoặc expression):
				
										Đây là điều kiện được xác định bằng cách sử dụng một biểu thức Spring Expression Language (SpEL). Biểu thức này quyết định xem người dùng có quyền truy cập vào phương thức hay không.
										
										@PreAuthorize("hasRole('ROLE_ADMIN')")
										public void deleteProduct(int productId) {
											// Xóa sản phẩm
										}
										
				filterTarget:
				
										Thuộc tính này chỉ định tên của một biến mà biểu thức có thể tham chiếu đến. Nói cách khác, nếu bạn muốn sử dụng một biến cụ thể trong biểu thức SpEL của mình, bạn có thể đặt tên
										biến này ở đây.
										
										@PreAuthorize("hasRole('ROLE_USER') and #productId == 5")
										public void getProduct(int productId) {
											// Lấy thông tin sản phẩm
										}
		@PostAuthorize--Annotation:
									
									- Nếu như @PreAuthorize kiểm tra quyền trước khi method thực thi thì có những tình huống quyết định cho phép truy cập tiếp hay không chỉ sau khi phương thức được thực
									thi. Ví dụ GET /post/{id} sẽ trả về bài viết. Tôi muốn rằng chỉ tác giả của chính bài viết đó mới có thể được xem để sửa. Spring Boot đã có user.id đang đăng nhập,
									nhưng để biết tác giả của bài viết thì cần phải lấy bài viết đó từ CSDL ra đã. @PostAuthorize
									- Các phương thức và thuộc tính giống với @PreAuthorize
									
									@PostAuthorize("#username == authentication.principal.username")
									public String getMyRoles2(String username) {
										//...
									}
									
									@PreAuthorize("isAuthenticated()") //Phải đảm bảo là user login để có principal.id
									@PostAuthorize("returnObject.user.id == authentication.principal.id")  //chỉ trả bài viết nếu user.id == id của login user
									@GetMapping("/post/{id}")
									public Post showEditPostForm(@PathVariable("id") long id) {
										Optional<Post> oPost = postRepo.findById(id);
										if (oPost.isPresent()) {
											return oPost.get();
										} else {
											throw new RuntimeException("Cannot find post with id " + id);
										}
									}
		@PostFilter--Annotation:
									
									- Để lọc dữ liệu trước khi trả về, có 2 cách: để lập trình viên tự viết code trong phương thức hoặc cấu hình bằng annotation @PostFilter.
									- Trong ví dụ này, phương thức getPostsOfAnUser() sẽ trả về một danh sách tất cả bài viết. Tôi muốn lọc ra chỉ trả về những bài viết do chính user đang login
									authentication.principal viết mà thôi.
									
									@PreAuthorize("isAuthenticated()")
									@PostFilter("filterObject.user.id == authentication.principal.id")
									@GetMapping("/post")
									public List<Post> getPostsOfAnUser() {
										return postRepo.findAll();
									}
									
									@PostFilter("filterObject.assignee == authentication.name")
									List<Task> findAll() {
										...
									}
		@PreFilter--Annotation:
									
									@Prefilter lại cho phép lọc dữ liệu truyền vào phương thức trước khi thực thi.
									
									import org.springframework.security.access.prepost.PreAuthorize;
									import org.springframework.security.access.prepost.PreFilter;
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.RestController;
									import java.util.ArrayList;
									import java.util.List;
									@RestController
									public class UserController {
										private List<User> users = new ArrayList<>();									
										public UserController() {
											users.add(new User("admin", "ADMIN"));
											users.add(new User("user1", "USER"));
											users.add(new User("user2", "USER"));
										}
										@GetMapping("/users")
										@PreAuthorize("hasRole('ADMIN') or hasRole('USER')") // phương thức getUsersByRole chỉ có thể được thực thi nếu người dùng có vai trò là "ADMIN" hoặc "USER".
																							 // Nếu một người dùng không có vai trò là "ADMIN" hoặc "USER" cố gắng
																							 // truy cập vào phương thức này, họ sẽ nhận được một ngoại lệ AccessDeniedException từ Spring Security.
										@PreFilter("hasRole('ADMIN') ? filterObject.role == 'ADMIN' : filterObject.role == 'USER'") // chỉ định rằng danh sách người dùng sẽ được lọc trước khi trả về.
																																	// Đối với người dùng có vai trò là "ADMIN", danh sách sẽ chỉ chứa các
																																	// người dùng có vai trò là "ADMIN". Đối với người dùng có vai trò là
																																	// "USER", danh sách sẽ chỉ chứa các người dùng có vai trò là "USER".
																																	// Nếu một người dùng không có vai trò là "ADMIN" hoặc "USER" cố gắng
																																	// truy cập vào phương thức này, họ sẽ nhận được một ngoại lệ
																																	// AccessDeniedException từ Spring Security.
										public List<User> getUsersByRole() {
											return users;
										}
										private static class User {
											private String username;
											private String role;
											public User(String username, String role) {
												this.username = username;
												this.role = role;
											}
											// Getters and setters
										}
									}
									
									@PreFilter("hasRole('MANAGER') or filterObject.assignee == authentication.name")
									Iterable<Task> save(Iterable<Task> entities) {
										// ...
									}
		@ControllerAdvice--Annotation:
										
										- Là một annotation được sử dụng để đánh dấu một lớp như một global controller advice (lời khuyên toàn cục cho controller). Nó cho phép bạn xử lý các ngoại lệ chung
										và thực hiện một số xử lý toàn cục cho tất cả các controller trong ứng dụng.
										- Các phương thức trong lớp đánh dấu bởi @ControllerAdvice có thể được đánh dấu bằng các annotation như @ExceptionHandler, @InitBinder, và @ModelAttribute.
										- Các annotation này cho phép bạn xử lý các ngoại lệ, tiền xử lý (pre-processing), và ánh xạ các thuộc tính mô hình (model attributes) một cách toàn cục cho các
										controller.
										
										import org.springframework.http.HttpStatus;
										import org.springframework.http.ResponseEntity;
										import org.springframework.web.bind.annotation.ControllerAdvice;
										import org.springframework.web.bind.annotation.ExceptionHandler;
										@ControllerAdvice
										public class GlobalExceptionHandler {
											@ExceptionHandler(Exception.class)
											public ResponseEntity<String> handleException(Exception e) {
												return new ResponseEntity<>("Global Exception Handler: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
											}
										}
										
		@ExceptionHandler--Annotation:
										
										- Là một annotation được sử dụng để đánh dấu một phương thức trong controller, cho biết rằng phương thức đó sẽ được sử dụng để xử lý các ngoại lệ (exceptions) được
										ném ra trong phạm vi của controller đó. Annotation này cho phép bạn tách biệt xử lý ngoại lệ khỏi phương thức chính của controller, giúp mã nguồn sạch hơn và dễ
										bảo trì hơn.

										public class ResourceNotFoundException extends RuntimeException {
											public ResourceNotFoundException(String message) {
												super(message);
											}
										}
										import org.springframework.web.bind.annotation.GetMapping;
										import org.springframework.web.bind.annotation.PathVariable;
										import org.springframework.web.bind.annotation.RestController;
										@RestController
										public class UserController {
											@GetMapping("/user/{id}")
											public String getUserById(@PathVariable String id) {
												if ("123".equals(id)) {
													return "User found";
												} else {
													throw new ResourceNotFoundException("User not found with id: " + id);
												}
											}
										}
										import org.springframework.http.HttpStatus;
										import org.springframework.http.ResponseEntity;
										import org.springframework.web.bind.annotation.ExceptionHandler;
										import org.springframework.web.bind.annotation.RestControllerAdvice;
										@RestControllerAdvice
										public class GlobalExceptionHandler {
											@ExceptionHandler(ResourceNotFoundException.class)
											public ResponseEntity<String> handleResourceNotFoundException(ResourceNotFoundException ex) {
												return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
											}
										}
										ResourceNotFoundException là một ngoại lệ tùy chỉnh mở rộng từ RuntimeException.
										UserController chứa phương thức getUserById sẽ ném ResourceNotFoundException nếu người dùng không được tìm thấy.
										GlobalExceptionHandler là một lớp toàn cục để xử lý ngoại lệ, sử dụng @RestControllerAdvice để áp dụng cho tất cả các controller trong ứng dụng.
										@ExceptionHandler(ResourceNotFoundException.class) xử lý ngoại lệ ResourceNotFoundException.
										@ExceptionHandler(Exception.class) xử lý tất cả các ngoại lệ khác chưa được xử lý cụ thể.
										
										@Controller
										public class MyController {

											@GetMapping("/hello")
											public String hello() {
												throw new RuntimeException("Lỗi xảy ra trong quá trình xử lý yêu cầu");
											}

											@ExceptionHandler(RuntimeException.class)
											public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {
												return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Lỗi xảy ra: " + ex.getMessage());
											}
										}								
										
										@ExceptionHandler(NullPointerException.class) // Method processNullPointerException sẽ xử lý tất cả các exception NullPointerException ném ra từ các
																					  // @RequestMapping trong cùng class.
										public String processNullPointerException() {
										  return "null-pointer-exception";
										}
										@RequestMapping(value = "/nullPointerException")
										public String testNullPointerException() throws NullPointerException {
										  throw new NullPointerException("this is null pointer exception");
										}									
		@Enumerated--Annotation:
									
									- Lựa chọn phổ biến nhất để ánh xạ một enum với một cột trong database đó là sử dụng @Enumerated annotation được giới thiệu trong phiên bản JPA 2.1.
									- Bằng cách này, chúng ta có thể chỉ định các JPA provider chuyển đổi một enum thành string hoặc số thứ tự của nó trong tập enum được định nghĩa.
			
			Mapping Ordinal:		
			
									Nếu chúng ta chú thích @Enumerated(EnumType.ORDINAL) annotation lên các trường enum trong một entity. JPA sẽ sử dụng số thứ tự của enum làm giá trị khi thêm mới hoặc
									cập nhật giá trị của trường này.						
										
									public enum Status {
										OPEN, REVIEW, APPROVED, REJECTED;
									}
										
									package entities;
									import javax.persistence.Entity;
									import javax.persistence.EnumType;
									import javax.persistence.Enumerated;
									import javax.persistence.Id;
									@Entity
									public class Article {										
										@Id
										private int id;
										private String title;
										@Enumerated(EnumType.ORDINAL)
										private Status status;
										// getter, setter, constructor
									}
									
									import entities.Article;
									import entities.Status;
									import javax.persistence.EntityManager;
									import javax.persistence.EntityManagerFactory;
									import javax.persistence.Persistence;
									public class Example1 {
										public static void main(String... args) {
											EntityManagerFactory emf = Persistence.createEntityManagerFactory("enum-mapping");
											EntityManager entityManager = emf.createEntityManager();
											entityManager.getTransaction().begin();
											Article article = new Article();
											article.setId(1);
											article.setTitle("ordinal title");
											article.setStatus(Status.OPEN);
											entityManager.persist(article);
											entityManager.getTransaction().commit();
											entityManager.close();
											emf.close();
										}
									}
									
			Mapping String:			
			
									Tương tự, @Enumerated(EnumType.STRING) sẽ sử chuyển đổi giá trị của enum sang string để lưu xuống database.
									
									public enum Type {
										INTERNAL, EXTERNAL
									}
									
									@Entity
									public class Article {
										@Id
										private int id;
										private String title;
										@Enumerated(EnumType.ORDINAL)
										private Status status;
										@Enumerated(EnumType.STRING)
										private Type type;
									}
									
									import entities.Article;
									import entities.Status;
									import entities.Type;
									import javax.persistence.EntityManager;
									import javax.persistence.EntityManagerFactory;
									import javax.persistence.Persistence;
									public class Example2 {
										public static void main(String... args) {
											EntityManagerFactory emf = Persistence.createEntityManagerFactory("enum-mapping");
											EntityManager entityManager = emf.createEntityManager();
											entityManager.getTransaction().begin();
											Article article = new Article();
											article.setId(1);
											article.setTitle("string title");
											article.setStatus(Status.OPEN);
											article.setType(Type.EXTERNAL);
											entityManager.persist(article);
											entityManager.getTransaction().commit();
											entityManager.close();
											emf.close();
										}
									}
		@ResponseStatus--Annotation:
										
										- @ResponseStatus là một cách định nghĩa Http Status trả về cho người dùng.
										- Nếu bạn không muốn sử dụng ResponseEntity thì có thể dùng @ResponseStatus đánh dấu trên Object trả về.
										- @ResponseStatus là một annotation trong Spring, được sử dụng để chỉ định HTTP status code mà Spring sẽ trả về khi một ngoại lệ được ném ra.
										- Khi một exception xảy ra trong ứng dụng Spring, mặc định Spring sẽ trả về HTTP status code 500 (Internal Server Error). Tuy nhiên, trong một số trường hợp, bạn muốn trả về một
										HTTP status code khác, phù hợp với loại ngoại lệ đã xảy ra.
										- Ví dụ, khi một tài nguyên không được tìm thấy (404 Not Found), bạn có thể ném ra một ResourceNotFoundException và sử dụng @ResponseStatus để chỉ định HTTP status code 404
										sẽ được trả về
										- @ResponseStatus cũng có thể được sử dụng ở cấp độ method
										- Ngoài việc chỉ định HTTP status code, @ResponseStatus cũng có thể được sử dụng để chỉ định một custom message cho ngoại lệ
										- Sử dụng @ResponseStatus giúp đơn giản hóa và làm rõ ràng các mã trạng thái HTTP được sử dụng trong các controller của bạn. Điều này giúp cải thiện sự nhất quán và dễ hiểu
										của API, đồng thời cũng làm cho code trở nên sáng sủa và dễ bảo trì hơn.
										
										@ResponseStatus(HttpStatus.NOT_FOUND)
										@GetMapping("/users/{id}")
										public User getUserById(@PathVariable("id") Long id) {
											// code to retrieve user
											return user;
										}
										Trong ví dụ này, nếu không tìm thấy user, phương thức getUserById() sẽ trả về mã trạng thái 404 Not Found.
										
										@ResponseStatus(value = HttpStatus.PAYMENT_REQUIRED, reason = "Insufficient funds")
										@PostMapping("/transactions")
										public void processTransaction(@RequestBody Transaction transaction) {
											// code to process the transaction
										}
										Trong ví dụ này, nếu có lỗi xảy ra (ví dụ như không đủ tiền), phương thức processTransaction() sẽ trả về mã trạng thái 402 Payment Required với lý do "Insufficient funds".
										
										@ResponseStatus(HttpStatus.CONFLICT)
										public class UserAlreadyExistsException extends RuntimeException {
											// exception logic
										}
										@PostMapping("/users")
										public User createUser(@RequestBody User user) {
											try {
												// code to create a new user
											} catch (UserAlreadyExistsException ex) {
												// this exception will be mapped to HTTP 409 Conflict
												throw ex;
											}
											return savedUser;
										}
										Ở đây, chúng ta định nghĩa một custom exception UserAlreadyExistsException và ánh xạ nó đến mã trạng thái HTTP 409 Conflict bằng cách sử dụng @ResponseStatus. Khi exception
										này được ném ra trong phương thức createUser(), Spring sẽ tự động trả về mã trạng thái 409 Conflict.
										
										@ResponseStatus(HttpStatus.NOT_FOUND)
										public class ResourceNotFoundException extends RuntimeException {
											// implementation
										}

										@ResponseStatus(HttpStatus.CREATED)
										@PostMapping("/users")
										public User createUser(@RequestBody User user) {
											// implementation
										}
										Trong ví dụ trên, khi một user mới được tạo thành công, Spring sẽ trả về HTTP status code 201 (Created) thay vì 200 (OK).	

										@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Resource not found")
										public class ResourceNotFoundException extends RuntimeException {
											// implementation
										}										
										
										@RestControllerAdvice
										public class ApiExceptionHandler {
											@ExceptionHandler(Exception.class)
											@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
											public ErrorMessage handleAllException(Exception ex, WebRequest request) {
												// quá trình kiểm soat lỗi diễn ra ở đây
												return new ErrorMessage(10000, ex.getLocalizedMessage());
											}
											@ExceptionHandler(IndexOutOfBoundsException.class) // IndexOutOfBoundsException sẽ được xử lý riêng tại đây
											@ResponseStatus(value = HttpStatus.BAD_REQUEST)
											public ErrorMessage TodoException(Exception ex, WebRequest request) {
												return new ErrorMessage(10100, "Đối tượng không tồn tại");
											}
										}
								
		@RestControllerAdvice--Annotation:
											
											- Là một biến thể của annotation @ControllerAdvice trong Spring Framework, nhưng được sử dụng đặc biệt cho các trường hợp khi bạn muốn xử lý các exception và
											trả về phản hồi dưới dạng dữ liệu JSON cho ứng dụng RESTful.
											- Khi bạn đánh dấu một lớp bằng @RestControllerAdvice, các phương thức xử lý exception trong lớp đó sẽ trả về dữ liệu JSON thay vì trang HTML như trong trường
											hợp sử dụng @ControllerAdvice.
											
											import org.springframework.http.ResponseEntity;
											import org.springframework.web.bind.annotation.ControllerAdvice;
											import org.springframework.web.bind.annotation.ExceptionHandler;
											import org.springframework.web.bind.annotation.RestControllerAdvice;
											@RestControllerAdvice
											public class GlobalExceptionHandler {
												@ExceptionHandler(Exception.class)
												public ResponseEntity<String> handleGlobalException(Exception ex) {
													return ResponseEntity.badRequest().body("Something went wrong.");
												}
											}
		@JsonAdapter--Annotation:
											
							- Trong thư viện Gson của Java, @JsonAdapter là một annotation được sử dụng để chỉ định một adapter tùy chỉnh để chuyển đổi giữa đối tượng Java và JSON khi thực hiện quá trình
							serialize và deserialize. Adapter tùy chỉnh này cho phép bạn kiểm soát cách mà Gson chuyển đổi các đối tượng thành JSON và ngược lại.
							- Áp dụng tùy chỉnh TypeAdapter, JsonSerializer, JsonDeserializer với @JsonAdapter
							- Chú thích này có thể được sử dụng field hoặc class để chỉ định lớp tùy chỉnh Gson TypeAdapter, JsonSerializer, JsonDeserializer được sử dụng trong khi serialization/ deserialization.
							- Một vài trường hợp sử dụng phổ biến của @JsonAdapter bao gồm:
								Chuyển đổi các kiểu dữ liệu tùy chỉnh
								Chuyển đổi các cấu trúc dữ liệu phức tạp: Ví dụ, bạn có thể sử dụng @JsonAdapter để chuyển đổi một Map<String, List<Integer>> sang một định dạng JSON tùy chỉnh.
								Áp dụng các quy tắc kiểm tra, xác thực hoặc biến đổi dữ liệu: Bạn có thể tạo một custom adapter để thực hiện các quy tắc này trong quá trình serialization và deserialization.
							- Để tạo một custom adapter, bạn cần tạo một class implements JsonSerializer<T> và JsonDeserializer<T> interfaces từ thư viện Jackson. Bạn có thể sử dụng các phương thức write() và
							read() để triển khai logic chuyển đổi tùy chỉnh.
							
							public class MyClass {
								@JsonAdapter(DateAdapter.class)
								private Date dateField;
								// Getters, setters, and other methods
							}
							public class DateAdapter extends TypeAdapter<Date> {
								@Override
								public void write(JsonWriter out, Date value) throws IOException {
									if (value == null) {
										out.nullValue();
									} else {
										out.value(value.getTime());
									}
								}
								@Override
								public Date read(JsonReader in) throws IOException {
									long timestamp = in.nextLong();
									return new Date(timestamp);
								}
							}
							Trong ví dụ trên, chúng ta có một DateAdapter class, được áp dụng cho dateField sử dụng @JsonAdapter(DateAdapter.class). Khi serializing một instance của MyClass sang
							JSON, DateAdapter sẽ được sử dụng để chuyển đổi dateField (một Date object) sang một số nguyên đại diện cho timestamp (milliseconds since Unix epoch).
							Khi deserializing JSON data trở lại thành một instance của MyClass, DateAdapter sẽ được sử dụng để chuyển đổi số nguyên (timestamp) trở lại thành một Date object.
							
							
							package com.gpcoder.gson.object;
							import java.util.Arrays;
							import java.util.Date;											 
							import com.google.gson.annotations.JsonAdapter;
							import com.gpcoder.gson.annotation.CustomTypeAdapter;										 
							public class AmazonBook {
								private String title;
								private String[] authors;
								private String isbn10;
								private String isbn13;
								private Double price;
								private Date publishedDate;											 
								public String getTitle() {
									return title;
								}											 
								public void setTitle(String title) {
									this.title = title;
								}										 
								public String[] getAuthors() {
									return authors;
								}										 
								public void setAuthors(String[] authors) {
									this.authors = authors;
								}											 
								public String getIsbn10() {
									return isbn10;
								}										 
								public void setIsbn10(String isbn10) {
									this.isbn10 = isbn10;
								}										 
								public String getIsbn13() {
									return isbn13;
								}										 
								public void setIsbn13(String isbn13) {
									this.isbn13 = isbn13;
								}										 
								public Double getPrice() {
									return price;
								}									 
								public void setPrice(Double price) {
									this.price = price;
								}									 
								public Date getPublishedDate() {
									return publishedDate;
								}									 
								public void setPublishedDate(Date publishedDate) {
									this.publishedDate = publishedDate;
								}							 
								@Override
								public String toString() {
									return "Book [title=" + title + ", authors=" + Arrays.toString(authors) + ", isbn10=" + isbn10 + ", isbn13="
											+ isbn13 + ", price=" + price + ", publishedDate=" + publishedDate + "]";
								}									 
							}
							
							package com.gpcoder.gson.annotation;
							import java.io.IOException;
							import java.text.ParseException;
							import java.text.SimpleDateFormat;
							import java.util.ArrayList;
							import java.util.Date;
							import java.util.List;					 
							import com.google.gson.TypeAdapter;
							import com.google.gson.stream.JsonReader;
							import com.google.gson.stream.JsonWriter;
							import com.gpcoder.gson.object.AmazonBook;											 
							public class CustomTypeAdapter extends TypeAdapter<AmazonBook> {										 
								public static final SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");										 
								@Override
								public AmazonBook read(final JsonReader in) throws IOException {
									final AmazonBook book = new AmazonBook();									 
									in.beginObject();
									while (in.hasNext()) {
										switch (in.nextName()) {
										case "title":
											book.setTitle(in.nextString());
											break;
										case "isbn-10":
											book.setIsbn10(in.nextString());
											break;
										case "isbn-13":
											book.setIsbn13(in.nextString());
											break;
										case "price":
											book.setPrice(in.nextDouble());
											break;
										case "publishedDate":
											Date publishedDate = null;
											try {
												publishedDate = sdf.parse(in.nextString());
											} catch (ParseException e) {
												e.printStackTrace();
											}
											book.setPublishedDate(publishedDate);
											break;
										case "authors":
											in.beginArray();
											final List<String> authors = new ArrayList<>();
											while (in.hasNext()) {
												authors.add(in.nextString());
											}
											in.endArray();
											book.setAuthors(authors.toArray(new String[authors.size()]));
											break;
										}
									}
									in.endObject();										
									return book;
								}											 
								@Override
								public void write(final JsonWriter out, final AmazonBook book) throws IOException {
									out.beginObject();
									out.name("title").value(book.getTitle());
									out.name("isbn-10").value(book.getIsbn10());
									out.name("isbn-13").value(book.getIsbn13());
									out.name("price").value(book.getPrice());
									out.name("publishedDate").value(sdf.format(book.getPublishedDate()));
									out.name("authors");
									out.beginArray();
									for (final String author : book.getAuthors()) {
										out.value(author);
									}
									out.endArray();
									out.endObject();
								}
							}
							
							@JsonAdapter(value = CustomTypeAdapter.class)
							public class AmazonBook {
								// Fields ...
							}
							
							package com.gpcoder.gson.annotation;
							import java.util.Calendar;									 
							import com.google.gson.Gson;
							import com.google.gson.GsonBuilder;
							import com.gpcoder.gson.object.AmazonBook;											 
							public class JsonAdapterExample {
								public static void main(String args[]) {
									final GsonBuilder gsonBuilder = new GsonBuilder();
									gsonBuilder.setPrettyPrinting();											 
									final Gson gson = gsonBuilder.create();											 
									final AmazonBook book = new AmazonBook();
									book.setTitle("Head First Design Patterns");
									book.setIsbn10("0596007124");
									book.setIsbn13("978-0596007126");
									book.setPrice(52.41);										 
									Calendar c = Calendar.getInstance();
									c.set(2004, Calendar.OCTOBER, 1);
									book.setPublishedDate(c.getTime());											 
									String[] authors = new String[] { "Eric Freeman", "Bert Bates", "Kathy Sierra", "Elisabeth Robson" };
									book.setAuthors(authors);										 
									System.out.println("Convert Book object to JSON string: ");
									final String json = gson.toJson(book);
									System.out.println(json);										 
									System.out.println("Convert JSON String to Book object: ");
									final AmazonBook parsedBook1 = gson.fromJson(json, AmazonBook.class);
									System.out.println(parsedBook1);
								}
							}
							
							Kết quả thực thi chương trình trên:
							Convert Book object to JSON string: 
							{
							  "title": "Head First Design Patterns",
							  "isbn-10": "0596007124",
							  "isbn-13": "978-0596007126",
							  "price": 52.41,
							  "publishedDate": "01/10/2004",
							  "authors": [
								"Eric Freeman",
								"Bert Bates",
								"Kathy Sierra",
								"Elisabeth Robson"
							  ]
							}
							 
							Convert JSON String to Book object: 
							Book [title=Head First Design Patterns, authors=[Eric Freeman, Bert Bates, Kathy Sierra, Elisabeth Robson], isbn10=0596007124, isbn13=978-0596007126, price=52.41,
							publishedDate=Fri Oct 01 00:00:00 ICT 2004]

		@EnableFeignClients--Annotation:
		
			- @EnableFeignClients là một annotation trong Spring Cloud, được sử dụng để kích hoạt chức năng Feign Client trong một ứng dụng Spring. Feign Client là một thư viện cung cấp cách thức dễ dàng hơn để gọi các
			RESTful API từ các dịch vụ khác trong một hệ thống microservice.
			
			- Khi bạn sử dụng @EnableFeignClients, Spring sẽ tự động:
			
					Quét các package được chỉ định hoặc package gốc của ứng dụng để tìm các interface khai báo Feign Client.
					Tạo ra các implementation của các interface Feign Client đó.
					Đăng ký các bean Feign Client vào Spring IoC container để bạn có thể autowire chúng vào các class khác.
					
			@FeignClient(name = "user-service")
			public interface UserServiceClient {
				@GetMapping("/users/{id}")
				User getUser(@PathVariable("id") Long id);
			}
			Khi bạn thêm @EnableFeignClients vào class @SpringBootApplication chính của ứng dụng, Spring sẽ tự động tạo ra implementation của UserServiceClient và đăng ký nó vào container. Bây giờ bạn có thể autowire
			UserServiceClient vào các class cần sử dụng nó.	
			Annotation @EnableFeignClients cũng có một số tham số khác để cấu hình, ví dụ như chỉ định các package cụ thể cần quét để tìm Feign Client, hay cấu hình các option khác cho Feign Client.
			
		@RequiredArgsConstructor--Annotation:
		
			- @RequiredArgsConstructor là một annotation trong thư viện Lombok, được sử dụng để tự động tạo ra một constructor có các tham số là các trường final hoặc các trường có @NonNull annotation.
			- Khi bạn sử dụng @RequiredArgsConstructor trên một class, Lombok sẽ tự động tạo ra một constructor có các tham số là các trường final hoặc các trường có @NonNull annotation trong class đó.
			
			@Data
			@RequiredArgsConstructor
			public class User {
				private final Long id;
				private final String name;
				@NonNull
				private String email;
				private Integer age;
			}

			Khi bạn sử dụng @RequiredArgsConstructor, Lombok sẽ tự động tạo ra một constructor như sau:

			public User(Long id, String name, @NonNull String email) {
				this.id = id;
				this.name = name;
				this.email = Objects.requireNonNull(email);
			}
			Trong ví dụ trên, id và name là các trường final, nên chúng được đưa vào constructor. email có @NonNull annotation, nên cũng được đưa vào constructor. age không được đưa vào constructor vì nó không phải là
			trường final và cũng không có @NonNull annotation.
			
		@CrossOrigin--Annotation:
			
			- @CrossOrigin là một annotation trong Spring Boot, được sử dụng để cho phép các ứng dụng web trên các miền (domains) khác có thể gửi request tới các endpoint của ứng dụng của bạn.
			- Khi một ứng dụng web (chẳng hạn như một ứng dụng ReactJS) chạy trên một miền (domain) khác với ứng dụng Spring Boot của bạn, nó sẽ gặp vấn đề về "Cross-Origin Resource Sharing" (CORS) khi cố gắng gửi request
			tới các endpoint của ứng dụng Spring Boot. Lúc này, bạn cần phải cấu hình CORS để cho phép các ứng dụng web từ các miền khác có thể truy cập các endpoint của ứng dụng Spring Boot.
			- Bằng cách sử dụng @CrossOrigin, bạn có thể dễ dàng cấu hình CORS cho các endpoint của ứng dụng Spring Boot.
			- @CrossOrigin có một số tham số khác như maxAge, allowedHeaders, exposedHeaders, allowCredentials, methods, v.v. để bạn có thể tuỳ chỉnh CORS theo nhu cầu của ứng dụng.
			- Ngoài việc sử dụng @CrossOrigin trên level class, bạn cũng có thể sử dụng nó trên level method để cấu hình CORS cho từng endpoint riêng biệt.
			
			@CrossOrigin(origins = "http://example.com")
			@RestController
			public class MyController {
				// các endpoint được định nghĩa ở đây
			}
			Trong ví dụ trên, @CrossOrigin(origins = "http://example.com") sẽ cho phép ứng dụng web chạy trên miền http://example.com có thể gửi request tới các endpoint định nghĩa trong MyController.
			
		@KafkaListener--Annotation:
		
			- @KafkaListener là một annotation trong Spring for Apache Kafka, được sử dụng để đánh dấu một phương thức là một listener của một hoặc nhiều topic Kafka.
			- Khi một message được gửi đến một topic mà phương thức có @KafkaListener đang lắng nghe, phương thức đó sẽ được gọi để xử lý message đó.
			- @KafkaListener có nhiều thuộc tính có thể được sử dụng để cấu hình listener:
				topics: chỉ định danh sách các topic mà listener sẽ lắng nghe.
				groupId: chỉ định group ID của consumer.
				containerFactory: chỉ định bean KafkaListenerContainerFactory để tạo container lắng nghe.
				errorHandler: chỉ định bean AsyncListenerErrorHandler để xử lý lỗi.
				clientIdPrefix: chỉ định tiền tố cho client ID.
				idIsGroup: chỉ định liệu client ID có được sử dụng làm group ID hay không.
			- Sử dụng @KafkaListener giúp bạn dễ dàng tích hợp ứng dụng Spring với Apache Kafka, đồng thời cũng cung cấp nhiều tùy chỉnh để đáp ứng các yêu cầu cụ thể của ứng dụng.
			
			@Component
			public class MyKafkaListener {

				@KafkaListener(topics = "my-topic")
				public void processMessage(String message) {
					// Xử lý message
					System.out.println("Received message: " + message);
				}
			}
			Trong ví dụ này, phương thức processMessage() sẽ được gọi mỗi khi một message được gửi đến topic "my-topic".
			
			@KafkaListener(topics = {"topic1", "topic2"}, groupId = "my-group")
			public void processMessages(String message1, String message2) {
				// Xử lý cả 2 message
			}
			Trong ví dụ này, phương thức processMessages() sẽ được gọi mỗi khi có message được gửi đến topic "topic1" hoặc "topic2", và consumer sẽ thuộc về group "my-group".
	
		@KafkaHandler--Annotation:
		
			- @KafkaHandler là một annotation trong Spring for Apache Kafka, được sử dụng để đánh dấu một phương thức trong một class như một listener cho một chủ đề (topic) Kafka cụ thể.
			- Một số điểm chú ý khi sử dụng @KafkaHandler:
				Các phương thức được đánh dấu @KafkaHandler phải có tham số là kiểu của message mà chúng xử lý.
				Nếu có nhiều phương thức @KafkaHandler với cùng loại tham số, Spring sẽ gọi tất cả chúng để xử lý message.
				Bạn có thể sử dụng các annotation khác như @Header, @Payload, @KafkaKey để truy cập các thông tin khác của message.
			- Việc sử dụng @KafkaHandler giúp code của bạn trở nên rõ ràng, dễ bảo trì và mở rộng hơn, đặc biệt khi bạn cần xử lý nhiều loại message từ Kafka.
			- Annotation @KafkaListener đánh dấu class MyKafkaListener như một Kafka listener cho chủ đề my-topic.
		     - Annotation @KafkaHandler đánh dấu các phương thức trong class MyKafkaListener như các handler để xử lý các loại message khác nhau từ chủ đề Kafka.
			 
			import org.springframework.kafka.annotation.KafkaHandler;
			import org.springframework.kafka.annotation.KafkaListener;
			import org.springframework.stereotype.Component;
			@Component
			@KafkaListener(topics = "my-topic")
			public class MyKafkaListener {
				@KafkaHandler
				public void handleMessage(String message) {
					// Xử lý message từ Kafka
					System.out.println("Received message: " + message);
				}
				@KafkaHandler
				public void handleOtherMessage(AnotherType message) {
					// Xử lý message khác từ Kafka
					System.out.println("Received another message: " + message);
				}
			}
			Khi có message từ chủ đề my-topic được gửi vào, Spring sẽ tự động gọi đến phương thức phù hợp dựa trên loại message.
		
		@Slf4j--Annotation:
		
			- @Slf4j là một annotation từ thư viện Lombok, được sử dụng trong Spring để tạo ra một logger instance của SLF4J (Simple Logging Facade for Java) một cách nhanh chóng và thuận tiện.
			- Khi sử dụng @Slf4j, Lombok sẽ tự động một private static final Logger field với tên log trong class đó. Việc này giúp bạn có thể sử dụng log để ghi log mà không cần phải khai báo và khởi tạo Logger
			object một cách thủ công.
			- Lợi ích của việc sử dụng @Slf4j:
				Giảm lượng code: Bạn không cần phải khai báo và khởi tạo Logger object một cách thủ công.
				Dễ dàng chuyển đổi logging framework: Vì @Slf4j sử dụng SLF4J, bạn có thể dễ dàng chuyển đổi giữa các logging framework như Logback, Log4j, Java Util Logging, v.v.
				Đồng nhất cách sử dụng logging: Việc sử dụng @Slf4j giúp đồng nhất cách sử dụng logging trong toàn bộ ứng dụng.
		
			import lombok.extern.slf4j.Slf4j;
			import org.springframework.stereotype.Service;
			@Slf4j
			@Service
			public class MyService {
				public void doSomething() {
					log.info("Performing some operation...");
					try {
						// some business logic
					} catch (Exception e) {
						log.error("An error occurred: {}", e.getMessage(), e);
					}
				}
			}
			@Slf4j được thêm vào class MyService, cho phép Lombok tạo ra một log field.
			Bên trong doSomething() method, log.info() và log.error() được sử dụng để ghi lại các thông tin và lỗi.
		
		@JsonIgnore--Annotation:
		
			- @JsonIgnore là một annotation trong Spring, được sử dụng để đánh dấu một thuộc tính hoặc một phương thức trong một class sẽ bị bỏ qua (ignore) khi chuyển đổi đối tượng Java sang JSON và ngược lại.
			- Một số lưu ý khi sử dụng @JsonIgnore:
				Nó có thể được sử dụng trên các thuộc tính, getter và setter.
				Nó còn có thể sử dụng trên cấp độ class để bỏ qua toàn bộ các thuộc tính của class.
				Ngoài @JsonIgnore, bạn cũng có thể sử dụng các annotation khác như @JsonProperty để kiểm soát việc chuyển đổi dữ liệu.
				@JsonIgnore rất hữu ích khi bạn muốn ẩn một số thông tin nhạy cảm hoặc không cần thiết khi chuyển đổi đối tượng sang JSON.
			
			import com.fasterxml.jackson.annotation.JsonIgnore;
			public class User {
				private int id;
				private String name;
				@JsonIgnore
				private String password;
				// Các getter và setter
				public int getId() { return id; }
				public void setId(int id) { this.id = id; }
				public String getName() { return name; }
				public void setName(String name) { this.name = name; }
				public String getPassword() { return password; }
				public void setPassword(String password) { this.password = password; }
			}
			Thuộc tính password được đánh dấu bằng @JsonIgnore, do đó nó sẽ bị bỏ qua khi chuyển đổi đối tượng User sang JSON.
			Khi chuyển đổi đối tượng User sang JSON, chỉ có các thuộc tính id và name được bao gồm.
			Khi chuyển đổi JSON trở lại thành đối tượng User, thuộc tính password cũng sẽ được bỏ qua.
			
		@Builder--Annotation:
		
			- @Builder là một annotation được sử dụng trong Java để tạo ra một Builder pattern một cách dễ dàng. Builder pattern là một mẫu thiết kế phần mềm cho phép tạo ra các đối tượng phức tạp một cách dễ dàng và
			thể hiện rõ các bước trong quá trình tạo đối tượng.
			- Khi sử dụng @Builder trong Spring, bạn có thể tạo ra một Builder class cho một class khác một cách tự động
			- Việc sử dụng Builder pattern cung cấp một số lợi ích:
				Tính rõ ràng: Cách tạo ra đối tượng trở nên rõ ràng và dễ hiểu hơn.
				Tính linh hoạt: Bạn có thể thêm hoặc bỏ các tham số khi tạo đối tượng mà không ảnh hưởng đến constructor.
				Tính an toàn: Đảm bảo các trường bắt buộc được thiết lập và có giá trị hợp lệ.
			
			import lombok.Builder;
			import lombok.Data;
			@Data
			@Builder
			public class User {
				private int id;
				private String name;
				private String email;
				private int age;
			}
			User user = User.builder()
                .id(1)
                .name("John Doe")
                .email("john.doe@example.com")
                .age(30)
                .build();
				
		@EnableScheduling--Annotation:
			
			- @EnableScheduling là một annotation trong Spring Framework được sử dụng để kích hoạt chức năng lập lịch (scheduling) trong ứng dụng Spring. Khi bạn thêm @EnableScheduling vào một class, nó sẽ tự động cấu
			hình một TaskScheduler để cho phép sử dụng các annotation liên quan đến lập lịch, chẳng hạn như @Scheduled.
			- Sau khi kích hoạt chức năng lập lịch, bạn có thể sử dụng annotation @Scheduled trên các phương thức trong ứng dụng của mình để lên lịch các tác vụ định kỳ.
			- Một số lưu ý khi sử dụng @EnableScheduling:
				Nó yêu cầu bạn sử dụng @Configuration annotation hoặc kích hoạt component scanning để Spring có thể tìm thấy và cấu hình các bean liên quan đến lập lịch.
				Bạn có thể tùy chỉnh cấu hình lập lịch bằng cách cung cấp một TaskScheduler bean riêng.
				@Scheduled annotation hỗ trợ nhiều loại lịch trình khác nhau, chẳng hạn như fixedRate, fixedDelay, cron, v.v.
			
			import org.springframework.context.annotation.Configuration;
			import org.springframework.scheduling.annotation.EnableScheduling;
			@Configuration
			@EnableScheduling
			public class SchedulingConfig {
				// Các bean và cấu hình khác liên quan đến lập lịch
			}
			import org.springframework.scheduling.annotation.Scheduled;
			import org.springframework.stereotype.Component;
			@Component
			public class ScheduledTask {
				@Scheduled(fixedRate = 60000) // Chạy mỗi 60 giây
				public void performTask() {
					// Thực hiện tác vụ ở đây
					System.out.println("Tác vụ định kỳ được thực hiện.");
				}
			}
			
		@EnableSwagger2--Annotation:
		
			- @EnableSwagger2 là một annotation trong Spring được sử dụng để kích hoạt Swagger, một framework giúp tạo và quản lý API documentation cho ứng dụng Spring.
			- Khi bạn thêm @EnableSwagger2 vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết để Swagger hoạt động, bao gồm:
				Servlet để phục vụ Swagger UI
				Swagger Docket bean để cấu hình các thông tin API như title, description, version, etc.
				Các bean khác liên quan đến Swagger như ApiInfoBuilder, Contact, v.v.
			- Sau khi cấu hình Swagger, bạn có thể truy cập Swagger UI tại đường dẫn mặc định /swagger-ui.html. Ví dụ, nếu ứng dụng của bạn chạy trên localhost:8080, thì Swagger UI sẽ có thể truy
			cập tại http://localhost:8080/swagger-ui.html.
			- Một số lưu ý khi sử dụng @EnableSwagger2:
				Bạn có thể tùy chỉnh cấu hình Swagger bằng cách sử dụng các phương thức khác trên Docket bean, chẳng hạn như apiInfo(), useDefaultResponseMessages(), v.v.
				Ngoài ra, bạn cũng có thể sử dụng các annotation như @ApiOperation, @ApiParam, @ApiResponse trên các controller và model để cung cấp thêm thông tin cho Swagger.
				@EnableSwagger2 yêu cầu bạn sử dụng Springfox framework, vì vậy bạn cần thêm các dependency liên quan trong pom.xml hoặc build.gradle của dự án.
			
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import springfox.documentation.builders.PathSelectors;
			import springfox.documentation.builders.RequestHandlerSelectors;
			import springfox.documentation.spi.DocumentationType;
			import springfox.documentation.spring.web.plugins.Docket;
			import springfox.documentation.swagger2.annotations.EnableSwagger2;
			@Configuration
			@EnableSwagger2
			public class SwaggerConfig {
				@Bean
				public Docket api() {
					return new Docket(DocumentationType.SWAGGER_2)
							.select()
							.apis(RequestHandlerSelectors.any())
							.paths(PathSelectors.any())
							.build();
				}
			}
			@EnableSwagger2 kích hoạt Swagger trong ứng dụng.
			Một bean Docket được định nghĩa, cấu hình Swagger để tìm tất cả các controller và generate API documentation.

		@EnableWebSecurity--Annotation:

			- @EnableWebSecurity là một annotation trong Spring Security được sử dụng để kích hoạt và cấu hình bảo mật Web trong ứng dụng Spring.
			- Khi bạn thêm @EnableWebSecurity vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết cho Spring Security, bao gồm:
				HttpSecurity: Cấu hình các chính sách bảo mật cho các endpoint, chẳng hạn như phân quyền, csrf protection, session management, v.v.
				AuthenticationManagerBuilder: Cấu hình các provider để xác thực người dùng, ví dụ như In-Memory Authentication, JDBC Authentication, LDAP Authentication, v.v.
				UserDetailsService: Cung cấp thông tin về người dùng, như tên đăng nhập, mật khẩu, vai trò.
			- Một số lưu ý khi sử dụng @EnableWebSecurity:
				Bạn có thể tùy chỉnh cấu hình bảo mật bằng cách ghi đè các phương thức trong lớp WebSecurityConfigurerAdapter.
				Ngoài In-Memory Authentication, bạn cũng có thể sử dụng các cơ chế xác thực khác như JDBC Authentication, LDAP Authentication, v.v.
				@EnableWebSecurity yêu cầu bạn sử dụng Spring Security, vì vậy bạn cần thêm các dependency liên quan trong pom.xml hoặc build.gradle của dự án.

			import org.springframework.context.annotation.Configuration;
			import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
			import org.springframework.security.config.annotation.web.builders.HttpSecurity;
			import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
			import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
			import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
			@Configuration
			@EnableWebSecurity
			public class SecurityConfig extends WebSecurityConfigurerAdapter {
				@Override
				protected void configure(AuthenticationManagerBuilder auth) throws Exception {
					auth.inMemoryAuthentication()
						.withUser("user")
						.password(passwordEncoder().encode("password"))
						.roles("USER")
						.and()
						.withUser("admin")
						.password(passwordEncoder().encode("admin"))
						.roles("ADMIN");
				}
				@Override
				protected void configure(HttpSecurity http) throws Exception {
					http.authorizeRequests()
						.antMatchers("/admin/**").hasRole("ADMIN")
						.antMatchers("/user/**").hasRole("USER")
						.anyRequest().authenticated()
						.and()
						.formLogin()
						.and()
						.logout();
				}
				public BCryptPasswordEncoder passwordEncoder() {
					return new BCryptPasswordEncoder();
				}
			}
			Lớp SecurityConfig kế thừa từ WebSecurityConfigurerAdapter, cung cấp các phương thức để cấu hình xác thực và ủy quyền.
			Phương thức configure(AuthenticationManagerBuilder) cấu hình In-Memory Authentication, với 2 người dùng "user" và "admin".
			Phương thức configure(HttpSecurity) cấu hình các chính sách bảo mật, chẳng hạn như phân quyền truy cập các endpoint "/admin/" và "/user/".
			Phương thức passwordEncoder() cung cấp một instance của BCryptPasswordEncoder để mã hóa mật khẩu.

		@EnableGlobalMethodSecurity--Annotation:
			
			- @EnableGlobalMethodSecurity là một annotation trong Spring Security được sử dụng để kích hoạt và cấu hình bảo mật phương thức (method-level security) trong ứng dụng Spring.
			- Khi bạn thêm @EnableGlobalMethodSecurity vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết cho Spring Security để áp dụng bảo mật ở mức phương
			thức, bao gồm:
				MethodSecurityInterceptor: Interceptor để chặn các cuộc gọi phương thức và kiểm tra quyền truy cập.
				AccessDecisionManager: Quản lý các quyết định về việc cho phép hay không cho phép truy cập vào phương thức.
				SecurityExpressionHandler: Xử lý các biểu thức an ninh được sử dụng trong các chính sách quyền truy cập.
			- Sau khi cấu hình @EnableGlobalMethodSecurity, bạn có thể sử dụng các chú thích sau trên các phương thức của ứng dụng:
				@PreAuthorize: Kiểm tra quyền truy cập trước khi gọi phương thức.
				@PostAuthorize: Kiểm tra quyền truy cập sau khi gọi phương thức.
				@PreFilter: Lọc các đầu vào trước khi gọi phương thức.
				@PostFilter: Lọc các kết quả trả về từ phương thức.

			import org.springframework.context.annotation.Configuration;
			import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
			import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
			import org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration;
			import org.springframework.security.oauth2.provider.expression.OAuth2MethodSecurityExpressionHandler;
			@Configuration
			@EnableGlobalMethodSecurity(prePostEnabled = true)
			public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
				@Override
				protected MethodSecurityExpressionHandler createExpressionHandler() {
					return new OAuth2MethodSecurityExpressionHandler();
				}
			}			
			Lớp MethodSecurityConfig kế thừ từ GlobalMethodSecurityConfiguration, cung cấp các phương thức để cấu hình bảo mật phương thức.
			Phương thức createExpressionHandler() cung cấp một instance của OAuth2MethodSecurityExpressionHandler, cho phép sử dụng các biểu thức an ninh liên quan đến OAuth2.
			prePostEnabled = true cho phép sử dụng các chú thích như @PreAuthorize và @PostAuthorize trên các phương thức.

			@Service
			public class UserService {
				@PreAuthorize("hasRole('ADMIN')")
				public List<User> getAllUsers() {
					// Implementation
				}
				@PreAuthorize("hasPermission(#id, 'user', 'read')")
				public User getUser(Long id) {
					// Implementation
				}
				@PreAuthorize("hasRole('ADMIN')")
				@PostFilter("filterObject.active == true")
				public List<User> getActiveUsers() {
					// Implementation
				}
			}
			Trong ví dụ trên, phương thức getAllUsers() chỉ có thể được gọi bởi người dùng có vai trò "ADMIN", getUser() yêu cầu quyền "read" trên tài nguyên "user" với ID được cung cấp, và getActiveUsers() trả về danh
			sách người dùng đang hoạt động, nhưng chỉ với người dùng có vai trò "ADMIN".

		@EnableWebSocketMessageBroker--Annotation:

			- @EnableWebSocketMessageBroker là một annotation trong Spring Framework được sử dụng để kích hoạt và cấu hình WebSocket message broker trong ứng dụng Spring.
			- Khi bạn thêm @EnableWebSocketMessageBroker vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết để thiết lập kết nối WebSocket
			và sử dụng message broker để giao tiếp giữa client và server, bao gồm:
				WebSocketMessageBrokerConfigurer: Cấu hình các giải pháp message broker như STOMP, RabbitMQ, Redis, v.v.
				SimpMessageSendingOperations: Cung cấp các phương thức để gửi tin nhắn đến các client đăng ký.
				SimpSubscriptionMappingMethodArgumentResolver: Giải quyết các tham số của phương thức liên quan đến các chủ đề (topic) đăng ký.
			- Sau khi cấu hình @EnableWebSocketMessageBroker, bạn có thể sử dụng các chú thích như @MessageMapping, @SubscribeMapping, @SendTo và @SendToUser trên các phương thức controller để xử lý các
			tin nhắn WebSocket.

			import org.springframework.context.annotation.Configuration;
			import org.springframework.messaging.simp.config.MessageBrokerRegistry;
			import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
			import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
			import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
			@Configuration
			@EnableWebSocketMessageBroker
			public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
				@Override
				public void configureMessageBroker(MessageBrokerRegistry config) {
					config.enableSimpleBroker("/topic", "/queue");
					config.setApplicationDestinationPrefixes("/app");
				}
				@Override
				public void registerStompEndpoints(StompEndpointRegistry registry) {
					registry.addEndpoint("/websocket").withSockJS();
				}
			}
			Lớp WebSocketConfig cài đặt các phương thức để cấu hình message broker và đăng ký các STOMP endpoints.
			Phương thức configureMessageBroker() cấu hình message broker để nhận và gửi tin nhắn đến các chủ đề (topic) và hàng đợi (queue) với các tiền tố "/topic", "/queue" và "/app".
			Phương thức registerStompEndpoints() đăng ký một endpoint STOMP với địa chỉ "/websocket" và sử dụng SockJS fallback options.
			
			import org.springframework.messaging.handler.annotation.MessageMapping;
			import org.springframework.messaging.handler.annotation.SendTo;
			import org.springframework.stereotype.Controller;
			@Controller
			public class ChatController {
				@MessageMapping("/chat.sendMessage")
				@SendTo("/topic/public")
				public ChatMessage sendMessage(ChatMessage chatMessage) {
					return chatMessage;
				}
			}		

		@EqualsAndHashCode--Annotation:

			- @EqualsAndHashCode là một annotation trong Spring Data Lombok, một thư viện tiện ích giúp giảm bớt code boilerplate trong Java. Annotation này được sử dụng để tự động tạo phương thức
			equals() và hashCode() cho các lớp Java.
			- Khi bạn thêm @EqualsAndHashCode vào một lớp, Lombok sẽ tự động tạo các phương thức equals() và hashCode() dựa trên các trường của lớp đó. Điều này giúp bạn tiết kiệm thời gian và công
			sức khi làm việc với các lớp Java.
			- Ngoài ra, @EqualsAndHashCode còn có một số tùy chọn để bạn có thể tùy chỉnh cách tạo các phương thức equals() và hashCode(), chẳng hạn như:
				callSuper: Gọi phương thức equals() và hashCode() của lớp cha.
				exclude: Loại trừ một số trường khỏi việc tạo equals() và hashCode().
				of: Chỉ sử dụng một số trường cụ thể để tạo equals() và hashCode().

			import lombok.EqualsAndHashCode;
			import lombok.Getter;
			import lombok.Setter;
			@Getter
			@Setter
			@EqualsAndHashCode
			public class User {
				private Long id;
				private String name;
				private String email;
			}
			Trong ví dụ trên, chúng ta sử dụng @EqualsAndHashCode để tự động tạo các phương thức equals() và hashCode() dựa trên các trường id, name và email của lớp User.
			Khi bạn tạo một instance của lớp User và so sánh chúng, Lombok sẽ sử dụng các phương thức equals() và hashCode() được tạo tự động để so sánh các trường của các instance.
			
			User user1 = new User();
			user1.setId(1L);
			user1.setName("John Doe");
			user1.setEmail("john.doe@example.com");
			User user2 = new User();
			user2.setId(1L);
			user2.setName("John Doe");
			user2.setEmail("john.doe@example.com");
			System.out.println(user1.equals(user2)); // true
			System.out.println(user1.hashCode() == user2.hashCode()); // true		
			Trong ví dụ trên, hai instance user1 và user2 có cùng giá trị cho các trường id, name và email, nên chúng được coi là bằng nhau khi sử dụng equals() và hashCode().
			
		@Email--Annotation:

			- @Email là một annotation trong Spring Validation, một thư viện để định nghĩa và xác thực các ràng buộc đối với các thuộc tính của một lớp Java.
			- Annotation @Email được sử dụng để đảm bảo rằng một giá trị thuộc tính là một địa chỉ email hợp lệ. Khi bạn sử dụng @Email trên một trường, Spring Validation sẽ tự động kiểm tra xem giá trị của
			trường đó có phải là một địa chỉ email hợp lệ hay không.
			- Ngoài ra, @Email cũng có một số tùy chọn để bạn có thể tùy chỉnh cách xác thực địa chỉ email, chẳng hạn như:
				regexp: Cung cấp một regular expression tùy chỉnh để xác thực địa chỉ email.
				flags: Cung cấp các flag để điều chỉnh cách xác thực regular expression.
				message: Cung cấp một thông báo lỗi tùy chỉnh khi địa chỉ email không hợp lệ.

			import javax.validation.constraints.Email;
			import javax.validation.constraints.NotBlank;
			public class UserDTO {
				@NotBlank
				private String name;
				@NotBlank
				@Email
				private String email;
				// Getters, setters, and other methods
			}
			Trong ví dụ trên, chúng ta sử dụng @Email để đảm bảo rằng giá trị của trường email phải là một địa chỉ email hợp lệ. Ngoài ra, chúng ta cũng sử dụng @NotBlank để đảm bảo rằng trường name
			và email không được để trống.
			Khi bạn gửi một instance của UserDTO đến một controller trong Spring MVC, Spring Validation sẽ tự động kiểm tra các ràng buộc được định nghĩa trên các trường, bao gồm cả ràng buộc @Email. Nếu
			một trường không đáp ứng ràng buộc, Spring Validation sẽ tạo ra một validation error, và bạn có thể xử lý lỗi này trong controller.

			@PostMapping("/users")
			public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
				// Handle the validated user DTO and create a new user
				User newUser = userService.createUser(userDTO);
				return ResponseEntity.status(HttpStatus.CREATED).body(newUser);
			}
			Trong ví dụ trên, khi gửi một request với một UserDTO không hợp lệ (ví dụ, email không hợp lệ), Spring Validation sẽ tạo ra một validation error, và controller sẽ không thể xử lý request này.

		@JsonProperty--Annotation:

			- @JsonProperty là một annotation trong Spring MVC và Spring Boot, được sử dụng để định nghĩa tên của một thuộc tính khi chuyển đổi giữa Java objects và JSON formats.
			- Khi bạn sử dụng @JsonProperty trên một trường hoặc getter/setter method trong một Java class, nó sẽ chỉ định tên của thuộc tính JSON tương ứng. Điều này rất hữu ích khi tên của thuộc tính
			Java khác với tên của thuộc tính JSON.
			- Ngoài việc sử dụng @JsonProperty để đặt tên của các thuộc tính JSON, bạn cũng có thể sử dụng nó để:
				Đổi tên một thuộc tính JSON khi serializing/deserializing
				Bỏ qua một thuộc tính khi serializing/deserializing
				Chỉ định thứ tự của các thuộc tính JSON

			public class UserDTO {
				private int userId;
				@JsonProperty("user_name")
				private String userName;
				@JsonProperty("email_address")
				private String emailAddress;
				// Getters, setters, and other methods
			}
			Trong ví dụ trên, chúng ta có ba thuộc tính: userId, userName, và emailAddress. Khi chuyển đổi một instance của UserDTO sang JSON, các tên của thuộc tính JSON sẽ là "user_name" và
			"email_address", thay vì sử dụng tên của các trường Java.
			
			{
				"userId": 1,
				"user_name": "John Doe",
				"email_address": "john.doe@example.com"
			}
			Khi serializing một instance của UserDTO sang JSON
			Ngược lại, khi deserializing JSON data trở lại thành một instance của UserDTO, Spring sẽ tự động ánh xạ các thuộc tính JSON với các trường Java dựa trên tên được định nghĩa bởi @JsonProperty.
			
			public class UserDTO {
				@JsonProperty(value = "user_id", index = 0)
				private int userId;
				@JsonProperty(value = "full_name", index = 1)
				private String fullName;
				@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
				private String password;
			}
			@JsonProperty(value = "user_id", index = 0) sẽ đặt tên của thuộc tính JSON là "user_id" và chỉ định nó sẽ được serialized/deserialized đầu tiên.
			@JsonProperty(value = "full_name", index = 1) sẽ đặt tên của thuộc tính JSON là "full_name" và chỉ định nó sẽ được serialized/deserialized sau "user_id".
			@JsonProperty(access = JsonProperty.Access.WRITE_ONLY) sẽ bỏ qua thuộc tính password khi serializing (từ Java object sang JSON), nhưng vẫn cho phép nó
			được deserialize (từ JSON sang Java object).

		@JsonCreator--Annotation:
		
			- Trong Spring, đặc biệt là khi làm việc với Jackson để xử lý JSON, annotation @JsonCreator được sử dụng để chỉ định một hàm tạo (constructor) hoặc phương thức factory nào đó sẽ được sử dụng để
			khởi tạo một đối tượng từ JSON. Điều này rất hữu ích khi bạn cần kiểm soát cách thức mà Jackson tạo ra các đối tượng khi giải mã (deserialization) JSON thành các đối tượng Java.
			- Cách sử dụng @JsonCreator
				Constructor-based Deserialization: Bạn có thể sử dụng @JsonCreator trên constructor để chỉ định rằng constructor đó sẽ được sử dụng khi tạo đối tượng từ JSON.
				Factory Method-based Deserialization: Ngoài constructor, bạn cũng có thể sử dụng @JsonCreator trên một phương thức tĩnh (static factory method) để chỉ định rằng
				phương thức này sẽ được sử dụng để tạo đối tượng từ JSON.
				
			import com.fasterxml.jackson.annotation.JsonCreator;
			import com.fasterxml.jackson.annotation.JsonProperty;
			public class Person {
				private String name;
				private int age;
				@JsonCreator
				public Person(@JsonProperty("name") String name, @JsonProperty("age") int age) {
					this.name = name;
					this.age = age;
				}
				// Getters and setters
			}
			@JsonCreator được dùng để chỉ định rằng constructor này sẽ được sử dụng cho quá trình deserialization.
			@JsonProperty được sử dụng để ánh xạ các trường JSON tới các tham số của constructor.
			Với cấu trúc JSON như sau, Jackson sẽ sử dụng constructor đã được chỉ định để tạo đối tượng Person:
				{
				  "name": "John",
				  "age": 30
				}
				
		@JsonTypeInfo--Annotation:
		
			- Trong Spring (thường khi kết hợp với Jackson để xử lý JSON), annotation @JsonTypeInfo được sử dụng để thêm thông tin về kiểu (type) vào JSON khi thực hiện serialization (tuần tự hóa)
			và deserialization (giải tuần tự hóa). Annotation này rất hữu ích trong các tình huống mà bạn cần xử lý đa hình (polymorphism), chẳng hạn như khi bạn có một lớp cha (superclass) và nhiều
			lớp con (subclasses), và bạn muốn Jackson biết phải khởi tạo kiểu nào khi giải mã JSON.
			- Cách sử dụng @JsonTypeInfo
				use: Chỉ định cách thức mà thông tin kiểu được chỉ định. Một số giá trị phổ biến là:
					JsonTypeInfo.Id.CLASS: Sử dụng tên lớp Java hoàn chỉnh.
					JsonTypeInfo.Id.NAME: Sử dụng tên định nghĩa tùy chỉnh cho mỗi lớp.
					JsonTypeInfo.Id.MINIMAL_CLASS: Sử dụng tên lớp Java nhưng ở dạng rút gọn (minimal).
					JsonTypeInfo.Id.NONE: Không sử dụng thông tin kiểu.
				include: Chỉ định vị trí của thông tin kiểu trong JSON. Một số giá trị phổ biến là:
					JsonTypeInfo.As.PROPERTY: Thêm một thuộc tính vào JSON để chỉ định thông tin kiểu.
					JsonTypeInfo.As.WRAPPER_OBJECT: Bao bọc đối tượng trong một đối tượng JSON để chỉ định thông tin kiểu.
					JsonTypeInfo.As.EXTERNAL_PROPERTY: Thông tin kiểu được cung cấp bên ngoài đối tượng thực tế.
					JsonTypeInfo.As.EXISTING_PROPERTY: Sử dụng một thuộc tính hiện có để chỉ định thông tin kiểu.
				property: Tên của thuộc tính JSON được sử dụng để lưu trữ thông tin kiểu (chỉ khi include là PROPERTY hoặc EXISTING_PROPERTY).
				defaultImpl: Chỉ định một lớp mặc định nếu không có thông tin kiểu nào khớp trong quá trình deserialization.
				
			import com.fasterxml.jackson.annotation.JsonTypeInfo;
			@JsonTypeInfo(
			  use = JsonTypeInfo.Id.NAME, 
			  include = JsonTypeInfo.As.PROPERTY, 
			  property = "type"
			)
			public abstract class Animal {
				private String name;
				// Constructor, getters, and setters
			}
			public class Dog extends Animal {
				private String breed;
				// Constructor, getters, and setters
			}
			public class Cat extends Animal {
				private int lives;
				// Constructor, getters, and setters
			}
			@JsonTypeInfo được sử dụng trên lớp cha Animal.
			use = JsonTypeInfo.Id.NAME chỉ định rằng chúng ta sẽ sử dụng tên định nghĩa (như "Dog" hoặc "Cat") để biểu thị kiểu của đối tượng.
			include = JsonTypeInfo.As.PROPERTY chỉ định rằng thông tin kiểu sẽ được thêm như một thuộc tính JSON riêng biệt.
			property = "type" chỉ định tên thuộc tính JSON ("type") sẽ chứa thông tin kiểu.
			Với cấu hình này, khi chúng ta thực hiện serialization của một đối tượng Dog hoặc Cat, JSON kết quả sẽ trông như sau:
				{
				  "type": "Dog",
				  "name": "Buddy",
				  "breed": "Golden Retriever"
				}
				hoặc
				{
				  "type": "Cat",
				  "name": "Whiskers",
				  "lives": 9
				}

					
		
		@Log4j2--Annotation:

			- @Log4j2 là một annotation trong Spring Boot, được sử dụng để tạo ra một Logger instance tự động cho một class, mà không cần phải khai báo và khởi tạo nó một cách thủ công.
			- Khi bạn sử dụng @Log4j2 trên một class, Spring Boot sẽ tự động tạo ra một Logger instance với tên tương ứng với tên của class đó, và bạn có thể sử dụng Logger instance này để ghi log trong class.
			- Một số ưu điểm của việc sử dụng @Log4j2:
					Giảm Boilerplate Code: Bạn không cần phải khai báo và khởi tạo Logger instance một cách thủ công. @Log4j2 làm việc này tự động cho bạn.
					Đặt tên Logger tự động: Tên của Logger instance sẽ tự động được đặt dựa trên tên của class.
					Tích hợp tốt với Spring Boot: @Log4j2 hoạt động rất tốt với Spring Boot và có thể được sử dụng trong các ứng dụng Spring Boot.
					Sử dụng Log4j2 Library: @Log4j2 sử dụng thư viện Log4j2 để cung cấp các tính năng logging mạnh mẽ.
			
			import org.springframework.stereotype.Service;
			import org.apache.logging.log4j.LogManager;
			import org.apache.logging.log4j.Logger;
			@Service
			@Log4j2
			public class MyService {
				// Logger instance is automatically created and available as "log"
				public void doSomething() {
					log.info("Doing something...");
					try {
						// Some business logic
					} catch (Exception e) {
						log.error("Error occurred", e);
					}
				}
			}
			Trong ví dụ trên, chúng ta có một MyService class, được đánh dấu bằng @Log4j2. Bây giờ, một Logger instance với tên log sẽ được tự động tạo ra và có thể được sử dụng trong các phương thức của class.

		@Modifying--Annotation:

			- @Modifying là một annotation trong Spring Data JPA, được sử dụng để chỉ định rằng một phương thức trong interface Repository sẽ thực hiện một phép
			sửa đổi (insert, update, delete) trong cơ sở dữ liệu.
			- Khi bạn sử dụng @Modifying, Spring sẽ biết rằng phương thức này không chỉ đơn giản là truy vấn dữ liệu, mà còn có tác dụng thay đổi dữ liệu trong cơ
			sở dữ liệu. Điều này cho phép Spring thực hiện một số xử lý đặc biệt, chẳng hạn như:
				Transaction Management: Spring sẽ tự động bắt đầu một transaction trước khi thực hiện phương thức sửa đổi và commit transaction sau khi hoàn thành. Điều này
				đảm bảo tính nhất quán và an toàn của dữ liệu.
				Clearing Cache: Nếu bạn đang sử dụng caching trong ứng dụng, Spring sẽ tự động xóa các mục liên quan từ cache sau khi thực hiện phương thức sửa đổi. Điều này
				đảm bảo rằng dữ liệu trong cache luôn được cập nhật.
				Flush Mode: Spring sẽ tự động đảm bảo rằng các thay đổi được đẩy về cơ sở dữ liệu ngay lập tức sau khi phương thức sửa đổi được gọi.
			- Lưu ý rằng chúng ta cũng sử dụng @Transactional annotation để đảm bảo rằng transaction được quản lý đúng cách. Điều này là cần thiết khi sử dụng @Modifying.
			- Sử dụng @Modifying giúp bạn tránh các lỗi liên quan đến transaction và cache mà không cần phải xử lý chúng một cách thủ công. Điều này làm cho code của bạn trở
			nên gọn gàng và dễ bảo trì hơn.

			import org.springframework.data.jpa.repository.JpaRepository;
			import org.springframework.data.jpa.repository.Modifying;
			import org.springframework.data.jpa.repository.Query;
			import org.springframework.transaction.annotation.Transactional;
			public interface UserRepository extends JpaRepository<User, Long> {
				@Modifying
				@Transactional
				@Query("UPDATE User u SET u.email = :newEmail WHERE u.id = :userId")
				int updateUserEmail(Long userId, String newEmail);
				@Modifying
				@Transactional
				@Query("DELETE FROM User u WHERE u.id = :userId")
				int deleteUserById(Long userId);
			}
			updateUserEmail: Phương thức này được sử dụng để cập nhật email của một người dùng dựa trên ID. Khi gọi phương thức này, Spring sẽ tự động bắt đầu một transaction,
			cập nhật dữ liệu trong cơ sở dữ liệu, và commit transaction sau khi hoàn thành.
			deleteUserById: Phương thức này được sử dụng để xóa một người dùng dựa trên ID. Tương tự, Spring sẽ tự động xử lý transaction và các cập nhật cache (nếu có) khi
			phương thức này được gọi.

		@EnableDiscoveryClient--Annotation:

			- @EnableDiscoveryClient là một annotation trong Spring Cloud, được sử dụng để kích hoạt tính năng Discovery Client trong ứng dụng của bạn.
			- Discovery Client là một thành phần quan trọng trong việc xây dựng các hệ thống phân tán, microservices-based. Nó giúp các dịch vụ có thể tự động phát hiện và giao
			tiếp với các dịch vụ khác trong hệ thống, mà không cần phải cấu hình tĩnh địa chỉ IP hoặc hostname.
			- Khi bạn sử dụng @EnableDiscoveryClient, Spring Cloud sẽ tự động:
				Đăng ký dịch vụ: Ứng dụng của bạn sẽ được đăng ký với Discovery Server (như Eureka, Consul, hoặc Zookeeper) để các dịch vụ khác có thể tìm và gọi nó.
				Khám phá dịch vụ: Ứng dụng của bạn sẽ có khả năng tự động khám phá và giao tiếp với các dịch vụ khác đã được đăng ký với Discovery Server.
				Load Balancing: Khi gọi các dịch vụ khác, ứng dụng của bạn sẽ được hỗ trợ load balancing tự động, giúp phân tải đều giữa các instances của dịch vụ.
				Health Checking: Ứng dụng của bạn sẽ được giám sát và kiểm tra tình trạng sức khỏe (health checks) định kỳ bởi Discovery Server.
			- Sử dụng @EnableDiscoveryClient giúp đơn giản hóa việc xây dựng các hệ thống phân tán, microservices-based bằng cách tự động xử lý các vấn đề như discovery, load balancing và
			health checking. Điều này giúp code của bạn trở nên sáng sủa, dễ bảo trì và mở rộng hơn.

			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;
			import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
			@SpringBootApplication
			@EnableDiscoveryClient
			public class MyApplication {
				public static void main(String[] args) {
					SpringApplication.run(MyApplication.class, args);
				}
			}
			Trong ví dụ này, chúng ta đánh dấu class MyApplication với @EnableDiscoveryClient. Điều này sẽ kích hoạt tính năng Discovery Client trong ứng dụng, cho phép nó tự động đăng ký và khám phá
			các dịch vụ khác trong hệ thống.

			spring:
			  application:
				name: my-service
			  cloud:
				discovery:
				  client:
					simple:
					  instances:
						my-service:
						  - http://localhost:8080
			Để hoạt động, ứng dụng cần được cấu hình để kết nối với Discovery Server. Điều này có thể được thực hiện bằng cách thêm các cấu hình liên quan trong file application.properties hoặc application.yml
			Trong cấu hình trên, chúng ta đã cung cấp thông tin về dịch vụ (my-service) và địa chỉ endpoint của nó (http://localhost:8080). Khi ứng dụng khởi động, nó sẽ tự động đăng ký với Discovery Server
			và các dịch vụ khác có thể tìm và giao tiếp với nó.

		@Transient--Annotation:
		
			- @Transient là một annotation trong Spring được sử dụng để đánh dấu một trường trong một entity class sẽ không được lưu vào cơ sở dữ liệu. Nó thường được sử dụng khi bạn có một số trường dữ liệu
			trong class mà không cần lưu trữ chúng trong cơ sở dữ liệu.
			- Một số trường hợp khác khi sử dụng @Transient:
				Tính toán dữ liệu: Bạn có thể sử dụng @Transient cho các trường tính toán được dựa trên các trường khác trong entity.
				Dữ liệu tạm thời: Các trường lưu trữ dữ liệu tạm thời, không liên quan đến cơ sở dữ liệu.
				Bảo mật: Bạn có thể sử dụng @Transient cho các trường chứa thông tin nhạy cảm như mật khẩu hoặc token, để chúng không được lưu trữ trong cơ sở dữ liệu.
			- Tóm lại, @Transient là một annotation hữu ích trong Spring, cho phép bạn loại bỏ các trường không cần thiết khỏi việc lưu trữ trong cơ sở dữ liệu, giúp cải thiện hiệu suất và bảo mật của ứng dụng.

			@Entity
			@Table(name = "users")
			public class User {
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY)
				private Long id;
				private String username;
				private String password;
				@Transient
				private String confirmPassword;
				// getters, setters, and other methods
			}
			Trong ví dụ này, confirmPassword là một trường tạm thời, không cần được lưu trữ trong cơ sở dữ liệu. Nó chỉ được sử dụng trong logic của ứng dụng, như để xác nhận mật khẩu khi người dùng đăng ký.
			Lưu ý rằng, @Transient chỉ ảnh hưởng đến việc lưu trữ dữ liệu trong cơ sở dữ liệu, nhưng không ảnh hưởng đến việc sử dụng trường này trong logic ứng dụng. Trường confirmPassword vẫn có thể được
			sử dụng trong các phương thức của entity class và trong controller.
			Trong ví dụ này, confirmPassword là một trường tạm thời, không cần được lưu trữ trong cơ sở dữ liệu. Nó chỉ được sử dụng trong logic của ứng dụng, như để xác nhận mật khẩu khi người dùng đăng ký.

		@NoArgsContructor--Annotation:
		
			- @NoArgsConstructor là một annotation trong Spring được sử dụng để tự động tạo một constructor không tham số (no-args constructor) cho một class.
			- Khi bạn áp dụng @NoArgsConstructor trên một class, Spring sẽ tự động tạo một constructor không tham số cho class đó, ngay cả khi bạn không định nghĩa nó trong code.
			- Sử dụng @NoArgsConstructor có một số lợi ích:
				Tạo đối tượng mới: Khi bạn cần tạo một đối tượng mới của class, constructor không tham số sẽ rất hữu ích, ví dụ như khi sử dụng new User().
				Tích hợp với các framework: Nhiều framework như Spring, Hibernate, và các thư viện khác sử dụng constructor không tham số để tạo và thao tác với các đối tượng. Sử
				dụng @NoArgsConstructor sẽ đảm bảo rằng framework có thể hoạt động đúng cách với class của bạn.
				Serialization và deserialization: Các quá trình serialization và deserialization thường yêu cầu một constructor không tham số để tạo đối tượng mới. @NoArgsConstructor giúp
				đơn giản hóa việc này.
			- Lưu ý rằng, nếu bạn định nghĩa một constructor có tham số cho class, Spring sẽ không tự động tạo constructor không tham số. Trong trường hợp này, bạn có thể sử
			dụng @NoArgsConstructor(force = true) để buộc Spring tạo constructor không tham số.
			- Tóm lại, @NoArgsConstructor là một annotation hữu ích trong Spring để đơn giản hóa việc tạo và quản lý các đối tượng, đặc biệt khi làm việc với các framework và quá trình serialization.

			@Entity
			@Table(name = "users")
			@NoArgsConstructor
			public class User {
				@Id
				@GeneratedValue(strategy = GenerationType.IDENTITY)
				private Long id;
				private String username;
				private String email;
				public User(String username, String email) {
					this.username = username;
					this.email = email;
				}
				// Getters, setters, and other methods
			}
			Trong ví dụ trên, class User có một constructor có tham số và một constructor không tham số. Tuy nhiên, nhờ có @NoArgsConstructor, Spring sẽ tự động tạo ra constructor không tham số cho class này, ngay cả
			khi bạn không định nghĩa nó.

		@AllArgsConstructor--Annotation:
		
			- @AllArgsConstructor là một annotation Lombok, được sử dụng để tự động tạo một constructor có tất cả các tham số của một class. Nó sẽ tạo một constructor với tất cả
			các trường của class làm tham số.
			- Sử dụng @AllArgsConstructor có các lợi ích sau:
				Giảm code boilerplate: Bạn không cần phải tự định nghĩa constructor có tất cả các tham số, Lombok sẽ tự động tạo nó cho bạn.
				Tích hợp với các framework: Nhiều framework như Spring, Hibernate yêu cầu constructor có tất cả các trường làm tham số. @AllArgsConstructor giúp đơn giản hóa việc này.
				Tăng tính rõ ràng: Khi tạo một đối tượng mới, bạn sẽ biết chính xác các trường cần được khởi tạo.

			import lombok.AllArgsConstructor;
			import lombok.Data;
			@Data
			@AllArgsConstructor
			public class User {
				private Long id;
				private String username;
				private String email;
			}
			
			Trong ví dụ trên, Lombok sẽ tự động tạo một constructor có tất cả các trường của class User làm tham số:
			public User(Long id, String username, String email) {
				this.id = id;
				this.username = username;
				this.email = email;
			}

		@Documented--Annotation:
		
			- Trong Spring, @Documented là một annotation được sử dụng để đánh dấu các annotation khác. Nó không có bất kỳ tác dụng trực tiếp nào đối với các class, method, hay field
			được đánh dấu. Thay vào đó, nó đóng vai trò như một metatag để chỉ ra rằng annotation được gắn với nó sẽ được bao gồm trong Javadoc của phần tử được anotationed.
			- Tóm lại, @Documented là một annotation meta-annotation trong Spring, được sử dụng để đánh dấu các annotation khác nhằm đảm bảo chúng được bao gồm trong Javadoc của các phần tử được anotationed.
			- Một số ứng dụng của @JsonIgnoreProperty:
				Loại bỏ các thuộc tính nhạy cảm như mật khẩu, token, v.v. khỏi JSON output: Điều này giúp tăng cường bảo mật cho ứng dụng.
				
			
			@Documented
			@Retention(RetentionPolicy.RUNTIME)
			@Target({ElementType.TYPE, ElementType.METHOD})
			public @interface MyCustomAnnotation {
				String value();
			}	
			Khi bạn sử dụng @MyCustomAnnotation trên một class hoặc method, thông tin về annotation này sẽ được hiển thị trong Javadoc của phần tử được anotationed. Điều này giúp người dùng
			dễ dàng nhận biết và hiểu được ý nghĩa của annotation.
			Ngoài ra, @Documented cũng có thể được sử dụng với các annotation có sẵn trong Spring, như @Component, @Service, @Repository, v.v. Điều này giúp các annotation này được lưu lại
			trong Javadoc của các class, method, và field được đánh dấu.
			Việc sử dụng @Documented không làm thay đổi bất kỳ hành vi hay tính năng nào của các annotation. Thay vào đó, nó chỉ đơn giản là một cách để đảm bảo rằng các annotation được
			lưu lại và hiển thị trong các tài liệu Javadoc.
	
	
		@JsonIgnoreProperty--Annotation:
		
			- Annotation @JsonIgnoreProperty trong Spring được sử dụng để chỉ định các thuộc tính của một class sẽ bị bỏ qua khi serialize/deserialize JSON.
			- Một số ứng dụng của @JsonIgnoreProperty:
				Loại bỏ các thuộc tính nhạy cảm như mật khẩu, token, v.v. khỏi JSON output: Điều này giúp tăng cường bảo mật cho ứng dụng.
				Bỏ qua các thuộc tính không cần thiết khi serialize/deserialize: Giúp giảm kích thước dữ liệu được truyền đi.
				Xử lý các trường hợp không tương thích giữa cấu trúc JSON và class: Ví dụ khi JSON có thuộc tính không khớp với class.
			
			public class User {
				private int id;
				private String name;
				@JsonIgnoreProperty
				private String password;
				private String email;
			}
			Khi serialize một đối tượng User thành JSON, thuộc tính password sẽ không được bao gồm trong JSON output:
			{
				"id": 1,
				"name": "John Doe",
				"email": "john.doe@example.com"
			}
			Ngược lại, khi deserialize một JSON object thành đối tượng User, thuộc tính password sẽ không được gán giá trị.
	
		@EntityScan--Annotation:
		
			- Annotation @EntityScan trong Spring là một annotation dùng để chỉ định các package chứa các thực thể (entity) JPA trong ứng dụng.
			- Khi sử dụng JPA (Java Persistence API) trong một ứng dụng Spring, Spring sẽ cần biết các entity class được sử dụng trong ứng dụng để có thể quản lý và thao tác với
			chúng. Thông thường, Spring sẽ tự động quét các package để tìm các entity class, nhưng trong một số trường hợp, chúng ta cần chỉ định rõ ràng các package chứa các entity.
			- Ngoài ra, @EntityScan cũng có thể được sử dụng để chỉ định các entity class cụ thể
			- Annotation @EntityScan thường được sử dụng khi:
				Các entity class không được đặt trong package mặc định hoặc các package con của package gốc.
				Cần chỉ định danh sách các entity class cụ thể.
				Muốn tách biệt các entity class thành các package riêng biệt.
	
			@SpringBootApplication
			@EntityScan(basePackages = {"com.example.myapp.entities"})
			public class MyApplication {
				// ...
			}	
			Trong ví dụ trên, @EntityScan chỉ định rằng các entity class được định nghĩa trong package com.example.myapp.entities và các sub-package của nó.
	
			@SpringBootApplication
			@EntityScan(basePackageClasses = {User.class, Order.class})
			public class MyApplication {
				// ...
			}
			Trong trường hợp này, Spring sẽ quét các package chứa các class User và Order để tìm các entity class.
	
		@EnableJpaRepositories--Annotation:
		
			- Annotation @EnableJpaRepositories trong Spring là một annotation dùng để kích hoạt tính năng JPA Repository trong một ứng dụng Spring.
			- Khi sử dụng JPA (Java Persistence API) trong ứng dụng Spring, chúng ta thường sử dụng các Repository interface để thực hiện các thao tác
			CRUD (Create, Read, Update, Delete) trên các entity. Spring Data JPA cung cấp một cách tiếp cận rất tiện lợi để triển khai các Repository interface này.
			- Annotation @EnableJpaRepositories cho phép Spring tự động tạo ra các implementation classes cho các interface Repository, dựa trên các quy ước đặt
			tên và các phương thức được định nghĩa trong interface.
			- Ngoài ra, @EnableJpaRepositories cũng có một số tùy chọn khác như:
				entityManagerFactoryRef: Tham chiếu đến bean EntityManagerFactory cần sử dụng.
				transactionManagerRef: Tham chiếu đến bean PlatformTransactionManager cần sử dụng.
				repositoryImplementationPostfix: Đặt hậu tố cho các implementation class của Repository.
			- Annotation @EnableJpaRepositories là một phần quan trọng trong việc cấu hình và kích hoạt tính năng JPA Repository trong ứng dụng Spring. Nó giúp đơn giản
			hóa quá trình triển khai các Repository interface và tự động tạo ra các implementation class.
			
			@SpringBootApplication
			@EnableJpaRepositories(basePackages = "com.example.myapp.repositories")
			public class MyApplication {
				// ...
			}	
			Trong ví dụ trên, @EnableJpaRepositories chỉ định rằng các interface Repository được định nghĩa trong package com.example.myapp.repositories và các sub-package của nó.
	
			@SpringBootApplication
			@EnableJpaRepositories(
				basePackages = "com.example.myapp.repositories",
				entityManagerFactoryRef = "customEntityManagerFactory",
				transactionManagerRef = "customTransactionManager"
			)
			public class MyApplication {
				// ...
			}
			Trong ví dụ trên, @EnableJpaRepositories chỉ định rằng các Repository interface được định nghĩa trong package com.example.myapp.repositories, sử dụng
			customEntityManagerFactory và customTransactionManager beans.
	
	
		@Retention--Annotation:
		
			- Annotation @Retention trong Java (và cũng được sử dụng trong Spring) là một annotation dùng để chỉ định ở mức độ nào (retention policy) một annotation có thể được giữ lại.
			- Có 3 mức độ retention policy được xác định bởi @Retention:
				SOURCE: Annotation chỉ tồn tại ở mức mã nguồn (source code) và sẽ bị bỏ đi khi được biên dịch.
				CLASS: Annotation sẽ được lưu trong file class, nhưng không được runtime environment sử dụng.
				RUNTIME: Annotation sẽ được lưu trong file class và có thể được runtime environment sử dụng, ví dụ như Spring có thể truy cập và sử dụng các annotation này.
			- Ví dụ, trong Spring, một số annotation phổ biến sử dụng @Retention(RetentionPolicy.RUNTIME) như:
				@Component: Đánh dấu một class là một Spring bean.
				@Autowired: Đánh dấu một field, constructor hoặc method để Spring tự động wired dependency.
				@RequestMapping: Đánh dấu một method trong controller class để định nghĩa URL mapping.
			- Bằng cách sử dụng @Retention(RetentionPolicy.RUNTIME), Spring có thể truy cập và sử dụng các annotation này trong quá trình khởi chạy và chạy ứng dụng.
			- Trong khi đó, một số annotation khác chỉ cần tồn tại ở mức mã nguồn, ví dụ như:
				@Deprecated: Đánh dấu một phần của code là đã lỗi thời và không nên sử dụng.
				@SuppressWarnings: Chỉ thị cho trình biên dịch bỏ qua một số cảnh báo.
			- Những annotation này sử dụng @Retention(RetentionPolicy.SOURCE) vì chúng chỉ cần được biên dịch, chứ không cần được runtime environment sử dụng.
			- Việc lựa chọn mức độ retention policy phù hợp là rất quan trọng trong quá trình thiết kế và sử dụng annotation, bởi vì nó ảnh hưởng đến việc annotation đó có thể được truy
			cập và sử dụng ở các giai đoạn khác nhau của vòng đời ứng dụng.
			- Khi bạn muốn tạo một annotation tùy chỉnh trong Java, bạn có thể sử dụng @Retention để chỉ định thời gian tồn tại của nó.
			
			import java.lang.annotation.Retention;
			import java.lang.annotation.RetentionPolicy;
			// Định nghĩa annotation tùy chỉnh
			@Retention(RetentionPolicy.RUNTIME)
			public @interface MyCustomAnnotation {
				String value();
			}
			Trong ví dụ này, annotation MyCustomAnnotation sẽ tồn tại tại runtime, có nghĩa là nó có thể được truy cập thông qua reflection.
	
		@TaskFlowOder--Annotation:
	
			- Trong Spring, chúng ta có thể sử dụng @TaskFlowOrder để chỉ định thứ tự thực hiện của các task trong một flow.
			- Để sử dụng @TaskFlowOrder, ta cần:
				Trong lớp định nghĩa task, thêm @TaskFlowOrder(n) với n là số nguyên chỉ định thứ tự thực hiện.
				Trong lớp chủ quản (ví dụ: controller, service, etc.) gọi các task theo thứ tự đã được chỉ định bằng @TaskFlowOrder.
			- Việc sử dụng @TaskFlowOrder giúp ta dễ dàng quản lý và kiểm soát thứ tự thực hiện các task trong một flow, đồng thời cũng giúp code trở nên dễ đọc và bảo trì hơn.
			- Annotation @TaskFlowOrder trong Spring có các thuộc tính sau:
				value: Một số nguyên dương chỉ định thứ tự thực hiện của task. Các task sẽ được thực hiện theo thứ tự tăng dần của giá trị value.
				description: Một chuỗi mô tả về task. Thuộc tính này không ảnh hưởng đến thứ tự thực hiện, mà chỉ dùng để mô tả và lưu trữ thông tin về task.
				dependencies: Một mảng các class để chỉ định các task mà task hiện tại phụ thuộc vào. Khi sử dụng thuộc tính này, Spring sẽ đảm bảo các task phụ
				thuộc được thực hiện trước khi thực hiện task hiện tại.
	
			@Component
			@TaskFlowOrder(1)
			public class Task1 implements TaskExecutor {
				// Implement the logic for Task1
			}
			@Component
			@TaskFlowOrder(2)
			public class Task2 implements TaskExecutor {
				// Implement the logic for Task2
			}
			@Component
			@TaskFlowOrder(3)
			public class Task3 implements TaskExecutor {
				// Implement the logic for Task3
			}
			Trong ví dụ trên, Task1 sẽ được thực hiện trước Task2, và Task2 sẽ được thực hiện trước Task3.
	
			@Service
			public class TaskFlowService {
				private final List<TaskExecutor> taskExecutors;
				public TaskFlowService(List<TaskExecutor> taskExecutors) {
					this.taskExecutors = taskExecutors;
				}
				public void executeTaskFlow() {
					taskExecutors.stream()
							.sorted(Comparator.comparingInt(t -> t.getClass().getAnnotation(TaskFlowOrder.class).value()))
							.forEach(TaskExecutor::execute);
				}
			}	
			Trong ví dụ trên, chúng ta sử dụng Stream và sorted() để sắp xếp các TaskExecutor theo thứ tự được chỉ định bằng @TaskFlowOrder, sau đó gọi phương
			thức execute() của từng task theo đúng thứ tự.
			
			@Component
			@TaskFlowOrder(1)
			public class Task1 implements TaskExecutor {
				// Implement the logic for Task1
			}
			@Component
			@TaskFlowOrder(2)
			public class Task2 implements TaskExecutor {
				// Implement the logic for Task2
			}
			
			@Component
			@TaskFlowOrder(value = 1, description = "Initialize the database connection")
			public class Task1 implements TaskExecutor {
				// Implement the logic for Task1
			}
	
			@Component
			@TaskFlowOrder(value = 2, dependencies = {Task1.class, Task3.class})
			public class Task2 implements TaskExecutor {
				// Implement the logic for Task2
			}
	
		@Mapper--Annotation:
		
			- Annotation @Mapper trong Spring là một phần của Spring Data Mybatis, được sử dụng để định nghĩa một interface làm nhiệm vụ ánh xạ dữ liệu từ database
			sang các đối tượng Java và ngược lại.
			- Khi một interface được đánh dấu với @Mapper, Spring sẽ tự động tạo ra một implementation class cho interface đó, cung cấp các phương thức để thực hiện
			các truy vấn SQL và ánh xạ dữ liệu.
			- Một số thuộc tính chính của @Mapper:
				componentModel: Xác định component model được sử dụng cho Mapper, thường là "spring".
				MapperScan: Dùng để chỉ định gói chứa các Mapper interface.
				MapperScannerConfigurer: Dùng để cấu hình các tùy chọn cho MapperScan.
			- Việc sử dụng @Mapper giúp giảm thiểu code lặp lại và dễ dàng tích hợp Mybatis vào trong ứng dụng Spring.
	
			@Mapper(componentModel = "spring")
			public interface UserMapper {
				@Select("SELECT * FROM users WHERE id = #{id}")
				User getUserById(int id);
				@Insert("INSERT INTO users(name, email) VALUES(#{name}, #{email})")
				int insertUser(User user);
			}
			Trong ví dụ trên, UserMapper là một interface được đánh dấu bằng @Mapper. Nó có các phương thức để truy vấn thông tin về user từ database và thêm mới user vào database.
			Spring sẽ tự động tạo ra một implementation class cho UserMapper và quản lý nó như một Spring bean. Các phương thức trong UserMapper sẽ được thực thi bằng các truy vấn SQL tương ứng.
			
		@SpringBootTest--Annotation:

			- Annotation @SpringBootTest trong Spring Boot được sử dụng để tạo ra một môi trường testing hoàn chỉnh cho ứng dụng Spring Boot của bạn.
			- Khi sử dụng @SpringBootTest, Spring sẽ tạo ra một ApplicationContext hoàn chỉnh, tương tự như khi khởi chạy ứng dụng trong môi trường production. Điều này giúp bạn có
			thể thực hiện các test case một cách chính xác và đầy đủ.
			- Một số thuộc tính chính của @SpringBootTest:
				webEnvironment: Xác định loại web environment được sử dụng trong test. Có các giá trị như MOCK, RANDOM_PORT, DEFINED_PORT, NONE.
				properties: Cho phép khai báo các property cần thiết cho test.
				classes: Chỉ định các class cần được loaded trong application context.
				components: Chỉ định các component cần được mocking.
			- Với @SpringBootTest, bạn có thể thực hiện các test case một cách đầy đủ, bao gồm các tương tác với database, các service, controller, etc. Điều này giúp đảm bảo rằng ứng dụng
			của bạn hoạt động chính xác khi được triển khai trong môi trường production.
			
			@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
			class MyServiceTests {
				@Autowired
				private MyService myService;
				@LocalServerPort
				private int randomPort;
				@Test
				void testMyService() {
					// Write your test cases here
					assertThat(myService.doSomething()).isEqualTo("expected_result");
					// ...
				}
			}
			webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT: Chỉ định rằng ứng dụng sẽ được khởi chạy trên một cổng ngẫu nhiên.
			@Autowired được sử dụng để inject MyService vào test case.
			@LocalServerPort được sử dụng để lấy cổng ngẫu nhiên mà ứng dụng đang chạy trên.
			
		@Test--Annotation:

			- Trong Spring, @Test là một annotation được sử dụng để đánh dấu một phương thức là một unit test. Nó được sử dụng trong kết hợp với các framework
			kiểm thử như JUnit để viết các unit test cho ứng dụng Spring.
			- Khi chạy unit test này, framework kiểm thử (như JUnit) sẽ tự động thực thi phương thức đánh dấu bằng @Test và kiểm tra xem kết quả có đúng với mong đợi hay không.
			- Bạn có thể sử dụng @Test annotation kết hợp với các annotation khác như @BeforeEach, @AfterEach, @BeforeAll, @AfterAll để thiết lập và dọn dẹp môi trường
			trước và sau khi chạy các unit test.
			
			import org.junit.jupiter.api.Test;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.test.context.SpringBootTest;
			@SpringBootTest
			public class MyServiceTest {
				@Autowired
				private MyService myService;
				@Test
				public void testMyService() {
					// Arrange
					String input = "Hello, world!";
					// Act
					String output = myService.processString(input);
					// Assert
					assertEquals("HELLO, WORLD!", output);
				}
			}
			@SpringBootTest annotation được sử dụng để đánh dấu lớp là một Spring Boot test case.
			@Autowired annotation được sử dụng để tự động liên kết MyService vào test case.
			@Test annotation được sử dụng để đánh dấu phương thức testMyService() là một unit test.
			Trong phương thức testMyService(), ta thực hiện các bước sau:
				Arrange: Chuẩn bị dữ liệu đầu vào.
				Act: Gọi phương thức processString() của MyService.
				Assert: Kiểm tra xem kết quả trả về có đúng với kỳ vọng không.
			
		@ToString--Annotation:

			- Trong Spring, @ToString là một annotation được sử dụng để tạo ra một phương thức toString() mặc định cho một lớp. Khi được sử dụng, @ToString sẽ tự
			động tạo ra phương thức toString() và hiển thị các trường của lớp.
			- Ngoài ra, @ToString annotation cũng có một số tùy chọn để định cấu hình cách hiển thị của phương thức toString(), chẳng hạn như:
				includeFieldNames: Thiết lập xem có hiển thị tên trường hay không.
				includeStatics: Thiết lập xem có hiển thị các trường static hay không.
				callSuper: Thiết lập xem có gọi phương thức toString() của lớp cha hay không.
			
			import lombok.ToString;
			@ToString
			public class MyClass {
				private String name;
				private int age;
				public MyClass(String name, int age) {
					this.name = name;
					this.age = age;
				}
				// Các phương thức getter/setter
			}
			
			Khi sử dụng @ToString, Spring sẽ tự động tạo ra một phương thức toString() với nội dung như sau:
			public String toString() {
				return "MyClass(name=" + this.getName() + ", age=" + this.getAge() + ")";
			}
			
			Khi bạn in ra một đối tượng của MyClass, kết quả sẽ giống như:
			MyClass(name=John, age=30)
			
			@ToString(includeFieldNames = false, callSuper = true)
			public class MyClass extends ParentClass {
				// ...
			}

		@ApiImplicitParams--Annotation:
		
			- @ApiImplicitParams là một annotation trong Spring được sử dụng để mô tả các tham số đầu vào của một API endpoint trong Swagger documentation.
			- Annotation này được sử dụng khi bạn muốn mô tả các tham số không phải là path variables hoặc request bodies. Ví dụ, các tham số được truyền qua
			query parameters, headers, form data, etc.
			- Khi sử dụng Swagger UI, các tham số được mô tả bởi @ApiImplicitParams sẽ được hiển thị trong phần "Parameters" của API endpoint, giúp người dùng dễ dàng hiểu và sử dụng API.
			- Lưu ý rằng, @ApiImplicitParams chỉ được sử dụng khi bạn không thể sử dụng @RequestParam hoặc @RequestBody annotations để mô tả các tham số đầu vào. Đối với các tham số được truyền
			qua URL path, bạn có thể sử dụng @PathVariable annotation.

			import io.swagger.annotations.ApiImplicitParam;
			import io.swagger.annotations.ApiImplicitParams;
			import io.swagger.annotations.ApiOperation;
			import org.springframework.http.ResponseEntity;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RequestParam;
			import org.springframework.web.bind.annotation.RestController;
			@RestController
			@RequestMapping("/api/users")
			public class UserController {
				@GetMapping
				@ApiOperation(value = "Get users")
				@ApiImplicitParams({
					@ApiImplicitParam(name = "name", dataType = "string", paramType = "query", value = "User's name"),
					@ApiImplicitParam(name = "age", dataType = "integer", paramType = "query", value = "User's age")
				})
				public ResponseEntity<String> getUsers(@RequestParam(required = false) String name,
													  @RequestParam(required = false) Integer age) {
					// Implement your logic here
					return ResponseEntity.ok("Users retrieved");
				}
			}
			@ApiImplicitParams annotation được sử dụng để mô tả các tham số đầu vào của API endpoint getUsers().
			Bên trong @ApiImplicitParams, có hai @ApiImplicitParam annotations, mỗi annotation mô tả một tham số đầu vào:
				name: Tên của tham số
				dataType: Kiểu dữ liệu của tham số
				paramType: Loại tham số (query, header, form, path, ...)
				value: Mô tả ngắn gọn về tham số
				
		@Before--Annotation:

			- @Before là một annotation trong Spring Framework được sử dụng để chỉ định một phương thức nên được thực thi trước khi một phương thức khác được gọi. Nó thường được
			sử dụng trong lập trình hướng khía cạn (Aspect-Oriented Programming - AOP) để thực hiện các tác vụ chung như logging, validations, transaction management, etc.
			- Bạn có thể sử dụng nhiều @Before annotations để thực hiện nhiều tác vụ trước khi một phương thức được gọi. Ngoài ra, bạn cũng có thể sử dụng các annotation khác
			như @After, @Around, @AfterReturning, @AfterThrowing để thực hiện các tác vụ khác.

			import org.aspectj.lang.JoinPoint;
			import org.aspectj.lang.annotation.Aspect;
			import org.aspectj.lang.annotation.Before;
			import org.springframework.stereotype.Component;
			@Aspect
			@Component
			public class LoggingAspect {
				@Before("execution(* com.example.service.*.*(..))")
				public void logMethodCall(JoinPoint joinPoint) {
					String methodName = joinPoint.getSignature().getName();
					Object[] args = joinPoint.getArgs();

					System.out.println("Calling method: " + methodName + " with arguments: " + args);
				}
			}
			@Aspect annotation chỉ định lớp LoggingAspect là một lớp khía cạn (Aspect).
			@Component annotation chỉ định lớp LoggingAspect là một bean Spring.
			@Before annotation chỉ định rằng phương thức logMethodCall() sẽ được thực thi trước khi bất kỳ phương thức nào trong com.example.service package được gọi.
			Khi một phương thức trong com.example.service package được gọi, phương thức logMethodCall() sẽ được thực thi trước, in ra thông tin về phương thức được gọi.
			Trong phương thức logMethodCall():
				JoinPoint đối tượng được sử dụng để lấy thông tin về phương thức đang được gọi, chẳng hạn như tên phương thức và các đối số.
				
		@Mockbean--Annotation:
		
			- @MockBean là một annotation trong Spring Boot Test để tạo và cấu hình các mock object cho các bean được sử dụng trong các unit test.
			- Khi sử dụng @MockBean, Spring sẽ tự động tạo một mock object và gắn nó vào application context để thay thế cho bean thực sự. Điều này rất hữu ích khi bạn
			muốn kiểm tra một component mà không phụ thuộc vào các dependencies của nó.

			import org.junit.jupiter.api.Test;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.test.context.SpringBootTest;
			import org.springframework.boot.test.mock.mockito.MockBean;
			import com.example.service.UserService;
			import com.example.model.User;
			import static org.mockito.Mockito.when;
			import static org.junit.jupiter.api.Assertions.assertEquals;
			@SpringBootTest
			public class UserControllerTest {
				@Autowired
				private UserController userController;
				@MockBean
				private UserService userService;
				@Test
				public void testGetUser() {
					User mockUser = new User(1, "John Doe");
					when(userService.getUser(1)).thenReturn(mockUser);
					User user = userController.getUser(1);
					assertEquals(mockUser, user);
				}
			}
			@SpringBootTest annotation được sử dụng để tạo một ứng dụng Spring Boot hoàn chỉnh để chạy test.
			@Autowired annotation được sử dụng để tự động inject UserController vào test case.
			@MockBean annotation được sử dụng để tạo một mock UserService bean và đăng ký nó vào application context.
			Trong phương thức testGetUser():
				Khi userService.getUser(1) được gọi, mock object sẽ trả về mockUser.
				Sau đó, test case kiểm tra xem userController.getUser(1) có trả về đúng mockUser hay không.
				
		@Api--Annotation:

			- @Api là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin về một API endpoint.
			- Khi sử dụng @Api, bạn có thể cung cấp các thông tin sau:
				value: Mô tả về API endpoint.
				description: Mô tả chi tiết về API endpoint.
				tags: Nhóm các API endpoints liên quan với nhau.
				produces: Định nghĩa các media types mà API endpoint có thể trả về.
				consumes: Định nghĩa các media types mà API endpoint có thể nhận vào.
				protocols: Định nghĩa các protocols mà API endpoint hỗ trợ (HTTP, HTTPS, v.v.).
				authorizations: Định nghĩa các authorization schemes mà API endpoint sử dụng.
				hidden: Ẩn API endpoint khỏi Swagger UI.
			- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho
			các developer dễ dàng hiểu và sử dụng API.
				
			import io.swagger.annotations.Api;
			import io.swagger.annotations.ApiOperation;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RestController;
			@Api(value = "User API", description = "Provides operations to manage users")
			@RequestMapping("/api/users")
			@RestController
			public class UserController {
				@ApiOperation(value = "Get all users", notes = "Returns a list of all users")
				@GetMapping
				public List<User> getAllUsers() {
					// implementation
				}
				@ApiOperation(value = "Get a user by ID", notes = "Returns a user with the specified ID")
				@GetMapping("/{id}")
				public User getUserById(@PathVariable Long id) {
					// implementation
				}
			}
			@Api được sử dụng để mô tả chung về API endpoint, bao gồm tên, mô tả và các media types được hỗ trợ.
			@ApiOperation được sử dụng để mô tả chi tiết về từng phương thức trong controller, bao gồm tên, mô tả và các thông tin khác.
				
		@ApiOperation--Annotation:

			- @ApiOperation là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin chi tiết về một phương thức (method) trong một REST API controller.
			- Khi sử dụng @ApiOperation, bạn có thể cung cấp các thông tin sau:
				value: Mô tả ngắn về chức năng của phương thức.
				notes: Mô tả chi tiết về chức năng của phương thức.
				response: Định nghĩa kiểu dữ liệu trả về của phương thức.
				responseContainer: Định nghĩa kiểu dữ liệu chứa kết quả trả về (ví dụ: List, Set, Map, v.v.).
				responseReference: Định nghĩa một model reference cho kết quả trả về.
				produces: Định nghĩa các media types mà phương thức có thể trả về.
				consumes: Định nghĩa các media types mà phương thức có thể nhận vào.
				tags: Nhóm phương thức vào các tag tương ứng.
				code: Định nghĩa các HTTP status code mà phương thức có thể trả về.
				nickname: Định nghĩa một nickname cho phương thức.
			- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho các developer dễ dàng hiểu và sử dụng API.
				
				import io.swagger.annotations.Api;
				import io.swagger.annotations.ApiOperation;
				import org.springframework.web.bind.annotation.GetMapping;
				import org.springframework.web.bind.annotation.PathVariable;
				import org.springframework.web.bind.annotation.RequestMapping;
				import org.springframework.web.bind.annotation.RestController;
				@Api(value = "User API", description = "Provides operations to manage users")
				@RequestMapping("/api/users")
				@RestController
				public class UserController {
					@ApiOperation(value = "Get all users", notes = "Returns a list of all users")
					@GetMapping
					public List<User> getAllUsers() {
						// implementation
					}
					@ApiOperation(value = "Get a user by ID", notes = "Returns a user with the specified ID")
					@GetMapping("/{id}")
					public User getUserById(@PathVariable Long id) {
						// implementation
					}
				}				
				@ApiOperation được sử dụng để mô tả chi tiết về từng phương thức trong controller, bao gồm tên, mô tả, kiểu dữ liệu trả về và các thông tin khác.
				@Api được sử dụng để mô tả chung về API endpoint, bao gồm tên, mô tả và các media types được hỗ trợ.
				
		@ApiModelProperty--Annotation:

			- @ApiModelProperty là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin chi tiết về một
			trường (field) trong một model class.
			- Khi sử dụng @ApiModelProperty, bạn có thể cung cấp các thông tin sau:
				value: Mô tả ngắn về trường.
				name: Tên của trường.
				required: Chỉ ra liệu trường này có bắt buộc phải có giá trị hay không.
				dataType: Định nghĩa kiểu dữ liệu của trường.
				example: Cung cấp một ví dụ giá trị của trường.
				allowableValues: Chỉ ra các giá trị được phép của trường.
				access: Chỉ ra trường này có thể truy cập (read/write) như thế nào.
				position: Xác định vị trí của trường trong mô tả model.
				notes: Cung cấp thêm thông tin mô tả về trường.
				reference: Tham chiếu đến một model khác.
			- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho
			các developer dễ dàng hiểu và sử dụng API.
				
			import io.swagger.annotations.ApiModel;
			import io.swagger.annotations.ApiModelProperty;
			@ApiModel(description = "User model")
			public class User {
				@ApiModelProperty(
					value = "User ID",
					required = true,
					dataType = "long",
					example = "1234",
					position = 1
				)
				private Long id;
				@ApiModelProperty(
					value = "User name",
					required = true,
					dataType = "string",
					example = "John Doe",
					position = 2
				)
				private String name;
				@ApiModelProperty(
					value = "User email",
					required = true,
					dataType = "string",
					example = "john.doe@example.com",
					position = 3
				)
				private String email;
				// getters, setters, and other methods
			}
			@ApiModel được sử dụng để mô tả chung về model class, bao gồm tên và mô tả.
			@ApiModelProperty được sử dụng để mô tả chi tiết về từng trường trong model class, bao gồm tên, mô tả, kiểu dữ liệu, ví dụ và các thông tin khác.
				
		@ServletComponentScan--Annotation:

			- @ServletComponentScan là một annotation trong Spring framework được sử dụng để tự động đăng ký các servlet, filter và listener được khai báo
			bằng annotation @WebServlet, @WebFilter và @WebListener.
			- Sử dụng @ServletComponentScan giúp đơn giản hóa quá trình cấu hình ứng dụng web, đặc biệt là trong các ứng dụng Spring Boot. Nó giúp tách biệt các định nghĩa
			servlet, filter và listener ra khỏi cấu hình chung của ứng dụng, tăng tính modularization và dễ dàng bảo trì hơn.
				
			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;
			import org.springframework.boot.web.servlet.ServletComponentScan;
			@SpringBootApplication
			@ServletComponentScan
			public class MyApplication {
				public static void main(String[] args) {
					SpringApplication.run(MyApplication.class, args);
				}
			}				
			@ServletComponentScan đánh dấu Spring sẽ tự động quét và đăng ký các servlet, filter và listener được khai báo bằng các annotation @WebServlet, @WebFilter và @WebListener.	
				
			import javax.servlet.annotation.WebServlet;
			import javax.servlet.http.HttpServlet;
			import javax.servlet.http.HttpServletRequest;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;
			@WebServlet(urlPatterns = "/hello")
			public class HelloServlet extends HttpServlet {
				@Override
				protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
					response.getWriter().write("Hello from HelloServlet!");
				}
			}				
			Trong ví dụ trên, servlet HelloServlet được khai báo bằng @WebServlet với URL pattern /hello. Khi ứng dụng được khởi chạy, Spring sẽ tự động đăng ký servlet này mà
			không cần phải khai báo trong web.xml.	
				
		@DisplayName--Annotation:

			- @DisplayName là một annotation trong Spring Framework, được sử dụng để cung cấp một tên hiển thị cho các test case trong unit test.	
			- Khi sử dụng @DisplayName, thay vì sử dụng tên của phương thức test làm tên hiển thị, bạn có thể cung cấp một tên mô tả rõ ràng hơn cho test case.
			- Khi chạy các test case này, trình chạy test (như JUnit) sẽ hiển thị tên được định nghĩa bằng @DisplayName thay vì tên phương thức. Điều này giúp tăng tính đọc
			hiểu và dễ dàng theo dõi kết quả test.
			- Sử dụng @DisplayName là một cách tốt để làm cho các test case trở nên rõ ràng và dễ hiểu hơn, đặc biệt là trong các dự án lớn với nhiều test case. Nó giúp tăng
			tính đọc hiểu và dễ bảo trì của bộ test.
				
			import org.junit.jupiter.api.DisplayName;
			import org.junit.jupiter.api.Test;
			class MyServiceTest {
				@Test
				@DisplayName("Test add method with positive numbers")
				void testAddPositiveNumbers() {
					// test code
				}
				@Test
				@DisplayName("Test add method with negative numbers")
				void testAddNegativeNumbers() {
					// test code
				}
			}				
			Trong ví dụ này, thay vì sử dụng tên phương thức là testAddPositiveNumbers và testAddNegativeNumbers, chúng ta đã sử dụng @DisplayName để cung cấp tên mô tả rõ ràng hơn cho mỗi test case.	
				
		@FeignClient--Annotation:

			- @FeignClient là một annotation trong Spring Cloud, được sử dụng để tạo ra một client proxy cho các RESTful web service. Nó cho phép bạn định nghĩa và cấu hình một client
			để gọi các API từ các dịch vụ khác.
			- Một số thuộc tính quan trọng của @FeignClient bao gồm:
				name: Đặt tên cho client, được sử dụng để tham chiếu đến nó trong các lớp khác.
				url: Cung cấp URL base của dịch vụ mà client sẽ gọi đến.
				configuration: Cho phép bạn cung cấp một lớp cấu hình tùy chỉnh cho client.
				fallback: Chỉ định một lớp fallback để xử lý trường hợp lỗi khi gọi API.
				path: Chỉ định một đường dẫn chung cho tất cả các phương thức trong client.
			- Khi sử dụng @FeignClient, bạn cũng có thể kết hợp với các annotation khác như @GetMapping, @PostMapping, @PutMapping, v.v. để định nghĩa các phương thức gọi API.
			- Bằng cách sử dụng @FeignClient, bạn có thể tạo ra các client proxy một cách dễ dàng, giúp tách biệt logic gọi API ra khỏi các lớp business logic trong ứng dụng. Điều này
			giúp mã nguồn trở nên gọn gàng, dễ bảo trì và dễ mở rộng hơn.	
				
			import org.springframework.cloud.openfeign.FeignClient;
			import org.springframework.web.bind.annotation.GetMapping;
			@FeignClient(name = "userService", url = "http://example.com/api/users")
			public interface UserServiceClient {
				@GetMapping("/{id}")
				User getUser(@PathVariable("id") Long id);
			}				
			Trong ví dụ này, @FeignClient được sử dụng để tạo ra một client proxy cho dịch vụ "userService", được host tại URL http://example.com/api/users. Một interface UserServiceClient
			được định nghĩa, và nó chứa một phương thức getUser() để gọi API lấy thông tin về một user cụ thể.	
				
		@LocalServerPort--Annotation:

			- @LocalServerPort là một annotation trong Spring Boot được sử dụng để lấy ra port của ứng dụng web đang chạy trên máy local. Nó rất hữu ích khi bạn cần biết port của ứng dụng
			để sử dụng trong các test case hoặc khi gọi API từ một ứng dụng khác.
			- Ngoài ra, bạn cũng có thể sử dụng @Value("${local.server.port}") để lấy ra port của ứng dụng, nhưng @LocalServerPort thì thuận tiện hơn vì nó tự động inject giá trị port vào biến.
				
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.test.context.SpringBootTest;
			import org.springframework.boot.test.web.server.LocalServerPort;
			import org.springframework.test.context.junit4.SpringRunner;
			@RunWith(SpringRunner.class)
			@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
			public class MyControllerTest {
				@LocalServerPort
				private int port;
				@Autowired
				private MyController controller;
				@Test
				public void testMyController() {
					// Use the port value to make a call to the controller
					int actualPort = port;
					// Perform assertions on the controller
				}
			}				
			Chúng ta sử dụng @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) để chạy ứng dụng web trong một môi trường test với một port ngẫu nhiên.
			@LocalServerPort được sử dụng để tự động inject giá trị của port hiện tại vào biến port.
			Trong test case, chúng ta có thể sử dụng biến port để gọi API hoặc thực hiện các assertions khác.
				
		@WebFilter--Annotation:

			- @WebFilter là một annotation trong Spring Boot được sử dụng để đăng ký một javax.servlet.Filter bean. Filters trong Spring Boot được sử dụng để lọc và xử lý các
			request trước khi chúng đến Servlet.
			- Bạn cũng có thể sử dụng @Order annotation để chỉ định thứ tự ưu tiên của filter, nếu ứng dụng có nhiều filter.
			- Ngoài ra, bạn cũng có thể sử dụng @Component và @Filter annotations thay vì @WebFilter nếu muốn có thêm control over filter registration.

			import javax.servlet.Filter;
			import javax.servlet.FilterChain;
			import javax.servlet.FilterConfig;
			import javax.servlet.ServletException;
			import javax.servlet.ServletRequest;
			import javax.servlet.ServletResponse;
			import javax.servlet.http.HttpServletRequest;
			import org.springframework.stereotype.Component;
			@Component
			@WebFilter(urlPatterns = "/*")
			public class MyCustomFilter implements Filter {
				@Override
				public void init(FilterConfig filterConfig) throws ServletException {
					// Initialization logic
				}
				@Override
				public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
						throws IOException, ServletException {
					HttpServletRequest httpRequest = (HttpServletRequest) request;
					System.out.println("Request URI: " + httpRequest.getRequestURI());
					chain.doFilter(request, response);
				}
				@Override
				public void destroy() {
					// Cleanup logic
				}
			}
			Chúng ta sử dụng @WebFilter annotation để đăng ký filter này, với urlPatterns = "/*" để lọc tất cả các request.
			Trong doFilter() method, chúng ta in ra URI của request và sau đó gọi chain.doFilter() để tiếp tục xử lý request.

		@WebMvcTest--Annotation:

			- @WebMvcTest là một annotation trong Spring Boot được sử dụng để tạo ra một bối cảnh test cho các lớp Controller trong ứng dụng web MVC.
			- Khi sử dụng @WebMvcTest, Spring sẽ chỉ khởi tạo các bean liên quan đến Web MVC, như @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter,
			Filter, WebMvcConfigurer và HandlerMethodArgumentResolver. Điều này giúp tăng tốc độ chạy test và giảm bớt các phụ thuộc không cần thiết.
			- Lưu ý rằng @WebMvcTest chỉ test các controller và các thành phần liên quan đến Web MVC. Nếu bạn cần test các service, repository hoặc các thành phần khác, bạn
			cần sử dụng @SpringBootTest thay vì @WebMvcTest.
			- Ngoài ra, bạn cũng có thể sử dụng các annotation khác như @MockBean để mock các dependency của controller.

			import org.junit.jupiter.api.Test;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
			import org.springframework.test.web.servlet.MockMvc;
			import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
			import org.springframework.test.web.servlet.result.MockMvcResultMatchers;=
			@WebMvcTest(controllers = MyController.class)
			public class MyControllerTest {
				@Autowired
				private MockMvc mockMvc;
				@Test
				public void testMyController() throws Exception {
					mockMvc.perform(MockMvcRequestBuilders.get("/myendpoint"))
							.andExpect(MockMvcResultMatchers.status().isOk())
							.andExpect(MockMvcResultMatchers.content().string("Hello, World!"));
				}
			}
			Chúng ta sử dụng @WebMvcTest annotation và chỉ định MyController.class như là controller cần được test.
			Spring sẽ chỉ khởi tạo các bean liên quan đến Web MVC, giúp test chạy nhanh hơn.
			Chúng ta sử dụng MockMvc để mô phỏng các request và kiểm tra kết quả trả về.

		@RunWith--Annotation:
		
			- @RunWith là một annotation trong JUnit (một framework kiểm thử phổ biến trong Java) được sử dụng để chỉ định một class Runner cụ thể sẽ được sử dụng để chạy các test case.
			- Trong Spring, khi bạn sử dụng Spring Test Framework, thường bạn sẽ kết hợp @RunWith với @SpringRunner hoặc @SpringJUnit4ClassRunner để chạy các test case trong môi trường Spring.
			- SpringRunner là một class runner được cung cấp bởi Spring Test Framework. Nó sẽ chịu trách nhiệm khởi tạo và quản lý vòng đời của Spring context trong quá trình chạy test case.
			- Khi sử dụng @RunWith(SpringRunner.class), Spring sẽ tự động:
				Khởi tạo ApplicationContext.
				Tiêm các dependency được khai báo bằng @Autowired.
				Quản lý vòng đời của ApplicationContext.
			- Điều này giúp các test case có thể tương tác với các bean và dịch vụ được định nghĩa trong ứng dụng Spring một cách dễ dàng.

			import org.junit.Test;
			import org.junit.runner.RunWith;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.test.context.SpringBootTest;
			import org.springframework.test.context.junit4.SpringRunner;
			import com.example.myapp.MyService;
			@RunWith(SpringRunner.class)
			@SpringBootTest
			public class MyServiceTest {
				@Autowired
				private MyService myService;
				@Test
				public void testMyService() {
					// Test the MyService class
					myService.doSomething();
					// Add your assertions here
				}
			}
			@RunWith(SpringRunner.class) chỉ định rằng test case này sẽ được chạy bằng cách sử dụng SpringRunner class runner.
			@SpringBootTest chỉ định rằng test case này sẽ được chạy trong một Spring Boot test context.

		@Import--Annotation:

			- @Import là một annotation trong Spring được sử dụng để định nghĩa và import các configuration classes vào trong ứng dụng của bạn.
			- Đây là một số trường hợp bạn có thể sử dụng @Import:
				Chia nhỏ Configuration Classes:
					Khi ứng dụng của bạn trở nên phức tạp, bạn có thể chia nhỏ các configuration classes thành các modules nhỏ hơn.
					Sử dụng @Import để import các configuration classes này vào một configuration class chính.
				Sử dụng Configuration Classes của Bên Thứ Ba:
					Khi sử dụng các thư viện/framework của bên thứ ba, bạn có thể import configuration classes của chúng vào ứng dụng của mình.
			- Bằng cách sử dụng @Import, bạn có thể tổ chức và quản lý các configuration classes của ứng dụng một cách dễ dàng, đặc biệt là khi ứng dụng trở nên phức tạp hơn.
			- Ngoài ra, @Import còn có một số tính năng nâng cao khác như:
				Conditional Import: Chỉ import configuration classes khi một điều kiện cụ thể được đáp ứng.
				Importing Bean Definition Registrars: Import các Bean Definition Registrars để đăng ký các bean động.

			import org.springframework.context.annotation.Configuration;
			import org.springframework.context.annotation.Import;
			@Configuration
			@Import({
				DatabaseConfig.class,
				SecurityConfig.class,
				WebConfig.class
			})
			public class ApplicationConfig {
				// Main application configuration
			}
			@Import annotation được sử dụng để import các configuration classes khác (DatabaseConfig, SecurityConfig, WebConfig) vào ApplicationConfig.
			Khi ApplicationConfig được load, Spring sẽ tự động load và configure các configuration classes được import bằng @Import.

		@interface--Annotation:
		
			- Trong Java, @interface được sử dụng để khai báo một annotation. Trong Spring, bạn có thể tạo các custom annotations để sử dụng cho các mục đích đặc biệt trong ứng dụng của
			mình, ví dụ như đánh dấu các phương thức hoặc lớp cụ thể với một logic kinh doanh hoặc cấu hình nào đó.
			
			package com.example.annotation;
			import java.lang.annotation.ElementType;
			import java.lang.annotation.Retention;
			import java.lang.annotation.RetentionPolicy;
			import java.lang.annotation.Target;
			@Retention(RetentionPolicy.RUNTIME)
			@Target(ElementType.METHOD)
			public @interface LogExecutionTime {
			}
			package com.example.aspect;
			import org.aspectj.lang.ProceedingJoinPoint;
			import org.aspectj.lang.annotation.Around;
			import org.aspectj.lang.annotation.Aspect;
			import org.springframework.stereotype.Component;
			@Aspect
			@Component
			public class LoggingAspect {
				@Around("@annotation(com.example.annotation.LogExecutionTime)")
				public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
					long start = System.currentTimeMillis();
					Object proceed = joinPoint.proceed();
					long executionTime = System.currentTimeMillis() - start;
					System.out.println(joinPoint.getSignature() + " executed in " + executionTime + "ms");
					return proceed;
				}
			}
			package com.example.controller;
			import com.example.annotation.LogExecutionTime;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.RestController;
			@RestController
			public class UserController {
				@LogExecutionTime
				@GetMapping("/user")
				public String getUser() {
					// Simulate a time-consuming task
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					return "User data";
				}
			}
			package com.example;
			import org.springframework.boot.SpringApplication;
			import org.springframework.boot.autoconfigure.SpringBootApplication;
			@SpringBootApplication
			public class Application {
				public static void main(String[] args) {
					SpringApplication.run(Application.class, args);
				}
			}
			Trong đó @Around("@annotation(com.example.annotation.LogExecutionTime)"): Chỉ định rằng phương thức logExecutionTime sẽ được gọi xung quanh (trước và sau) bất kỳ phương thức
			nào được chú thích với @LogExecutionTime.

		@JoinColumn--Annotation:
		
			- @JoinColumn là một annotation được sử dụng để chỉ định cột mà qua đó thực thể này tham chiếu tới thực thể khác trong quan hệ cơ sở dữ liệu.
			
			import javax.persistence.Entity;
			import javax.persistence.Id;
			import javax.persistence.ManyToOne;
			import javax.persistence.JoinColumn;
			@Entity
			public class Employee {
				@Id
				private Long id;
				@ManyToOne
				@JoinColumn(name = "department_id", referencedColumnName = "id")
				private Department department;
				// Getters and setters
			}
			
		@JoinColumns--Annotation:
		
			- @JoinColumns là một annotation được sử dụng để xác định nhiều cột khóa ngoại khi có một quan hệ phức tạp liên quan đến nhiều cột khóa ngoại. Điều này thường được sử dụng
			trong các quan hệ mà bảng con tham chiếu tới bảng cha bằng nhiều cột khóa ngoại.
			
			import javax.persistence.Entity;
			import javax.persistence.Id;
			import javax.persistence.ManyToOne;
			import javax.persistence.JoinColumns;
			import javax.persistence.JoinColumn;
			@Entity
			public class Employee {
				@Id
				private Long id;
				@ManyToOne
				@JoinColumns({
					@JoinColumn(name = "department_id", referencedColumnName = "id"),
					@JoinColumn(name = "location_id", referencedColumnName = "location_id")
				})
				private Department department;
				// Getters and setters
			}	

	Phân trang--SPRING:
				Pageable:	
															Pageable pageable = PageRequest.of(0, 3, Sort.by("name"));
															Pageable pageable = PageRequest.of(0, 3, Sort.by("price").descending());
															Pageable pageable = PageRequest.of(0, 5, Sort.by("price").descending().and(Sort.by("name")));
															
															Pageable pageable;
															if(pageSize == 0){
																pageable = Pageable.unpaged();
															} else {
																pageable = PageRequest.of(pageNo, pageSize, Sort.by("status"));
															}
				Phân trang trong spring data jpa (Paging):	
															@Query("SELECT e FROM Customer e")
															Page<Customer> findCustomers(Pageable pageable);
															
															
	ResponseEntity--SPRING:
	
				Công thức chung:
				
					Trả về một đối tượng đơn giản với mã trạng thái HTTP:

													new ResponseEntity<>(<body>, <HttpStatus>)
												
					Trả về một đối tượng với mã trạng thái HTTP và tiêu đề:
					
													new ResponseEntity<>(<body>, <headers>, <HttpStatus>)
													
					Sử dụng các phương thức tiện ích của ResponseEntity:
					
													ResponseEntity.ok(<body>)
													ResponseEntity.status(<HttpStatus>).body(<body>)
													ResponseEntity.notFound().build()
													ResponseEntity.badRequest().body(<body>)
													
					Trả về đối tượng JSON:								
													
													ResponseEntity.ok(<object>)
													
					Trả về một danh sách các đối tượng:
					
													ResponseEntity.ok(<List<object>>)
													
					Trả về phản hồi với tiêu đề và nội dung tùy chỉnh:
					
													ResponseEntity.created(<URI>).body(<body>)
																	
				HttpStatus.OK:						
				
													@GetMapping("/hello")
													ResponseEntity<String> hello() {
														return new ResponseEntity<>("Hello World!", HttpStatus.OK);
													}
				HttpStatus.UNAUTHORIZED:    		@GetMapping("/unauthorized")
													public ResponseEntity<String> unauthorized() {
														// Trả về một phản hồi lỗi "Unauthorized" với mã HTTP Status là 401 Unauthorized
														return new ResponseEntity<>("Unauthorized", HttpStatus.UNAUTHORIZED);
													}
				HttpStatus.NOT_FOUND:				@GetMapping("/notfound")
													public ResponseEntity<String> notFound() {
														// Trả về một phản hồi lỗi "Not Found" với mã HTTP Status là 404 Not Found
														return new ResponseEntity<>("Not Found", HttpStatus.NOT_FOUND);
													}
											
				HttpStatus.INTERNAL_SERVER_ERROR:	@GetMapping("/internalerror")
													public ResponseEntity<String> internalError() {
														// Trả về một phản hồi lỗi "Internal Server Error" với mã HTTP Status là 500 Internal Server Error
														return new ResponseEntity<>("Internal Server Error", HttpStatus.INTERNAL_SERVER_ERROR);
													}
				HTTP headers:						@GetMapping("/customHeader")
													ResponseEntity<String> customHeader() {
														HttpHeaders headers = new HttpHeaders();
														headers.add("Custom-Header", "foo");
															
														return new ResponseEntity<>(
														  "Custom header set", headers, HttpStatus.OK);
													}
				BodyBuilder.status:					@GetMapping("/example")
													public ResponseEntity<String> example() {
														return ResponseEntity.status(201).body("Example created");
													}
															
														return new ResponseEntity<>(
														  "Custom header set", headers, HttpStatus.OK);
													}
				BodyBuilder.body:					@GetMapping("/age")
													ResponseEntity<String> age(@RequestParam("yearOfBirth") int yearOfBirth) {
														if (isInFuture(yearOfBirth)) {
															return ResponseEntity.badRequest()
																.body("Year of birth cannot be in the future");
														}

														return ResponseEntity.status(HttpStatus.OK)
															.body("Your age is " + calculateAge(yearOfBirth));
													}
				BodyBuilder.headers:				@GetMapping("/customHeader")
													ResponseEntity<String> customHeader() {
														return ResponseEntity.ok()
															.header("Custom-Header", "foo")
															.body("Custom header set");
													}
				HttpStatus.OK.value:
													int statusCode = HttpStatus.OK.value(); // statusCode sẽ có giá trị 200
				getBody(),
				getStatusCode(),
				getStatusCodeValue(),
				getHeaders(),
				hasBody(),
				getRawStatusCode(),
				getContentType()
													import org.springframework.http.HttpStatus;
													import org.springframework.http.ResponseEntity;
													public class ResponseEntityExample {
														public static void main(String[] args) {
															ResponseEntity<String> responseEntity = new ResponseEntity<>("Unauthorized", HttpStatus.UNAUTHORIZED);
															// getStatusCode() và getStatusCodeValue()
															HttpStatus statusCode = responseEntity.getStatusCode();
															int statusCodeValue = responseEntity.getStatusCodeValue();
															System.out.println("Status code: " + statusCode); // Status code: 401 UNAUTHORIZED
															System.out.println("Status code value: " + statusCodeValue); // Status code value: 401
															// getHeaders()
															HttpHeaders headers = responseEntity.getHeaders();
															System.out.println("Headers: " + headers); // Headers: [Content-Type:"application/octet-stream"]
															// hasBody()
															boolean hasBody = responseEntity.hasBody();
															System.out.println("Has body: " + hasBody); // Has body: true
															// getRawStatusCode()
															int rawStatusCode = responseEntity.getRawStatusCode();
															System.out.println("Raw status code: " + rawStatusCode); // Raw status code: 401
															// getContentType()
															MediaType contentType = responseEntity.getHeaders().getContentType();
															System.out.println("Content-Type: " + contentType); // Content-Type: application/octet-stream
															// getBody()
															String body = responseEntity.getBody();
															System.out.println("Response body: " + body); // Response body: Unauthorized
														}
													}

	ModelMapper--SPRING:

						- ModelMapper là một thư viện Java được sử dụng để tự động ánh xạ (mapping) dữ liệu giữa các đối tượng có cấu trúc khác nhau. Nó rất hữu ích trong các ứng dụng Spring, đặc biệt trong việc
						chuyển đổi giữa các lớp DTO (Data Transfer Object) và các lớp domain/entity.
	
						@Getter
						@Setter
						class User {
							private String username;
							private String password;
							private String displayName;
							private int age;
						}
						@Getter
						@Setter
						class UserDto {
							private String username;
							private String displayName;
							private int age;
						}
						User user = new User("john", "123456", "Nguyễn Văn John", 20); // Object nguồn							
						ModelMapper mapper = new ModelMapper(); // Tạo mapper object						
						UserDto userDto = mapper.map(user, UserDto.class); // Map thành object đích



	Query creation--SPRING:
									
					JpaRepository<Customer, Integer> thì sẽ chỉ select trong table được define ở đây là Customer, Integer là kiểu dữ liệu của primary key
	
					package stackjava.com.querycreation.repository;
					import java.util.List;
					import org.springframework.data.jpa.repository.JpaRepository;
					import org.springframework.stereotype.Repository;
					import stackjava.com.querycreation.entities.Customer;
					@Repository
					public interface CustomerRepository extends JpaRepository<Customer, Integer> {				
					
						List<Customer> findAllByOrderByNameDesc(); // SELECT * FROM table_name ORDER BY name DESC;	
																
						List<Customer> findByName(String name); // SELECT * FROM table_name WHERE name = 'value';
																
						List<Customer> findByNameAndAddress(String name, String address); // SELECT * FROM table_name WHERE name = 'name' AND address = 'address';
																						
						List<Customer> findByNameLike(String name); // SELECT * FROM table_name WHERE name LIKE '%name%';
																	
						List<Customer> findByIdIn(List<Integer> ids); // SELECT * FROM table_name WHERE id IN (id1, id2, ...);
																	
						List<Customer> findByIdLessThan(int index); // SELECT * FROM table_name WHERE id < index;
																	
						Product findDistinctByName(String name); // SELECT DISTINCT * FROM product WHERE name = 'name';
						
						List<String> findNameByLastname(String lastname); // SELECT p.name FROM Person p WHERE p.lastname = :lastname
						
					}
					
					Optional<Product> findById(Long id); // SELECT * FROM product WHERE id = id;
														
					List<Product> findByPriceGreaterThan(BigDecimal price); // SELECT * FROM product WHERE price > price;
																			
					List<Product> findByNameContaining(String name); // SELECT * FROM product WHERE name LIKE '%name%';
																	
					List<Product> findByPriceBetween(BigDecimal startPrice, BigDecimal endPrice); // SELECT * FROM product WHERE price BETWEEN startPrice AND endPrice;
																								
					Person findPersonByLastname(String lastname); // SELECT * FROM person WHERE lastname = 'lastname'.
																
					Person findAllByLastname(String lastname); // SELECT * FROM person WHERE lastname = 'lastname';
					
					List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname); // SELECT * FROM person WHERE email_address = 'emailAddress' AND lastname = 'lastname';
					
					List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname); // SELECT DISTINCT * FROM person WHERE lastname = 'lastname' OR firstname = 'firstname';
					
					List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname); // SELECT DISTINCT * FROM person WHERE lastname = 'lastname' OR firstname = 'firstname';
					
					List<Person> findByLastnameIgnoreCase(String lastname); // SELECT * FROM person WHERE LOWER(lastname) = LOWER('lastname');
					
					List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); // SELECT * FROM person WHERE LOWER(lastname) = LOWER('lastname') AND LOWER(firstname) = LOWER('firstname');
					
					List<Person> findByAddressZipCode(ZipCode zipCode); // SELECT * FROM person WHERE address_zip_code = 'zipCode';
																		
					findPersonByLastname(String lastname); // Nó sẽ trả về một đối tượng Person. Nếu không có kết quả nào khớp, nó có thể trả về null hoặc Optional.empty() tùy thuộc vào cấu hình.
					
					findAllByLastname(String lastname); // Kết quả trả về sẽ là một danh sách (List) các đối tượng Person.
					
					findByLastname(String lastname); // Kết quả trả về sẽ là một danh sách (List) các đối tượng Person.												

		@Query:
						public interface UserRepository extends JpaRepository<User, Long> {								
							@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name") // JPQL
							User findUserByNamedParams(@Param("status") Integer status, @Param("name") String name);								
							@Query(value = "SELECT * FROM Users u WHERE u.status = :status and u.name = :name", nativeQuery = true) // Native SQL
							User findUserByNamedParamsNative(@Param("status") Integer status, @Param("name") String name);
						}
						
						public interface UserRepository extends JpaRepository<User, Long> {

							@Query("select u from User u where u.emailAddress = ?1") // Khi được gắn @Query, thì tên của method không còn tác dụng nữa. Đây là JPQL
																					 // Cách truyền tham số là gọi theo thứ tự các tham số của method bên dưới ?1, ?2
							User myCustomQuery(String emailAddress);								
							@Query(value = "select * from User u where u.email_address = ?1", nativeQuery = true) // Đây là Native SQL
							User myCustomQuery2(String emailAddress);
						}
						
	
	Exeption Handler--SPRING:
		@ExceptionHandler:
																@ExceptionHandler
																public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException exc) {
																	StudentErrorResponse error = new StudentErrorResponse();
																	error.setStatus(HttpStatus.NOT_FOUND.value());
																	error.setMessage(exc.getMessage());
																	error.setTimeStamp(System.currentTimeMillis());
																	return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
																}
		@ControllerAdvice và @ExceptionHandler:
																@ControllerAdvice
																public class GlobalExceptionHandler {

																	@ExceptionHandler(NumberFormatException.class)
																	public ModelAndView handleNumberFormatException(NumberFormatException ex) {
																		ModelAndView modelAndView = new ModelAndView("error");
																		modelAndView.addObject("errorMessage", "Invalid number format. Please enter a valid number.");
																		return modelAndView;
																	}
																}
																
																@ControllerAdvice
																public class StudentRestExceptionHandler {
																	@ExceptionHandler
																	public ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException exc) {
																		StudentErrorResponse error = new StudentErrorResponse();
																		error.setStatus(HttpStatus.NOT_FOUND.value());
																		error.setMessage(exc.getMessage());
																		error.setTimeStamp(System.currentTimeMillis());
																		return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
																	}
																}
		@RestControllerAdvice:
																@RestControllerAdvice
																public class GlobalExceptionHandler {
																	@ExceptionHandler({ ExceptionA.class, ExceptionB.class })  // Có thể bắt nhiều loại exception
																	public ResponseEntity<String> handleExceptionA(Exception e) {
																		return ResponseEntity.status(432).body(e.getMessage());
																	}																	
																	// Có thêm các @ExceptionHandler khác...																																		// Nên bắt cả Exception.class
																	@ExceptionHandler(Exception.class)
																	public ResponseEntity<String> handleUnwantedException(Exception e) {
																		// Log lỗi ra và ẩn đi message thực sự (xem phần 3.2)
																		e.printStackTrace();  // Thực tế người ta dùng logger
																		return ResponseEntity.status(500).body("Unknow error");
																	}
																}
		@JsonAdapter:
																Trong thư viện Gson của Java, @JsonAdapter là một annotation được sử dụng để chỉ định một adapter tùy chỉnh để chuyển đổi giữa đối tượng Java và JSON khi thực
																hiện quá trình serialize và deserialize. Adapter tùy chỉnh này cho phép bạn kiểm soát cách mà Gson chuyển đổi các đối tượng thành JSON và ngược lại.
																
																import java.io.IOException;
																import com.google.gson.Gson;
																import com.google.gson.TypeAdapter;
																import com.google.gson.annotations.JsonAdapter;
																import com.google.gson.stream.JsonReader;
																import com.google.gson.stream.JsonWriter;
																public class JsonAdapterTest {
																   public static void main(String[] args) {
																	  Gson gson = new Gson();
																	  System.out.println(gson.toJson(new Customer()));
																   }
																}
																// Customer class
																class Customer {
																   @JsonAdapter(CustomJsonAdapter.class)
																   Integer customerId = 101;
																}
																// CustomJsonAdapter class
																class CustomJsonAdapter extends TypeAdapter<Integer> {
																   @Override
																   public Integer read(JsonReader jreader) throws IOException {
																	  return null;
																   }
																   @Override
																   public void write(JsonWriter jwriter, Integer customerId) throws IOException {
																	  jwriter.beginObject();
																	  jwriter.name("customerId");
																	  jwriter.value(String.valueOf(customerId));
																	  jwriter.endObject();
																   }
																}																


	Email--SPRING:
		Maven Dependencies:
			Spring:					
									<dependency>
										<groupId>org.springframework</groupId>
										<artifactId>spring-context-support</artifactId>
										<version>5.2.8.RELEASE</version>
									</dependency>
			Spring Boot:			
									<dependency>
										<groupId>org.springframework.boot</groupId>
										<artifactId>spring-boot-starter-mail</artifactId>
										<version>2.5.6</version>
									</dependency>
		Mail Server Properties:	
			Spring Mail Server Properties:			
													@Bean
													public JavaMailSender getJavaMailSender() {
														JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
														mailSender.setHost("smtp.gmail.com");
														mailSender.setPort(587);
														
														mailSender.setUsername("my.gmail@gmail.com");
														mailSender.setPassword("password");
														
														Properties props = mailSender.getJavaMailProperties();
														props.put("mail.transport.protocol", "smtp");
														props.put("mail.smtp.auth", "true");
														props.put("mail.smtp.starttls.enable", "true");
														props.put("mail.debug", "true");
														
														return mailSender;
													}
			Spring Boot Mail Server Properties:
				Gmail SMTP Properties:				
													spring.mail.host=smtp.gmail.com
													spring.mail.port=587
													spring.mail.username=<login user to smtp server>
													spring.mail.password=<login password to smtp server>
													spring.mail.properties.mail.smtp.auth=true
													spring.mail.properties.mail.smtp.starttls.enable=true
				SES SMTP Properties:
													spring.mail.host=email-smtp.us-west-2.amazonaws.com
													spring.mail.username=username
													spring.mail.password=password
													spring.mail.properties.mail.transport.protocol=smtp
													spring.mail.properties.mail.smtp.port=25
													spring.mail.properties.mail.smtp.auth=true
													spring.mail.properties.mail.smtp.starttls.enable=true
													spring.mail.properties.mail.smtp.starttls.required=true
			Sending Email:
				Sending Simple Emails:
													@Component
													public class EmailServiceImpl implements EmailService {

														@Autowired
														private JavaMailSender emailSender;

														public void sendSimpleMessage(
														  String to, String subject, String text) {
															...
															SimpleMailMessage message = new SimpleMailMessage(); 
															message.setFrom("noreply@baeldung.com");
															message.setTo(to); 
															message.setSubject(subject); 
															message.setText(text);
															emailSender.send(message);
															...
														}
													}
				Sending Emails With Attachments:
													@Override
													public void sendMessageWithAttachment(String to, String subject, String text, String pathToAttachment) {
														// ...
														
														MimeMessage message = emailSender.createMimeMessage();
														 
														MimeMessageHelper helper = new MimeMessageHelper(message, true);
														
														helper.setFrom("noreply@baeldung.com");
														helper.setTo(to);
														helper.setSubject(subject);
														helper.setText(text);
															
														FileSystemResource file = new FileSystemResource(new File(pathToAttachment));
														helper.addAttachment("Invoice", file);

														emailSender.send(message);
														// ...
													}
	Lazy Initialization--SPRING:
													spring.main.lazy-initialization=true
													
													@RestController
													public class DemoController {
														private Coach myCoach;
														@Autowired
														public DemoController(@Qualifier("cricketCoach") Coach theCoach) {
															System.out.println("In constructor: " + getClass().getSimpleName());
															myCoach = theCoach;
													   ...
													}
	Bean Scopes--SPRING:
		Explicitly Specify Bean Scope:
													@Component
													@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
													public class CricketCoach implements Coach {
														…
													}
		Additional Spring Bean Scopes:
			singleton           	Create a single shared instance of the bean. Default scope.
			prototype           	Creates a new bean instance for each container request.
			session              	Scoped to an HTTP web session. Only used for web apps.
			global-session   		Scoped to a global HTTP web session. Only used for web apps.
		Checking on the scope:
									private Coach myCoach;
									private Coach anotherCoach;
									@Autowired
									public DemoController(
											@Qualifier("cricketCoach") Coach theCoach,
											@Qualifier("cricketCoach") Coach theAnotherCoach) {
										myCoach = theCoach;
										anotherCoach = theAnotherCoach;
									}
									@GetMapping("/check")
									public String check() {
										return "Comparing beans: myCoach == anotherCoach, " + (myCoach == anotherCoach); // Singleton: True
																														 // Prototype: False
									}
		Bean Lifecycle:				Container Started -> Bean Instantiated -> Dependencies Injected -> Internal Spring Processing -> Your Custom Init Method -> Bean Is Ready For Use ->
									Container Is Shutdown -> Your Custom Destroy Method -> Stop
		Init: method configuration:			
											@PostConstruct
											public void doMyStartupStuff() {
												System.out.println("In doMyStartupStuff(): " + getClass().getSimpleName());
											}
		Destroy: method configuration:
											@PreDestroy
											public void doMyCleanupStuff() {
												System.out.println("In doMyCleanupStuff(): " + getClass().getSimpleName());
											}
	
	Turn off the Spring boot banner--SPRING:		spring.main.banner-mode=off
	Reduce logging level--SPRING:					logging.level.root=warn
	ID Generation Strategies--SPRING:
													GenerationType.AUTO                         Pick an appropriate strategy for the particular database
													GenerationType.IDENTITY                   	Assign primary keys using database identity column
													GenerationType.SEQUENCE              		Assign primary keys using a database sequence
													GenerationType.TABLE                        Assign primary keys using an underlying database table to ensure uniqueness
	Saving a Java Object with JPA(EntityManager)--SPRING:
													@Repository
													public class StudentDAOImpl implements StudentDAO {
														 private EntityManager entityManager;
														 @Autowired
														 public StudentDAOImpl(EntityManager theEntityManager) {
															 entityManager = theEntityManager;
														 }
														@Override
														public void save(Student theStudent) {
															 entityManager.persist(theStudent);
														}
													}
													
													@Override
													@Transactional
													public void save(Student theStudent) {
														entityManager.persist(theStudent);
													}
													
													@SpringBootApplication
													public class CruddemoApplication {
														 ...
														@Bean
														public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
															return runner -> {
																createStudent(studentDAO);
													}
														private void createStudent(StudentDAO studentDAO) {
															...
														}
													}
	Reading Objects with JPA(EntityManager)--SPRING:
													@Override
													public Student findById(Integer id) {
														return entityManager.find(Student.class, id);
													}
													
													@Bean
													public CommandLineRunner commandLineRunner(StudentDAO studentDAO) {
														return runner -> {
															readStudent(studentDAO);
														};
													}
	Querying Objects with JPA(EntityManager)--SPRING:
		Retrieving all Students:					
													TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class); // All JPQL syntax is based on entity name and entity fields
																																			 // NOT the name of the database table
													List<Student> students = theQuery.getResultList();
		Retrieving Students using LIKE predicate:
													TypedQuery<Student> theQuery = entityManager.createQuery(
																			"FROM Student WHERE email LIKE ‘%luv2code.com’", Student.class);
		JPQL - Named Parameters:					public List<Student> findByLastName(String theLastName) {
														 TypedQuery<Student> theQuery = entityManager.createQuery(
																								"FROM Student WHERE lastName=:theData", Student.class);
														 theQuery.setParameter("theData", theLastName);
														 return theQuery.getResultList();
													}
	Updating Objects with JPA(EntityManager)--SPRING:
		Update a Student:
													@Override
													@Transactional
													public void update(Student theStudent) {
														entityManager.merge(theStudent);
													}
													
													Student myStudent = studentDAO.findById(studentId);
													// change first name to "Scooby"
													myStudent.setFirstName("Scooby");
													studentDAO.update(myStudent);
													
		Update last name for all students:			int numRowsUpdated = entityManager.createQuery("UPDATE Student SET lastName=‘Tester’”).executeUpdate();
	Deleting Objects with JPA(EntityManager)--SPRING:
		Delete a Student:													
													int id = 1;
													Student theStudent = entityManager.find(Student.class, id); // retrieve the student													
													entityManager.remove(theStudent); // delete the student
		Delete based on a condition:				int numRowsDeleted = entityManager.createQuery("DELETE FROM Student WHERE lastName=‘Smith’").executeUpdate();
		Delete All Students:						int numRowsDeleted = entityManager.createQuery("DELETE FROM Student").executeUpdate();
	Spring Boot REST Path Variables--SPRING:													
													@GetMapping("/students/{studentId}") // define endpoint for "/students/{studentId}" - return student at index
													public Student getStudent(@PathVariable int studentId) {
														List<Student> theStudents = new ArrayList<>();
														// populate theStudents
														…
														return theStudents.get(studentId);
													}
	Spring Boot Define Service Layer--SPRING:
													@Service
													public class EmployeeServiceImpl implements EmployeeService {
														// inject EmployeeDAO
														…
														@Override
														public List<Employee> findAll() {
															return employeeDAO.findAll();
														}
													}
	Spring Boot REST: Spring Data JPA--SPRING:
													public interface EmployeeRepository extends JpaRepository<Employee, Integer> { // Entity: Employee. Primary key: Integer
														// that's it ... no need to write any code LOL!
													}
													
													@Service
													public class EmployeeServiceImpl implements EmployeeService {
														private EmployeeRepository employeeRepository;
														@Autowired
														public EmployeeServiceImpl(EmployeeRepository theEmployeeRepository) {
															employeeRepository = theEmployeeRepository;
														}
														@Override
														public List<Employee> findAll() {
															return employeeRepository.findAll();
														}
														…
													}
	Spring Data REST Configs and Sorting--SPRING::
													spring.data.rest.base-path                  Base path used to expose repository resources
													spring.data.rest.default-page-size      	Default size of pages
													spring.data.rest.max-page-size          	Maximum size of pages
													@RepositoryRestResource(path="members")
														public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
													}
		Sorting:
			Sort by last name (ascending is default):			http://localhost:8080/employees?sort=lastName
			Sort by first name, descending:						http://localhost:8080/employees?sort=firstName,desc
			Sort by last name, then first name, ascending:		http://localhost:8080/employees?sort=lastName,firstName,asc
																						
	Fetch Types--SPRING:
	
		FetchType Eager:
		
													- FetchType eager (tạm dịch: nhanh chóng) được sử dụng để nạp dữ liệu từ cơ sở dữ liệu vào đối tượng Java ngay lập tức khi đối tượng cha được truy vấn.
													- Khi sử dụng FetchType eager, JPA sẽ tự động nạp tất cả các dữ liệu liên quan (trong trường hợp mối quan hệ là một-nhiều hoặc nhiều-nhiều) hoặc các dữ liệu tham
													chiếu (trong trường hợp mối quan hệ là một-một) từ cơ sở dữ liệu vào đối tượng Java.
													- FetchType eager thường được sử dụng khi ta cần truy cập đến các dữ liệu liên quan một cách thường xuyên và khi dữ liệu liên quan không quá lớn để gây ra vấn đề hiệu suất.
													
		FetchType Lazy:
		
													- FetchType lazy (tạm dịch: lười biếng) được sử dụng để trì hoãn việc nạp dữ liệu từ cơ sở dữ liệu vào đối tượng Java cho đến khi có yêu cầu cụ thể.
													- Khi sử dụng FetchType lazy, JPA chỉ nạp dữ liệu khi ta yêu cầu truy cập đến nó lần đầu tiên. Điều này giúp tránh việc tải quá nhiều dữ liệu không cần thiết và cải thiện
													hiệu suất ứng dụng.
													- FetchType lazy thường được sử dụng khi ta cần tối ưu hóa hiệu suất và tránh việc tải nhiều dữ liệu không cần thiết.
	
		Specify the fetch type: EAGER or LAZY:
		
													@Entity
													@Table(name="instructor")
													public class Instructor {
														…
														@OneToMany(fetch=FetchType.LAZY, mappedBy=“instructor”)
														private List<Course> courses;
														…
													}
		Default Fetch Type:
													@OneToOne    	FetchType.EAGER
													@OneToMany  	FetchType.LAZY
													@ManyToOne  	FetchType.EAGER
													@ManyToMany 	FetchType.LAZY
	Entity Lifecycle--SPRING:
		Detach										If entity is detached, it is not associated with a Hibernate session
		Merge										If instance is detached from session, then merge will reattach to session
		Persist										Transitions new instances to managed state. Next flush / commit will save in db.
		Remove										Transitions managed entity to be removed. Next flush / commit will delete from db
		Refresh										Reload / synch object with data from db. Prevents stale data
		
	@OneToOne--SPRING:
													 
							- Whoever owns the foreign key column gets the @JoinColumn annotation.
							- mapped chỉ là phần phát sinh thêm trong code Java, nên sẽ theo tên của cột trong Java
							- Khóa ngoại có thể đặt ở một trong hai bảng hoặc kết hợp hai bảng.
		
		Ví dụ One-To-One Unidirectional Relationship:
		
			Việc gọi stockRepository.save(stock); là không cần thiết khi bạn đã sử dụng CascadeType.ALL trong quan hệ giữa Product và Stock.
			
			Điều này có nghĩa là mọi thao tác (như persist, merge, remove, refresh, detach) thực hiện trên thực thể Product cũng sẽ được thực hiện trên
			thực thể Stock. Nói cách khác, nếu bạn lưu một Product, JPA sẽ tự động lưu Stock liên kết với nó mà không cần phải gọi
			
		
													package com.example.springdatajpa;
													import com.example.springdatajpa.entities.Product;
													import com.example.springdatajpa.entities.Stock;
													import com.example.springdatajpa.entities.StockStatus;
													import com.example.springdatajpa.repositories.ProductRepository;
													import com.example.springdatajpa.repositories.StockRepository;
													import lombok.extern.slf4j.Slf4j;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import org.springframework.context.ApplicationContext;
													@SpringBootApplication
													@Slf4j
													public class SpringDataJpaApplication {
														@Autowired
														private ProductService productService;
														 public static void main(String[] args)
														 {
														  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
														  ProductRepository productRepository = context.getBean(ProductRepository.class);
														  StockRepository stockRepository = context.getBean(StockRepository.class);
														  Product product = new Product();
														  product.setProductName("iPad");
														  product.setProductPrice(59999);												 
														  Stock stock = new Stock();
														  stock.setStockQuantity(74);
														  stock.setStockStatus(StockStatus.IN_STOCK);
														 // Save product with stock
														 productService.saveProductWithStock(product, stock);											  
														 }
													}
													
													package com.example.springdatajpa;
													import com.example.springdatajpa.entities.Product;
													import com.example.springdatajpa.entities.Stock;
													import com.example.springdatajpa.entities.StockStatus;
													import com.example.springdatajpa.repositories.ProductRepository;
													import com.example.springdatajpa.repositories.StockRepository;
													import lombok.extern.slf4j.Slf4j;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import org.springframework.context.ApplicationContext;
													@SpringBootApplication
													@Slf4j
													public class SpringDataJpaApplication
													{
													 public static void main(String[] args)
													 {
													  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
													  ProductRepository productRepository = context.getBean(ProductRepository.class);
													  StockRepository stockRepository = context.getBean(StockRepository.class);
													  Product product = new Product();
													  product.setProductName("iPhone");
													  product.setProductPrice(85999);
													  Stock stock = new Stock();
													  stock.setStockQuantity(32);
													  stock.setStockStatus(StockStatus.IN_STOCK);
													  product.setStock(stock);
													  productRepository.save(product);												 
													  log.info("Saved Product and Stock Information : {} {}", product.getProductName(), product.getStock());
													 }
													}		
		
													package com.example.springdatajpa.entities;
													import jakarta.persistence.*;
													import lombok.Data;
													@Entity
													@Table(name = "products")
													@Data
													//@ToString(exclude = "stock")
													public class Product
													{
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														private int productId;
														private String productName;
														private int productPrice;
														@OneToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
														@JoinColumn(name = "stock_id", referencedColumnName = "stockId")  // This means Foreign key will be created only in the Product
																														  // table i.e. extra column 'stock_id' will be created in the Product table
														private Stock stock;
														// Product-Stock One-To-One Unidirectional Relationship Mapping
														// By using CascadeType.ALL, it essentially means that any operation performed on the parent entity should also be performed on the child entity.
														// With FetchType.LAZY and @ToString(exclude = "stock") at the entity Class level,
														// it will fetch the details of the Parent only i.e. Product
														// With FetchType.EAGER, it will fetch the details of the Child along with the Parent i.e.
														// both Stock and Product details
													}
													
													package com.example.springdatajpa.entities;
													import jakarta.persistence.*;
													import lombok.Data;
													@Entity
													@Table(name = "stocks")
													@Data
													public class Stock
													{
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														private int stockId;
														private int stockQuantity;
														@Enumeraed(EnumType.STRING)
														private StockStatus stockStatus;

													}
													
													package com.example.springdatajpa.entities;
													public enum StockStatus
													{
														IN_STOCK, OUT_OF_STOCK
													}
													
													package com.example.springdatajpa.repositories;
													import com.example.springdatajpa.entities.Product;
													import org.springframework.data.jpa.repository.JpaRepository;
													public interface ProductRepository extends JpaRepository<Product,Integer>
													{
													}
													
													package com.example.springdatajpa.repositories;
													import com.example.springdatajpa.entities.Stock;
													import org.springframework.data.jpa.repository.JpaRepository;
													public interface StockRepository extends JpaRepository<Stock,Integer>
													{
													}
													
													@Service
													public class ProductService {
														@Autowired
														private ProductRepository productRepository;
														@Autowired
														private StockRepository stockRepository;
														public void saveProductWithStock(Product product, Stock stock) {
															product.setStock(stock);  // Associate the product with the stock
															// Save the stock (which cascades to product due to CascadeType.ALL)
															stockRepository.save(stock);
															// Save the product
															productRepository.save(product);
														}
													}											

		Ví dụ One-To-One Bidirectional Relationship
		
			Việc thiết lập cả hai liên kết giúp duy trì tính nhất quán giữa hai thực thể trong mối quan hệ hai chiều. Nếu chỉ thiết lập một bên (ví dụ, chỉ thiết lập liên kết từ Product đến Stock mà
			không thiết lập ngược lại), thì thông tin về sản phẩm liên kết với kho hàng sẽ không hoàn chỉnh và bạn có thể gặp khó khăn trong việc điều hướng và truy xuất thông tin.
		
													package com.example.springdatajpa;
													import com.example.springdatajpa.entities.Product;
													import com.example.springdatajpa.entities.Stock;
													import com.example.springdatajpa.entities.StockStatus;
													import com.example.springdatajpa.repositories.ProductRepository;
													import com.example.springdatajpa.repositories.StockRepository;
													import lombok.extern.slf4j.Slf4j;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import org.springframework.context.ApplicationContext;
													@SpringBootApplication
													@Slf4j
													public class SpringDataJpaApplication
													{
													 public static void main(String[] args)
													 {
													  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
													  ProductRepository productRepository = context.getBean(ProductRepository.class);
													  StockRepository stockRepository = context.getBean(StockRepository.class);
													  Product product = new Product();
													  product.setProductName("MacBook Pro M3");
													  product.setProductPrice(151999);
													  Stock stock = new Stock();
													  stock.setStockQuantity(99);
													  stock.setStockStatus(StockStatus.IN_STOCK);
													  product.setStock(stock);
													  stock.setProduct(product);
													  productRepository.save(product);
													  // log.info("Saved Product and Stock Information : {} {}", product.getProductName(), product.getStock());
													 }
													}													
													
													package com.example.springdatajpa.entities;
													import jakarta.persistence.*;
													import lombok.Data;
													@Entity
													@Table(name = "products")
													@Data
													public class Product
													{
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														private int productId;
														private String productName;
														private int productPrice;
														@OneToOne(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
														@JoinColumn(name = "stock_id", referencedColumnName = "stockId")  // This means Foreign key will be created only in the Product table
																														  // i.e. extra column 'stock_id' will be created in the Product table
														private Stock stock;
														// Product-Stock One-To-One Unidirectional Relationship Mapping
														// With FetchType.LAZY and @ToString(exclude = "stock") at the entity Class level,
														// it will fetch the details of the Parent only i.e. Product
														// With FetchType.EAGER, it will fetch the details of the Child along with the Parent i.e.
														// both Stock and Product details
													}
													
													package com.example.springdatajpa.entities;
													import jakarta.persistence.*;
													import lombok.Data;
													@Entity
													@Table(name = "stocks")
													@Data
													public class Stock
													{
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														private int stockId;
														private int stockQuantity;
														@Enumerated(EnumType.STRING)
														private StockStatus stockStatus;
														@OneToOne(mappedBy = "stock")  // Can define 'cascade = CascadeType.ALL' here as well instead of in Product entity
														private Product product;
													}
													
													package com.example.springdatajpa.entities;
													public enum StockStatus
													{
														IN_STOCK, OUT_OF_STOCK
													}												

		Example 1:
		
													import javax.persistence.Entity;
													import javax.persistence.GeneratedValue;
													import javax.persistence.Id;
													import javax.persistence.JoinColumn;
													import javax.persistence.OneToOne;
													import lombok.Builder;
													import lombok.Data;
													@Entity // Hibernate entity
													@Data // Lombok 
													@Builder // Lombok
													public class Person { //Table person
														@Id // Đánh dấu trường này là primary key
														@GeneratedValue // Tự động tăng giá trị id
														private Long id;
														private String name;
													}
													@Entity
													@Data
													@Builder
													public class Address { // Table address
														@Id
														@GeneratedValue
														private Long id;
														private String city;
														private String province;
														@OneToOne // Đánh dấu có mỗi quan hệ 1-1 với Person ở phía dưới
														@JoinColumn(name = "person_id") // Liên kết với nhau qua khóa ngoại person_id
														private Person person; 
													}
													
													import javax.transaction.Transactional;
													import org.springframework.boot.CommandLineRunner;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import com.google.common.collect.Lists;
													import lombok.RequiredArgsConstructor;
													@SpringBootApplication
													@RequiredArgsConstructor
													public class OneToOneExampleApplication implements CommandLineRunner {
														public static void main(String[] args) {
															SpringApplication.run(OneToOneExampleApplication.class, args);
														}
														// Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired
														private final PersonRepository personRepository;
														private final AddressRepository addressRepository;
														@Override
														public void run(String... args) throws Exception {
															// Tạo ra đối tượng person
															Person person = Person.builder()
																				  .name("loda")
																				  .build();
															// Lưu vào db
															personRepository.save(person);
															// Tạo ra đối tượng Address có tham chiếu tới person
															Address address = Address.builder()
																	.city("Hanoi")
																	.person(person)
																	.build();
															// Lưu vào db
															addressRepository.save(address);
															// Vào: http://localhost:8080/h2-console/ để xem dữ liệu đã insert
														}
													}
													
													Vậy là thằng Address đã liên kết tới Person có id=1.
			
		Example 2:
		
													CREATE TABLE `address` (
													  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
													  PRIMARY KEY (`cart_id`)
													  'street' varchar(45),
													  'city' varchar(45)
													) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
													
													CREATE TABLE `user` (
													  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
													  `phone` int(11),
													  'name' varchar(45)
													  KEY `adress_id` (`user_address`),
													  CONSTRAINT `usser_address` FOREIGN KEY (`id`) REFERENCES `Address` (`address_id`)
													) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;
													
													@Entity
													@Table(name = "users")
													public class User {
														@Id
														@GeneratedValue(strategy = GenerationType.AUTO)
														@Column(name = "id")
														private Long id;
														//...
														@OneToOne(cascade = CascadeType.ALL)
														@JoinColumn(name = "address_id", referencedColumnName = "id")
														private Address address; // biến address này sẽ trùng  với giá trị  mappedBy trong Class User 
														// ... getters and setters
													}
													
													@Entity
													@Table(name = "address")
													public class Address {
														@Id
														@GeneratedValue(strategy = GenerationType.AUTO)
														@Column(name = "id")
														private Long id;
														//...
														@OneToOne(mappedBy = "address")
														private User user;
														//... getters and setters
													}
													
													Address address = new Address ("Address 1");
													User user  = new User();
													user.setAddress(address);
													user.save(); // như vậy ta sẽ lưu dữ liệu xuống 2 bảng User và Address
		
		Example 3:
													
													@OneToOne(cascade=CascadeType.ALL)
													@JoinColumn(name="instructor_detail_id")
													private InstructorDetail instructorDetail;
													
													@Entity
													public class User {   
														//...
														@OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
														private Address address;
														//...
													}
													
													@Entity
													public class Address {
														//...
														@OneToOne
														@JoinColumn(name = "user_id")
														private User user;  
														//...
													}
													
													private void createInstructor(AppDAO appDAO) {													
														Instructor tempInstructor = new Instructor("Chad", "Darby", "darby@luv2code.com"); // create the instructor																										
														InstructorDetail tempInstructorDetail = new InstructorDetail( "http://www.luv2code.com/youtube", "Luv 2 code!!!"); // create the instructor detail																										
														tempInstructor.setInstructorDetail(tempInstructorDetail); // associate the objects																										
														System.out.println("Saving instructor: " + tempInstructor);
														appDAO.save(tempInstructor); // save the instructor													
														System.out.println("Done!");														
													}
													
		Example 4:

													@Entity
													@Table(name = "users")
													public class User {												
														@Id
														@GeneratedValue(strategy = GenerationType.AUTO)
														@Column(name = "id")
														private Long id;
														//... 
														@OneToOne(cascade = CascadeType.ALL)
														@JoinColumn(name = "address_id", referencedColumnName = "id")
														private Address address;
														// ... getters and setters
													}
													
													@Entity
													@Table(name = "address")
													public class Address {
														@Id
														@GeneratedValue(strategy = GenerationType.AUTO)
														@Column(name = "id")
														private Long id;
														//...
														@OneToOne(mappedBy = "address")
														private User user;
														//... getters and setters
													}
		
		Example 5:
		
			sql:
			
													DROP SCHEMA IF EXISTS `hb-01-one-to-one-uni`;
													CREATE SCHEMA `hb-01-one-to-one-uni`;
													use `hb-01-one-to-one-uni`;
													SET FOREIGN_KEY_CHECKS = 0;
													CREATE TABLE `instructor_detail` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `youtube_channel` varchar(128) DEFAULT NULL,
													  `hobby` varchar(45) DEFAULT NULL,
													  PRIMARY KEY (`id`)
													) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
													CREATE TABLE `instructor` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `first_name` varchar(45) DEFAULT NULL,
													  `last_name` varchar(45) DEFAULT NULL,
													  `email` varchar(45) DEFAULT NULL,
													  `instructor_detail_id` int DEFAULT NULL,
													  PRIMARY KEY (`id`),
													  KEY `FK_DETAIL_idx` (`instructor_detail_id`),
													  CONSTRAINT `FK_DETAIL` FOREIGN KEY (`instructor_detail_id`) REFERENCES `instructor_detail` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
													) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
													SET FOREIGN_KEY_CHECKS = 1;
													
			Instructor.java:
			
													package com.luv2code.cruddemo.entity;
													import jakarta.persistence.*;
													@Entity
													@Table(name="instructor")
													public class Instructor {
														// annotate the class as an entity and map to db table
														// define the fields
														// annotate the fields with db column names
														// ** set up mapping to InstructorDetail entity
														// create constructors
														// generate getter/setter methods
														// generate toString() method
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														@Column(name="id")
														private int id;
														@Column(name="first_name")
														private String firstName;
														@Column(name="last_name")
														private String lastName;
														@Column(name="email")
														private String email;
														@OneToOne(cascade = CascadeType.ALL)
														@JoinColumn(name = "instructor_detail_id")
														private InstructorDetail instructorDetail;
														public Instructor() {
														}
														public Instructor(String firstName, String lastName, String email) {
															this.firstName = firstName;
															this.lastName = lastName;
															this.email = email;
														}
														public int getId() {
															return id;
														}
														public void setId(int id) {
															this.id = id;
														}
														public String getFirstName() {
															return firstName;
														}
														public void setFirstName(String firstName) {
															this.firstName = firstName;
														}
														public String getLastName() {
															return lastName;
														}
														public void setLastName(String lastName) {
															this.lastName = lastName;
														}
														public String getEmail() {
															return email;
														}
														public void setEmail(String email) {
															this.email = email;
														}
														public InstructorDetail getInstructorDetail() {
															return instructorDetail;
														}
														public void setInstructorDetail(InstructorDetail instructorDetail) {
															this.instructorDetail = instructorDetail;
														}
														@Override
														public String toString() {
															return "Instructor{" +
																	"id=" + id +
																	", firstName='" + firstName + '\'' +
																	", lastName='" + lastName + '\'' +
																	", email='" + email + '\'' +
																	", instructorDetail=" + instructorDetail +
																	'}';
														}
													}
													
			InstructorDetail.java:
			
													package com.luv2code.cruddemo.entity;
													import jakarta.persistence.*;
													@Entity
													@Table(name="instructor_detail")
													public class InstructorDetail {
														// annotate the class as an entity and map to db table
														// define the fields
														// annotate the fields with db column names
														// create constructors
														// generate getter/setter methods
														// generate toString() method
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														@Column(name="id")
														private int id;
														@Column(name="youtube_channel")
														private String youtubeChannel;
														@Column(name="hobby")
														private String hobby;
														// add @OneToOne annotation
														@OneToOne(mappedBy = "instructorDetail",
																cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
														private Instructor instructor;
														public InstructorDetail() {
														}
														public InstructorDetail(String youtubeChannel, String hobby) {
															this.youtubeChannel = youtubeChannel;
															this.hobby = hobby;
														}
														public int getId() {
															return id;
														}
														public void setId(int id) {
															this.id = id;
														}
														public String getYoutubeChannel() {
															return youtubeChannel;
														}
														public void setYoutubeChannel(String youtubeChannel) {
															this.youtubeChannel = youtubeChannel;
														}
														public String getHobby() {
															return hobby;
														}
														public void setHobby(String hobby) {
															this.hobby = hobby;
														}
														public Instructor getInstructor() {
															return instructor;
														}
														public void setInstructor(Instructor instructor) {
															this.instructor = instructor;
														}
														@Override
														public String toString() {
															return "InstructorDetail{" +
																	"id=" + id +
																	", youtubeChannel='" + youtubeChannel + '\'' +
																	", hobby='" + hobby + '\'' +
																	'}';
														}
													}
													
			AppDAOImpl.java:
			
													package com.luv2code.cruddemo.dao;
													import com.luv2code.cruddemo.entity.Instructor;
													import com.luv2code.cruddemo.entity.InstructorDetail;
													import jakarta.persistence.EntityManager;
													import org.springframework.beans.factory.annotation.Autowired;
													import org.springframework.stereotype.Repository;
													import org.springframework.transaction.annotation.Transactional;
													@Repository
													public class AppDAOImpl implements AppDAO {
														// define field for entity manager
														private EntityManager entityManager;
														// inject entity manager using constructor injection
														@Autowired
														public AppDAOImpl(EntityManager entityManager) {
															this.entityManager = entityManager;
														}
														@Override
														@Transactional
														public void save(Instructor theInstructor) {
															entityManager.persist(theInstructor);
														}
														@Override
														public Instructor findInstructorById(int theId) {
															return entityManager.find(Instructor.class, theId);
														}
														@Override
														@Transactional
														public void deleteInstructorById(int theId) {
															// retrieve the instructor
															Instructor tempInstructor = entityManager.find(Instructor.class, theId);
															// delete the instructor
															entityManager.remove(tempInstructor);
														}
														@Override
														public InstructorDetail findInstructorDetailById(int theId) {
															return entityManager.find(InstructorDetail.class, theId);
														}
														@Override
														@Transactional
														public void deleteInstructorDetailById(int theId) {
															// retrieve instructor detail
															InstructorDetail tempInstructorDetail = entityManager.find(InstructorDetail.class, theId);
															// remove the associated object reference
															// break bi-directional link
															//
															tempInstructorDetail.getInstructor().setInstructorDetail(null);
															// delete the instructor detail
															entityManager.remove(tempInstructorDetail);
														}
													}
													
			CruddemoApplication.java:
			
													package com.luv2code.cruddemo;
													import com.luv2code.cruddemo.dao.AppDAO;
													import com.luv2code.cruddemo.entity.Instructor;
													import com.luv2code.cruddemo.entity.InstructorDetail;
													import org.springframework.boot.CommandLineRunner;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import org.springframework.context.annotation.Bean;
													@SpringBootApplication
													public class CruddemoApplication {
														public static void main(String[] args) {
															SpringApplication.run(CruddemoApplication.class, args);
														}
														@Bean
														public CommandLineRunner commandLineRunner(AppDAO appDAO) {
															return runner -> {
																// createInstructor(appDAO);
																// findInstructor(appDAO);
																// deleteInstructor(appDAO);
																// findInstructorDetail(appDAO);
																deleteInstructorDetail(appDAO);
															};
														}
														private void deleteInstructorDetail(AppDAO appDAO) {
															int theId = 3;
															System.out.println("Deleting instructor detail id: " + theId);
															appDAO.deleteInstructorDetailById(theId);
															System.out.println("Done!");
														}
														private void findInstructorDetail(AppDAO appDAO) {
															// get the instructor detail object
															int theId = 2;
															InstructorDetail tempInstructorDetail = appDAO.findInstructorDetailById(theId);
															// print the instructor detail
															System.out.println("tempInstructorDetail: " + tempInstructorDetail);
															// print the associated instructor
															System.out.println("the associated instructor: " + tempInstructorDetail.getInstructor());
															System.out.println("Done!");
														}
														private void deleteInstructor(AppDAO appDAO) {
															int theId = 1;
															System.out.println("Deleting instructor id: " + theId);
															appDAO.deleteInstructorById(theId);
															System.out.println("Done!");
														}
														private void findInstructor(AppDAO appDAO) {
															int theId = 2;
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorById(theId);
															System.out.println("tempInstructor: " + tempInstructor);
															System.out.println("the associated instructorDetail only: " + tempInstructor.getInstructorDetail());
														}
														private void createInstructor(AppDAO appDAO) {
															/*
															// create the instructor
															Instructor tempInstructor =
																	new Instructor("Chad", "Darby", "darby@luv2code.com");
															// create the instructor detail
															InstructorDetail tempInstructorDetail =
																	new InstructorDetail(
																			"http://www.luv2code.com/youtube",
																			"Luv 2 code!!!");
															*/
															// create the instructor
															Instructor tempInstructor =
																	new Instructor("Madhu", "Patel", "madhu@luv2code.com");
															// create the instructor detail
															InstructorDetail tempInstructorDetail =
																	new InstructorDetail(
																			"http://www.luv2code.com/youtube",
																			"Guitar");
															// associate the objects
															tempInstructor.setInstructorDetail(tempInstructorDetail);
															// save the instructor
															//
															// NOTE: this will ALSO save the details object
															// because of CascadeType.ALL
															//
															System.out.println("Saving instructor: " + tempInstructor);
															appDAO.save(tempInstructor);
															System.out.println("Done!");
														}
													}
		
		@OneToOne - Cascade Types:					
													By default, no operations are cascaded.
		
													PERSIST									If entity is persisted / saved, related entity will also be persisted
													REMOVE									If entity is removed / deleted, related entity will also be deleted
													REFRESH									If entity is refreshed, related entity will also be refreshed
													DETACH									If entity is detached (not associated w/ session), then related entity will also be detached
													MERGE									If entity is merged, then related entity will also be merged
													ALL										All of above cascade types
													
													@OneToOne(cascade={CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH, CascadeType.REMOVE})
													

		Unidirectional (@OneToOne uni):
													@Entity
													public class User {
														// ...
														@OneToOne
														@JoinColumn(name = "address_id")
														private Address address;
														// ...
													}
		One-to-One: Find an entity:
													@Repository
													public class AppDAOImpl implements AppDAO {
														…
														@Override
														public Instructor findInstructorById(int theId) {
															return entityManager.find(Instructor.class, theId);
														}
													}
		One-to-One: Delete an entity:
													@Repository
													public class AppDAOImpl implements AppDAO {
													…
														@Override
														@Transactional
														public void deleteInstructorById(int theId) {														
															Instructor tempInstructor = entityManager.find(Instructor.class, theId); // retrieve the instructor																									
															entityManager.remove(tempInstructor); // delete the instructor
														}
													}
		Bidirectional (@OneToOne bi):
													@Entity
													public class User {
														// ...
														@OneToOne(mappedBy = "user")
														private Address address;
														// ...
													}

													@Entity
													public class Address {
														@OneToOne
														@JoinColumn(name = "user_id")
														private User user;
														// ...
													}
													
	@OneToMany--SPRING:
								- Chú ý trong mối quan hệ một nhiều, foreign key sẽ nằm ở bảng nhiều, không nằm ở bảng một
								- Khi sử dụng @OneToMany, Spring sẽ hiểu rằng có một quan hệ một-nhiều giữa hai entity và sẽ tự động quản lý việc lưu trữ và truy xuất dữ liệu theo quan hệ này. Nếu không sử
								dụng @OneToMany, bạn sẽ cần tự tay quản lý việc lưu trữ và truy xuất dữ liệu giữa các entity.
								- Việc sử dụng @OneToMany có thể giúp bạn viết mã một cách ngắn gọn và dễ hiểu hơn, vì Spring tự động xử lý nhiều công việc cho bạn. Tuy nhiên, nếu bạn cần kiểm soát
								hoàn toàn cách dữ liệu được lưu trữ và truy xuất, bạn có thể muốn tự quản lý các quan hệ mà không sử dụng @OneToMany.
								- Bảng cha không chứa foreign key (bảng trong java có mapped) thì khi add data của bảng foreign xong phải set lại data của bảng foreign key với giá trị là con trỏ this.
								- @ManyToOne áp dụng cho bảng một cái này tương ứng với nhiều cái kia
								- @OneToMany áp dụng cho bảng nhiều cái này tương ứng với một cái kia
								- Khi sử dụng @OneToMany, Spring Data JPA tự động sinh ra các câu truy vấn SQL phù hợp để thực hiện các thao tác CRUD (tạo, đọc, cập nhật, xóa) cho mối quan hệ này.
								- Nếu không sử dụng @OneToMany, bạn sẽ cần phải thực hiện việc quản lý mối quan hệ một cách thủ công. Điều này bao gồm việc tạo các bảng liên kết, viết các câu truy vấn
								SQL thủ công để thực hiện các thao tác CRUD cho mối quan hệ đó. Các thao tác này sẽ mất nhiều thời gian và công sức hơn so với việc sử dụng các tính năng tự động hóa được
								cung cấp bởi Spring Data JPA thông qua @OneToMany.
								- Để duy trì tính nhất quán giữa các đối tượng Instructor và Course, cả hai đều cần biết về nhau.
								- Khóa ngoại đặt ở bảng phía "nhiều".
													
		Ví dụ khi có @OneToMany không cần phải lưu đến database riêng từng cái:
		
														private void createInstructorWithCourses(AppDAO appDAO) {
															
															Instructor tempInstructor = // create the instructor
																	new Instructor("Susan", "Public", "susan.public@luv2code.com");													
															tempInstructor.setInstructorDetail(tempInstructorDetail); // associate the objects										
															Course tempCourse1 = new Course("Air Guitar - The Ultimate Guide"); // create some courses
															Course tempCourse2 = new Course("The Pinball Masterclass");
															// add courses to instructor
															tempInstructor.add(tempCourse1);
															tempInstructor.add(tempCourse2);
															// save the instructor
															//
															// NOTE: this will ALSO save the courses
															// because of CascadeType.PERSIST
															//
															System.out.println("Saving instructor: " + tempInstructor);
															System.out.println("The courses: " + tempInstructor.getCourses());
															appDAO.save(tempInstructor);
															System.out.println("Done!");
														}
				
		Ví dụ One-To-Many Unidirectional Relationship
		
														package com.example.springdatajpa.entities;
														import jakarta.persistence.*;
														import lombok.*;
														import java.util.HashSet;
														import java.util.Set;
														@Entity
														@Table(name = "authors")
														@Data
														public class Author
														{
															@Id
															@GeneratedValue(strategy = GenerationType.SEQUENCE)
															private Long authorId;
															private String name;
															@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
															@JoinColumn(name = "author_id", referencedColumnName = "authorId")
															private Set<Book> books = new HashSet<>();
															// Uni-directional One to Many mapping -> One Author can have Many Books
															// Here, extra column 'author_id' will be created on the many side of the relationship i.e. in the Books table
														}
														
														package com.example.springdatajpa.entities;
														import jakarta.persistence.*;
														import lombok.*;
														@Entity
														@Table(name = "books")
														@Data
														public class Book
														{
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															private Long bookId;
															private String title;
														}
													
														package com.example.springdatajpa.entities;
														import jakarta.persistence.*;
														import lombok.*;
														@Entity
														@Table(name = "books")
														@Data
														public class Book
														{
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															private Long bookId;
															private String title;
														}
														
														package com.example.springdatajpa;
														import com.example.springdatajpa.entities.*;
														import com.example.springdatajpa.repositories.AuthorRepository;
														import com.example.springdatajpa.repositories.BookRepository;
														import com.example.springdatajpa.repositories.ProductRepository;
														import com.example.springdatajpa.repositories.StockRepository;
														import lombok.extern.slf4j.Slf4j;
														import org.springframework.boot.SpringApplication;
														import org.springframework.boot.autoconfigure.SpringBootApplication;
														import org.springframework.context.ApplicationContext;
														@SpringBootApplication
														@Slf4j
														public class SpringDataJpaApplication
														{
														 public static void main(String[] args)
														 {
														  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
														  AuthorRepository authorRepository = context.getBean(AuthorRepository.class);
														  BookRepository bookRepository = context.getBean(BookRepository.class);
														  // Create authors
														  Author author1 = new Author();
														  author1.setName("Deepak Kumar");
														  Author author2 = new Author();
														  author2.setName("Katty Janes");
														  // Create books
														  Book book1 = new Book();
														  book1.setTitle("Welcome to CSS");
														  Book book2 = new Book();
														  book2.setTitle("Javascript Programming");
														  // Associate books with authors
														  author1.getBooks().add(book1);
														  author2.getBooks().add(book2);
														  // Save authors (and cascade to save associated books)
														  authorRepository.save(author1);
														  authorRepository.save(author2);
														  // Retrieve and print saved authors (optional)
														  System.out.println("Saved Authors:");
														  authorRepository.findAll().forEach(System.out::println);
														 }
														}
			
		Ví dụ One-To-Many Bidirectional Relationship
														
														@Entity
														@Table(name = "BLOG_DETAILS")
														public class Blog {
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															@Column(name = "ID")
															private int id;
															@Column(name = "title")
															private String title;
															@Column(name = "category")
															private String category;
															@Column(name = "content")
															private String content;
															@ManyToOne(cascade = CascadeType.ALL)
															@JoinColumn(name = "owner_id")
															private Owner owner;
															public Blog() { }
															public Blog(String title, String category, String content) {
																this.title = title;
																this.category = category;
																this.content = content;
															}
															public int getId() { return id; }
															public void setId(int id) { this.id = id; }
															public String getTitle() { return title; }
															public void setTitle(String title) { this.title = title; }
															public String getCategory() { return category; }
															public void setCategory(String category) { this.category = category; }
															public String getContent() { return content; }
															public void setContent(String content) { this.content = content; }
															public Owner getOwner() { return owner; }
															public void setOwner(Owner owner) { this.owner = owner; }
															@Override
															public String toString() {
																return "Blog{" + "id=" + id + ", title='" + title + '\'' + ", category='" + category + '\'' +
																		", content='" + content + '\'' + '}';
															}
														}
														
														@Entity
														@Table(name = "OWNER_DETAILS")
														public class Owner {													
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															@Column(name = "ID")
															private int id;
															@Column(name = "name")
															private String name;
															@Column(name = "email")
															private String email;
															@OneToMany(fetch = FetchType.LAZY, mappedBy = "owner", cascade = CascadeType.ALL)
															private List<Blog> blogList;
															public Owner() { }
															public Owner(String name, String email) {
																this.name = name;
																this.email = email;
															}
															public int getId() { return id; }
															public void setId(int id) { this.id = id; }
															public String getName() {return name; }
															public void setName(String name) { this.name = name; }
															public String getEmail() { return email; }
															public void setEmail(String email) { this.email = email; }
															public List<Blog> getBlogList() { return blogList; }
															public void setBlogList(List<Blog> blogList) { this.blogList = blogList; }
															@Override
															public String toString() {
																return "Owner{" + "id=" + id + ", name='" + name + '\'' + ", email='" + email + '\'' + '}';
															}
														}
															
														@RestController
														@RequestMapping("/owner")
														public class OwnerController {
															@Autowired
															private OwnerRepository ownerRepository;
															@Autowired
															private BlogRepository blogRepository;
															@PostMapping("/saveOwner")
															public String saveOwner(@RequestBody Owner owner) {
																System.out.println("Owner save called...");
															// a new Owner
																Owner ownerIn = new Owner(owner.getName(), owner.getEmail());
															// list of Blog
																List<Blog> blogs = new ArrayList<>();
																for (Blog blogIn : owner.getBlogList()) {
																	// new Blog
																	Blog blog = new Blog(blogIn.getTitle(), blogIn.getCategory(), blogIn.getContent());
																	// set owner to Blog
																	blog.setOwner(ownerIn);
																	// add blog to list
																	blogs.add(blog);
																}													
																// add blog list to Owner
																ownerIn.setBlogList(blogs);
															// save Owner
																Owner ownerOut = ownerRepository.save(ownerIn);
																System.out.println("Owner out :: " + ownerOut);
																System.out.println("Saved!!!");
																return "Owner saved!!!";
															}
															@PostMapping("/saveBlog")
															public String saveBlog(@RequestParam(name = "id") String id) {
																System.out.println("Blog save called...");													
															// fetch Ower
																Owner ownerTemp = ownerRepository.getById(Integer.valueOf(id));
															// list of Blog
																List<Blog> blogs = new ArrayList<>();
															// new Blog
																Blog blog = new Blog("Build application server using NodeJs", "nodeJs",
																		"We will build REStful api using nodeJs.");
															// set owner to blog
																blog.setOwner(ownerTemp);
																// add Blog to list
																blogs.add(blog);
																blog = new Blog("Single Page Application using Angular", "Angular",
																		"We can build robust application using Angular framework.");
															// set owner to blog
																blog.setOwner(ownerTemp);
																blogs.add(blog);
															// add Blog list to Owner
																ownerTemp.setBlogList(blogs);
															// save Owner
																ownerRepository.save(ownerTemp);
																System.out.println("Saved!!!");
																return "Blog saved!!!";
															}
															@GetMapping("/getOwner/{id}")
															public String getOwner(@PathVariable(name = "id") String id) {
																System.out.println("Owner get called...");
															// fetch Owner
																Owner ownerOut = ownerRepository.getById(Integer.valueOf(id));
																System.out.println("\nOwner details :: \n" + ownerOut);
																System.out.println("\nList of Blogs :: \n" + ownerOut.getBlogList());
																System.out.println("\nDone!!!");
																return "Owner fetched...";
															}
															@GetMapping("/getBlog/{id}")
															public String getBlog(@PathVariable(name = "id") String id) {
																System.out.println("Blog get called...");
															// fetch Blog
																Blog blogOut = blogRepository.getById(Integer.valueOf(id));
																System.out.println("\nBlog details :: \n" + blogOut);
																System.out.println("\nOwner details :: \n" + blogOut.getOwner());
																System.out.println("\nDone!!!");
																return "Blog fetched...";
															}
														}

		Example 1:
		
													@Entity
													@Table(name="course")
													public class Course {
														…
														@ManyToOne
														@JoinColumn(name="instructor_id")
														private Instructor instructor;
														…
														// constructors, getters / setters
													}
													
													@Entity
													@Table(name="instructor")
													public class Instructor {
														…
														@OneToMany(mappedBy="instructor")
														private List<Course> courses;
														public List<Course> getCourses() {
															return courses;
														}
														public void setCourses(List<Course> courses) {
															this.courses = courses;
														} …
													}
		Example 2:
							
													@Entity
													@Table(name="CART")
													public class Cart {
														//...
														@OneToMany(mappedBy="cart")
														private Set<Item> items;												
														// getters and setters
													}
													
													@Entity
													@Table(name="ITEMS")
													public class Item {													
														//...
														@ManyToOne
														@JoinColumn(name="cart_id", nullable=false)
														private Cart cart;
														public Item() {}												
														// getters and setters
													}
													
		Example 3:
		
													Course chứa foreign key của Instructor
		
			sql:
			
													DROP SCHEMA IF EXISTS `hb-04-one-to-many-uni`;
													CREATE SCHEMA `hb-04-one-to-many-uni`;
													use `hb-04-one-to-many-uni`;
													SET FOREIGN_KEY_CHECKS = 0;
													CREATE TABLE `instructor_detail` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `youtube_channel` varchar(128) DEFAULT NULL,
													  `hobby` varchar(45) DEFAULT NULL,
													  PRIMARY KEY (`id`)
													) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
													CREATE TABLE `instructor` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `first_name` varchar(45) DEFAULT NULL,
													  `last_name` varchar(45) DEFAULT NULL,
													  `email` varchar(45) DEFAULT NULL,
													  `instructor_detail_id` int DEFAULT NULL,
													  PRIMARY KEY (`id`),
													  KEY `FK_DETAIL_idx` (`instructor_detail_id`),
													  CONSTRAINT `FK_DETAIL` FOREIGN KEY (`instructor_detail_id`) 
													  REFERENCES `instructor_detail` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
													) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
													CREATE TABLE `course` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `title` varchar(128) DEFAULT NULL,
													  `instructor_id` int DEFAULT NULL,												 
													  PRIMARY KEY (`id`),												  
													  UNIQUE KEY `TITLE_UNIQUE` (`title`),								  
													  KEY `FK_INSTRUCTOR_idx` (`instructor_id`),								  
													  CONSTRAINT `FK_INSTRUCTOR` 
													  FOREIGN KEY (`instructor_id`) 
													  REFERENCES `instructor` (`id`) 					  
													  ON DELETE NO ACTION ON UPDATE NO ACTION
													) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=latin1;
													CREATE TABLE `review` (
													  `id` int NOT NULL AUTO_INCREMENT,
													  `comment` varchar(256) DEFAULT NULL,
													  `course_id` int DEFAULT NULL,
													  PRIMARY KEY (`id`),
													  KEY `FK_COURSE_ID_idx` (`course_id`),
													  CONSTRAINT `FK_COURSE` 
													  FOREIGN KEY (`course_id`) 
													  REFERENCES `course` (`id`) 
													  ON DELETE NO ACTION ON UPDATE NO ACTION
													) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=latin1;
													SET FOREIGN_KEY_CHECKS = 1;
				
			Course.java:
		
													package com.luv2code.cruddemo.entity;
													import jakarta.persistence.*;
													import java.util.ArrayList;
													import java.util.List;
													@Entity
													@Table(name="course")
													public class Course {
														// define our fields
														// define constructors
														// define getter setters
														// define toString
														// annotate fields
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														@Column(name="id")
														private int id;
														@Column(name="title")
														private String title;
														@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE,
																			  CascadeType.DETACH, CascadeType.REFRESH})
														@JoinColumn(name="instructor_id")
														private Instructor instructor;
														@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
														@JoinColumn(name = "course_id")
														private List<Review> reviews;
														public Course() {
														}
														public Course(String title) {
															this.title = title;
														}
														public int getId() {
															return id;
														}
														public void setId(int id) {
															this.id = id;
														}
														public String getTitle() {
															return title;
														}
														public void setTitle(String title) {
															this.title = title;
														}
														public Instructor getInstructor() {
															return instructor;
														}
														public void setInstructor(Instructor instructor) {
															this.instructor = instructor;
														}
														public List<Review> getReviews() {
															return reviews;
														}
														public void setReviews(List<Review> reviews) {
															this.reviews = reviews;
														}
														// add a convenience method
														public void addReview(Review theReview) {
															if (reviews == null) {
																reviews = new ArrayList<>();
															}
															reviews.add(theReview);
														}
														@Override
														public String toString() {
															return "Course{" +
																	"id=" + id +
																	", title='" + title + '\'' +
																	'}';
														}
													}
													
		Instructor.java:
													
													package com.luv2code.cruddemo.entity;
													import jakarta.persistence.*;
													import java.util.ArrayList;
													import java.util.List;
													@Entity
													@Table(name="instructor")
													public class Instructor {
														// annotate the class as an entity and map to db table
														// define the fields
														// annotate the fields with db column names
														// ** set up mapping to InstructorDetail entity
														// create constructors
														// generate getter/setter methods
														// generate toString() method
														@Id
														@GeneratedValue(strategy = GenerationType.IDENTITY)
														@Column(name="id")
														private int id;
														@Column(name="first_name")
														private String firstName;
														@Column(name="last_name")
														private String lastName;
														@Column(name="email")
														private String email;
														@OneToOne(cascade = CascadeType.ALL)
														@JoinColumn(name = "instructor_detail_id")
														private InstructorDetail instructorDetail;
														@OneToMany(mappedBy = "instructor",
																   fetch = FetchType.LAZY,
																   cascade = {CascadeType.PERSIST, CascadeType.MERGE,
																			  CascadeType.DETACH, CascadeType.REFRESH})
														private List<Course> courses;
														public Instructor() {
														}
														public Instructor(String firstName, String lastName, String email) {
															this.firstName = firstName;
															this.lastName = lastName;
															this.email = email;
														}
														public int getId() {
															return id;
														}
														public void setId(int id) {
															this.id = id;
														}
														public String getFirstName() {
															return firstName;
														}
														public void setFirstName(String firstName) {
															this.firstName = firstName;
														}
														public String getLastName() {
															return lastName;
														}
														public void setLastName(String lastName) {
															this.lastName = lastName;
														}
														public String getEmail() {
															return email;
														}
														public void setEmail(String email) {
															this.email = email;
														}
														public InstructorDetail getInstructorDetail() {
															return instructorDetail;
														}
														public void setInstructorDetail(InstructorDetail instructorDetail) {
															this.instructorDetail = instructorDetail;
														}
														@Override
														public String toString() {
															return "Instructor{" +
																	"id=" + id +
																	", firstName='" + firstName + '\'' +
																	", lastName='" + lastName + '\'' +
																	", email='" + email + '\'' +
																	", instructorDetail=" + instructorDetail +
																	'}';
														}
														public List<Course> getCourses() {
															return courses;
														}
														public void setCourses(List<Course> courses) {
															this.courses = courses;
														}
														// add convenience methods for bi-directional relationship
														public void add(Course tempCourse) {
															if (courses == null) {
																courses = new ArrayList<>();
															}
															courses.add(tempCourse);
															tempCourse.setInstructor(this);
														}
													}
													
		AppDAOImpl.java:											
													
													package com.luv2code.cruddemo.dao;
													import com.luv2code.cruddemo.entity.Course;
													import com.luv2code.cruddemo.entity.Instructor;
													import com.luv2code.cruddemo.entity.InstructorDetail;
													import jakarta.persistence.EntityManager;
													import jakarta.persistence.TypedQuery;
													import org.springframework.beans.factory.annotation.Autowired;
													import org.springframework.stereotype.Repository;
													import org.springframework.transaction.annotation.Transactional;
													import java.util.List;
													@Repository
													public class AppDAOImpl implements AppDAO {
														// define field for entity manager
														private EntityManager entityManager;
														// inject entity manager using constructor injection
														@Autowired
														public AppDAOImpl(EntityManager entityManager) {
															this.entityManager = entityManager;
														}
														@Override
														@Transactional
														public void save(Instructor theInstructor) {
															entityManager.persist(theInstructor);
														}
														@Override
														public Instructor findInstructorById(int theId) {
															return entityManager.find(Instructor.class, theId);
														}
														@Override
														@Transactional
														public void deleteInstructorById(int theId) {
															// retrieve the instructor
															Instructor tempInstructor = entityManager.find(Instructor.class, theId);
															// get the courses
															List<Course> courses = tempInstructor.getCourses();
															// break association of all courses for the instructor
															for (Course tempCourse : courses) {
																tempCourse.setInstructor(null);
															}
															// delete the instructor
															entityManager.remove(tempInstructor);
														}
														@Override
														public InstructorDetail findInstructorDetailById(int theId) {
															return entityManager.find(InstructorDetail.class, theId);
														}
														@Override
														@Transactional
														public void deleteInstructorDetailById(int theId) {
															// retrieve instructor detail
															InstructorDetail tempInstructorDetail = entityManager.find(InstructorDetail.class, theId);
															// remove the associated object reference
															// break bi-directional link
															//
															tempInstructorDetail.getInstructor().setInstructorDetail(null);
															// delete the instructor detail
															entityManager.remove(tempInstructorDetail);
														}
														@Override
														public List<Course> findCoursesByInstructorId(int theId) {
															// create query
															TypedQuery<Course> query = entityManager.createQuery(
																						"from Course where instructor.id = :data", Course.class);
															query.setParameter("data", theId);
															// execute query
															List<Course> courses = query.getResultList();
															return courses;
														}
														@Override
														public Instructor findInstructorByIdJoinFetch(int theId) {
															// create query
															TypedQuery<Instructor> query = entityManager.createQuery(
																									"select i from Instructor i "
																										+ "JOIN FETCH i.courses "
																										+ "JOIN FETCH i.instructorDetail "
																										+ "where i.id = :data", Instructor.class);
															query.setParameter("data", theId);
															// execute query
															Instructor instructor = query.getSingleResult();
															return instructor;
														}
														@Override
														@Transactional
														public void update(Instructor tempInstructor) {
															entityManager.merge(tempInstructor);
														}
														@Override
														@Transactional
														public void update(Course tempCourse) {
															entityManager.merge(tempCourse);
														}
														@Override
														public Course findCourseById(int theId) {
															return entityManager.find(Course.class, theId);
														}
														@Override
														@Transactional
														public void deleteCourseById(int theId) {
															// retrieve the course
															Course tempCourse = entityManager.find(Course.class, theId);
															// delete the course
															entityManager.remove(tempCourse);												}
														@Override
														@Transactional
														public void save(Course theCourse) {
															entityManager.persist(theCourse);
														}
														@Override
														public Course findCourseAndReviewsByCourseId(int theId) {
															// create query
															TypedQuery<Course> query = entityManager.createQuery(
																	"select c from Course c "
																	+ "JOIN FETCH c.reviews "
																	+ "where c.id = :data", Course.class);
															query.setParameter("data", theId);
															// execute query
															Course course = query.getSingleResult();
															return course;
														}
													}
													
			CruddemoApplication.java:
			
													package com.luv2code.cruddemo;
													import com.luv2code.cruddemo.dao.AppDAO;
													import com.luv2code.cruddemo.entity.Course;
													import com.luv2code.cruddemo.entity.Instructor;
													import com.luv2code.cruddemo.entity.InstructorDetail;
													import com.luv2code.cruddemo.entity.Review;
													import org.springframework.boot.CommandLineRunner;
													import org.springframework.boot.SpringApplication;
													import org.springframework.boot.autoconfigure.SpringBootApplication;
													import org.springframework.context.annotation.Bean;
													import java.util.List;
													@SpringBootApplication
													public class CruddemoApplication {
														public static void main(String[] args) {
															SpringApplication.run(CruddemoApplication.class, args);
														}
														@Bean
														public CommandLineRunner commandLineRunner(AppDAO appDAO) {
															return runner -> {
																// createCourseAndReviews(appDAO);
																// retrieveCourseAndReviews(appDAO);
																deleteCourseAndReviews(appDAO);
															};
														}
														private void deleteCourseAndReviews(AppDAO appDAO) {
															int theId = 10;
															System.out.println("Deleting course id: " + theId);
															appDAO.deleteCourseById(theId);
															System.out.println("Done!");
														}
														private void retrieveCourseAndReviews(AppDAO appDAO) {
															// get the course and reviews
															int theId = 10;
															Course tempCourse = appDAO.findCourseAndReviewsByCourseId(theId);
															// print the course
															System.out.println(tempCourse);
															// print the reviews
															System.out.println(tempCourse.getReviews());
														}
														private void createCourseAndReviews(AppDAO appDAO) {
															// create a course
															Course tempCourse = new Course("Pacman - How To Score One Million Points");
															// add some reviews
															tempCourse.addReview(new Review("Great course ... loved it!"));
															tempCourse.addReview(new Review("Cool course, job well done."));
															tempCourse.addReview(new Review("What a dumb course, you are an idiot!"));
															// save the course ... and leverage the cascade all
															System.out.println("Saving the course");
															System.out.println(tempCourse);
															System.out.println(tempCourse.getReviews());
															appDAO.save(tempCourse);
															System.out.println("Done!");
														}
														private void deleteCourse(AppDAO appDAO) {
															int theId = 10;
															System.out.println("Deleting course id: " + theId);
															appDAO.deleteCourseById(theId);
															System.out.println("Done!");
														}
														private void updateCourse(AppDAO appDAO) {
															int theId = 10;
															// find the course
															System.out.println("Finding course id: " + theId);
															Course tempCourse = appDAO.findCourseById(theId);
															// update the course
															System.out.println("Updating course id: " + theId);
															tempCourse.setTitle("Enjoy the Simple Things");
															appDAO.update(tempCourse);
															System.out.println("Done!");
														}
														private void updateInstructor(AppDAO appDAO) {
															int theId = 1;
															// find the instructor
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorById(theId);
															// update the instructor
															System.out.println("Updating instructor id: " + theId);
															tempInstructor.setLastName("TESTER");
															appDAO.update(tempInstructor);
															System.out.println("Done!");
														}
														private void findInstructorWithCoursesJoinFetch(AppDAO appDAO) {
															int theId = 1;
															// find the instructor
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorByIdJoinFetch(theId);
															System.out.println("tempInstructor: " + tempInstructor);
															System.out.println("the associated courses: " + tempInstructor.getCourses());
															System.out.println("Done!");
														}
														private void findCoursesForInstructor(AppDAO appDAO) {
															int theId = 1;
															// find instructor
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorById(theId);
															System.out.println("tempInstructor: " + tempInstructor);
															// find courses for instructor
															System.out.println("Finding courses for instructor id: " + theId);
															List<Course> courses = appDAO.findCoursesByInstructorId(theId);
															// associate the objects
															tempInstructor.setCourses(courses);
															System.out.println("the associated courses: " + tempInstructor.getCourses());
															System.out.println("Done!");
														}
														private void findInstructorWithCourses(AppDAO appDAO) {
															int theId = 1;
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorById(theId);
															System.out.println("tempInstructor: " + tempInstructor);
															System.out.println("the associated courses: " + tempInstructor.getCourses());
															System.out.println("Done!");
														}
														private void createInstructorWithCourses(AppDAO appDAO) {
															// create the instructor
															Instructor tempInstructor =
																	new Instructor("Susan", "Public", "susan.public@luv2code.com");
															// create the instructor detail
															InstructorDetail tempInstructorDetail =
																	new InstructorDetail(
																			"http://www.youtube.com",
																			"Video Games");
															// associate the objects
															tempInstructor.setInstructorDetail(tempInstructorDetail);
															// create some courses
															Course tempCourse1 = new Course("Air Guitar - The Ultimate Guide");
															Course tempCourse2 = new Course("The Pinball Masterclass");
															// add courses to instructor
															tempInstructor.add(tempCourse1);
															tempInstructor.add(tempCourse2);
															// save the instructor
															//
															// NOTE: this will ALSO save the courses
															// because of CascadeType.PERSIST
															//
															System.out.println("Saving instructor: " + tempInstructor);
															System.out.println("The courses: " + tempInstructor.getCourses());
															appDAO.save(tempInstructor);
															System.out.println("Done!");
														}
														private void deleteInstructorDetail(AppDAO appDAO) {
															int theId = 3;
															System.out.println("Deleting instructor detail id: " + theId);
															appDAO.deleteInstructorDetailById(theId);
															System.out.println("Done!");
														}
														private void findInstructorDetail(AppDAO appDAO) {
															// get the instructor detail object
															int theId = 2;
															InstructorDetail tempInstructorDetail = appDAO.findInstructorDetailById(theId);
															// print the instructor detail
															System.out.println("tempInstructorDetail: " + tempInstructorDetail);
															// print the associated instructor
															System.out.println("the associated instructor: " + tempInstructorDetail.getInstructor());
															System.out.println("Done!");
														}
														private void deleteInstructor(AppDAO appDAO) {
															int theId = 1;
															System.out.println("Deleting instructor id: " + theId);
															appDAO.deleteInstructorById(theId);
															System.out.println("Done!");
														}
														private void findInstructor(AppDAO appDAO) {
															int theId = 2;
															System.out.println("Finding instructor id: " + theId);
															Instructor tempInstructor = appDAO.findInstructorById(theId);
															System.out.println("tempInstructor: " + tempInstructor);
															System.out.println("the associated instructorDetail only: " + tempInstructor.getInstructorDetail());
														}
														private void createInstructor(AppDAO appDAO) {
															/*
															// create the instructor
															Instructor tempInstructor =
																	new Instructor("Chad", "Darby", "darby@luv2code.com");
															// create the instructor detail
															InstructorDetail tempInstructorDetail =
																	new InstructorDetail(
																			"http://www.luv2code.com/youtube",
																			"Luv 2 code!!!");
															*/
															// create the instructor
															Instructor tempInstructor =
																	new Instructor("Madhu", "Patel", "madhu@luv2code.com");
															// create the instructor detail
															InstructorDetail tempInstructorDetail =
																	new InstructorDetail(
																			"http://www.luv2code.com/youtube",
																			"Guitar");
															// associate the objects
															tempInstructor.setInstructorDetail(tempInstructorDetail);
															// save the instructor
															//
															// NOTE: this will ALSO save the details object
															// because of CascadeType.ALL
															//
															System.out.println("Saving instructor: " + tempInstructor);
															appDAO.save(tempInstructor);
															System.out.println("Done!");
														}
													}
		
		Add convenience methods for bi-directional:
														@Entity
														@Table(name="instructor")
														public class Instructor {
															…															
															public void add(Course tempCourse) { // add convenience methods for bi-directional relationship
															if (courses == null) {
																courses = new ArrayList<>();
															}
															courses.add(tempCourse);
															tempCourse.setInstructor(this);
															}…
														}
		Delete Instructor:								@Override
														@Transactional
														public void deleteInstructorById(int theId) {																														
															Instructor tempInstructor = entityManager.find(Instructor.class, theId); // retrieve the instructor
															List<Course> courses = tempInstructor.getCourses();																														
															for (Course tempCourse : courses) { // break associations of all courses for instructor
																tempCourse.setInstructor(null); // Remove the instructor from the courses
															}																														
															entityManager.remove(tempInstructor); // We only delete the instructor …
																								  // not the associated course based on our cascade types
														}				
	@ManyToMany--SPRING:
	
														
								- Cần tạo 1 table trung gian trong code sql cũng như code java (@JoinTable)
								- The joinColumn attribute will connect to the owner side of the relationship, and the inverseJoinColumn to the other side
								- Keep in mind that since a many-to-many relationship doesn’t have an owner side in the database, we could configure the join table in the Course class and reference it
								from the Student class.
								- Chú ý từ @JoinTable ta mới tạo 1 biến để link đến bảng đối diện
								- Sử dụng bảng trung gian chứa các khóa ngoại tham chiếu đến khóa chính của cả hai bảng chính.
		
		Theo quy tắc thiết kế Cơ sở dữ liệu, khi có Quan hệ Nhiều - Nhiều (N-N) xuất hiện, Cơ sở dữ liệu sẽ:
		
								- Sinh thêm Bảng (table) Trung gian.
								- Bảng (table) Trung gian sẽ có tên là tên của Mối quan hệ Nhiều - Nhiều (N-N).
								- Trong bảng (table) Trung gian sẽ có đầy đủ khóa ngoại (Foreign key - FK) liên kết đến table Master.
								- Trong bảng (table) Trung gian sẽ có thêm các cột dùng để lưu trữ thông tin bổ sung/làm rõ nghĩa Mối quan hệ Nhiều - Nhiều (N-N). Tuy nhiên, các cột này không bắt buộc (tùy vào thiết kế
								của bạn)
		
		Ví dụ Many-To-Many Unidirectional Relationship
								
								package com.example.springdatajpa.entities;
								import jakarta.persistence.*;
								import lombok.Data;
								import java.util.HashSet;
								import java.util.Set;
								@Entity
								@Data
								public class Student
								{
									@Id
									@GeneratedValue(strategy = GenerationType.IDENTITY)
									private Long studentId;
									private String name;
									@ManyToMany(fetch = FetchType.EAGER)
									@JoinTable(
											name = "student_courses",
											joinColumns = @JoinColumn(name = "student_id", referencedColumnName = "studentId"),
											inverseJoinColumns = @JoinColumn(name = "course_id", referencedColumnName = "courseId"))
									private Set<Course> courses = new HashSet<>();
								}
								
								package com.example.springdatajpa.entities;
								import jakarta.persistence.Entity;
								import jakarta.persistence.GeneratedValue;
								import jakarta.persistence.GenerationType;
								import jakarta.persistence.Id;
								import lombok.Data;
								@Entity
								@Data
								public class Course
								{
									@Id
									@GeneratedValue(strategy = GenerationType.SEQUENCE)
									private Long courseId;
									private String name;
									private String courseCode;
								}
								
								package com.example.springdatajpa;
								import com.example.springdatajpa.entities.*;
								import com.example.springdatajpa.repositories.*;
								import lombok.extern.slf4j.Slf4j;
								import org.springframework.boot.SpringApplication;
								import org.springframework.boot.autoconfigure.SpringBootApplication;
								import org.springframework.context.ApplicationContext;
								@SpringBootApplication
								@Slf4j
								public class SpringDataJpaApplication
								{
								 public static void main(String[] args)
								 {
								  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
								  StudentRepository studentRepository = context.getBean(StudentRepository.class);
								  CourseRepository courseRepository = context.getBean(CourseRepository.class);
								  // Create and save sample courses
								  Course course1 = new Course();
								  course1.setName("Course 101");
								  course1.setCourseCode("Python");
								  courseRepository.save(course1);
								  Course course2 = new Course();
								  course2.setName("Course 102");
								  course2.setCourseCode("Javascript");
								  courseRepository.save(course2);
								  // Create and save sample students
								  Student student1 = new Student();
								  student1.setName("Ravi");
								  student1.getCourses().add(course1);
								  studentRepository.save(student1);
								  Student student2 = new Student();
								  student2.setName("Deepak");
								  student2.getCourses().add(course1);
								  student2.getCourses().add(course2);
								  studentRepository.save(student2);
								  // Retrieve and print saved Students (optional)
								  System.out.println("Saved Departments:");
								  studentRepository.findAll().forEach(System.out::println);
								 }
								}
		
		Ví dụ Many-To-Many Bidirectional Relationship
		
								package com.example.springdatajpa.entities;
								import jakarta.persistence.*;
								import lombok.Data;
								import java.util.HashSet;
								import java.util.Set;
								@Entity
								@Data
								public class Student
								{
									@Id
									@GeneratedValue(strategy = GenerationType.IDENTITY)
									private Long studentId;
									private String name;
									@ManyToMany(fetch = FetchType.EAGER)
									@JoinTable(
											name = "student_courses",
											joinColumns = @JoinColumn(name = "student_id", referencedColumnName = "studentId"),
											inverseJoinColumns = @JoinColumn(name = "course_id", referencedColumnName = "courseId"))
									private Set<Course> courses = new HashSet<>();
								}
								
								package com.example.springdatajpa.entities;
								import jakarta.persistence.*;
								import lombok.Data;
								import java.util.HashSet;
								import java.util.Set;
								@Entity
								@Data
								public class Course
								{
									@Id
									@GeneratedValue(strategy = GenerationType.SEQUENCE)
									private Long courseId;
									private String name;
									private String courseCode;
									@ManyToMany(mappedBy = "courses")
									private Set<Student> students = new HashSet<>();
								}
								
								package com.example.springdatajpa;
								import com.example.springdatajpa.entities.*;
								import com.example.springdatajpa.repositories.*;
								import lombok.extern.slf4j.Slf4j;
								import org.springframework.boot.SpringApplication;
								import org.springframework.boot.autoconfigure.SpringBootApplication;
								import org.springframework.context.ApplicationContext;
								@SpringBootApplication
								@Slf4j
								public class SpringDataJpaApplication
								{
								 public static void main(String[] args)
								 {
								  ApplicationContext context = SpringApplication.run(SpringDataJpaApplication.class, args);
								  StudentRepository studentRepository = context.getBean(StudentRepository.class);
								  CourseRepository courseRepository = context.getBean(CourseRepository.class);
								  // Create students
								  Student student1 = new Student();
								  Student student2 = new Student();
								  student1.setName("James Smith");
								  student2.setName("Shane Wanes");
								  // Create courses
								  Course course1 = new Course();
								  Course course2 = new Course();
								  course1.setCourseCode("ME");
								  course1.setName("Mechanical");
								  course2.setCourseCode("CSE");
								  course2.setName("Computers");
								  // Associate students with courses
								  student1.getCourses().add(course1);
								  student1.getCourses().add(course2);
								  student2.getCourses().add(course2);
								  // Save students and courses
								  courseRepository.save(course1);
								  courseRepository.save(course2);
								  studentRepository.save(student1);
								  studentRepository.save(student2);
								  // Retrieve and print saved Students (optional)
								  System.out.println("Saved Students:");
								  studentRepository.findAll().forEach(System.out::println);
								 }
								}		
		
		Example 1:
		
														@Entity
														@Table(name="course")
														public class Course {
															…
															@ManyToMany
															@JoinTable(
																name="course_student",
																joinColumns=@JoinColumn(name="course_id"),
																inverseJoinColumns=@JoinColumn(name="student_id")
															)
															private List<Student> students;
															// getter / setters
															…
														}
														
														@Entity
														@Table(name="student")
														public class Student {
															…
															@ManyToMany
															@JoinTable(
																name="course_student",
																joinColumns=@JoinColumn(name="student_id"),
																inverseJoinColumns=@JoinColumn(name="course_id")
															)
															private List<Course> courses;
															// getter / setters
															…
														}
		
		Example 2:
		
														@Entity
														class Student {
															@Id
															Long id;
															@ManyToMany
															Set<Course> likedCourses;
															// additional properties
															// standard constructors, getters, and setters
														}
														@Entity
														class Course {
															@Id
															Long id;
															@ManyToMany
															Set<Student> likes;
															// additional properties
															// standard constructors, getters, and setters
														}
														
														@ManyToMany
														@JoinTable(
														  name = "course_like", 
														  joinColumns = @JoinColumn(name = "student_id"), 
														  inverseJoinColumns = @JoinColumn(name = "course_id"))
														Set<Course> likedCourses;
														
		Example 3:
		
			Course.java:

														package com.luv2code.cruddemo.entity;
														import jakarta.persistence.*;
														import java.util.ArrayList;
														import java.util.List;
														@Entity
														@Table(name="course")
														public class Course {
															// define our fields
															// define constructors
															// define getter setters
															// define toString
															// annotate fields
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															@Column(name="id")
															private int id;
															@Column(name="title")
															private String title;
															@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE,
																				  CascadeType.DETACH, CascadeType.REFRESH})
															@JoinColumn(name="instructor_id")
															private Instructor instructor;
															@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
															@JoinColumn(name = "course_id")
															private List<Review> reviews;
															@ManyToMany(fetch = FetchType.LAZY,
																	cascade = {CascadeType.PERSIST, CascadeType.MERGE,
																	CascadeType.DETACH, CascadeType.REFRESH})
															@JoinTable(
																	name = "course_student",
																	joinColumns = @JoinColumn(name = "course_id"),
																	inverseJoinColumns = @JoinColumn(name = "student_id")
															)
															private List<Student> students;
															public Course() {
															}
															public Course(String title) {
																this.title = title;
															}
															public int getId() {
																return id;
															}
															public void setId(int id) {
																this.id = id;
															}
															public String getTitle() {
																return title;
															}
															public void setTitle(String title) {
																this.title = title;
															}
															public Instructor getInstructor() {
																return instructor;
															}
															public void setInstructor(Instructor instructor) {
																this.instructor = instructor;
															}
															public List<Review> getReviews() {
																return reviews;
															}
															public void setReviews(List<Review> reviews) {
																this.reviews = reviews;
															}
															// add a convenience method
															public void addReview(Review theReview) {
																if (reviews == null) {
																	reviews = new ArrayList<>();
																}
																reviews.add(theReview);
															}
															public List<Student> getStudents() {
																return students;
															}
															public void setStudents(List<Student> students) {
																this.students = students;
															}
															// add a convenience method
															public void addStudent(Student theStudent) {
																if (students == null) {
																	students = new ArrayList<>();
																}
																students.add(theStudent);
															}
															@Override
															public String toString() {
																return "Course{" +
																		"id=" + id +
																		", title='" + title + '\'' +
																		'}';
															}
														}
														
			Student.java:
			
														package com.luv2code.cruddemo.entity;
														import jakarta.persistence.*;
														import java.util.ArrayList;
														import java.util.List;
														@Entity
														@Table(name = "student")
														public class Student {
															@Id
															@GeneratedValue(strategy = GenerationType.IDENTITY)
															@Column(name = "id")
															private int id;
															@Column(name = "first_name")
															private String firstName;
															@Column(name = "last_name")
															private String lastName;
															@Column(name = "email")
															private String email;
															@ManyToMany(fetch = FetchType.LAZY,
																	cascade = {CascadeType.PERSIST, CascadeType.MERGE,
																			CascadeType.DETACH, CascadeType.REFRESH})
															@JoinTable(
																	name = "course_student",
																	joinColumns = @JoinColumn(name = "student_id"),
																	inverseJoinColumns = @JoinColumn(name = "course_id")
															)
															private List<Course> courses;
															public Student() {
															}
															public Student(String firstName, String lastName, String email) {
																this.firstName = firstName;
																this.lastName = lastName;
																this.email = email;
															}
															public int getId() {
																return id;
															}
															public void setId(int id) {
																this.id = id;
															}
															public String getFirstName() {
																return firstName;
															}
															public void setFirstName(String firstName) {
																this.firstName = firstName;
															}
															public String getLastName() {
																return lastName;
															}
															public void setLastName(String lastName) {
																this.lastName = lastName;
															}
															public String getEmail() {
																return email;
															}
															public void setEmail(String email) {
																this.email = email;
															}
															public List<Course> getCourses() {
																return courses;
															}
															public void setCourses(List<Course> courses) {
																this.courses = courses;
															}
															// add convenience method
															public void addCourse(Course theCourse) {
																if (courses == null) {
																	courses = new ArrayList<>();
																}
																courses.add(theCourse);
															}
															@Override
															public String toString() {
																return "Student{" +
																		"id=" + id +
																		", firstName='" + firstName + '\'' +
																		", lastName='" + lastName + '\'' +
																		", email='" + email + '\'' +
																		'}';
															}
														}
														
			AppDAOImpl.java:
			
														package com.luv2code.cruddemo.dao;
														import com.luv2code.cruddemo.entity.Course;
														import com.luv2code.cruddemo.entity.Instructor;
														import com.luv2code.cruddemo.entity.InstructorDetail;
														import com.luv2code.cruddemo.entity.Student;
														import jakarta.persistence.EntityManager;
														import jakarta.persistence.TypedQuery;
														import org.springframework.beans.factory.annotation.Autowired;
														import org.springframework.stereotype.Repository;
														import org.springframework.transaction.annotation.Transactional;
														import java.util.List;
														@Repository
														public class AppDAOImpl implements AppDAO {
															// define field for entity manager
															private EntityManager entityManager;
															// inject entity manager using constructor injection
															@Autowired
															public AppDAOImpl(EntityManager entityManager) {
																this.entityManager = entityManager;
															}
															@Override
															@Transactional
															public void save(Instructor theInstructor) {
																entityManager.persist(theInstructor);
															}
															@Override
															public Instructor findInstructorById(int theId) {
																return entityManager.find(Instructor.class, theId);
															}
															@Override
															@Transactional
															public void deleteInstructorById(int theId) {
																// retrieve the instructor
																Instructor tempInstructor = entityManager.find(Instructor.class, theId);
																// get the courses
																List<Course> courses = tempInstructor.getCourses();
																// break association of all courses for the instructor
																for (Course tempCourse : courses) {
																	tempCourse.setInstructor(null);
																}
																// delete the instructor
																entityManager.remove(tempInstructor);
															}
															@Override
															public InstructorDetail findInstructorDetailById(int theId) {
																return entityManager.find(InstructorDetail.class, theId);
															}
															@Override
															@Transactional
															public void deleteInstructorDetailById(int theId) {
																// retrieve instructor detail
																InstructorDetail tempInstructorDetail = entityManager.find(InstructorDetail.class, theId);
																// remove the associated object reference
																// break bi-directional link
																//
																tempInstructorDetail.getInstructor().setInstructorDetail(null);
																// delete the instructor detail
																entityManager.remove(tempInstructorDetail);
															}
															@Override
															public List<Course> findCoursesByInstructorId(int theId) {
																// create query
																TypedQuery<Course> query = entityManager.createQuery(
																							"from Course where instructor.id = :data", Course.class);
																query.setParameter("data", theId);
																// execute query
																List<Course> courses = query.getResultList();
																return courses;
															}
															@Override
															public Instructor findInstructorByIdJoinFetch(int theId) {
																// create query
																TypedQuery<Instructor> query = entityManager.createQuery(
																										"select i from Instructor i "
																											+ "JOIN FETCH i.courses "
																											+ "JOIN FETCH i.instructorDetail "
																											+ "where i.id = :data", Instructor.class);
																query.setParameter("data", theId);
																// execute query
																Instructor instructor = query.getSingleResult();
																return instructor;
															}
															@Override
															@Transactional
															public void update(Instructor tempInstructor) {
																entityManager.merge(tempInstructor);
															}
															@Override
															@Transactional
															public void update(Course tempCourse) {
																entityManager.merge(tempCourse);
															}
															@Override
															public Course findCourseById(int theId) {
																return entityManager.find(Course.class, theId);
															}
															@Override
															@Transactional
															public void deleteCourseById(int theId) {
																// retrieve the course
																Course tempCourse = entityManager.find(Course.class, theId);
																// delete the course
																entityManager.remove(tempCourse);
															}
															@Override
															@Transactional
															public void save(Course theCourse) {
																entityManager.persist(theCourse);
															}
															@Override
															public Course findCourseAndReviewsByCourseId(int theId) {
																// create query
																TypedQuery<Course> query = entityManager.createQuery(
																		"select c from Course c "
																		+ "JOIN FETCH c.reviews "
																		+ "where c.id = :data", Course.class);
																query.setParameter("data", theId);
																// execute query
																Course course = query.getSingleResult();
																return course;
															}
															@Override
															public Course findCourseAndStudentsByCourseId(int theId) {
																// create query
																TypedQuery<Course> query = entityManager.createQuery(
																		"select c from Course c "
																				+ "JOIN FETCH c.students "
																				+ "where c.id = :data", Course.class);
																query.setParameter("data", theId);
																// execute query
																Course course = query.getSingleResult();
																return course;
															}
															@Override
															public Student findStudentAndCoursesByStudentId(int theId) {
																// create query
																TypedQuery<Student> query = entityManager.createQuery(
																		"select s from Student s "
																				+ "JOIN FETCH s.courses "
																				+ "where s.id = :data", Student.class);
																query.setParameter("data", theId);
																// execute query
																Student student = query.getSingleResult();
																return student;
															}
															@Override
															@Transactional
															public void update(Student tempStudent) {
																entityManager.merge(tempStudent);
															}
															@Override
															@Transactional
															public void deleteStudentById(int theId) {
																// retrieve the student
																Student tempStudent = entityManager.find(Student.class, theId);
																// delete the student
																entityManager.remove(tempStudent);
															}
														}
														
			CruddemoApplication.java:
			
														package com.luv2code.cruddemo;
														import com.luv2code.cruddemo.dao.AppDAO;
														import com.luv2code.cruddemo.entity.*;
														import org.springframework.boot.CommandLineRunner;
														import org.springframework.boot.SpringApplication;
														import org.springframework.boot.autoconfigure.SpringBootApplication;
														import org.springframework.context.annotation.Bean;
														import java.util.List;
														@SpringBootApplication
														public class CruddemoApplication {
															public static void main(String[] args) {
																SpringApplication.run(CruddemoApplication.class, args);
															}
															@Bean
															public CommandLineRunner commandLineRunner(AppDAO appDAO) {
																return runner -> {
																	// createCourseAndStudents(appDAO);
																	// findCourseAndStudents(appDAO);
																	// findStudentAndCourses(appDAO);
																	// addMoreCoursesForStudent(appDAO);
																	// deleteCourse(appDAO);
																	deleteStudent(appDAO);
																};
															}
															private void deleteStudent(AppDAO appDAO) {
																int theId = 1;
																System.out.println("Deleting student id: " + theId);
																appDAO.deleteStudentById(theId);
																System.out.println("Done!");
															}
															private void addMoreCoursesForStudent(AppDAO appDAO) {
																int theId = 2;
																Student tempStudent = appDAO.findStudentAndCoursesByStudentId(theId);
																// create more courses
																Course tempCourse1 = new Course("Rubik's Cube - How to Speed Cube");
																Course tempCourse2 = new Course("Atari 2600 - Game Development");
																// add courses to student
																tempStudent.addCourse(tempCourse1);
																tempStudent.addCourse(tempCourse2);
																System.out.println("Updating student: " + tempStudent);
																System.out.println("associated courses: " + tempStudent.getCourses());
																appDAO.update(tempStudent);
																System.out.println("Done!");
															}
															private void findStudentAndCourses(AppDAO appDAO) {
																int theId = 2;
																Student tempStudent = appDAO.findStudentAndCoursesByStudentId(theId);
																System.out.println("Loaded student: " + tempStudent);
																System.out.println("Courses: " + tempStudent.getCourses());
																System.out.println("Done!");
															}
															private void findCourseAndStudents(AppDAO appDAO) {
																int theId = 10;
																Course tempCourse = appDAO.findCourseAndStudentsByCourseId(theId);
																System.out.println("Loaded course: " + tempCourse);
																System.out.println("Students: " + tempCourse.getStudents());
																System.out.println("Done!");
															}
															private void createCourseAndStudents(AppDAO appDAO) {
																// create a course
																Course tempCourse = new Course("Pacman - How To Score One Million Points");
																// create the students
																Student tempStudent1 = new Student("John", "Doe", "john@luv2code.com");
																Student tempStudent2 = new Student("Mary", "Public", "mary@luv2code.com");
																// add students to the course
																tempCourse.addStudent(tempStudent1);
																tempCourse.addStudent(tempStudent2);
																// save the course and associated students
																System.out.println("Saving the course: " + tempCourse);
																System.out.println("associated students: " + tempCourse.getStudents());
																appDAO.save(tempCourse);
																System.out.println("Done!");
															}
															private void retrieveCourseAndReviews(AppDAO appDAO) {
																// get the course and reviews
																int theId = 10;
																Course tempCourse = appDAO.findCourseAndReviewsByCourseId(theId);
																// print the course
																System.out.println(tempCourse);
																// print the reviews
																System.out.println(tempCourse.getReviews());
																System.out.println("Done!");
															}
															private void createCourseAndReviews(AppDAO appDAO) {
																// create a course
																Course tempCourse = new Course("Pacman - How To Score One Million Points");
																// add some reviews
																tempCourse.addReview(new Review("Great course ... loved it!"));
																tempCourse.addReview(new Review("Cool course, job well done."));
																tempCourse.addReview(new Review("What a dumb course, you are an idiot!"));
																// save the course ... and leverage the cascade all
																System.out.println("Saving the course");
																System.out.println(tempCourse);
																System.out.println(tempCourse.getReviews());
																appDAO.save(tempCourse);
																System.out.println("Done!");
															}
															private void deleteCourse(AppDAO appDAO) {
																int theId = 10;
																System.out.println("Deleting course id: " + theId);
																appDAO.deleteCourseById(theId);
																System.out.println("Done!");
															}
															private void updateCourse(AppDAO appDAO) {
																int theId = 10;
																// find the course
																System.out.println("Finding course id: " + theId);
																Course tempCourse = appDAO.findCourseById(theId);
																// update the course
																System.out.println("Updating course id: " + theId);
																tempCourse.setTitle("Enjoy the Simple Things");
																appDAO.update(tempCourse);
																System.out.println("Done!");
															}
															private void updateInstructor(AppDAO appDAO) {
																int theId = 1;
																// find the instructor
																System.out.println("Finding instructor id: " + theId);
																Instructor tempInstructor = appDAO.findInstructorById(theId);
																// update the instructor
																System.out.println("Updating instructor id: " + theId);
																tempInstructor.setLastName("TESTER");
																appDAO.update(tempInstructor);
																System.out.println("Done!");
															}
															private void findInstructorWithCoursesJoinFetch(AppDAO appDAO) {
																int theId = 1;
																// find the instructor
																System.out.println("Finding instructor id: " + theId);
																Instructor tempInstructor = appDAO.findInstructorByIdJoinFetch(theId);
																System.out.println("tempInstructor: " + tempInstructor);
																System.out.println("the associated courses: " + tempInstructor.getCourses());
																System.out.println("Done!");
															}
															private void findCoursesForInstructor(AppDAO appDAO) {
																int theId = 1;
																// find instructor
																System.out.println("Finding instructor id: " + theId);
																Instructor tempInstructor = appDAO.findInstructorById(theId);
																System.out.println("tempInstructor: " + tempInstructor);
																// find courses for instructor
																System.out.println("Finding courses for instructor id: " + theId);
																List<Course> courses = appDAO.findCoursesByInstructorId(theId);
																// associate the objects
																tempInstructor.setCourses(courses);
																System.out.println("the associated courses: " + tempInstructor.getCourses());
																System.out.println("Done!");
															}
															private void findInstructorWithCourses(AppDAO appDAO) {
																int theId = 1;
																System.out.println("Finding instructor id: " + theId);
																Instructor tempInstructor = appDAO.findInstructorById(theId);
																System.out.println("tempInstructor: " + tempInstructor);
																System.out.println("the associated courses: " + tempInstructor.getCourses());
																System.out.println("Done!");
															}
															private void createInstructorWithCourses(AppDAO appDAO) {
																// create the instructor
																Instructor tempInstructor =
																		new Instructor("Susan", "Public", "susan.public@luv2code.com");
																// create the instructor detail
																InstructorDetail tempInstructorDetail =
																		new InstructorDetail(
																				"http://www.youtube.com",
																				"Video Games");
																// associate the objects
																tempInstructor.setInstructorDetail(tempInstructorDetail);
																// create some courses
																Course tempCourse1 = new Course("Air Guitar - The Ultimate Guide");
																Course tempCourse2 = new Course("The Pinball Masterclass");
																// add courses to instructor
																tempInstructor.add(tempCourse1);
																tempInstructor.add(tempCourse2);
																// save the instructor
																//
																// NOTE: this will ALSO save the courses
																// because of CascadeType.PERSIST
																//
																System.out.println("Saving instructor: " + tempInstructor);
																System.out.println("The courses: " + tempInstructor.getCourses());
																appDAO.save(tempInstructor);
																System.out.println("Done!");
															}
															private void deleteInstructorDetail(AppDAO appDAO) {
																int theId = 3;
																System.out.println("Deleting instructor detail id: " + theId);
																appDAO.deleteInstructorDetailById(theId);
																System.out.println("Done!");
															}
															private void findInstructorDetail(AppDAO appDAO) {
																// get the instructor detail object
																int theId = 2;
																InstructorDetail tempInstructorDetail = appDAO.findInstructorDetailById(theId);
																// print the instructor detail
																System.out.println("tempInstructorDetail: " + tempInstructorDetail);
																// print the associated instructor
																System.out.println("the associated instructor: " + tempInstructorDetail.getInstructor());
																System.out.println("Done!");
															}
															private void deleteInstructor(AppDAO appDAO) {
																int theId = 1;
																System.out.println("Deleting instructor id: " + theId);
																appDAO.deleteInstructorById(theId);
																System.out.println("Done!");
															}
															private void findInstructor(AppDAO appDAO) {
																int theId = 2;
																System.out.println("Finding instructor id: " + theId);
																Instructor tempInstructor = appDAO.findInstructorById(theId);
																System.out.println("tempInstructor: " + tempInstructor);
																System.out.println("the associated instructorDetail only: " + tempInstructor.getInstructorDetail());

															}
															private void createInstructor(AppDAO appDAO) {
																/*
																// create the instructor
																Instructor tempInstructor =
																		new Instructor("Chad", "Darby", "darby@luv2code.com");
																// create the instructor detail
																InstructorDetail tempInstructorDetail =
																		new InstructorDetail(
																				"http://www.luv2code.com/youtube",
																				"Luv 2 code!!!");
																*/
																// create the instructor
																Instructor tempInstructor =
																		new Instructor("Madhu", "Patel", "madhu@luv2code.com");
																// create the instructor detail
																InstructorDetail tempInstructorDetail =
																		new InstructorDetail(
																				"http://www.luv2code.com/youtube",
																				"Guitar");
																// associate the objects
																tempInstructor.setInstructorDetail(tempInstructorDetail);
																// save the instructor
																//
																// NOTE: this will ALSO save the details object
																// because of CascadeType.ALL
																//
																System.out.println("Saving instructor: " + tempInstructor);
																appDAO.save(tempInstructor);
																System.out.println("Done!");
															}
														}
		
	Security--SPRING:
	
		Spring Boot REST API Security--Security:
			
			Bộ lọc Servlet--Security:
			
																Bạn có thể đặt bộ lọc lên trước các servlet, tức là bạn có thể viết SecurityFilter và cấu hình nó trong Tomcat (servlet container/ application server) của
																bạn để lọc mọi request HTTP trước khi nó truy cập vào servlet của bạn.
																
				Một SecurityFilter đơn giản:
				
																- Đầu tiên, bộ lọc cần extract username/password từ request. Nó có thể thông qua Basic Auth Http Header, hoặc các field trong form, hoặc cookie, v.v.
																- Sau đó, bộ lọc cần xác thực bằng cách đối chiếu tổ hợp username/password đó với một thứ gì đó , chẳng hạn như database.
																- Sau khi authenticate thành công, bộ lọc cần kiểm tra user có được phép truy cập requested URI hay không.
																- Nếu request vẫn tồn tại sau tất cả các lần kiểm tra này, thì bộ lọc có thể cho phép request chuyển đến DispatcherServlet của bạn, tức là @Controllers của bạn.
																
				FilterChains:
				
									- Xác minh trong thực tế: Trong khi code trên có thể hoạt động khi biên dịch, nó sớm hay muộn cũng dẫn đến một bộ lọc chất đầy hàng tấn code cho các cơ chế
									authentication và authorization khác nhau.
									- Trong thế giới thực, bạn sẽ chia bộ lọc này thành nhiều bộ lọc, sau đó bạn _cha_in với nhau.
									- Ví dụ: một request HTTP sẽ…:
												Đầu tiên, đi qua LoginMethodFilter…
												Sau đó, đi qua AuthenticationFilter…
												Sau đó, chuyển qua AuthorizationFilter…
												Cuối cùng, chạm vào servlet của bạn.
									- Với một bộ lọc (chain) như vậy thì về cơ bản, bạn có thể xử lý mọi vấn đề authentication hay authorization có trong ứng dụng của mình mà không cần thay đổi việc
									triển khai ứng dụng thực tế của bạn (như là @RestControllers / @Controllers của bạn).
																
			Authentication với Spring Security--Security:
			
									- Khi nói đến authentication và Spring Security, bạn có ba kịch bản sau. Chú ý đang nói đến việc lấy thông tin trong database:
										
										Mặc định:
															Bạn có thể truy cập (hashed) password của user, bởi vì bạn có thông tin chi tiết của mình (username, password) được lưu chẳng hạn trong một 
															bảng database.
										Ít phổ biến hơn:	
															Bạn không thể truy cập password (hashed) của user. Đây là trường hợp nếu user và password của bạn được lưu trữ ở một nơi khác, chẳng hạn như
															trong một sản phẩm quản lý danh tính của bên thứ ba cung cấp dịch vụ REST cho authentication.
										Cũng phổ biến:
															Bạn muốn sử dụng OAuth2 hoặc “Đăng nhập bằng Google / Twitter / v.v.” (OpenID), khả năng kết hợp với JWT. Sau đó, không có điều nào có thể
															áp dụng thì bạn nên chuyển thẳng đến phần OAuth2.
															
									- Lưu ý : Tùy thuộc vào bạn rơi vào kịch bản nào, bạn cần chỉ định các @Beans khác nhau để Spring Security hoạt động, nếu không bạn sẽ nhận được các exception khá
									khó hiểu (như NullPointerException nếu bạn quên chỉ định PasswordEncoder). Hãy ghi nhớ nó trong tâm trí.
																
				UserDetailsService: Có quyền truy cập vào password của user (trường hợp mặc định):
				
														- UserDetailsService có một số implement phổ biến:
														
															JdbcUserDetailsManager:
															
																							Là một implement của UserDetailsService dựa trên JDBC (database). Nó cho phép tải thông tin người dùng từ một cơ sở dữ liệu
																							quan hệ bằng cách sử dụng JDBC.
																							
															InMemoryUserDetailsManager:
															
																							Được sử dụng để lưu trữ thông tin người dùng trong bộ nhớ (memory). Thông tin người dùng được cấu hình trực tiếp trong mã nguồn hoặc
																							qua cấu hình Java hoặc XML.
																							
															LdapUserDetailsService:
															
																							Sử dụng để tải thông tin người dùng từ một máy chủ LDAP (Lightweight Directory Access Protocol). Nó cho phép tìm kiếm và truy xuất
																							thông tin người dùng từ một cây thư mục LDAP.
																							
															Custom implement:
															
																							Bạn có thể tạo ra implement của UserDetailsService tùy chỉnh cho nhu cầu cụ thể của ứng dụng. Điều này có thể bao gồm việc tải thông
																							tin người dùng từ một dịch vụ web, một cơ sở dữ liệu không phải quan hệ, hoặc bất kỳ nguồn dữ liệu nào khác phù hợp với yêu cầu của ứng
																							dụng.
																							
														- Nếu bạn đang sử dụng Spring Security và có thể truy cập vào password của user, thì:
														
															Chỉ định một UserDetailsService. Bạn có thể triển khai UserDetailsService một cách tùy chọn hoặc sử dụng một trong các implement do Spring Security cung cấp như
															JdbcUserDetailsManager, InMemoryUserDetailsManager hoặc triển khai tùy chỉnh.
															Chỉ định một PasswordEncoder.
															
														- Hãy tưởng tượng bạn có một bảng database nơi bạn lưu trữ user của mình. Nó có một vài cột, nhưng quan trọng nhất là nó có cột username và password, nơi bạn lưu trữ
														hashed password của user:
														
															create table users (id int auto_increment primary key, username varchar(255), password varchar(255));
															
														- Trong trường hợp này, Spring Security cần bạn xác định hai bean để thiết lập và chạy authentication:
														
															UserDetailsService:
															
																					- Một UserDetailsService để load UserDetails qua username của user. Lưu ý rằng method chỉ nhận một tham số: username (không phải password).
																					- Interface UserDetails có các method để lấy (hashed) password và một method để lấy username.
																					- UserDetails thậm chí còn có nhiều method hơn, chẳng hạn như account đang hoạt động hay bị chặn, thông tin đăng nhập đã hết hạn hay user
																					được cấp phép gì - nhưng chúng ta sẽ không đề cập đến ở đây.
																					- Vì vậy, bạn có thể tự implement các interface này, giống như chúng ta đã làm ở trên, hoặc là sử dụng các interface hiện có mà Spring
																					Security cung cấp.
																					
																					// Ví dụ sử dụng sẵn implement của UserDetailsService
																					import org.springframework.context.annotation.Bean;
																					import org.springframework.context.annotation.Configuration;
																					import org.springframework.security.authentication.AuthenticationManager;
																					import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
																					import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
																					import org.springframework.security.core.userdetails.UserDetailsService;
																					import org.springframework.security.core.userdetails.User;
																					import org.springframework.security.core.userdetails.UserDetails;
																					import org.springframework.security.provisioning.InMemoryUserDetailsManager;
																					import org.springframework.security.crypto.password.PasswordEncoder;
																					import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
																					@Configuration
																					public class SecurityConfig {
																						@Bean
																						public UserDetailsService userDetailsService() {
																							UserDetails user = User.builder()
																												   .username("user")
																												   .password(passwordEncoder().encode("password"))
																												   .roles("USER")
																												   .build();
																							UserDetails admin = User.builder()
																												    .username("admin")
																												    .password(passwordEncoder().encode("admin"))
																												    .roles("ADMIN")
																												    .build();
																							return new InMemoryUserDetailsManager(user, admin);
																						}
																						@Bean
																						public PasswordEncoder passwordEncoder() {
																							return new BCryptPasswordEncoder();
																						}
																						@Bean
																						public DaoAuthenticationProvider authenticationProvider() {
																							DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
																							authProvider.setUserDetailsService(userDetailsService());
																							authProvider.setPasswordEncoder(passwordEncoder());
																							return authProvider;
																						}
																					}																					
																					
																					// Ví dụ về custom implement của UserDetailsService
																					@Bean
																					public UserDetailsService userDetailsService() {
																						return new MyDatabaseUserDetailsService(); // (1)
																					}
																					public class MyDatabaseUserDetailsService implements UserDetailsService {
																							UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { // (1)
																							 // 1. Load the user from the users table by username. If not found, throw UsernameNotFoundException.
																							 // 2. Convert/wrap the user to a UserDetails object and return it.
																							return someUserDetails;
																						}
																					}
																					public interface UserDetails extends Serializable { // (2)
																						String getUsername();
																						String getPassword();
																						// <3> more methods:
																						// isAccountNonExpired,isAccountNonLocked,
																						// isCredentialsNonExpired,isEnabled
																					}		
																					
																	Các Implementation
																	sẵn có:
																	
																							Một lưu ý nhỏ: Bạn luôn có thể tự mình triển khai các interface UserDetailsService và UserDetails.
																							Tuy nhiên, bạn cũng có thể thay thế bằng các implementations có sẵn của Spring Security mà bạn có thể sử dụng
																							/configure/extend/override.
																							
																							- JdbcUserDetailsManager:
																								Là một UserDetailsService dựa trên JDBC (database). Bạn có thể cấu hình nó để khớp với cấu trúc bảng/cột user của mình
																								
																								import org.springframework.beans.factory.annotation.Autowired;
																								import org.springframework.context.annotation.Bean;
																								import org.springframework.context.annotation.Configuration;
																								import org.springframework.jdbc.datasource.DriverManagerDataSource;
																								import org.springframework.security.core.userdetails.jdbc.JdbcUserDetailsManager;
																								import javax.sql.DataSource;
																								@Configuration
																								public class SecurityConfig {
																									@Bean
																									public DataSource dataSource() { // cấu hình một DataSource để kết nối đến cơ sở dữ liệu MySQL.
																										DriverManagerDataSource dataSource = new DriverManagerDataSource();
																										dataSource.setDriverClassName("com.mysql.jdbc.Driver");
																										dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");
																										dataSource.setUsername("username");
																										dataSource.setPassword("password");
																										return dataSource;
																									}
																									@Bean
																									public JdbcUserDetailsManager jdbcUserDetailsManager(DataSource dataSource) { // tạo một đối tượng JdbcUserDetailsManager, cấu
																																												  // hình nó để sử dụng DataSource đã được cấu hình
																																												  // trước đó.
																										JdbcUserDetailsManager userDetailsManager = new JdbcUserDetailsManager();
																										userDetailsManager.setDataSource(dataSource);
																										return userDetailsManager;
																									}
																								}
																								import org.springframework.beans.factory.annotation.Autowired;
																								import org.springframework.security.core.userdetails.UserDetails;
																								import org.springframework.security.core.userdetails.UserDetailsService;
																								import org.springframework.stereotype.Service;
																								@Service
																								public class CustomUserDetailsService implements UserDetailsService {
																									@Autowired
																									private JdbcUserDetailsManager jdbcUserDetailsManager; // sử dụng JdbcUserDetailsManager để tìm kiếm thông tin người dùng khi họ
																																						   // đăng nhập
																									@Override
																									public UserDetails loadUserByUsername(String username) { // tải chi tiết người dùng dựa trên tên đăng nhập.
																										return jdbcUserDetailsManager.loadUserByUsername(username);
																									}
																								}

																							- InMemoryUserDetailsManager:
																							
																								Giữ tất cả các chi tiết user in-memory và rất tốt cho việc test.
																								
																								import org.springframework.context.annotation.Bean;
																								import org.springframework.context.annotation.Configuration;
																								import org.springframework.security.authentication.AuthenticationManager;
																								import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
																								import org.springframework.security.core.userdetails.User;
																								import org.springframework.security.core.userdetails.UserDetails;
																								import org.springframework.security.provisioning.InMemoryUserDetailsManager;
																								@Configuration
																								public class SecurityConfig {
																									@Bean
																									public InMemoryUserDetailsManager inMemoryUserDetailsManager() {
																										UserDetails user = User.withDefaultPasswordEncoder()
																												.username("user")
																												.password("password")
																												.roles("USER")
																												.build();
																										UserDetails admin = User.withDefaultPasswordEncoder()
																												.username("admin")
																												.password("admin")
																												.roles("ADMIN")
																												.build();

																										return new InMemoryUserDetailsManager(user, admin);
																									}
																									@Bean
																									public AuthenticationManager authenticationManager(InMemoryUserDetailsManager inMemoryUserDetailsManager) throws Exception {
																										return new AuthenticationManagerBuilder(inMemoryUserDetailsManager).build();
																									}
																								}

																							- org.springframework.security.core.userdetail.User:
																								Là một implementation UserDetails mặc định, hợp lý mà bạn có thể sử dụng. Điều đó có nghĩa là có khả năng ánh xạ/sao chép
																								giữa các entity/ bảng database của bạn và class User này. Ngoài ra, bạn có thể chỉ cần làm cho các entity của mình implement
																								interface UserDetails.
																								
																								import org.springframework.context.annotation.Bean;
																								import org.springframework.context.annotation.Configuration;
																								import org.springframework.security.core.userdetails.UserDetails;
																								import org.springframework.security.core.userdetails.User;
																								import org.springframework.security.core.userdetails.UserDetailsService;
																								import org.springframework.security.provisioning.InMemoryUserDetailsManager;
																								@Configuration
																								public class SecurityConfig {
																									@Bean
																									public UserDetailsService userDetailsService() {
																										UserDetails user = User.builder() // User.builder() cho phép bạn cung cấp các thuộc tính như username, password và roles để
																																		  // xác định các chi tiết của người dùng.
																												.username("user")
																												.password("password")
																												.roles("USER")
																												.build();
																										UserDetails admin = User.builder()
																												.username("admin")
																												.password("admin")
																												.roles("ADMIN")
																												.build();

																										return new InMemoryUserDetailsManager(user, admin); // cung cấp chi tiết người dùng được cấu hình trong bộ nhớ.
																									}
																								}																						
																								
																	Quy trình làm việc
																	đầy đủ của UserDetails:
																	
																	HTTP Basic Authentication
																	
																							Bây giờ, hãy quay trở lại HTTP Basic Authentication của bạn, bạn đang bảo mật ứng dụng của mình bằng Spring Security và Basic
																							Auth. Đây là những gì sẽ diễn ra khi bạn chỉ định một UserDetailsService và cố gắng login:
																								Extract tổ hợp username/password từ HTTP Basic Authentication header trong một bộ lọc. Bạn không phải làm bất cứ điều gì cả, nó sẽ
																								tự diễn ra đằng sau tấm màn che.
																								Gọi MyDatabaseUserDetailsService của bạn để tải user tương ứng từ database, được bao bọc dưới dạng đối tượng UserDetails, làm lộ
																								hashed password của user.
																								Lấy password được extract từ HTTP Basic Auth header, tự động băm nó và so sánh nó với hashed password từ object UserDetails của bạn.
																								Nếu cả hai khớp, user sẽ được authenticate thành công.
																								
															Một PasswordEncoder:
															
																							Spring Security không thể đoán một cách kỳ diệu thuật toán băm password ưa thích của bạn. Đó là lý do tại sao bạn cần chỉ định một @Bean
																							khác, một PasswordEncoder. Giả sử nếu bạn muốn sử dụng chức năng hashed password kiểu BCrypt (mặc định của Spring Security) cho tất cả
																							các password của mình , bạn sẽ chỉ định @Bean này trong SecurityConfig:
																								@Bean
																								public BCryptPasswordEncoder bCryptPasswordEncoder() {
																									return new BCryptPasswordEncoder();
																								}
																								
																							Điều gì sẽ xảy ra nếu bạn có nhiều thuật toán băm password, vì bạn có một số user cũ có password được lưu trữ bằng MD5 (đừng làm điều
																							này) và những user mới hơn với Bcrypt hoặc thậm chí là thuật toán thứ ba như SHA-256? Vậy thì bạn sẽ sử dụng bộ mã hóa sau:
																								@Bean
																								public PasswordEncoder passwordEncoder() {
																									return PasswordEncoderFactories.createDelegatingPasswordEncoder();
																								}
																								
																							Bộ mã hóa này hoạt động như thế nào? Nó sẽ xem xét hashed password của UserDetail (đến từ bảng database của bạn chẳng hạn), bây giờ
																							phải bắt đầu với một <em style="box-sizing:border-box">{prefix}</em>. Prefix (tiền tố) đó, chính là phương pháp hash của bạn!
																							Spring Security sẽ:
																								Đọc các password đó và loại bỏ tiền tố ({bcrypt} hoặc {sha256}).
																								Tùy thuộc vào giá trị tiền tố, hãy sử dụng PasswordEncoder cho chính xác (tức là BCryptEncoder hoặc SHA256Encoder)
																								Băm password thô với PasswordEncoder đó và so sánh với password đã lưu trữ.
				AuthenticationProvider: Không có
				quyền truy cập vào password của
				user(trường hợp Ít phổ biến hơn):
				
														- Bây giờ, hãy tưởng tượng rằng bạn đang sử dụng Atlassian Crowd để quản lý danh tính. Điều đó có nghĩa là tất cả user và password của bạn cho tất cả các ứng dụng được lưu
														trữ trong Atlassian Crowd và không còn trong bảng database của bạn nữa.
														- Điều này có hai hàm ý:
															Bạn không có password user trong ứng dụng của mình nữa, vì bạn không thể yêu cầu Crowd cung cấp cho bạn những password đó.
															Tuy nhiên, bạn có một API REST mà bạn có thể đăng nhập bằng username và password của mình. (Một POST request đến điểm cuối
															<em style="box-sizing:border-box">/rest/usermanagement/1/authentication</em> của REST).
															
														- Nếu đúng như vậy, bạn không thể sử dụng UserDetailsService nữa, thay vào đó, bạn cần implement và cung cấp AuthenticationProvider @Bean:
														
															@Bean
															public AuthenticationProvider authenticationProvider() {
																return new AtlassianCrowdAuthenticationProvider();
															}
															
														- Một AuthenticationProvider chủ yếu bao gồm một method và một implementation ngắn gọn có thể trông như thế này:
														
															public class AtlassianCrowdAuthenticationProvider implements AuthenticationProvider {
																Authentication authenticate(Authentication authentication) throws AuthenticationException {// (1)																		
																	String username = authentication.getPrincipal().toString(); // (1)
																	String password = authentication.getCredentials().toString(); // (1)
																	User user = callAtlassianCrowdRestService(username, password); // (2)
																	if (user == null) {                                     // (3)
																		throw new AuthenticationException("could not login");
																	}
																	return new UserNamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), user.getAuthorities()); // (4)
																}
																	// other method ignored
															}
														- So với method UserDetails load (), nơi bạn chỉ có quyền truy cập vào username, giờ đây bạn đã có quyền truy cập để authenticate hoàn chỉnh, thường chứa username
														và password.
														- Bạn có thể làm bất cứ điều gì bạn muốn để authenticate user, như gọi một REST-service chẳng hạn.
														- Nếu authenticate không thành công, bạn cần phải throw ra một exception.
														- Nếu authenticate thành công, bạn cần return một UsernamePasswordAuthenticationToken được khởi tạo đầy đủ. Nó là một implementation của interface Authentication
														và cần phải đặt trường được authenticate thành true (mà constructor được sử dụng ở trên sẽ tự động đặt).
														
						Quy trình làm việc
						AuthenticationProvider
						đầy đủ: HTTP Basic
						Authentication:
						
														- Extract tổ hợp username / password từ HTTP Basic Authentication Header trong một bộ lọc. Bạn không phải làm bất cứ điều gì để thực hiện việc đó cả, nó sẽ tự diễn ra đằng
														sau tấm màn che.
														- Gọi AuthenticationProvider của bạn (ví dụ: AtlassianCrowdAuthenticationProvider) bằng username và password đó để bạn tự thực hiện authentication (ví dụ: gọi REST).
														- Không có quá trình hash password hoặc gì đó tương tự đang diễn ra, vì về cơ bản bạn đang ủy quyền cho bên thứ ba thực hiện kiểm tra username / password thực tế.
														
			Chú ý--Security:
			
				OAuth2--security chú ý:
														OAuth2 là một giao thức ủy quyền mạnh mẽ được sử dụng rộng rãi cho việc xác thực và ủy quyền trong ứng dụng web và di động. Với OAuth2, người dùng có thể cho phép ứng dụng
														của bạn truy cập vào tài nguyên của họ mà không cần chia sẻ mật khẩu. Thay vào đó, ứng dụng yêu cầu một mã truy cập (access token) từ máy chủ ủy quyền (authorization
														server) sau khi người dùng đã xác thực thành công.
														
				Đăng nhập bằng Google / Twitter / v.v.
				(OpenID)--security chú ý:
				
														Đăng nhập bằng các dịch vụ lớn như Google, Twitter, Facebook,... cung cấp một cách thuận tiện và an toàn để người dùng xác thực trong ứng dụng của bạn. Thay vì tạo và quản
														lý tài khoản riêng, người dùng có thể sử dụng tài khoản của họ trên các dịch vụ này để đăng nhập vào ứng dụng của bạn. OpenID là một chuẩn phổ biến cho phương thức này.
														
				JSON Web Tokens (JWT)--security chú ý:
				
												- JWT là một phương tiện truyền thông được sử dụng để truyền dữ liệu giữa các bên một cách an toàn và kiểm soát tính xác thực. JWT thường được sử dụng trong các cơ chế xác
												thực stateless như OAuth2. Khi người dùng xác thực thành công, máy chủ sẽ tạo ra một JWT chứa thông tin về quyền truy cập và gửi nó lại cho ứng dụng của bạn. Ứng dụng có
												thể sử dụng JWT này để xác thực và ủy quyền người dùng trong các yêu cầu tiếp theo mà không cần phải lưu trữ trạng thái xác thực ở phía máy chủ.
												- Authentication là phần không thể thiếu trong bất kỳ hệ thống nào. Phương pháp authentication đơn giản và hay được sử dụng trong các ứng dụng web đó là user gửi thông tin
												username và password lên server. Sau khi server chứng thực thành công sẽ tạo ra một chuỗi session_id và lưu vào session hay database ở phía server. Sau đó, gửi session_id
												này về client và được client lưu trên cookie. Nhưng với các ứng dụng trên mobile và các ứng dụng web SPA (Single Page Application) thì cần có cơ chế authentication tốt hơn
												khi mà chúng ta phải thiết kế các RESTful api (stateless) thì server không thể đảm nhiệm việc lưu trạng thái phiên làm việc của user. Một trong những phương pháp tốt để
												giải quyết vấn đề này là sử dụng JSON Web Token (JWT).
												- Khi một máy chủ nhận được JWT, nó có thể đảm bảo dữ liệu mà nó chứa có thể được tin cậy bởi vì nó đã được xác thực với chữ ký đã được lưu trữ. Không yếu tố trung gian nào
												có thể sửa đổi JWT sau khi nó được gửi.
														
					Bảo mật cao--JWT:
					
														JWT hỗ trợ chữ ký số để đảm bảo tính toàn vẹn và xác thực của dữ liệu. Điều này giúp ngăn chặn sửa đổi thông tin và xác định rõ ràng nguồn gốc của dữ liệu.
														
					JWT đảm bảo quyền sở hữu dữ
					liệu nhưng không mã hóa--JWT:
					
														- JWT được sử dụng để truyền thông tin giữa các bên một cách an toàn và kiểm soát. Tuy nhiên, điểm quan trọng cần lưu ý là JWT không mã hóa dữ liệu trong nó. Thay vào đó, nó
														ký và tuần tự hóa dữ liệu dưới dạng JSON. Điều này có nghĩa là bất kỳ ai có được JWT đều có thể giải mã và xem dữ liệu trong nó.
														- Do tính không mã hóa của dữ liệu trong JWT, nó cần được truyền đi trong môi trường an toàn để đảm bảo bảo mật. HTTPS (HTTP Secure) cung cấp một kênh truyền dữ liệu an
														toàn bằng cách mã hóa dữ liệu trước khi truyền đi, điều này ngăn chặn bất kỳ kẻ tấn công nào cũng không thể đọc hoặc thay đổi dữ liệu trong quá trình truyền đi. Do đó, việc
														sử dụng JWT cùng với HTTPS là quan trọng để đảm bảo an toàn cho thông tin trong JWT.
														
					Gọn nhẹ (compact)--JWT:
					
														JWT có thể được truyền đi thông qua URL, hoặc qua giao thức POST, hay gán vào bên trong phần HTTP Header. Kích thước nhỏ hơn ứng với công việc truyền tải sẽ nhanh hơn. Dưới
														đây là cách thức truyền token vào trong HTTP Header sử dụng Bearer Schema:
														
															Authorization: Bearer <token>
															
					Tự đóng gói (self-contained)--JWT:
					
														Payload của JWT đã chứa các thông tin cần thiết về user (thay vì phải truy vấn cơ sở dữ liệu nhiều lần).
														
					Các thành phần của JSON Web
					Token (JWT)--JWT:
					
											Chi tiết hơn xem tại https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields
											
											Header:
											
														Đây là nơi chứa thông tin mà được dùng để trả lời cho câu hỏi: “Mã JWT được tính toán như thế nào?”
														Gồm 2 phần: type của token, giá tri là JWT, và phương thức mã hóa (HMAC SHA256 hay RSA).
														JSON object này sau đó được mã hóa Base64URL.
														
														{
														  "typ": "JWT",  // “typ” (viết tắt của type) là kiểu Token, ở đây chính là JWT.
														  "alg": "HS256" // “alg” (viết tắt của algorithm) là thuật toán băm tạo ra chữ ký cho Token, ở ví dụ trên HS256 là thuật toán có tên HMAC-SHA256, một thuật
																		 // toán băm sử dụng khóa bí mật (Secret Key) để tính toán tạo ra chữ ký.
														}
														
											Payload:
											
														Đây là nơi chứa những dữ liệu mà chúng ta muốn lưu lại trong JWT.
														
														{
														  "userId": "7j79y-kdjr8n4h-5jd8-5k39-cfk8ghr9wu",
														  "username": "trungquandev17",
														  "occupation": "Full stack web developer",
														  // standard fields
														  "iss": "Trung Quan, author of blog: https://trungquandev.com", // “iss” viết tắt của Issuer là thông tin người tạo ra Token (không phải user đâu nhé, mà nó
																														 // chính là tên cái hệ thống backend của các bạn chẳng hạn)
														  "iat": 1568456819, // “iat” viết tắt của Issued at, là nhãn thời gian lúc mà cái token được tạo.
														  "exp": 1568460419 // “exp” viết tắt của Expiration time, xác định thời gian hết hạn của Token
														}
														
											SIGNATURE:
											
														- Đầu tiên, chúng ta sẽ Encode (chuyển đổi) 2 cái Header và Playload ở trên theo kiểu Base64URL Encoder, và nối 2 chuỗi nhận được lại (cách nhau bởi
														dấu chấm “.”)rồi gán nó vào một biến là data.
														- Tiếp theo sẽ Hash (băm) cái data đó bằng “alg”, chính thuật toán tạo chữ ký mà chúng ta đã định nghĩa ở trên Header (HS256 – HMAC-SHA256) kèm với một chuỗi bí
														mật secret (chuỗi secret này sẽ được đặt tùy vào lập trình viên của mỗi dự án và đảm bảo không được để lộ chuỗi này ra ngoài, có thể đưa vào biến môi trường ENV.)
														- Sau khi băm xong ở trên thì thực hiện Encode tiếp một lần nữa cái dữ liệu băm đó dưới dạng Base64URL Encode, và chúng ta sẽ thu được chữ ký “Signature”.
														
														const headerEncode = base64urlEncode(header); // ví dụ kết quả: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
														const payloadEncode = base64urlEncode(payload); // ví dụ kết quả: eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
														const data = headerEncode + "." + payloadEncode;
														const hashedData = Hash(data, secret);
														const signature = base64urlEncode(hashedData);  // ví dụ kết quả: xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
														// cuối cùng thì mã JWT theo đúng cấu trúc header.payload.signature sẽ trông như sau:
														const JWT = headerEncode + "." + payloadEncode + "." + signature;
														// Kết quả: 
														"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM"
																	
					JWT bảo vệ dữ liệu của chúng
					ta bằng cách nào--JWT:
					
														- JWT không bảo vệ dữ liệu của bạn.
														- Mục đích quan trọng mà các bạn cần phải nắm được là JWT nó không ẩn, không làm mờ, không che giấu dữ liệu gì cả, mà nó được sử dụng để chứng minh rằng dữ liệu được tạo
														ra bởi một nguồn xác thực.
														- Các bạn có thể nhìn lại ở các bước xử lý Header, Payload, Signature trên kia, dữ liệu chỉ được Encoded và Hash (Signed) chứ không phải Encrypted.
														- Lưu ý: mình phải giữ nguyên mấy từ trên bằng tiếng anh bởi vì Encoded và Encrypted dịch ra tiếng việt đều là “Mã hóa” nhưng bản chất ý nghĩa của chúng hoàn toàn
														khác nhau.
														
					Nếu một kẻ tấn công ở giữa
					(Man-in-the-middle) bắt được gói
					tin có chứa mã JWT rồi họ decode
					ra và lấy được thông tin của user
					thì sao--JWT:
					
														Đúng, điều đó là có thể, vậy nên hãy luôn luôn đảm bảo rằng ứng dụng của các bạn chắc chắn phải có giao thức mã hóa đường truyền HTTPS nhé.
														
					Server xác thực mã JWT gửi lên
					từ client ra sao--JWT:
					
														- Trong phần 3 trên kia các bạn hãy nhìn lại cho mình đó là khi tạo mã JWT, chúng ta có sử dụng tới một chuỗi bí mật “Secret” trong bước tạo chữ ký (signature).
														- Chuỗi “Secret” này là unique cho ứng dụng và phải được ưu tiên lưu trữ bảo mật cẩn thận ở phía server.
														- Khi nhận được mã Token gửi lên từ phía client, Server sẽ lấy phần Signature (chữ ký) bên trong mã token đó, và verify (kiểm tra ) xem chữ ký nhận được có đúng chính
														xác là được HASH (băm) bởi cùng một thuật toán và chuỗi “Secret” như trên hay không.
														- Và cuối cùng, rõ ràng, nếu chữ ký của client gửi lên khớp với chữ ký được tạo ra từ máy chủ, thì JWT đó là hợp lệ, ngược lại thì không, và người lập trình API phía
														Backend như chúng ta sẽ tùy vào từng trường hợp mà response về cho client một cách hợp lý.
														
				In-memory--security chú ý:
				
														- Thông tin người dùng được lưu trữ trong bộ nhớ RAM của ứng dụng thay vì lưu trữ trong một cơ sở dữ liệu hoặc một nguồn dữ liệu khác. Điều này có nghĩa là dữ liệu
														người dùng chỉ tồn tại trong thời gian mà ứng dụng đang chạy, và sẽ bị xóa khi ứng dụng được tắt hoặc khởi động lại.
														- Tuy nhiên, cần lưu ý rằng việc lưu trữ thông tin người dùng trong bộ nhớ có nhược điểm là dữ liệu sẽ bị mất khi ứng dụng bị tắt hoặc khởi động lại, và không phù hợp
														cho các ứng dụng có nhu cầu lưu trữ thông tin người dùng lâu dài hoặc có lưu lượng truy cập lớn. Trong các trường hợp đó, việc sử dụng một cơ sở dữ liệu hoặc một
														nguồn dữ liệu khác là lựa chọn phù hợp hơn.
														- Việc lưu trữ thông tin người dùng trong bộ nhớ có thể là một giải pháp thuận tiện trong các trường hợp sau:
														
															Ứng dụng nhỏ và đơn giản:	
															
																							Trong các ứng dụng nhỏ và đơn giản, việc lưu trữ thông tin người dùng trong bộ nhớ có thể đủ để đáp ứng nhu cầu của ứng dụng mà không
																							cần phải sử dụng một cơ sở dữ liệu riêng biệt.
																							
															Phát triển và kiểm thử:
															
																							Trong quá trình phát triển và kiểm thử ứng dụng, việc sử dụng InMemoryUserDetailsManager có thể là một cách thuận tiện để quản lý thông
																							tin người dùng mà không cần cấu hình và kết nối đến một cơ sở dữ liệu.
																							
															Môi trường thử nghiệm và demo:
															
																							Trong một số trường hợp, việc triển khai ứng dụng trong môi trường thử nghiệm hoặc demo có thể sử dụng InMemoryUserDetailsManager để đơn
																							giản hóa quá trình triển khai và giảm thiểu chi phí vận hành.
				
				UserDetailService interface--security chú ý:
				
														- UserDetailService là một interface có duy nhất một mẫu phương thức UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
														- Trong ứng dụng Spring Boot, chỉ cần một Component hay Bean nào đó implements interface UserDetailService thì trong quá trình xác thực, phương thức
														UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; của Component hay Bean đó sẽ được gọi ra khi cần tìm kiếm user theo user name. Bản chất
														của cơ chế này là Auto Injection, khi quét (component scan) và nạp các Component hay Bean vào Application Context, Spring Boot đã biết được rõ, component nào dùng để tìm
														kiếm user theo user name thông qua kiểu Interface bạn không cần phải cấu hình gì thêm. Nếu có nhiều hơn một Component implements interface UserDetailService thì sao? Khi
														đó bạn có thể dùng annotation @Primary hay @Order để ưu tiên component bạn muốn sử dụng.
														- Khi một yêu cầu đăng nhập (authentication request) đến, Spring Security cần tìm chi tiết của người dùng (tên người dùng, mật khẩu, vai trò, quyền, v.v.) để kiểm tra tính
														hợp lệ của thông tin đăng nhập. Để thực hiện việc này, Spring Security sử dụng UserDetailsService để tìm kiếm thông tin người dùng từ một nguồn dữ liệu (ví dụ: cơ sở dữ
														liệu, hệ thống LDAP, dịch vụ web, v.v.).
														- Interface UserDetailService dùng để tìm kiếm người dùng theo user name. Cần phải có khi bạn muốn quản lý người dùng đăng nhập
				
				UserDetails interface--security chú ý:
				
														- Lớp x cài đặt interface UserDetails của Spring Security và biểu diễn một đối tượng người dùng trong ứng dụng. Lớp này sẽ lưu thông tin về xác thực (username và password)
														và thông tin về phân quyền (list authorities) và lần lượt cài đặt các phương thức của interface UserDetails. Trong đó có một số phương thức chúng ta cần để ý đến là
														getUsername(), getPassword(), và getAuthorities().
														- UserDetails là một interface cốt lõi của Spring Security. Nó đại diện cho một principal nhưng theo một cách mở rộng và cụ thể hơn. Vậy UserDetails cung cấp cho ta những
														thông tin gì? UserDetails bao gồm các method sau:
															- getAuthorities(): trả về danh sách các quyền của người dùng
															- getPassword(): trả về password đã dùng trong qúa trình xác thực
															- getUsername(): trả về username đã dùng trong qúa trình xác thực
															- isAccountNonExpired(): trả về true nếu tài khoản của người dùng chưa hết hạn
															- isAccountNonLocked(): trả về true nếu người dùng chưa bị khóa
															- isCredentialsNonExpired(): trả về true nếu chứng thực (mật khẩu) của người dùng chưa hết hạn
															- isEnabled(): trả về true nếu người dùng đã được kích hoạt
														- Chúng ta có thể thấy UserDetails mới chỉ cung cấp các phương thức để truy cập các thông tin cơ bản của người dùng. Để mở rộng thêm các thông tin, chúng ta sẽ tạo một lớp
														CustomUserDetails implements org.springframework.security.userdetails.UserDetails (tên lớp là tùy ý, bạn đặt tên thế nào cũng được).
														- UserDetails là một giao diện mô tả thông tin chi tiết về một người dùng được sử dụng để thực hiện xác thực và ủy quyền trong ứng dụng web.
				
				SecurityContext & SecurityContextHolder--security chú ý:
				
									- Là interface cốt lõi của Spring Security, lưu trữ tất cả các chi tiết liên quan đến bảo mật trong ứng dụng. Khi chúng ta kích hoạt Spring Security trong ứng dụng thì
									SecurityContext cũng sẽ được kích hoạt theo.												
									- Các phương thức quan trọng của SecurityContextHolder:
									
										getContext(): 						
										
																					Trả về context hiện tại của bảo mật. Context bao gồm thông tin về người dùng hiện tại và các quyền truy cập.	
																					
																					Authentication authentication = SecurityContextHolder.getContext().getAuthentication();																									
																					Authentication authentication =  .authenticate(
																												new UsernamePasswordAuthenticationToken(loginRequest.getId(), loginRequest.getPassword()));
																					SecurityContextHolder.getContext().setAuthentication(authentication);
										setContext(SecurityContext context): 																									
																					Đặt context bảo mật mới. Thường không được sử dụng trực tiếp, mà thay vào đó sử dụng các phương thức trên
																					SecurityContextHolder.																								
										clearContext(): 							
																					Xóa context bảo mật hiện tại khỏi SecurityContextHolder. Thường được gọi khi bạn muốn xóa thông tin xác thực của người dùng
																					sau khi họ đã thoát ra khỏi ứng dụng hoặc sau một phiên làm việc.																									
										createEmptyContext(): 						
																					Tạo một context bảo mật mới mà không có người dùng nào được xác thực																					
										MODE_THREADLOCAL: 							
																					Chế độ mặc định của SecurityContextHolder, nơi context bảo mật được lưu trữ trên một biến ThreadLocal. Điều này đảm bảo rằng
																					mỗi luồng (thread) trong ứng dụng có thể duy trì một context bảo mật riêng biệt.																							
										MODE_INHERITABLETHREADLOCAL: 				
																					Chế độ tương tự như MODE_THREADLOCAL, nhưng cho phép các luồng con (sub-threads) kế thừa context bảo mật từ luồng cha
																					(parent thread).																							
										MODE_GLOBAL: 								
																					Chế độ lưu trữ context bảo mật trên một biến static global. Điều này có thể gây ra các vấn đề về đồng bộ hóa trong các môi
																					trường đa luồng và không được khuyến khích sử dụng.
																					
									- Chúng ta sẽ không truy cập trực tiếp vào SecurityContext, thay vào đó sẽ sử dụng lớp SecurityContextHolder. Lớp này lưu trữ security context hiện tại của ứng dụng,
									bao gồm chi tiết của principal đang tương tác với ứng dụng. Spring Security sẽ dùng một đối tượng Authentication để biểu diễn thông tin này. Đoạn code dưới đây sẽ
									giúp chúng ta lấy được username của principal đã được xác thực (username ở đây ta nên hiểu là username trong cặp username – password mà người dùng nhập vào khi đăng nhập):
									
									Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
									if (principal instanceof UserDetails) {
										String username = ((UserDetails) principal).getUsername();
									} else {
										String username = principal.toString();
									}
									
									import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
									import org.springframework.security.core.Authentication;
									import org.springframework.security.core.context.SecurityContext;
									import org.springframework.security.core.context.SecurityContextHolder;
									public class SecurityContextHolderExample {
										public static void main(String[] args) {
											// Tạo một đối tượng Authentication
											Authentication authentication = new UsernamePasswordAuthenticationToken("user123", "password123");
											// Tạo một đối tượng SecurityContext và đặt đối tượng Authentication vào đó
											SecurityContext securityContext = SecurityContextHolder.createEmptyContext();
											securityContext.setAuthentication(authentication);
											// Đặt SecurityContext vào SecurityContextHolder
											SecurityContextHolder.setContext(securityContext);
											// Lấy đối tượng Authentication từ SecurityContextHolder
											Authentication retrievedAuthentication = SecurityContextHolder.getContext().getAuthentication();
											System.out.println("Principal: " + retrievedAuthentication.getPrincipal());
											System.out.println("Credentials: " + retrievedAuthentication.getCredentials());
											System.out.println("Authorities: " + retrievedAuthentication.getAuthorities());
											System.out.println("Is authenticated: " + retrievedAuthentication.isAuthenticated());
											// Xóa đối tượng Authentication khỏi SecurityContextHolder
											SecurityContextHolder.clearContext();
											// Kiểm tra xem SecurityContextHolder có rỗng không
											boolean isContextEmpty = SecurityContextHolder.getContext().getAuthentication() == null;
											System.out.println("Is SecurityContext empty? " + isContextEmpty);
										}
									}
									
				HttpSecurity--security chú ý:
														- Là đối tượng chính của Spring Security, cho phép chúng ta cấu hình mọi thứ cần bảo mật, và nó được xây dựng dưới design pattern giống với Builder Pattern , nên
														mọi cài đặt có thể viết liên tục thông qua toán tử.
														- It allows configuring web based security for specific http requests. By default it will be applied to all requests, but can be restricted using
														#requestMatcher(RequestMatcher) or other similar methods.
														- HttpSecurity là một lớp cung cấp cơ chế cấu hình bảo mật cho ứng dụng web. Nó là một phần quan trọng của cấu hình Spring Security và cho phép bạn xác định các quy
														tắc bảo mật dựa trên các yêu cầu HTTP đến ứng dụng của bạn.
														- Khi một yêu cầu HTTP được gửi đến ứng dụng, nó sẽ được xử lý bởi Spring Security và đi qua một loạt các bộ lọc (filters) bảo mật được cấu hình bởi HttpSecurity. Mỗi
														bộ lọc sẽ kiểm tra yêu cầu và thực hiện các hành động nhất định, chẳng hạn như xác thực người dùng, ủy quyền, kiểm tra quyền truy cập, và xử lý các tình huống bảo mật khác.
														- HttpSecurity cho phép bạn chỉ định các quy tắc cụ thể để kiểm soát cách mà yêu cầu HTTP được xử lý.
					.authorizeRequests():
														Phương thức này cho phép bạn cấu hình các quy tắc ủy quyền dựa trên các yêu cầu HTTP. Bạn có thể xác định các điều kiện để yêu cầu phải thỏa mãn trước khi được phép truy
														cập vào các tài nguyên.
					.formLogin(): 
														Phương thức này cho phép bạn cấu hình xác thực dựa trên mẫu đăng nhập. Nó sẽ tự động tạo trang đăng nhập cho bạn và xử lý quá trình đăng nhập.
					.logout(): 
														Phương thức này cho phép bạn cấu hình xử lý đăng xuất của người dùng.
					.csrf():
														Phương thức này cho phép bạn bật hoặc tắt tính năng bảo vệ chống tấn công giả mạo yêu cầu (Cross-Site Request Forgery).
					.cors(): 
														Phương thức này cho phép bạn cấu hình hỗ trợ Cross-Origin Resource Sharing (CORS) để cho phép hoặc hạn chế truy cập từ các tên miền khác.
					.httpBasic():
														Phương thức này cho phép xác thực dựa trên HTTP Basic Authentication. Nó sẽ tạo một cửa sổ hộp thoại đăng nhập của trình duyệt khi người dùng cố gắng truy cập vào các tài
														nguyên yêu cầu xác thực.
					.oauth2Login(): 
														Phương thức này cấu hình xác thực dựa trên OAuth 2.0. Nó cho phép người dùng đăng nhập bằng cách sử dụng một nhà cung cấp đăng nhập bên thứ ba như Google, Facebook, GitHub,
														v.v.
					.rememberMe(): 
														Phương thức này kích hoạt tính năng "Remember Me" để giữ cho người dùng đăng nhập sau khi hết hạn phiên đăng nhập.
					.sessionManagement():
														Phương thức này cho phép bạn cấu hình quản lý phiên (session) trong ứng dụng. Bạn có thể thiết lập thời gian hết hạn phiên, xác định cách xử lý nhiều phiên cùng lúc, v.v.
					.exceptionHandling():
														Phương thức này cho phép bạn xác định cách xử lý các ngoại lệ bảo mật trong ứng dụng. Bạn có thể định nghĩa trang đăng nhập tùy chỉnh hoặc xử lý các lỗi bảo mật khác.
					.headers():
														Phương thức này cho phép bạn cấu hình các tiêu đề bảo mật cho yêu cầu HTTP như HSTS (HTTP Strict Transport Security), X-Content-Type-Options, X-XSS-Protection, v.v.
					.authorizeRequests()
					.antMatchers("/path")
					.access("hasRole('ROLE_ADMIN') and 
					hasIpAddress('192.168.1.0/24')"): 
														Phương thức này cho phép bạn định nghĩa các quy tắc ủy quyền phức tạp bằng cách sử dụng Access Control Expressions (ACEs). Bạn có thể xác định các điều kiện phức
														tạp để xác định quyền truy cập vào các tài nguyên.	
														
														import org.springframework.context.annotation.Configuration;
														import org.springframework.security.config.annotation.web.builders.HttpSecurity;
														import org.springframework.security.crypto.password.PasswordEncoder;
														import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
														@Configuration
														public class SecurityConfig {
															@Bean
															public PasswordEncoder passwordEncoder() {
																return new BCryptPasswordEncoder();
															}
															@Bean
															public HttpSecurity httpSecurity() throws Exception {
																HttpSecurity http = new HttpSecurityBuilder<>();
																http
																	.authorizeRequests()
																		.antMatchers("/public/**").permitAll() // Cho phép tất cả mọi người truy cập các URL bắt đầu bằng /public/
																		.antMatchers("/admin/**").hasRole("ADMIN") // Chỉ cho phép người dùng có vai trò ADMIN truy cập các URL bắt đầu bằng /admin/
																		.antMatchers("/path").access("hasRole('ROLE_ADMIN') and hasIpAddress('192.168.1.0/24')") // Kiểm tra quyền và địa chỉ IP
																		.anyRequest().authenticated() // Tất cả các request còn lại đều cần xác thực
																		.and()
																	.formLogin() // Cho phép sử dụng form login
																		.and()
																	.logout() // Cho phép logout
																		.and()
																	.csrf().disable() // Vô hiệu hóa CSRF protection
																		.and()
																	.cors() // Cấu hình CORS (Cross-Origin Resource Sharing)
																		.and()
																	.httpBasic() // Cho phép sử dụng HTTP Basic Authentication
																		.and()
																	.oauth2Login() // Cho phép đăng nhập OAuth 2.0
																		.and()
																	.rememberMe() // Cho phép Remember Me Authentication
																		.and()
																	.sessionManagement() // Quản lý session
																		.and()
																	.exceptionHandling() // Xử lý các ngoại lệ liên quan đến bảo mật
																		.and()
																	.headers() // Cấu hình HTTP headers
																		.and();
																return http;
															}
														}
				JdbcUserDetailsManager--security chú ý:
				
														- JdbcUserDetailsManager là một implement của interface UserDetailsService trong Spring Security
														- Là một lớp cung cấp sẵn, được sử dụng để quản lý thông tin người dùng (user details) trong cơ sở dữ liệu bằng cách sử dụng JDBC (Java Database Connectivity). Nó là một
														cách tiện lợi để lưu trữ và quản lý thông tin người dùng như tên người dùng, mật khẩu, vai trò (roles) và quyền (authorities) trong cơ sở dữ liệu thay vì lưu trữ
														trong bộ nhớ (in-memory).
														- Khi bạn cần xác thực và ủy quyền người dùng trong ứng dụng của mình, bạn cần có một cơ chế để lưu trữ thông tin người dùng. Spring Security cung cấp một số lựa chọn
														để làm điều này, và JdbcUserDetailsManager là một trong số đó.
														- JdbcUserDetailsManager sử dụng JDBC để tương tác với cơ sở dữ liệu của bạn và có thể thực hiện các chức năng cơ bản như:
															Tạo người dùng mới và lưu trữ thông tin của họ trong cơ sở dữ liệu.
															Thay đổi thông tin người dùng như mật khẩu, vai trò, quyền, v.v.
															Xóa người dùng khỏi cơ sở dữ liệu.
															Tìm kiếm người dùng theo tên người dùng hoặc ID.
														- Để sử dụng JdbcUserDetailsManager, bạn cần cấu hình nó trong ứng dụng của mình thông qua các bean Spring. Bạn cần xác định nguồn dữ liệu JDBC (DataSource) để nó có thể
														kết nối và tương tác với cơ sở dữ liệu.
														
														import org.springframework.beans.factory.annotation.Autowired;
														import org.springframework.context.annotation.Bean;
														import org.springframework.context.annotation.Configuration;
														import org.springframework.security.core.userdetails.User;
														import org.springframework.security.core.userdetails.UserDetails;
														import org.springframework.security.crypto.password.PasswordEncoder;
														import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
														import org.springframework.security.provisioning.JdbcUserDetailsManager;
														import javax.sql.DataSource;
														@Configuration
														public class SecurityConfig {
															@Autowired
															private DataSource dataSource;
															@Bean
															public PasswordEncoder passwordEncoder() {
																return new BCryptPasswordEncoder();
															}
															@Bean
															public JdbcUserDetailsManager jdbcUserDetailsManager() {
																JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager();
																jdbcUserDetailsManager.setDataSource(dataSource);
																return jdbcUserDetailsManager;
															}
															@Bean
															public void loadUsers(JdbcUserDetailsManager jdbcUserDetailsManager, PasswordEncoder passwordEncoder) {
																// Thêm người dùng mới vào cơ sở dữ liệu
																UserDetails user = User.withUsername("user")
																		.password(passwordEncoder.encode("password"))
																		.roles("USER")
																		.build();
																UserDetails admin = User.withUsername("admin")
																		.password(passwordEncoder.encode("admin"))
																		.roles("ADMIN")
																		.build();
																if (!jdbcUserDetailsManager.userExists("user")) {
																	jdbcUserDetailsManager.createUser(user);
																}
																if (!jdbcUserDetailsManager.userExists("admin")) {
																	jdbcUserDetailsManager.createUser(admin);
																}
															}
														}
				SecurityFilterChain--security chú ý:
														- Là một interface chịu trách nhiệm xác định các bộ lọc (filters) mà Spring Security sử dụng để xử lý các yêu cầu HTTP vào ứng dụng. Mỗi SecurityFilterChain đại
														diện cho một tập hợp các bộ lọc được áp dụng theo một cách cụ thể cho các yêu cầu cụ thể. Khi một yêu cầu HTTP đến, Spring Security sẽ kiểm tra các
														SecurityFilterChain để xác định xem bộ lọc nào cần được áp dụng cho yêu cầu này.
														- Một ứng dụng Spring Security có thể có nhiều SecurityFilterChain để hỗ trợ các luồng xử lý bảo mật khác nhau cho các URL hoặc nhóm URL cụ thể. Điều này giúp bạn xác định
														mức độ bảo mật khác nhau cho các phần của ứng dụng của bạn.
														
														import org.springframework.context.annotation.Bean;
														import org.springframework.context.annotation.Configuration;
														import org.springframework.security.authentication.AuthenticationManager;
														import org.springframework.security.config.annotation.web.builders.HttpSecurity;
														import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
														import org.springframework.security.crypto.password.PasswordEncoder;
														import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
														import org.springframework.security.provisioning.JdbcUserDetailsManager;
														import org.springframework.security.web.SecurityFilterChain;
														import javax.sql.DataSource;
														@Configuration
														@EnableWebSecurity
														public class SecurityConfig {
															@Bean
															public PasswordEncoder passwordEncoder() {
																return new BCryptPasswordEncoder();
															}
															@Bean
															public JdbcUserDetailsManager jdbcUserDetailsManager(DataSource dataSource) {
																JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager();
																jdbcUserDetailsManager.setDataSource(dataSource);
																return jdbcUserDetailsManager;
															}
															@Bean
															public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
																http
																	.authorizeRequests()
																		.antMatchers("/public/**").permitAll()
																		.antMatchers("/admin/**").hasRole("ADMIN")
																		.anyRequest().authenticated()
																		.and()
																	.formLogin()
																		.and()
																	.logout()
																		.and()
																	.csrf().disable();
																return http.build();
															}
															@Bean
															public AuthenticationManager authenticationManagerBean() throws Exception {
																return super.authenticationManagerBean();
															}
														}

				DataSource--security chú ý:
														Trong Spring Framework, DataSource là một interface (giao diện) được sử dụng để cấu hình và quản lý kết nối đến cơ sở dữ liệu. Nó cung cấp một cách trừu tượng để tạo và
														giải phóng các kết nối đến cơ sở dữ liệu, đồng thời cho phép ứng dụng truy cập vào các tính năng của cơ sở dữ liệu một cách tiện lợi.
															Lấy một kết nối đến cơ sở dữ liệu (Connection): Ứng dụng có thể yêu cầu DataSource trả về một kết nối đang mở đến cơ sở dữ liệu để thực hiện các truy vấn.
															Giải phóng kết nối (Connection Release): 		Sau khi ứng dụng hoàn thành công việc với kết nối, nó có thể giải phóng nó để tái sử dụng bởi các yêu cầu kết nối
																											sau này.
														
														import javax.sql.DataSource;
														import org.springframework.context.annotation.Bean;
														import org.springframework.context.annotation.Configuration;
														import org.springframework.jdbc.datasource.DriverManagerDataSource;
														@Configuration
														public class DataSourceConfig {
															@Bean
															public DataSource dataSource() {
																DriverManagerDataSource dataSource = new DriverManagerDataSource();
																dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
																dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");
																dataSource.setUsername("username");
																dataSource.setPassword("password");
																return dataSource;
															}
														}		
				authorizeHttpRequests--security chú ý:
				
														Là một phần của cấu hình bảo mật (security configuration) cho ứng dụng web. Nó được sử dụng để xác định cách xác thực (authentication) và phân quyền (authorization) được
														thực hiện trên các yêu cầu HTTP vào ứng dụng.
														Phương thức authorizeHttpRequests cho phép bạn xác định các quy tắc (rules) để quyết định ai và khi nào được truy cập vào các tài nguyên, URL hoặc chức năng cụ thể của ứng
														dụng dựa trên vai trò (roles) của người dùng và các điều kiện khác.
														
														@Bean
														public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
															 http.authorizeHttpRequests(configurer ->
																	 configurer
																		 .requestMatchers(HttpMethod.GET, "/api/employees").hasRole("EMPLOYEE")
																		 .requestMatchers(HttpMethod.GET, "/api/employees/**").hasRole("EMPLOYEE")
																		 .requestMatchers(HttpMethod.POST, "/api/employees").hasRole("MANAGER")
																		 .requestMatchers(HttpMethod.PUT, "/api/employees").hasRole("MANAGER")
																		 .requestMatchers(HttpMethod.DELETE, "/api/employees/**").hasRole("ADMIN"));																 
															http.httpBasic(); // use HTTP Basic authentication																 
															http.csrf().disable(); // disable Cross Site Request Forgery (CSRF)
															return http.build();
														}														
				HTTP Basic Authentication--security chú ý:
				
														HTTP Basic Authentication là một phương thức xác thực trong giao thức HTTP được sử dụng để bảo vệ các tài nguyên trên web bằng cách yêu cầu người dùng cung cấp tên người
														dùng (username) và mật khẩu (password). Phương thức này là một trong những phương thức xác thực cơ bản và dễ dàng triển khai.
															Khi truy cập vào một tài nguyên yêu cầu xác thực, máy chủ sẽ trả về một mã trạng thái HTTP 401 Unauthorized.
															Trình duyệt hoặc ứng dụng khách sẽ hiển thị một hộp thoại yêu cầu người dùng nhập tên người dùng và mật khẩu.
															Người dùng cung cấp thông tin xác thực và gửi lại yêu cầu đến máy chủ.
															Máy chủ sẽ kiểm tra thông tin đăng nhập được cung cấp. Nếu thông tin xác thực chính xác, máy chủ sẽ phản hồi với mã trạng thái HTTP 200 OK và cung cấp truy cập vào tài
															nguyên yêu cầu. Ngược lại, nếu thông tin xác thực không chính xác, máy chủ sẽ trả về mã trạng thái HTTP 401 Unauthorized.
				
				HTTP Basic Authentication header--security chú ý:
				
														HTTP Basic Authentication header là một dạng header của yêu cầu HTTP được sử dụng để chứa thông tin đăng nhập của người dùng khi sử dụng phương thức xác thực HTTP Basic
														Authentication. Header này chứa tên người dùng và mật khẩu được mã hóa và gửi đến máy chủ để xác thực.
														Cấu trúc của HTTP Basic Authentication header như sau:
															Authorization: Basic <credentials>
																		Authorization: là tên của header, chỉ định rằng yêu cầu HTTP này được xác thực bằng phương thức HTTP Basic Authentication.
																		Basic: là loại phương thức xác thực, trong trường hợp này là HTTP Basic Authentication.
																		<credentials>: là chuỗi thông tin xác thực của người dùng, bao gồm tên người dùng và mật khẩu, được mã hóa theo thuật toán Base64.
														Ví dụ: 	
																		Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
																					Authorization là tên của header.
																					Basic là loại xác thực, cho biết rằng đây là phương thức Basic Authentication.
																					YWxhZGRpbjpvcGVuc2VzYW1l là tên người dùng (username) và mật khẩu (password) của người dùng, được mã hóa dưới dạng Base64.
				
				DaoAuthenticationProvider--security chú ý:
						
														- DaoAuthenticationProvider là một lớp trong Spring Security được sử dụng để cung cấp việc xác thực người dùng bằng cách sử dụng một implement của UserDetailsService
														để lấy thông tin người dùng từ một nguồn dữ liệu, sau đó so sánh mật khẩu đã nhập với mật khẩu lưu trữ để xác định xem người dùng có được phép truy cập hay không.
														- Đối với mỗi yêu cầu xác thực, DaoAuthenticationProvider sẽ sử dụng UserDetailsService được chỉ định để tìm kiếm thông tin người dùng dựa trên tên người dùng (username).
														Sau đó, nó sẽ so sánh mật khẩu đã nhập với mật khẩu lưu trữ của người dùng được trả về từ UserDetailsService. Nếu mật khẩu khớp, người dùng được xác thực thành công.
														
														Chúng ta tạo bean UserDetailsService và PasswordEncoder để cung cấp thông tin người dùng và mã hóa mật khẩu.
														Chúng ta cũng tạo một DaoAuthenticationProvider và cấu hình nó để sử dụng UserDetailsService và PasswordEncoder đã tạo.
														SecurityFilterChain được sử dụng để cấu hình bảo mật cho ứng dụng. Ở đây, chúng ta cấu hình phần tử HttpSecurity để cho phép truy cập vào các url có tiền tố là "/public" mà
														không cần xác thực, còn lại tất cả các yêu cầu khác phải được xác thực. Chúng ta cũng cấu hình form login và logout.
														
														import org.springframework.context.annotation.Bean;
														import org.springframework.context.annotation.Configuration;
														import org.springframework.security.authentication.AuthenticationManager;
														import org.springframework.security.authentication.AuthenticationProvider;
														import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
														import org.springframework.security.config.annotation.web.builders.HttpSecurity;
														import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
														import org.springframework.security.config.annotation.web.configuration.SecurityConfigurerAdapter;
														import org.springframework.security.config.annotation.web.configuration.SecurityFilterChain;
														import org.springframework.security.core.userdetails.UserDetailsService;
														import org.springframework.security.crypto.password.PasswordEncoder;
														import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
														@Configuration
														@EnableWebSecurity
														public class SecurityConfig {
															@Bean
															public UserDetailsService userDetailsService() {														
																return new CustomUserDetailsService(); // Trả về implement của UserDetailsService (có thể triển khai bằng cách sử dụng JDBC, LDAP, hoặc các cách khác)
															}
															@Bean
															public PasswordEncoder passwordEncoder() {														
																return new BCryptPasswordEncoder(); // Sử dụng BCryptPasswordEncoder cho mã hóa mật khẩu
															}
															@Bean
															public AuthenticationProvider authenticationProvider() {														
																DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(); // Tạo một DaoAuthenticationProvider và cấu hình nó
																authProvider.setUserDetailsService(userDetailsService());
																authProvider.setPasswordEncoder(passwordEncoder());
																return authProvider;
															}
															@Bean
															public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {															
																http // Cấu hình bảo mật cho ứng dụng
																	.authorizeRequests()
																		.antMatchers("/public/**").permitAll()
																		.anyRequest().authenticated()
																		.and()
																	.formLogin()
																		.loginPage("/login")
																		.permitAll()
																		.and()
																	.logout()
																		.permitAll();
																return http.build();
															}
														}
				Bcrypt--security chú ý:
														- Chú ý mật khẩu dạng thường đến backend chuyển thành bcrypt, nên khi hacker có mật khẩu dạng bcrypt cũng không làm gì, vì nó sẽ lại mã hóa mật khẩu đó sẽ tạo ra mật
														khẩu khác
														- Về cơ bản, cách mà bcrypt thực hiện so sánh hai mật khẩu mã hóa là một bí mật thương mại được giữ bởi nhà phát triển thư viện và không được tiết lộ công khai. Điều này
														giữ cho phương thức so sánh được an toàn và không thể dễ dàng bị tấn công.
														- Nếu mật khẩu được gửi dưới dạng bcrypt, việc bắt được mật khẩu này không có nghĩa là hacker có thể biết chính xác mật khẩu của bạn là gì. Bcrypt là một thuật toán mã hóa
														mật khẩu mạnh mẽ và an toàn, được thiết kế để ngăn chặn việc xác định mật khẩu gốc từ mật khẩu đã được mã hóa.
														- Thuật toán bcrypt sử dụng hàm hash mạnh mẽ và sử dụng salt (muối) để tăng cường bảo mật. Khi một mật khẩu được mã hóa bằng bcrypt, kết quả mã hóa sẽ không thể được quay
														ngược trở lại mật khẩu gốc một cách dễ dàng. Điều này đảm bảo rằng ngay cả khi mật khẩu bị bắt được, hacker sẽ gặp khó khăn trong việc xác định mật khẩu gốc.
														- Tuy nhiên, việc sử dụng bcrypt chỉ giúp bảo vệ mật khẩu của bạn nếu bạn đã chọn một mật khẩu mạnh và độ dài đủ lớn. Mật khẩu yếu vẫn có thể bị crack bằng các kỹ thuật
														tấn công từ điển hoặc tấn công brute force. Để tăng cường bảo mật, luôn nên sử dụng mật khẩu mạnh và hạn chế sử dụng cùng một mật khẩu cho nhiều tài khoản khác nhau.
														- Nếu một hacker bắt được một mật khẩu được mã hóa bằng bcrypt, họ không thể sử dụng trực tiếp mật khẩu đó để đăng nhập vào các hệ thống khác. Lý do là bcrypt sử dụng một
														kỹ thuật gọi là salt (muối) khi mã hóa mật khẩu. Salt là một chuỗi ngẫu nhiên được thêm vào trước khi thực hiện quá trình mã hóa, làm cho mỗi mật khẩu được mã hóa trở nên
														duy nhất, ngay cả khi hai mật khẩu có giá trị giống nhau.
														- Khi hacker bắt được một mật khẩu được mã hóa bằng bcrypt, họ chỉ có thể thực hiện các cuộc tấn công tương tự để cố gắng tìm ra mật khẩu gốc. Điều này thường là một quá
														trình tốn kém và tốn thời gian, đặc biệt nếu mật khẩu của bạn là một mật khẩu mạnh.
														- Tuy nhiên, nếu hacker có thể giải mã mật khẩu bcrypt thành mật khẩu gốc, họ có thể sử dụng mật khẩu đó để thử đăng nhập vào các hệ thống khác nếu bạn tái sử dụng mật khẩu
														đó. Đây là lý do tại sao quan trọng phải sử dụng một mật khẩu duy nhất và mạnh mẽ cho mỗi tài khoản của bạn.

														import org.springframework.security.crypto.password.PasswordEncoder;
														import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
														public class BcryptExample {
															public static void main(String[] args) {
																// Khởi tạo PasswordEncoder
																PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
																// Mật khẩu gốc
																String rawPassword = "myPassword123";
																// Mã hóa mật khẩu
																String encodedPassword = passwordEncoder.encode(rawPassword);
																System.out.println("Mật khẩu đã mã hóa: " + encodedPassword);
																// Kiểm tra mật khẩu
																boolean matches = passwordEncoder.matches(rawPassword, encodedPassword);
																System.out.println("Mật khẩu đúng: " + matches);
															}
														}
			Authentication--security chú ý:
												
								- Trong Spring Security, Authentication là một interface đại diện cho thông tin xác thực của một người dùng. Interface này cung cấp các phương thức để truy xuất thông tin
								liên quan đến quá trình xác thực của người dùng, bao gồm tên người dùng (principal), mật khẩu, các quyền (authorities), và các thông tin bổ sung.
									getPrincipal(): 							Trả về thông tin người dùng được xác thực (principal), thường là tên đăng nhập hoặc đối tượng đại diện cho người dùng.
									getCredentials():							Trả về thông tin xác thực của người dùng, thường là mật khẩu hoặc thông tin xác thực khác.
									getAuthorities(): 							Trả về danh sách các quyền (authorities) của người dùng sau khi xác thực.
									getDetails(): 								Trả về các thông tin chi tiết về quá trình xác thực. Thông thường, đây là các đối tượng tùy chỉnh được cung cấp bởi ứng dụng.
									getName(): 									Trả về tên người dùng, tương đương với getPrincipal().toString().
									isAuthenticated(): 							Kiểm tra xem người dùng đã được xác thực hay chưa.
									setAuthenticated(boolean authenticated): 	Đánh dấu người dùng là đã được xác thực hoặc chưa được xác thực.
									
									import org.springframework.security.core.Authentication;
									import org.springframework.security.core.context.SecurityContextHolder;
									public class AuthenticationExample {
										public static void main(String[] args) {															
											Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // Tạo một đối tượng Authentication
											// Lấy thông tin người dùng được xác thực
											Object principal = authentication.getPrincipal();
											System.out.println("Principal: " + principal);
											// Lấy thông tin xác thực
											Object credentials = authentication.getCredentials();
											System.out.println("Credentials: " + credentials);
											// Lấy danh sách quyền của người dùng
											System.out.println("Authorities: " + authentication.getAuthorities());
											// Kiểm tra xem người dùng đã được xác thực hay chưa
											boolean isAuthenticated = authentication.isAuthenticated();
											System.out.println("Is authenticated: " + isAuthenticated);
										}
									}
													
			Jwts--security chú ý:											
								
								- Jwts là một lớp tĩnh trong thư viện JWT của Java, thường được sử dụng để tạo ra và xác thực JSON Web Tokens (JWTs). Thư viện này cung cấp các phương thức tiện ích để
								tạo, phân tích và xác thực các chuỗi JWT.
								- Trong Spring Security, Jwts thường được sử dụng để tạo ra JWTs trong quá trình xác thực và tạo ra token cho người dùng đã đăng nhập.
								
								- Dưới đây là một số phương thức phổ biến của lớp Jwts:
										
										builder(): Phương thức này trả về một builder mới để bắt đầu quá trình tạo JWT.
										parser(): Trả về một parser để phân tích chuỗi JWT.
										compact() : Hoàn thành quá trình tạo JWT và trả về chuỗi JWT đã ký.
										setSubject(String subject): Đặt chủ thể (subject) của JWT.
										setIssuer(String issuer): Đặt người phát hành (issuer) của JWT.
										setAudience(String audience): Đặt đối tượng mà JWT được tạo cho (audience).
										setIssuedAt(Date issuedAt): Đặt thời gian phát hành (issued at) của JWT.
										setExpiration(Date expiration): Đặt thời gian hết hạn của JWT.
										setId(String id): Đặt ID của JWT.
										signWith(SignatureAlgorithm alg, Key key): Ký JWT bằng một thuật toán ký và một khóa.
										serializeToJson(JsonSerializationHelper jsonSerializationHelper): Chuyển đổi JWT thành đối tượng JSON.
										deserializeFromJson(JsonNode json, DeserializationContext deserializationContext): Chuyển đổi đối tượng JSON thành JWT.
										
										import io.jsonwebtoken.Jwts;
										import io.jsonwebtoken.SignatureAlgorithm;
										import java.util.Date;
										public class JwtExample {
											public static void main(String[] args) {																
												String secretKey = "mySecretKey"; // Khóa bí mật được sử dụng để ký JWT															
												long expirationMs = 3600000; // Thời gian hết hạn của JWT (60 phút)
												// Tạo JWT
												String jwt = Jwts.builder()
														.setSubject("user123") // Chủ thể của JWT
														.setIssuedAt(new Date()) // Thời gian phát hành
														.setExpiration(new Date(System.currentTimeMillis() + expirationMs)) // Thời gian hết hạn
														.signWith(SignatureAlgorithm.HS256, secretKey) // Ký JWT với thuật toán HS256 và khóa bí mật
														.compact();

												// In ra JWT đã tạo
												System.out.println("Generated JWT: " + jwt);
											}
										}
										
										Jwts.parserBuilder().setSigningKey(key()).build().parse(authToken);
										Jwts.parserBuilder()
											Mô tả: Đây là phương thức tĩnh của lớp Jwts, bắt đầu việc xây dựng một JwtParser thông qua một JwtParserBuilder.
											Chức năng: JwtParserBuilder cung cấp các phương thức để cấu hình các tùy chọn phân tích JWT.
										setSigningKey(key())
											Mô tả: Phương thức này thiết lập khóa ký (signing key) mà JwtParser sẽ sử dụng để xác thực JWT.
											Chức năng: key() là phương thức giả định của bạn (không được định nghĩa trong đoạn code). Phương thức này trả về khóa bí mật (secret key) được sử dụng để
											ký JWT. Khóa này phải giống với khóa được sử dụng khi JWT được tạo ra. Bạn cần đảm bảo rằng khóa này là một byte array hoặc một đối tượng Key (như
											SecretKey hoặc PublicKey nếu bạn sử dụng thuật toán không đối xứng).
											Chú ý: Nếu key() trả về một chuỗi, bạn có thể cần chuyển nó thành byte array như key().getBytes() tùy thuộc vào cách bạn cấu hình JwtParser.
										build()
											Mô tả: Phương thức này hoàn tất quá trình xây dựng và trả về một đối tượng JwtParser đã được cấu hình.
											Chức năng: build() tạo ra một JwtParser mà bạn có thể sử dụng để phân tích và xác thực JWT.
										parse(authToken)
											Mô tả: Phương thức parse của JwtParser nhận vào một JWT dưới dạng chuỗi (authToken) và cố gắng phân tích và xác thực nó.
											Chức năng: Nếu token hợp lệ và được ký bằng khóa đúng, parse sẽ trả về một đối tượng Jwt (hoặc Claims nếu bạn dùng parseClaimsJws). Nếu token không hợp lệ hoặc
											không thể xác thực được (do khóa sai hoặc token đã bị sửa đổi), nó sẽ ném ra một ngoại lệ như JwtException.
																	
			AuthenticationManager--security chú ý:

				- Trong Spring Security, AuthenticationManager là một thành phần cốt lõi chịu trách nhiệm xử lý xác thực (authentication). Nó có nhiệm vụ kiểm tra thông tin xác thực (credentials)
				do người dùng cung cấp (thông qua form đăng nhập, HTTP Basic, hoặc bất kỳ cơ chế nào khác) và quyết định xem người dùng có được phép truy cập vào hệ thống hay không.
				- Vai trò của AuthenticationManager:
					
					AuthenticationManager được sử dụng để xác minh danh tính người dùng. Nó nhận vào một đối tượng Authentication chứa thông tin đăng nhập của người dùng (ví dụ: tên đăng nhập và
					mật khẩu), sau đó kiểm tra thông tin này bằng cách sử dụng các bộ xử lý xác thực (authentication providers).
					
					Nếu thông tin xác thực là hợp lệ, AuthenticationManager sẽ trả về một đối tượng Authentication đã được xác thực (authentication token). Nếu không, nó sẽ ném ra một ngoại
					lệ, thường là AuthenticationException.

				- Sử dụng AuthenticationManager:
				
					Bạn thường không tạo thủ công AuthenticationManager, thay vào đó, Spring Security cung cấp một cách tự động để cấu hình nó trong quá trình thiết lập bảo mật.
					
					import org.springframework.context.annotation.Bean;
					import org.springframework.security.authentication.AuthenticationManager;
					import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
					@Configuration
					public class SecurityConfig {
						@Bean
						public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
							return authenticationConfiguration.getAuthenticationManager();
						}
					}
					Trong ví dụ trên, AuthenticationConfiguration là một thành phần của Spring Security giúp lấy AuthenticationManager từ cấu hình bảo mật hiện tại.
					
				- Quá trình xác thực với AuthenticationManager:
				
					Khi AuthenticationManager nhận một yêu cầu xác thực, nó sẽ lần lượt chuyển thông tin này đến các AuthenticationProvider mà nó quản lý. Mỗi AuthenticationProvider sẽ cố gắng xác thực
					yêu cầu. Nếu không có AuthenticationProvider nào thành công, quá trình xác thực sẽ thất bại.
					
					Ví dụ về quá trình xác thực:
					
						Người dùng gửi thông tin đăng nhập (username và password).
						AuthenticationManager nhận thông tin này và gọi đến các AuthenticationProvider.
						Nếu một AuthenticationProvider có thể xác thực, nó trả về một đối tượng Authentication đã xác thực, nếu không, nó ném ra ngoại lệ BadCredentialsException hoặc các ngoại lệ khác.

				- Các thành phần liên quan đến AuthenticationManager:
				
					Authentication: Đối tượng chứa thông tin đăng nhập người dùng, có thể là tên đăng nhập, mật khẩu, mã OTP, token, v.v.
					
					AuthenticationProvider: Là thành phần thực hiện logic xác thực. Một AuthenticationManager có thể sử dụng nhiều AuthenticationProvider khác nhau để xác thực người dùng.
					
					UserDetailsService: Cung cấp thông tin người dùng cho AuthenticationProvider để so sánh và kiểm tra thông tin xác thực.
					
				- Cấu hình tuỳ chỉnh AuthenticationManager:
				
					Bạn có thể cấu hình các AuthenticationProvider cho AuthenticationManager bằng cách thêm các provider vào cấu hình bảo mật.
					
					import org.springframework.context.annotation.Bean;
					import org.springframework.context.annotation.Configuration;
					import org.springframework.security.authentication.AuthenticationManager;
					import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
					import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
					import org.springframework.security.crypto.password.PasswordEncoder;
					import org.springframework.security.provisioning.UserDetailsManager;
					@Configuration
					public class SecurityConfig {
						private final UserDetailsManager userDetailsManager;
						private final PasswordEncoder passwordEncoder;
						public SecurityConfig(UserDetailsManager userDetailsManager, PasswordEncoder passwordEncoder) {
							this.userDetailsManager = userDetailsManager;
							this.passwordEncoder = passwordEncoder;
						}
						@Bean
						public AuthenticationManager authenticationManager(AuthenticationManagerBuilder auth) throws Exception {
							DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
							authProvider.setUserDetailsService(userDetailsManager);
							authProvider.setPasswordEncoder(passwordEncoder);
							return auth.authenticationProvider(authProvider).build();
						}
					}
					Trong ví dụ trên, chúng ta cấu hình một DaoAuthenticationProvider với UserDetailsService và PasswordEncoder, sau đó thêm nó vào AuthenticationManager.
					
					private final AuthenticationManager authenticationManager;
					Authentication authentication = authenticationManager.authenticate(
                            new UsernamePasswordAuthenticationToken(loginRequest.getId(), loginRequest.getPassword()));
					authenticate() là phương thức của AuthenticationManager, được sử dụng để xác thực thông tin người dùng.
					Phương thức này nhận một đối tượng Authentication (ở đây là UsernamePasswordAuthenticationToken) và tiến hành kiểm tra xem thông tin đăng nhập có hợp lệ không.
					Nếu thông tin hợp lệ, nó trả về đối tượng Authentication đã được xác thực.
					Nếu thông tin không hợp lệ, phương thức sẽ ném ra một ngoại lệ xác thực, chẳng hạn như BadCredentialsException.

			FilterChain--security chú ý:
			
				- Trong Spring Framework, FilterChain là một phần của cơ chế lọc (filtering) của Servlet API, được sử dụng để xử lý các yêu cầu HTTP trước khi chúng đến với các servlet hoặc các
				thành phần xử lý khác trong ứng dụng web của bạn. Spring cung cấp các công cụ và tiện ích để dễ dàng tích hợp và làm việc với FilterChain.
				- Filter: Là một đối tượng có nhiệm vụ thực hiện các tác vụ trước khi yêu cầu HTTP được chuyển tiếp đến servlet hoặc sau khi servlet xử lý xong yêu cầu.
				- FilterChain: Là một đối tượng giúp truyền yêu cầu HTTP qua chuỗi các filter để xử lý. FilterChain có phương thức doFilter() để chuyển tiếp yêu cầu đến filter tiếp theo trong chuỗi.
				- Đăng ký Filter: Bạn cần phải đăng ký filter trong ứng dụng của mình để Spring biết filter nào cần sử dụng và khi nào sử dụng.
				- Thứ tự Filter: Thứ tự đăng ký filter trong cấu hình có thể ảnh hưởng đến cách yêu cầu HTTP được xử lý.
				- Cách hoạt động của FilterChain:
				
					Khi một yêu cầu HTTP đến: Nó được gửi đến các filter trong ứng dụng theo thứ tự đã được định nghĩa.
					Mỗi filter có thể thực hiện các thao tác như kiểm tra quyền truy cập, ghi log, thay đổi yêu cầu/đáp ứng, v.v.
					Sau khi filter xử lý xong: Yêu cầu được chuyển tiếp đến filter tiếp theo thông qua phương thức doFilter() của FilterChain.
					Cuối cùng: Yêu cầu sẽ đến servlet để xử lý chính, hoặc nếu filter đã chấm dứt quá trình xử lý thì có thể gửi phản hồi ngay lập tức.
					
				- Cấu hình Filter trong Spring:
				
					Bạn có thể cấu hình Filter trong Spring bằng cách sử dụng các lớp Java Configuration hoặc XML Configuration.
					
						Tạo lớp Filter:
					
							import javax.servlet.Filter;
							import javax.servlet.FilterChain;
							import javax.servlet.FilterConfig;
							import javax.servlet.ServletException;
							import javax.servlet.ServletRequest;
							import javax.servlet.ServletResponse;
							import java.io.IOException;
							public class MyCustomFilter implements Filter {
								@Override
								public void init(FilterConfig filterConfig) throws ServletException {
									// Initialization code
								}
								@Override
								public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
										throws IOException, ServletException {
									// Pre-processing code
									System.out.println("Before processing request");
									// Continue to next filter or servlet
									chain.doFilter(request, response);
									// Post-processing code
									System.out.println("After processing request");
								}
								@Override
								public void destroy() {
									// Cleanup code
								}
							}
							
						Đăng ký Filter trong cấu hình Spring:
						
							import org.springframework.boot.web.servlet.FilterRegistrationBean;
							import org.springframework.context.annotation.Bean;
							import org.springframework.context.annotation.Configuration;
							@Configuration
							public class FilterConfig {
								@Bean
								public FilterRegistrationBean<MyCustomFilter> loggingFilter() {
									FilterRegistrationBean<MyCustomFilter> registrationBean = new FilterRegistrationBean<>();
									registrationBean.setFilter(new MyCustomFilter());
									registrationBean.addUrlPatterns("/api/*"); // Apply filter to specific URL patterns
									return registrationBean;
								}
							}

			
			Phân quyền tập trung hay phân
			quyền bằng annotation--Security:
														
														Tập trung cấu hình phần quyền trong phương thức protected void configure(HttpSecurity http) throws Exception sử dụng antMatchers hay mvcMatchers cho từng đường dẫn:
															
															http.authorizeRequests()
																.antMatchers("/admin").hasAuthority("ADMIN")
																.antMatchers("/free").hasAnyAuthority("ADMIN", "USER", "AUTHOR", "EDITOR")
																.antMatchers("/author").hasAnyAuthority("AUTHOR")
																.antMatchers("/user").hasAnyAuthority("USER")
																.antMatchers("/editor").hasAnyAuthority("EDITOR")
														
														Dùng annotation để phân quyền tại từng phương thức hoặc controller:
																
																@GetMapping("/admin")
																@PreAuthorize("hasAuthority('ADMIN')")
																public String showAdmin() {
																	return "admin";
																}

																@PreAuthorize("hasAuthority('USER')")
																@GetMapping("/user")
																public String showUserPage() {
																	return "user";
																}
														Thật tuyệt là chúng ta có thể kết hợp cả 2 phương pháp này. Những logic cấu hình authentication và những yêu cầu bảo mật chung như cần yêu cầu đăng nhập với request đến
														đường dẫn /api tôi luôn để trong hàm protected void configure(HttpSecurity http) throws Exception. Tôi chỉ dùng annotation phân quyền khi quy định đó dành riêng cho phương
														thức đó mà không áp dụng được cho phương thức khác.
			Expression-Based Access Control--Security:
														
														hasRole(role): Kiểm tra xem người dùng hiện tại có vai trò cụ thể không.
														hasAnyRole(role1, role2, ...): Kiểm tra xem người dùng hiện tại có ít nhất một trong các vai trò cụ thể không.
														hasAuthority(authority): Kiểm tra xem người dùng hiện tại có quyền cụ thể không.
														hasAnyAuthority(authority1, authority2, ...): Kiểm tra xem người dùng hiện tại có ít nhất một trong các quyền cụ thể không.
														principal: Đại diện cho người dùng hiện tại.
														authentication: Đại diện cho thông tin xác thực hiện tại, bao gồm người dùng và quyền truy cập của họ.
														permitAll: Cho phép tất cả các yêu cầu được truy cập mà không cần xác thực.
														denyAll: Từ chối tất cả các yêu cầu.
														anonymous: Kiểm tra xem người dùng có phải là người dùng ẩn danh không.
														rememberMe: Kiểm tra xem người dùng có đang xác thực bằng cơ chế ghi nhớ không.
														isAuthenticated(): Kiểm tra xem người dùng đã được xác thực hay chưa.
														isFullyAuthenticated(): Kiểm tra xem người dùng đã được xác thực một cách đầy đủ hay không (không phải là xác thực bằng ghi nhớ).
														hasIpAddress(ipAddressExpression): Kiểm tra xem địa chỉ IP của yêu cầu có khớp với biểu thức IP đã chỉ định không.
														hasPermission(target, permission): Kiểm tra xem người dùng có quyền cụ thể đối với một mục tiêu cụ thể không.
														
			Phân quyền ở cấp độ Controller--Security:
														@RestController
														@RequestMapping("/v2/api")
														@PreAuthorize("isAuthenticated()")
														public class APIControllerV2 {
														 ...
														}
			Phần quyền ở cấp độ phương thức--Security:
				@PreAuthorize:
														Kiểm tra trước khi chạy phương thức
														
														Yêu cầu đăng nhập isAuthenticated()
														Giá trị biến đường dẫn {username} bằng với tên đăng nhập hiện thời #username == authentication.principal.username. Chú ý authentication.principal là một biến mặc định mà
														Spring Security cung cấp để lấy thông tin về người dùng đang đăng nhập
														
														@GetMapping("/user/{username}") // Yêu cầu đăng nhập isAuthenticated()
														@PreAuthorize("isAuthenticated() and #username == authentication.principal.username")
														public String getMyRoles(@PathVariable("username") String username) {
																SecurityContext securityContext = SecurityContextHolder.getContext();
																return securityContext.getAuthentication().getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));
														}
														@GetMapping("/admin")
														@PreAuthorize("hasAuthority('ADMIN')")
														public String showAdmin() {
															return "admin";
														}
														
				@PostAuthorize:
														Nếu như @PreAuthorize kiểm tra quyền trước khi method thực thi thì có những tình huống quyết định cho phép truy cập tiếp hay không chỉ sau khi phương thức được thực thi. Ví
														dụ GET /post/{id} sẽ trả về bài viết. Tôi muốn rằng chỉ tác giả của chính bài viết đó mới có thể được xem để sửa. Spring Boot đã có user.id đang đăng nhập, nhưng để biết
														tác giả của bài viết thì cần phải lấy bài viết đó từ CSDL ra đã. @PostAuthorize
														
														@PreAuthorize("isAuthenticated()") //Phải đảm bảo là user login để có principal.id
														@PostAuthorize("returnObject.user.id == authentication.principal.id")  //chỉ trả bài viết nếu user.id == id của login user
														@GetMapping("/post/{id}")
														public Post showEditPostForm(@PathVariable("id") long id) {
															Optional<Post> oPost = postRepo.findById(id);
															if (oPost.isPresent()) {
																return oPost.get();
															} else {
																throw new RuntimeException("Cannot find post with id " + id);
															}
														}
														
				@PostFilter:
														Để lọc dữ liệu trước khi trả về, có 2 cách: để lập trình viên tự viết code trong phương thức hoặc cấu hình bằng annotation @PostFilter.
														Trong ví dụ này, phương thức getPostsOfAnUser() sẽ trả về một danh sách tất cả bài viết. Tôi muốn lọc ra chỉ trả về những bài viết do chính user đang login
														authentication.principal viết mà thôi.
														
														@PreAuthorize("isAuthenticated()")
														@PostFilter("filterObject.user.id == authentication.principal.id")
														@GetMapping("/post")
														public List<Post> getPostsOfAnUser() {
															return postRepo.findAll();
														}
														
				@PreFilter:
														@Prefilter lại cho phép lọc dữ liệu truyền vào phương thức trước khi thực thi.
			pom.xml--Security:										
																<dependency>
																	<groupId>org.springframework.boot</groupId>
																	<artifactId>spring-boot-starter-security</artifactId>
																</dependency>
														
																		spring.security.user.name=scott
																		spring.security.user.password=test123
			Custom Tables--Security:											
																		
																		@Bean
																		public UserDetailsManager userDetailsManager(DataSource dataSource) {
																			JdbcUserDetailsManager theUserDetailsManager = new JdbcUserDetailsManager(dataSource);																						 
																			theUserDetailsManager.setUsersByUsernameQuery("select user_id, pw, active from members where user_id=?");
																			theUserDetailsManager.setAuthoritiesByUsernameQuery("select user_id, role from roles where user_id=?");																						 
																			return theUserDetailsManager;
																		}
																		
			Basic Configuration--Security:	
																		
																		@Configuration
																		public class DemoSecurityConfig {
																			@Bean
																			public InMemoryUserDetailsManager userDetailsManager() {
																				UserDetails john = User.builder()
																									   .username("john")
																									   .password("{noop}test123")
																									   .roles("EMPLOYEE")
																									   .build();
																				UserDetails mary = User.builder()
																									   .username("mary")
																									   .password("{noop}test123")
																									   .roles("EMPLOYEE", "MANAGER")
																									   .build();
																			UserDetails susan = User.builder()
																					...
																				return new InMemoryUserDetailsManager(john, mary, susan);
																			}
																		}
																		
			Restrict URLs based on Roles--Security:
																		@Bean
																		public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
																			 http.authorizeHttpRequests(configurer ->
																					 configurer
																						 .requestMatchers(HttpMethod.GET, "/api/employees").hasRole("EMPLOYEE")
																						 .requestMatchers(HttpMethod.GET, "/api/employees/**").hasRole("EMPLOYEE")
																						 .requestMatchers(HttpMethod.POST, "/api/employees").hasRole("MANAGER")
																						 .requestMatchers(HttpMethod.PUT, "/api/employees").hasRole("MANAGER")
																						 .requestMatchers(HttpMethod.DELETE, "/api/employees/**").hasRole("ADMIN"));																 
																			http.httpBasic(); // use HTTP Basic authentication																 
																			http.csrf().disable(); // disable Cross Site Request Forgery (CSRF)
																			return http.build();
																		}
			JDBC Authentication - Plain Text--Security:			
																		
																		<dependency>
																			<groupId>com.mysql</groupId>
																			<artifactId>mysql-connector-j</artifactId>
																			<scope>runtime</scope>
																		</dependency>
																		
																		spring.datasource.url=jdbc:mysql://localhost:3306/employee_directory
																		spring.datasource.username=springstudent
																		spring.datasource.password=springstudent
			
																		@Configuration
																		public class DemoSecurityConfig {
																			 @Bean
																			 public UserDetailsManager userDetailsManager(DataSource dataSource) {
																				 return new JdbcUserDetailsManager(dataSource);
																			 }
																			 …
																		}
																		
			UsernamePasswordAuthenticationToken--Security:
			
									- UsernamePasswordAuthenticationToken là một loại đối tượng được sử dụng để đại diện cho thông tin xác thực của người dùng dựa trên tên người dùng và mật
									khẩu. Đối tượng này được sử dụng khi người dùng cung cấp thông tin đăng nhập, chẳng hạn khi họ nhập tên người dùng và mật khẩu vào một form đăng nhập.
									- UsernamePasswordAuthenticationToken kế thừa từ lớp AbstractAuthenticationToken, và nó chứa thông tin về tên người dùng và mật khẩu mà người dùng cung cấp
									khi đăng nhập. Thông thường, sau khi người dùng cung cấp thông tin đăng nhập, UsernamePasswordAuthenticationToken sẽ được tạo ra và chuyển đến
									AuthenticationManager để xác thực.
									- Sau khi xác thực thành công, UsernamePasswordAuthenticationToken có thể được chuyển đến SecurityContextHolder để lưu trữ thông tin về người dùng đã đăng
									nhập, giúp Spring Security tiếp tục quản lý phiên làm việc và kiểm soát truy cập của người dùng trong ứng dụng.
									- Các dạng constructor của UsernamePasswordAuthenticationToken:
									
										Constructor cơ bản (dùng cho xác thực chưa hoàn tất): Constructor này được sử dụng khi tạo một token cho quá trình xác thực (ví dụ: trước khi người dùng đăng nhập).
											
											public UsernamePasswordAuthenticationToken(Object principal, Object credentials)
											
												principal: Thông thường là tên đăng nhập hoặc đối tượng người dùng (có thể là String, UserDetails, v.v.).
												credentials: Mật khẩu hoặc thông tin xác thực khác (có thể là String).
												
											UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken("username", "password");
											
										Constructor có thêm quyền (dùng sau khi xác thực hoàn tất): Constructor này được sử dụng khi xác thực đã hoàn tất và bạn muốn cung cấp thông tin xác thực
										cùng với các quyền của người dùng.
										
											public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)
											
												principal: Đối tượng đại diện cho người dùng (có thể là String, UserDetails, v.v.).
												credentials: Mật khẩu hoặc thông tin xác thực.
												authorities: Danh sách các quyền của người dùng (danh sách các đối tượng triển khai GrantedAuthority).
												
											Collection<GrantedAuthority> authorities = Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));
											UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
											
										Constructor cho đối tượng được xác thực và không cần mật khẩu (credentials null): Khi dùng constructor này và giá trị credentials là null, nó thường biểu thị rằng quá
										trình xác thực đã hoàn tất, và mật khẩu không còn cần thiết (ví dụ: khi khôi phục người dùng từ token JWT).
										
											public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection<? extends GrantedAuthority> authorities)

											UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
											
									- UsernamePasswordAuthenticationToken có các constructor cho hai trường hợp chính:
									
										Trước khi xác thực: Chỉ có tên đăng nhập (principal) và mật khẩu (credentials).
										Sau khi xác thực: Có thêm quyền (authorities), và thường không cần mật khẩu nữa (credentials null).
										
									- setDetails() là một phương thức của lớp AbstractAuthenticationToken, mà UsernamePasswordAuthenticationToken kế thừa. Phương thức này được sử dụng để thiết lập các chi
									tiết bổ sung về yêu cầu xác thực (authentication details) trong đối tượng xác thực (authentication object).
									
										public void setDetails(Object details)
										
											details: Đây là một đối tượng có thể chứa thông tin chi tiết liên quan đến yêu cầu hiện tại. Đối tượng này thường là một thể hiện của WebAuthenticationDetails,
											chứa các thông tin như địa chỉ IP của người dùng và chi tiết về phiên làm việc (session).
											
										Ví dụ:
										
											authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));										
											new WebAuthenticationDetailsSource().buildDetails(request): Tạo ra một đối tượng WebAuthenticationDetails, chứa các thông tin chi tiết từ yêu cầu HTTP như
											địa chỉ IP, thông tin phiên (session), v.v.
										
									import org.springframework.security.authentication.AuthenticationManager;
									import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
									import org.springframework.security.core.Authentication;
									import org.springframework.security.core.context.SecurityContextHolder;
									import org.springframework.security.core.userdetails.UserDetails;
									import org.springframework.stereotype.Controller;
									import org.springframework.web.bind.annotation.PostMapping;
									import org.springframework.web.bind.annotation.RequestBody;
									import org.springframework.web.bind.annotation.ResponseBody;
									@Controller
									public class LoginController {
										// authenticationManager được tiêm vào controller thông qua dependency injection. Đây là một bean được Spring Security cung cấp mặc định.
										private final AuthenticationManager authenticationManager;
										public LoginController(AuthenticationManager authenticationManager) {
											this.authenticationManager = authenticationManager;
										}
										@PostMapping("/login")
										@ResponseBody
										public String login(@RequestBody LoginRequest loginRequest) {
											// Tạo một đối tượng UsernamePasswordAuthenticationToken từ dữ liệu đăng nhập
											UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
													loginRequest.getUsername(), loginRequest.getPassword());																			
											Authentication authentication = authenticationManager.authenticate(authenticationToken); // Xác thực thông tin đăng nhập																		
											SecurityContextHolder.getContext().setAuthentication(authentication); // Lưu thông tin về người dùng đã đăng nhập vào SecurityContextHolder
											return "Đăng nhập thành công!";
										}
									}
									 
									protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
										String jwt = parseJwt(request);
										if(serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwt).isEmpty()){//check token in blacklist
										  if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
											String id = jwtUtils.getUserIdFromJwtToken(jwt);
											UserDetails userDetails = employeeDetailsService.loadUserById(id);
											UsernamePasswordAuthenticationToken authentication =
													new UsernamePasswordAuthenticationToken(
															userDetails,
															null,
															userDetails.getAuthorities());
											authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); // setDetails: Gắn các chi tiết của yêu cầu HTTP (chẳng hạn như địa chỉ IP hoặc thông tin
																																   // bổ sung) vào đối tượng xác thực.
											SecurityContextHolder.getContext().setAuthentication(authentication);
										  }
										}
										filterChain.doFilter(request, response);
									}
									private String parseJwt(HttpServletRequest request) {
										String headerAuth = request.getHeader("Authorization");
										if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
										  return headerAuth.substring(7);
										}
										return null;
									}									
			
		Login--Security:
									@PostMapping("/signin")
									public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
										Authentication authentication = authenticationManager.authenticate(
																								new UsernamePasswordAuthenticationToken(loginRequest.getId(), loginRequest.getPassword()));
										SecurityContextHolder.getContext().setAuthentication(authentication);
										String jwt = jwtUtils.generateJwtToken(authentication);
										EmployeeDetailsImpl userDetails = (EmployeeDetailsImpl) authentication.getPrincipal();
										LoginUserInfo userInfo = LoginUserInfo.builder()
																			  .id(userDetails.getId())
																			  .username(userDetails.getUsername())
																			  .email(userDetails.getEmail())
																			  .listRole(userDetails.getRole())
																			  .avatar(userDetails.getAvatar())
																			  .build();
										return ResponseEntity.ok(new JwtResponse(jwt, userInfo, userDetails.getPermissionMap()));
									}
									
									public String generateJwtToken(Authentication authentication) {
										EmployeeDetailsImpl userPrincipal = (EmployeeDetailsImpl) authentication.getPrincipal();
										return Jwts.builder()
												   .setSubject((userPrincipal.getId()))
												   .setIssuedAt(new Date())
												   .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
												   .signWith(key(), SignatureAlgorithm.HS256)
												   .compact();
									}
									
		Logout--Security:
		
									@PostMapping("/logout")
									public ResponseEntity<?> logout(HttpServletRequest request) {
										String jwtToken = parseJwt(request);
										System.out.println("jwt token: " + jwtToken);
										if (jwtToken == null || jwtToken.isEmpty()) {
											return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Not logged in yet!");
										} else {
											if (serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwtToken).isEmpty()) {
												//Save logout access token to blacklist
												LogoutAccessToken token = LogoutAccessToken.builder()
														.token(jwtToken)
														.status(1) //blacklist token
														.build();
												serviceLifecycle.requestLogoutAccessTokenService().register(token);
											}
											return ResponseEntity.ok().body("Logout successfully!");
										}
									}
									
									private String parseJwt(HttpServletRequest request) {
										String headerAuth = request.getHeader("Authorization");
										if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
											return headerAuth.substring(7);
										}
										return null;
									}
																		
		Forgot Password--Security:
																		
									@PostMapping("/forgot-password")
									public ResponseEntity<?> ForgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
										M00Employee employee = serviceLifecycle.requestM00EmployeeService().getEmployeeByEmail(forgotPasswordRequest.getEmail());
										if(employee == null){
											ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
											forgotPasswordResponse.setError(true);
											forgotPasswordResponse.setMessage("Email is not exists on system. Please check again!");
											return ResponseEntity.ok(forgotPasswordResponse);
										}else{
											UUID uuid = UUID. randomUUID();
											Pme00PasswordToken pme00PasswordToken = getPme00PasswordToken(employee, uuid);
											String resetHtmlTemplate = LoadTemplate();
											Utils.MAIL_SMTP_SERVER = mailConfig.getSmtpHostServer();
											Utils.MAIL_SMTP_SERVER_PORT = mailConfig.getSmtpHostServerPort();
											Utils.MAIL_SMTP_EMAIL_ID = mailConfig.getEmailId();
											Utils.MAIL_SMTP_EMAIL_ID_ALIAS = mailConfig.getEmailName();
											Utils.MAIL_SMTP_EMAIL_USERNAME = mailConfig.getUserName();
											Utils.MAIL_SMTP_EMAIL_PASSWORD = mailConfig.getPassword();
											Utils.MAIL_FRONT_END_URL = mailConfig.getFrontEndUrl();
											Map<String, String> map = new HashMap<String, String>();
											map.put("url", mailConfig.getFrontEndUrl());
											map.put("token",uuid.toString());
											for (Map.Entry<String, String> entry : map.entrySet()) {
												resetHtmlTemplate = resetHtmlTemplate.replace("${" + entry.getKey() + "}", entry.getValue());
											}
											if(serviceLifecycle.requestLevel2Service().sendMail(employee.getMail(),mailConfig.getSubject(),resetHtmlTemplate)){
												serviceLifecycle.requestPasswordService().register(pme00PasswordToken);
												ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
												forgotPasswordResponse.setError(false);
												forgotPasswordResponse.setMessage("Please check email to process next step");
												return ResponseEntity.ok(forgotPasswordResponse);
											}else {
												ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
												forgotPasswordResponse.setError(true);
												forgotPasswordResponse.setMessage("Have Error when send email. Please contact with administrator");
												return ResponseEntity.ok(forgotPasswordResponse);
											}
										}
									}																	
									public class ForgotPasswordResponse extends  MessageResponse {
									  private boolean error;
									}																	
									public class MessageResponse {
									  private String message;
									}
									
									@NotNull
									private static Pme00PasswordToken getPme00PasswordToken(M00Employee employee, UUID uuid) {
										Pme00PasswordToken pme00PasswordToken=new Pme00PasswordToken();
										pme00PasswordToken.setEmpId(employee.getEmpId());
										pme00PasswordToken.setToken(uuid.toString());
										pme00PasswordToken.setCreateAt(new Date());
										pme00PasswordToken.setCreateBy("0");
										pme00PasswordToken.setUpdateAt(new Date());
										pme00PasswordToken.setUpdateBy("0");
										long currentTimeInMillis = System.currentTimeMillis();
										Calendar calendar = Calendar.getInstance();
										calendar.setTimeInMillis(currentTimeInMillis);
										calendar.add(Calendar.HOUR, Utils.MAX_EXPIRE_TOKEN);
										pme00PasswordToken.setExpire(calendar.getTimeInMillis());
										return pme00PasswordToken;
									}
									
									private String LoadTemplate() {
										try {
											return new String(Files.readAllBytes(ResourceUtils.getFile("classpath:password-reset.html").toPath()));
										} catch (IOException e) {
											e.printStackTrace();
										}
										return "";
									}
																		
		Reset Password--Security:
																		
									@CrossOrigin
									@GetMapping("/reset-password/{token}")
									public ResponseEntity<?> ResetPasswordGetToken(@PathVariable("token") String token) {
										//String s = LoadTemplate();

										ResetPasswordResponse resetPasswordResponse = new ResetPasswordResponse();
										Pme00PasswordToken pme00PasswordToken = serviceLifecycle.requestPasswordService().FindPasswordTokenByToken(token);
										if(pme00PasswordToken==null){
											resetPasswordResponse.setError(true);
											resetPasswordResponse.setMessage("Token is not exists on system. Please check again!");
											return ResponseEntity.ok(resetPasswordResponse);
										}else {
											if(pme00PasswordToken.IsExpired()){
												resetPasswordResponse.setError(true);
												resetPasswordResponse.setMessage("Token is expired!");
											}else{
												resetPasswordResponse.setError(false);
												resetPasswordResponse.setMessage("");
												resetPasswordResponse.setEmpId(pme00PasswordToken.getEmpId());
											}
											return ResponseEntity.ok(resetPasswordResponse);
										}
									}
									@PostMapping("/reset-password/{token}")
									public ResponseEntity<?> ResetPassword(@Valid @PathVariable("token") String token,
																		   @Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
										ResetPasswordResponse resetPasswordResponse = new ResetPasswordResponse();
										Pme00PasswordToken pme00PasswordToken = serviceLifecycle.requestPasswordService().FindPasswordTokenByToken(token);

										M00Employee m00Employee = serviceLifecycle.requestM00EmployeeService().find(pme00PasswordToken.getEmpId());
										if (m00Employee == null) {
											resetPasswordResponse.setError(true);
											resetPasswordResponse.setMessage("Token is not exists on system. Please check again!");
											return ResponseEntity.ok(resetPasswordResponse);
										} else {
											if (pme00PasswordToken.IsExpired()) {
												resetPasswordResponse.setError(true);
												resetPasswordResponse.setMessage("Token is expired!");
											} else {
												if(!resetPasswordRequest.getPassword().equals(resetPasswordRequest.getConfirmPassword())){
													resetPasswordResponse.setError(true);
													resetPasswordResponse.setMessage("Password is not match!");
												}else {
													String passwordToMd5Hex = DigestUtils
															.md5Hex(resetPasswordRequest.getPassword());
													m00Employee.setPassword(passwordToMd5Hex);
													M00Employee updateM00Employee = serviceLifecycle.requestM00EmployeeService().modify(m00Employee);

													resetPasswordResponse.setError(false);
													resetPasswordResponse.setMessage("Password is changed! You can login again, now!");
												}
											}
											return ResponseEntity.ok(resetPasswordResponse);
										}

									}
									
									public class ResetPasswordResponse extends  MessageResponse {
									  private int passwordTokenId;
									  private boolean error;
									  private String EmpId;
									}
									
		Another--Security:
									package com.poscodx.odc.ampro015.config.jwt;
									import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
									import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
									import org.springframework.security.core.context.SecurityContextHolder;
									import org.springframework.security.core.userdetails.UserDetails;
									import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
									import org.springframework.stereotype.Component;
									import org.springframework.util.StringUtils;
									import org.springframework.web.filter.OncePerRequestFilter;
									import javax.servlet.FilterChain;
									import javax.servlet.ServletException;
									import javax.servlet.http.HttpServletRequest;
									import javax.servlet.http.HttpServletResponse;
									import java.io.IOException;
									@Component
									public class AuthTokenFilter extends OncePerRequestFilter {
									  @Autowired
									  private JwtUtils jwtUtils;
									  @Autowired
									  private ServiceLifecycle serviceLifecycle;
									  @Autowired
									  private EmployeeDetailsServiceImpl employeeDetailsService;
									  @Override
									  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
										String jwt = parseJwt(request);
										if(serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwt).isEmpty()){//check token in blacklist
										  if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
											String id = jwtUtils.getUserIdFromJwtToken(jwt);
											UserDetails userDetails = employeeDetailsService.loadUserById(id);
											UsernamePasswordAuthenticationToken authentication =
													new UsernamePasswordAuthenticationToken(
															userDetails,
															null,
															userDetails.getAuthorities());
											authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
											SecurityContextHolder.getContext().setAuthentication(authentication);
										  }
										}
										filterChain.doFilter(request, response);
									  }
									  private String parseJwt(HttpServletRequest request) {
										String headerAuth = request.getHeader("Authorization");
										if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
										  return headerAuth.substring(7);
										}
										return null;
									  }
									}
									
									package com.poscodx.odc.ampro015.config.jwt;
									import com.poscodx.odc.ampro015.config.services.EmployeeDetailsImpl;
									import io.jsonwebtoken.*;
									import io.jsonwebtoken.io.Decoders;
									import io.jsonwebtoken.security.Keys;
									import org.springframework.beans.factory.annotation.Value;
									import org.springframework.security.core.Authentication;
									import org.springframework.stereotype.Component;
									import java.security.Key;
									import java.util.Date;
									@Component
									public class JwtUtils {
									  @Value("${bezkoder.app.jwtSecret}")
									  private String jwtSecret;
									  @Value("${bezkoder.app.jwtExpirationMs}")
									  private int jwtExpirationMs;
									  public String generateJwtToken(Authentication authentication) {
										EmployeeDetailsImpl userPrincipal = (EmployeeDetailsImpl) authentication.getPrincipal();
										return Jwts.builder()
											.setSubject((userPrincipal.getId()))
											.setIssuedAt(new Date())
											.setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
											.signWith(key(), SignatureAlgorithm.HS256)
											.compact();
									  }																	 
									  private Key key() {
										return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
									  }
									  public String getUserNameFromJwtToken(String token) {
										return Jwts.parserBuilder().setSigningKey(key()).build()
												   .parseClaimsJws(token).getBody().getSubject();
									  }
									  public String getUserIdFromJwtToken(String token) {
										return Jwts.parserBuilder().setSigningKey(key()).build()
												.parseClaimsJws(token).getBody().getSubject();
									  }
									  public boolean validateJwtToken(String authToken) {
										try {
										  Jwts.parserBuilder().setSigningKey(key()).build().parse(authToken);
										  return true;
										} catch (MalformedJwtException e) {
										  System.out.println("Invalid JWT token: {}" + e.getMessage());
										} catch (ExpiredJwtException e) {
										  System.out.println("JWT token is expired: {}" + e.getMessage());
										} catch (UnsupportedJwtException e) {
										  System.out.println("JWT token is unsupported: {}" + e.getMessage());
										} catch (IllegalArgumentException e) {
										  System.out.println("JWT claims string is empty: {}" +  e.getMessage());
										}
										return false;
									  }
									}
									
									package com.poscodx.odc.ampro015.config.provider;
									import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
									import lombok.RequiredArgsConstructor;
									import org.springframework.security.authentication.AuthenticationProvider;
									import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
									import org.springframework.security.core.Authentication;
									import org.springframework.security.core.AuthenticationException;
									import org.springframework.security.core.userdetails.UserDetails;
									import org.springframework.security.core.userdetails.UsernameNotFoundException;
									import org.springframework.security.crypto.password.PasswordEncoder;
									import org.springframework.stereotype.Component;
									@Component
									@RequiredArgsConstructor
									public class CustomAuthenticationProvider implements AuthenticationProvider {
										private final EmployeeDetailsServiceImpl employeeDetailsService;
										private final PasswordEncoder encoder;
										@Override
										public Authentication authenticate(Authentication authentication)
												throws AuthenticationException {
											String id = authentication.getPrincipal().toString();
											String password = authentication.getCredentials().toString();
											UserDetails currentUser = employeeDetailsService.loadUserById(id);
											if (currentUser == null) {
												throw new UsernameNotFoundException("User not found");
											}
											// Example: validating credentials
											if (!encoder.matches(password, currentUser.getPassword())) {
												throw new UsernameNotFoundException("Invalid credentials");
											}
											// Create a fully authenticated Authentication object
											return new UsernamePasswordAuthenticationToken(currentUser, password, currentUser.getAuthorities());
										}
										@Override
										public boolean supports(Class<?> authentication) {
											return authentication.equals(UsernamePasswordAuthenticationToken.class);
										}
									}
									
									package com.poscodx.odc.ampro015.config.services;
									import com.fasterxml.jackson.annotation.JsonIgnore;
									import com.poscdx.odc.ampro015.domain.entity.M00Employee;
									import lombok.Data;
									import org.springframework.security.core.GrantedAuthority;
									import org.springframework.security.core.authority.SimpleGrantedAuthority;
									import org.springframework.security.core.userdetails.UserDetails;
									import java.util.*;
									@Data
									public class EmployeeDetailsImpl implements UserDetails {
										private static final long serialVersionUID = 1L;
										private String id;
										private String username;
										private String avatar;
										private String email;
										private List<String> role;
										private Map <String, List<String>> permissionMap;
									  @JsonIgnore
									  private String password;
									  private Collection<? extends GrantedAuthority> authorities;
										public EmployeeDetailsImpl(String id, String username, String email, String avatar, String password, List<String> role,
																   Collection<? extends GrantedAuthority> authorities, Map <String, List<String>> permissionMap) {
											this.id = id;
											this.username = username;
											this.email = email;
											this.avatar = avatar;
											this.password = password;
											this.role = role;
											this.authorities = authorities;
											this.permissionMap = permissionMap;
										}
										public static EmployeeDetailsImpl build(M00Employee user, List<String> listRoles, List<Map<String, String>> listPermission) {
											Set<SimpleGrantedAuthority> authorities = new HashSet<>();
											Map <String, List<String>> permissionMap = new HashMap<>();
											List<String> permissionList;
											for (Map<String, String> map : listPermission) {
												Set<String> set = map.keySet();
												for (String key : set) {
													authorities.add(new SimpleGrantedAuthority(map.get(key)));
													permissionList = permissionMap.get(key) == null ? new ArrayList<>() : permissionMap.get(key);
													if (!permissionList.contains(map.get(key))) permissionList.add(map.get(key));
													permissionMap.put(key, permissionList);
												}
											}
											return new EmployeeDetailsImpl(
													user.getEmpId(),
													user.getName(),
													user.getMail(),
													user.getAvatar(),
													user.getPassword(),
													listRoles,
													authorities,
													permissionMap);
										}
										@Override
										public Collection<? extends GrantedAuthority> getAuthorities() {
											return authorities;
										}
										@Override
										public String getPassword() {
											return password;
										}
										@Override
										public String getUsername() {
											return username;
										}
										@Override
										public boolean isAccountNonExpired() {
											return true;
										}
										@Override
										public boolean isAccountNonLocked() {
											return true;
										}
										@Override
										public boolean isCredentialsNonExpired() {
											return true;
										}
										@Override
										public boolean isEnabled() {
											return true;
										}
										@Override
										public boolean equals(Object o) {
											if (this == o)
												return true;
											if (o == null || getClass() != o.getClass())
												return false;
											EmployeeDetailsImpl user = (EmployeeDetailsImpl) o;
											return Objects.equals(id, user.id);
										}
									}
									
									package com.poscodx.odc.ampro015.config.services;
									import com.netflix.discovery.converters.Auto;
									import com.poscdx.odc.ampro015.domain.entity.M00Employee;
									import com.poscdx.odc.ampro015.domain.entity.Pme00RoleUser;
									import com.poscdx.odc.ampro015.domain.entity.Pme00Setting;
									import com.poscdx.odc.ampro015.domain.entity.SettingMedia;
									import com.poscdx.odc.ampro015.domain.spec.Pme00SettingService;
									import com.poscdx.odc.ampro015.domain.utils.Utils;
									import com.poscodx.odc.ampro015.store.Pme00RoleUserJpaStore;
									import com.poscodx.odc.ampro015.store.jpo.M00EmployeeJpo;
									import com.poscodx.odc.ampro015.store.jpo.Pme00PerRoleJpo;
									import com.poscodx.odc.ampro015.store.jpo.Pme00PermissionJpo;
									import com.poscodx.odc.ampro015.store.jpo.Pme00SettingJpo;
									import com.poscodx.odc.ampro015.store.repository.*;
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.security.core.userdetails.UserDetails;
									import org.springframework.security.core.userdetails.UserDetailsService;
									import org.springframework.security.core.userdetails.UsernameNotFoundException;
									import org.springframework.stereotype.Service;
									import org.springframework.transaction.annotation.Transactional;
									import java.util.*;
									import java.util.stream.Collectors;
									@Service
									public class EmployeeDetailsServiceImpl implements UserDetailsService {
										@Autowired
										M00EmployeeRepository employeeRepository;
										@Autowired
										Pme00RoleRepository roleRepository;
										@Autowired
										Pme00PerRoleRepository perRoleRepository;
										@Autowired
										Pme00PermissionRepository permissionRepository;
										@Autowired
										Pme00RoleUserJpaStore pme00RoleUserJpaStore;
										@Autowired
										Pme00SettingService pme00SettingService;
										@Override
										@Transactional
										public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
											M00EmployeeJpo user = employeeRepository.findByName(username)
													.orElseThrow(() -> new UsernameNotFoundException("User Not Found with UserName: " + username));
											M00Employee employee = user.toDomain();
											SettingMedia settingMedia = pme00SettingService.getMediaSetting();
											if (settingMedia != null) {
												employee.setAvatar(Utils.setFilePath(settingMedia, employee.getAvatar(), Utils.UPLOAD_SERVICE_EMPLOYEE));
											}
											//List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findRoleUserByEmpId(user.getEmpId());
											List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findByEmployeeId(user.getEmpId());
											List<String> listRoles = new ArrayList<>();
											for (Pme00RoleUser roleUser : roles) {
												roleRepository.findById(roleUser.getRoleId()).ifPresent(pme00RoleJpo -> listRoles.add(pme00RoleJpo.getName()));
											}
											String roleName = "ROLE_STAFF";
											if (!roles.isEmpty()) {
												// roleName = role.get().getName().name();
												//roleName = role.get().getName();
											}
											return EmployeeDetailsImpl.build(employee, null, null);
										}
										@Transactional
										public UserDetails loadUserById(String id) throws RuntimeException {
											M00EmployeeJpo user = employeeRepository.findById(id)
													.orElseThrow(() -> new UsernameNotFoundException("User Not Found with Id: " + id));
											M00Employee employee = user.toDomain();
											SettingMedia settingMedia = pme00SettingService.getMediaSetting();
											if (settingMedia != null) {
												employee.setAvatar(Utils.setFilePath(settingMedia, employee.getAvatar(), Utils.UPLOAD_SERVICE_EMPLOYEE));
											}
											//List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findRoleUserByEmpId(user.getEmpId());
											List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findByEmployeeId(user.getEmpId());
											List<String> listRoles = new ArrayList<>();
											for (Pme00RoleUser roleUser : roles) {
												roleRepository.findById(roleUser.getRoleId()).ifPresent(pme00RoleJpo -> listRoles.add(pme00RoleJpo.getName()));
											}
											// Optional<Pme00RoleJpo> role = roleRepository.findByName(user.getRole());
											if (!roles.isEmpty()) {
												List<Map<String, String>> listPermission = new ArrayList<>();
												for (Pme00RoleUser roleUser : roles) {
													List<Integer> perIds = perRoleRepository.findByRoleId(roleUser.getRoleId()).stream()
															.map(Pme00PerRoleJpo::getPermissionId).collect(Collectors.toList());
													perIds.forEach(permissionId -> {
														Optional<Pme00PermissionJpo> permission = permissionRepository.findById(permissionId);
														if (permission.isPresent()) {
															//perName.add(permission.get().getName());
															Map<String, String> per = new HashMap<>();
															per.put(permission.get().getGroup(), permission.get().getName());
															listPermission.add(per);
														}
													});
												}
												return EmployeeDetailsImpl.build(employee, listRoles, listPermission);
											}
											return new EmployeeDetailsImpl(user.getEmpId(), user.getName(), user.getMail(), user.getAvatar(), user.getPassword(), listRoles, null, null);
										}
									}
									
									package com.poscodx.odc.ampro015.config;
									import com.poscodx.odc.ampro015.config.exceptionhandler.AuthEntryPoint;
									import com.poscodx.odc.ampro015.config.jwt.AuthTokenFilter;
									import com.poscodx.odc.ampro015.config.provider.CustomAuthenticationProvider;
									import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
									import java.security.MessageDigest;
									import java.security.NoSuchAlgorithmException;
									import org.apache.commons.codec.digest.Md5Crypt;
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.context.annotation.Bean;
									import org.springframework.context.annotation.Configuration;
									import org.springframework.http.HttpMethod;
									import org.springframework.security.authentication.AuthenticationManager;
									import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
									import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
									import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
									import org.springframework.security.config.annotation.web.builders.HttpSecurity;
									import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
									import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
									import org.springframework.security.config.http.SessionCreationPolicy;
									import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
									import org.springframework.security.crypto.password.PasswordEncoder;
									import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
									import org.springframework.context.annotation.Bean;
									import org.springframework.context.annotation.Configuration;
									import org.springframework.security.crypto.password.PasswordEncoder;
									import java.security.MessageDigest;
									import java.security.NoSuchAlgorithmException;
									import java.math.BigInteger;
									@Configuration
									@EnableWebSecurity
									@EnableGlobalMethodSecurity(prePostEnabled = true)
									public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
										@Autowired
										private AuthTokenFilter authTokenFilter;
										@Autowired
										private EmployeeDetailsServiceImpl employeeDetailsService;
										@Autowired
										private AuthEntryPoint unauthorizedHandler;
										@Autowired
										private CustomAuthenticationProvider authenticationProvider;
										// Details omitted for brevity
										@Bean
										public PasswordEncoder passwordEncoder() {
											return new PasswordEncoder() {
												@Override
												public String encode(CharSequence rawPassword) {
													try {
														MessageDigest md = MessageDigest.getInstance("MD5");
														byte[] messageDigest = md.digest(rawPassword.toString().getBytes());
														BigInteger number = new BigInteger(1, messageDigest);
														String hashtext = number.toString(16);
														while (hashtext.length() < 32) {
															hashtext = "0" + hashtext;
														}
														return hashtext;
													} catch (NoSuchAlgorithmException e) {
														throw new RuntimeException(e);
													}
												}
												@Override
												public boolean matches(CharSequence rawPassword, String encodedPassword) {
													return encode(rawPassword).equals(encodedPassword);
												}
											};
										}
										@Bean
										public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
											return authConfig.getAuthenticationManager();
										}
										@Override
										protected void configure(AuthenticationManagerBuilder auth)
												throws Exception {
											auth.authenticationProvider(authenticationProvider)
													.userDetailsService(employeeDetailsService)
													.passwordEncoder(passwordEncoder());
										}
										@Override
										protected void configure(HttpSecurity http) throws Exception {
											// Enable CORS and disable CSRF
											http = http.cors().and().csrf().disable();
											// Set session management to stateless
											http = http
													.sessionManagement()
													.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
													.and();
											// Set unauthorized requests exception handler
											http = http
													.exceptionHandling()
													.authenticationEntryPoint(
															unauthorizedHandler
													)
													.and();
											// Set permissions on endpoints
											http.authorizeRequests()
													// Our public endpoints
													.antMatchers(HttpMethod.POST, "/author/signup").permitAll()
													.antMatchers(HttpMethod.POST, "/author/signin").permitAll()
													.antMatchers(HttpMethod.POST, "/author/logout").permitAll()
													.anyRequest().permitAll();
											// Add JWT token filter
											http.addFilterBefore(
													authTokenFilter,
													UsernamePasswordAuthenticationFilter.class
											);
										}
									}
																		
									package com.poscodx.odc.ampro015.config.exceptionhandler;
									import com.fasterxml.jackson.databind.ObjectMapper;
									import org.springframework.http.MediaType;
									import org.springframework.security.core.AuthenticationException;
									import org.springframework.security.web.AuthenticationEntryPoint;
									import org.springframework.stereotype.Component;
									import javax.servlet.ServletException;
									import javax.servlet.http.HttpServletRequest;
									import javax.servlet.http.HttpServletResponse;
									import java.io.IOException;
									import java.util.LinkedHashMap;
									import java.util.Map;
									@Component
									public class AuthEntryPoint implements AuthenticationEntryPoint {
									//  private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);
									  @Override
									  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
										response.setContentType(MediaType.APPLICATION_JSON_VALUE);
										response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
										final Map<String, Object> body = new LinkedHashMap<>();;
										body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
										body.put("error", "Unauthorized");
										body.put("message", authException.getMessage());
										body.put("path", request.getServletPath());
										final ObjectMapper mapper = new ObjectMapper();
										mapper.writeValue(response.getOutputStream(), body);
									  }
									}
									
		Spring Security 5 – OAuth2 Login--Security:
																		
															- Spring Security 5 introduces a new OAuth2LoginConfigurer class that we can use for configuring an external Authorization Server.
															- Spring Security cung cấp tích hợp với OAuth, một giao thức ủy quyền phổ biến, cho phép ứng dụng của bạn xác thực và ủy quyền với dịch vụ của bên thứ ba.
															- OAuth là một giao thức ủy quyền mở được sử dụng để cho phép một ứng dụng (hoặc dịch vụ) yêu cầu quyền truy cập vào tài nguyên từ một người dùng mà không cần
															biết mật khẩu của người dùng. Thay vào đó, OAuth cung cấp một cách tiếp cận an toàn và phân quyền để cho phép người dùng chia sẻ tài nguyên của họ với các
															ứng dụng khác mà không cần tiết lộ mật khẩu của mình.
																		
		JWT (JSON Web Tokens)--Security:
																		Cơ chế xác thực dựa trên việc sử dụng token được mã hóa dưới dạng JSON, cho phép truyền thông tin xác thực giữa các bên một cách an toàn.
		HTTP Basic Authentication--Security:
																		Cách tiếp cận cơ bản nhất, trong đó thông tin đăng nhập được gửi dưới dạng mã thông báo cơ bản (base64-encoded) trong header của HTTP request.
		LDAP Authentication--Security:
																		Xác thực người dùng thông qua một máy chủ LDAP (Lightweight Directory Access Protocol), thường được sử dụng trong các môi trường doanh nghiệp.
		Custom Authentication Providers--Security:
																		Spring Security cho phép bạn triển khai các cơ chế xác thực tùy chỉnh, bằng cách triển khai các interface như UserDetailsService, AuthenticationProvider,...
		HTTP Form-based Authentication--Security:
																		Xác thực thông qua một form đăng nhập trên giao diện người dùng, trong đó thông tin đăng nhập được gửi dưới dạng POST request.
		HTTP Digest Authentication--Security:
																		Một phương thức xác thực tương tự HTTP Basic, nhưng thông tin đăng nhập được gửi dưới dạng mã thông báo tiêu chuẩn (digest) để tăng cường bảo mật.
		OpenID Connect--Security:
																		Một phương thức xác thực và ủy quyền dựa trên OAuth 2.0, thêm một số tính năng xác thực mở rộng và cải tiến.
		Spring Security cũng cung cấp một số tính năng và cách
		tiếp cận khác nhằm hỗ trợ bảo mật cho ứng dụng web Java,
		bao gồm--Security:														
					Method-Level Security:
																		Spring Security cho phép bạn áp dụng các quy định bảo mật tới các phương thức trong ứng dụng của mình. Bằng cách sử dụng các annotations như @PreAuthorize,
																		@PostAuthorize, và @Secured, bạn có thể xác định quyền truy cập cho từng phương thức cụ thể.
					CSRF Protection:
																		Cross-Site Request Forgery (CSRF) là một lỗ hổng bảo mật phổ biến trong các ứng dụng web. Spring Security cung cấp tính năng bảo vệ chống lại CSRF bằng cách
																		sử dụng token CSRF và kiểm tra token này trước khi xử lý bất kỳ yêu cầu POST nào.
					CORS (Cross-Origin Resource Sharing):
																		Spring Security cung cấp cơ chế để quản lý và cấu hình CORS trong ứng dụng web của bạn, cho phép hoặc từ chối yêu cầu từ các nguồn khác nhau.																		
					Session Management:
																		Spring Security hỗ trợ quản lý phiên (session) người dùng trong ứng dụng web của bạn. Bạn có thể cấu hình các chiến lược session management như thời gian
																		hết hạn phiên, cách thức lưu trữ phiên, và xử lý các trạng thái phiên không hợp lệ.
					Integration with External Systems:
																		Spring Security tích hợp tốt với các dịch vụ bảo mật và nhận dạng bên ngoài như OAuth 2.0, LDAP, OpenID Connect, và SAML.																		
					Remember-Me Authentication:
																		Tính năng này cho phép người dùng đăng nhập một lần và duy trì phiên đăng nhập cho một khoảng thời gian dài, thậm chí sau khi họ đóng trình duyệt và mở lại.
					Access Control Lists (ACLs):
																		ACLs cho phép bạn xác định các quyền truy cập cụ thể tới các đối tượng (ví dụ: tài liệu, bài viết, sản phẩm) trong ứng dụng của mình.
	Upload File--SPRING:
	
	MyBatis--SPRING:
	
		MyBatis Example--MyBatis Spring:
		
			Các bước thực hiện:
			
				Tạo project “mybatis-spring-example”:
				
					Add các dependency vào file pom.xml:
					
								<dependencies>
									<dependency>
										<groupId>mysql</groupId>
										<artifactId>mysql-connector-java</artifactId>
										<version>5.1.6</version>
									</dependency>
									<!-- MyBatis -->
									<dependency>
										<groupId>org.mybatis</groupId>
										<artifactId>mybatis</artifactId>
										<version>3.3.0</version>
									</dependency>
									<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
									<dependency>
										<groupId>org.mybatis</groupId>
										<artifactId>mybatis-spring</artifactId>
										<version>1.3.1</version>
									</dependency>
									<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
									<dependency>
										<groupId>org.springframework</groupId>
										<artifactId>spring-jdbc</artifactId>
										<version>4.3.6.RELEASE</version>
									</dependency>
									<!-- Spring core -->
									<dependency>
										<groupId>org.springframework</groupId>
										<artifactId>spring-core</artifactId>
										<version>4.3.6.RELEASE</version>
										<scope>provided</scope>
									</dependency>
									<!-- Spring context -->
									<dependency>
										<groupId>org.springframework</groupId>
										<artifactId>spring-context</artifactId>
										<version>4.3.6.RELEASE</version>
									</dependency>
								</dependencies>
				
				Tạo bảng details.student
				
								CREATE TABLE  details.student(
								   ID int(10) NOT NULL AUTO_INCREMENT,  
								   NAME varchar(100) NOT NULL,
								   BRANCH varchar(255) NOT NULL,
								   PERCENTAGE int(3) NOT NULL,  
								   PHONE int(10) NOT NULL,
								   EMAIL varchar(255) NOT NULL,
								   PRIMARY KEY ( ID )
								);
				
				Tạo lớp Student trong package vn.viettuts.mapper.entity
				package mybatis.mapper.entity;
				 
								public class Student {
									private int id;
									private String name;
									private String branch;
									private int percentage;
									private int phone;
									private String email;																	 
									public Student() {
									}																	 
									public Student(String name, String branch, int percentage, int phone, String email) {
										super();
										this.name = name;
										this.branch = branch;
										this.percentage = percentage;
										this.phone = phone;
										this.email = email;
									}																	 
								   // các setter và getter																		 
									@Override
									public String toString() {
										return getClass().getName() + "[" + "id = " + id + ", name = " + name + ", branch = " + branch 
												+ ", percentage = " + percentage  + ", phone = " + phone  + ", email = " + email + "]"; 
									}
								}
																	
				Tạo file cấu hình MyBatis SqlMapConfig.xml trong resources
					
					Trong file cấu hình này có sử dụng thẻ typeAliases tạo alias Student có type là lớp vn.viettuts.entity.Student. Bằng cách này trong các file cấu hình này hoặc trong các file mapper có thể sử dụng tên tắt
					Student thay vì vn.viettuts.entity.Student.
						
						<?xml version = "1.0" encoding = "UTF-8"?>
						<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">						 
						<configuration>						 
							<typeAliases>
								<typeAlias alias="Student" type="vn.viettuts.entity.Student" />
							</typeAliases>					 
							<mappers>
								<mapper resource="vn/viettuts/mapper/sql/Student.xml" />
							</mappers>						 
						</configuration>
						
						File cấu hình trỏ đển file mapper vn/viettuts/mapper/sql/Student.xml.
				
				Tạo file mapper Student.xml
				
					Đối với kết quả trả về của câu lệnh truy vấn select các bạn có thể dùng thuộc tính resultMap hoặc resultType như được khai báo dưới đây.
						
						<?xml version = "1.0" encoding = "UTF-8"?>
						<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">						 
						<mapper namespace="vn.viettuts.mapper.StudentMapper">
							<insert id="insertStudent" parameterType="Student" >
								INSERT INTO STUDENT (ID, NAME, BRANCH, PERCENTAGE, PHONE, EMAIL ) VALUES (#{id}, #{name}, #{branch}, #{percentage}, #{phone}, #{email});
							</insert>						 
							<update id="updateStudent" parameterType="Student">
								UPDATE STUDENT SET EMAIL = #{email}, NAME = #{name}, BRANCH = #{branch}, PERCENTAGE = #{percentage}, PHONE = #{phone} WHERE ID = #{id};
							</update>							 
							<delete id="deleteStudentById" parameterType="int">
								DELETE from STUDENT WHERE ID = #{id};
							</delete>							 
							<select id="selectAllStudent" resultMap="result">
								SELECT * FROM STUDENT;
							</select>						 
							<select id="selectStudentById" parameterType="int" resultType="Student">
								SELECT * FROM STUDENT WHERE ID = #{id};
							</select>							 
							<resultMap id = "result" type = "Student">
							   <result property = "id" column = "ID"/>
							   <result property = "name" column = "NAME"/>
							   <result property = "branch" column = "BRANCH"/>
							   <result property = "percentage" column = "PERCENTAGE"/>
							   <result property = "phone" column = "PHONE"/>
							   <result property = "email" column = "EMAIL"/>
							</resultMap>
						</mapper>
						
						Vì các tên cột của bảng details.student giống với các tên trường của lớp vn.viettuts.entity.Student (không phân biệt chữ hoa, chữ thường), nên trong câu lệnh select có id="selectStudentById" ta có thể
						khai báo kết quả trả về là resultType="Student". Trong trường hợp này là hoàn toàn hợp lệ.
						
					Giả sử có tên cột của bảng trong database nào đó khác tên trường của lớp java thì ta dùng resultMap để ánh xạ chúng với nhau.
					
					File mapper Student.xml có namespace="vn.viettuts.mapper.StudentMapper"
				
				Tạo interface StudentMapper.java
				
					Tạo interface StudentMapper.java và định nghĩa các method có tên giống với các id của câu lệnh trong file mapper Student.xml. Và tham số truyền vào và giá trị trả về của phương thức có kiểu dữ
					liệu tương ứng.
						
						package vn.viettuts.mapper;				 
						import java.util.List;						 
						import vn.viettuts.entity.Student;						 
						public interface StudentMapper {
							public int insertStudent(Student student);
							public int updateStudent(Student student);
							public int deleteStudentById(int studentId);
							public List<Student> selectAllStudent();
							public Student selectStudentById(int studentId);
						}
						
				Tạo file AppConfig.java
				
					package vn.viettuts.config;			 
					import java.io.IOException;
					import java.io.InputStream;
					import java.util.Properties;				 
					import org.mybatis.spring.SqlSessionFactoryBean;
					import org.mybatis.spring.SqlSessionTemplate;
					import org.mybatis.spring.mapper.MapperScannerConfigurer;
					import org.springframework.context.annotation.Bean;
					import org.springframework.context.annotation.ComponentScan;
					import org.springframework.context.annotation.Configuration;
					import org.springframework.core.io.ClassPathResource;
					import org.springframework.core.io.Resource;
					import org.springframework.jdbc.datasource.DriverManagerDataSource;				 
					import vn.viettuts.mapper.StudentMapper;				 
					@Configuration
					@ComponentScan(basePackages = { "vn.viettuts.service" })
					public class AppConfig {				 
						// Tạo bean dataSource
						@Bean
						public DriverManagerDataSource dataSource() throws IOException {
							DriverManagerDataSource dataSource = new DriverManagerDataSource();
							Properties properties = new Properties();
							InputStream user_props = this.getClass()
									.getResourceAsStream("/application.properties");
							properties.load(user_props);
							dataSource.setDriverClassName(
									properties.getProperty("spring.datasource.driver-class-name"));
							dataSource.setUrl(properties.getProperty("spring.datasource.url"));
							dataSource.setUsername(
									properties.getProperty("spring.datasource.username"));
							dataSource.setPassword(
									properties.getProperty("spring.datasource.password"));
							return dataSource;
						}
					 
						// đọc thông tin file cấu hình MyBatis
						@Bean
						public SqlSessionFactoryBean sqlSessionFactory() throws Exception {
							Resource resource = new ClassPathResource("SqlMapConfig.xml");
							SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean();
							sqlSessionFactory.setDataSource(dataSource());
							sqlSessionFactory.setConfigLocation(resource);
							return sqlSessionFactory;
						}
					 
						// scan tất cả những mapper package vn.viettuts.mapper
						@Bean
						public MapperScannerConfigurer mapperScannerConfigurer() {
							MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();
							mapperScannerConfigurer.setBasePackage("vn.viettuts.mapper");
							mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory");
							return mapperScannerConfigurer;
						}
					 
						// Có thể tạo @Bean cho mỗi interface mapper thay vì scan toàn bộ package vn.viettuts.mapper
						/*
						@Bean (name = "studentMapper")
						public StudentMapper studentMapper() throws Exception {
							SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory().getObject());
							return sessionTemplate.getMapper(StudentMapper.class);
						}
						*/
					}
					
				Tạo Student Service
				
					package vn.viettuts.service;				 
					import java.util.List;					 
					import vn.viettuts.entity.Student;					
					public interface StudentService {
						public int insertStudent(Student student);
						public int updateStudent(Student student);
						public int deleteStudentById(int studentId);
						public List<Student> selectAllStudent();
						public Student selectStudentById(int studentId);
					}
					
					package vn.viettuts.service;				 
					import java.util.List;					 
					import org.springframework.beans.factory.annotation.Autowired;
					import org.springframework.stereotype.Service;					 
					import vn.viettuts.entity.Student;
					import vn.viettuts.mapper.StudentMapper;					 
					@Service(value = "studentService")
					public class StudentServiceImpl implements StudentService {
						@Autowired
						StudentMapper studentMapper;					 
						public int insertStudent(Student student) {
							return studentMapper.insertStudent(student);
						}					 
						public int updateStudent(Student student) {
							return studentMapper.updateStudent(student);
						}					 
						public int deleteStudentById(int studentId) {
							return studentMapper.deleteStudentById(studentId);
						}					 
						public List<Student> selectAllStudent() {
							return studentMapper.selectAllStudent();
						}					 
						public Student selectStudentById(int studentId) {
							return studentMapper.selectStudentById(studentId);
						}
					}
					
				Tạo class test StudentTest.java
					
					package vn.viettuts.main;				 
					import java.util.List;					 
					import org.springframework.context.annotation.AnnotationConfigApplicationContext;
					import org.springframework.context.support.AbstractApplicationContext;					 
					import vn.viettuts.config.AppConfig;
					import vn.viettuts.entity.Student;
					import vn.viettuts.service.StudentService;				 
					public class StudentTest {
						public static void main(String[] args) {
							AbstractApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
							StudentService studentService = (StudentService) context.getBean("studentService");						 
							// create student
							Student student1 = new Student("Jim", "Java Dev", 95, 1234568, "jimdev@gmail.com");							 
							// insert student
							studentService.insertStudent(student1);
							System.out.println("insert : " + student1);							 
							// select all student
							List<Student> listStudents = studentService.selectAllStudent();
							System.out.println("select all : ");
							for (Student student : listStudents) {
								System.out.println(student);
							}							 
							// select student by id
							Student student2 = studentService.selectStudentById(1);									 
							// update student
							student2.setPercentage(99);
							studentService.updateStudent(student2);
							System.out.println("update : " + student2);							 
							// delete student by id
							studentService.deleteStudentById(student2.getId());
							System.out.println("delete : " + student2);
						}
					}
					
					Kết quả:
						select all : 
						vn.viettuts.entity.Student[id = 1, name = Jim, branch = Java Dev, percentage = 95, phone = 1234568, email = jimdev@gmail.com]
						insert : vn.viettuts.entity.Student[id = 1, name = Jim, branch = Java Dev, percentage = 95, phone = 1234568, email = jimdev@gmail.com]
						update : vn.viettuts.entity.Student[id = 1, name = Jim, branch = Java Dev, percentage = 99, phone = 1234568, email = jimdev@gmail.com]
						delete : vn.viettuts.entity.Student[id = 1, name = Jim, branch = Java Dev, percentage = 99, phone = 1234568, email = jimdev@gmail.com]				

	pom.xml--SPRING:
	
		<dependency>:
			
			- Thẻ này xác định một phụ thuộc mà dự án cần. Các thẻ con bên trong thẻ này cung cấp thông tin chi tiết về phụ thuộc đó.
			
		<groupId>:
		
			- Xác định nhóm của phụ thuộc. Thông thường, groupId theo cấu trúc của tên miền ngược, ví dụ: com.poscodx.odc. Nó giúp tổ chức và phân biệt giữa các dự án hoặc thư viện khác nhau.
			
		<artifactId>:

			- Xác định tên của phụ thuộc cụ thể trong nhóm. Trong trường hợp này, tên của phụ thuộc là ampro015-store. Mỗi dự án hoặc thư viện sẽ có một artifactId duy nhất trong nhóm của nó.
			
		<version>:
		
			- Xác định phiên bản của phụ thuộc mà dự án sẽ sử dụng. Trong trường hợp này, phiên bản là 1.0-SNAPSHOT.
			
			- SNAPSHOT là một phiên bản đặc biệt trong Maven, đại diện cho một phiên bản phát triển (chưa hoàn thiện hoặc đang trong quá trình phát triển). Mỗi lần bạn build dự án, Maven có thể tải về phiên bản
			mới nhất của SNAPSHOT từ kho lưu trữ.
		
		Ví dụ:	
	
			pom-boot.xml
			
				<?xml version="1.0" encoding="UTF-8"?>
				<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
					<modelVersion>4.0.0</modelVersion>
					<parent>
						<groupId>com.posco.base</groupId>
						<artifactId>posco-boot-jar</artifactId>
						<version>1.0.0-SNAPSHOT</version>
						<relativePath/>
					</parent>
					<packaging>jar</packaging>
					<groupId>com.poscodx.odc</groupId>
					<artifactId>ampro015-boot</artifactId>
					<version>1.0-SNAPSHOT</version>
					<properties>
					<sonar.projectKey>f2knight_ampro-backend_AY0VVIi2V7A74ivlyQbm</sonar.projectKey>
					<sonar.projectName>AMPro BackEnd</sonar.projectName>
					<sonar.qualitygate.wait>true</sonar.qualitygate.wait>
					</properties>
					<dependencies>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-config-client</artifactId>
						</dependency>
						<dependency>
							<groupId>com.poscodx.odc</groupId>
							<artifactId>ampro015-service</artifactId>
							<version>1.0-SNAPSHOT</version>
						</dependency>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.cloud</groupId>
							<artifactId>spring-cloud-sleuth-zipkin</artifactId>
						</dependency>
						<dependency>
							<groupId>io.springfox</groupId>
							<artifactId>springfox-swagger2</artifactId>
							<version>${springfox-swagger.version}</version>
						</dependency>
						<dependency>
							<groupId>io.springfox</groupId>
							<artifactId>springfox-swagger-ui</artifactId>
							<version>${springfox-swagger.version}</version>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-log4j2</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-actuator</artifactId>
							<exclusions>
								<exclusion>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-starter-logging</artifactId>
								</exclusion>
							</exclusions>
						</dependency>
						<dependency>
							<groupId>org.apache.poi</groupId>
							<artifactId>poi-ooxml</artifactId>
							<version>4.1.0</version>
						</dependency>
						<dependency>
							<groupId>com.google.zxing</groupId>
							<artifactId>core</artifactId>
							<version>3.4.0</version>
						</dependency>
						<dependency>
							<groupId>com.google.zxing</groupId>
							<artifactId>javase</artifactId>
							<version>3.4.0</version>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-web</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-security</artifactId>
						</dependency>
						<dependency>
							<groupId>io.jsonwebtoken</groupId>
							<artifactId>jjwt-api</artifactId>
							<version>0.11.5</version>
						</dependency>
						<dependency>
							<groupId>io.jsonwebtoken</groupId>
							<artifactId>jjwt-impl</artifactId>
							<version>0.11.5</version>
							<scope>runtime</scope>
						</dependency>
						<dependency>
							<groupId>io.jsonwebtoken</groupId>
							<artifactId>jjwt-jackson</artifactId>
							<version>0.11.5</version>
							<scope>runtime</scope>
						</dependency>
						<dependency>
							<groupId>org.springframework.security</groupId>
							<artifactId>spring-security-core</artifactId>
							<version>5.2.1.RELEASE</version>
						</dependency>
						<dependency>
							<groupId>org.jetbrains</groupId>
							<artifactId>annotations</artifactId>
							<version>RELEASE</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-websocket</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework</groupId>
							<artifactId>spring-tx</artifactId>
						</dependency>
						<dependency>
							<groupId>com.poscoict.base.share</groupId>
							<artifactId>share-util</artifactId>
						</dependency>
						<dependency>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</dependency>
						<dependency>
							<groupId>io.minio</groupId>
							<artifactId>minio</artifactId>
							<version>7.1.4</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>com.poscodx.odc</groupId>
							<artifactId>ampro015-domain</artifactId>
							<version>1.0-SNAPSHOT</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>com.poscodx.odc</groupId>
							<artifactId>ampro015-store</artifactId>
							<version>1.0-SNAPSHOT</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>org.springframework.kafka</groupId>
							<artifactId>spring-kafka</artifactId>
						</dependency>
						<dependency>
							<groupId>org.apache.poi</groupId>
							<artifactId>poi-ooxml</artifactId>
							<version>4.1.0</version>
						</dependency>
					</dependencies>
					<dependencyManagement>
						<dependencies>
							<dependency>
								<groupId>com.posco.reuse</groupId>
								<artifactId>reuse-dependencies</artifactId>
								<version>${posco-reuse.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-dependencies</artifactId>
								<version>${spring-boot.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>${spring-cloud.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
						</dependencies>
					</dependencyManagement>
					<build>
						<plugins>
							<plugin>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-maven-plugin</artifactId>
								<executions>
									<execution>
										<configuration>
											<mainClass>com.poscodx.odc.ampro015.ProductApplication</mainClass>
										</configuration>
									</execution>
								</executions>
							</plugin>
						</plugins>
					</build>
				</project>
				
			pom-domain.xml
			
				<?xml version="1.0" encoding="UTF-8"?>
				<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
					<modelVersion>4.0.0</modelVersion>
					<parent>
						<groupId>com.posco.base</groupId>
						<artifactId>posco-comp-jar</artifactId>
						<version>1.0.0-SNAPSHOT</version>
						<relativePath/>
					</parent>
					<groupId>com.poscodx.odc</groupId>
					<artifactId>ampro015-domain</artifactId>
					<version>1.0-SNAPSHOT</version>
					<dependencies>
						<!-- Other dependencies -->
						<dependency>
							<groupId>com.fasterxml.jackson.core</groupId>
							<artifactId>jackson-databind</artifactId>
						</dependency>
						<dependency>
							<groupId>com.poscoict.base.share</groupId>
							<artifactId>share-domain</artifactId>
						</dependency>
						<dependency>
							<groupId>com.poscoict.base.share</groupId>
							<artifactId>share-event</artifactId>
						</dependency>
						<dependency>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</dependency>
						<dependency>
							<groupId>org.apache.tomcat.embed</groupId>
							<artifactId>tomcat-embed-core</artifactId>
						</dependency>
						<dependency>
							<groupId>org.apache.poi</groupId>
							<artifactId>poi</artifactId>
							<version>4.1.0</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>org.apache.poi</groupId>
							<artifactId>poi-ooxml</artifactId>
							<version>4.1.0</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>com.google.zxing</groupId>
							<artifactId>core</artifactId>
							<version>3.4.0</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>com.netflix.archaius</groupId>
							<artifactId>archaius-core</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework</groupId>
							<artifactId>spring-web</artifactId>
						</dependency>
						<dependency>
							<groupId>com.posco.reuse</groupId>
							<artifactId>posco-reuse-logging</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework</groupId>
							<artifactId>spring-tx</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.data</groupId>
							<artifactId>spring-data-commons</artifactId>
							<version>2.2.1.RELEASE</version>
						</dependency>
						<dependency>
							<groupId>org.springframework.data</groupId>
							<artifactId>spring-data-jpa</artifactId>
							<version>2.2.1.RELEASE</version>
						</dependency>
						<dependency>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</dependency>
						<dependency>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</dependency>
						<dependency>
							<groupId>org.springframework.boot</groupId>
							<artifactId>spring-boot-starter-validation</artifactId>
						</dependency>
						<dependency>
							<groupId>org.apache.httpcomponents</groupId>
							<artifactId>httpcore</artifactId>
						</dependency>
						<dependency>
							<groupId>io.minio</groupId>
							<artifactId>minio</artifactId>
							<version>7.1.4</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>org.modelmapper</groupId>
							<artifactId>modelmapper</artifactId>
							<version>3.2.0</version>
						</dependency>
						<dependency>
							<groupId>com.sun.mail</groupId>
							<artifactId>javax.mail</artifactId>
							<version>1.6.2</version>
						</dependency>
						<dependency>
							<groupId>org.springframework.security</groupId>
							<artifactId>spring-security-core</artifactId>
							<version>5.2.1.RELEASE</version>
						</dependency>
						<dependency>
							<groupId>commons-io</groupId>
							<artifactId>commons-io</artifactId>
							<version>2.6</version>
						</dependency>
						<dependency>
							<groupId>commons-io</groupId>
							<artifactId>commons-io</artifactId>
							<version>2.6</version>
							<scope>compile</scope>
						</dependency>
						<dependency>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>1.18.10</version>
							<scope>provided</scope>
						</dependency>
					</dependencies>
					<dependencyManagement>
						<dependencies>
							<dependency>
								<groupId>com.posco.reuse</groupId>
								<artifactId>reuse-dependencies</artifactId>
								<version>${posco-reuse.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-dependencies</artifactId>
								<version>${spring-boot.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-dependencies</artifactId>
								<version>${spring-cloud.version}</version>
								<type>pom</type>
								<scope>import</scope>
							</dependency>
						</dependencies>
					</dependencyManagement>
				</project>

			pom-service.xml	
				
					<?xml version="1.0" encoding="UTF-8"?>
					<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
							 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
						<modelVersion>4.0.0</modelVersion>
						<parent>
							<groupId>com.posco.base</groupId>
							<artifactId>posco-comp-jar</artifactId>
							<version>1.0.0-SNAPSHOT</version>
							<relativePath/>
						</parent>
						<groupId>com.poscodx.odc</groupId>
						<artifactId>ampro015-service</artifactId>
						<version>1.0-SNAPSHOT</version>
						<properties>
						</properties>
						<dependencies>
							<dependency>
								<groupId>com.poscodx.odc</groupId>
								<artifactId>ampro015-store</artifactId>
								<version>1.0-SNAPSHOT</version>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-starter-web</artifactId>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-starter-log4j2</artifactId>
							</dependency>
							<dependency>
								<groupId>org.springframework.cloud</groupId>
								<artifactId>spring-cloud-starter-openfeign</artifactId>
							</dependency>
							<dependency>
								<groupId>org.jetbrains</groupId>
								<artifactId>annotations</artifactId>
								<version>RELEASE</version>
								<scope>compile</scope>
							</dependency>
							<dependency>
								<groupId>io.minio</groupId>
								<artifactId>minio</artifactId>
								<version>7.1.4</version>
								<scope>compile</scope>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-starter-validation</artifactId>
							</dependency>
							<dependency>
								<groupId>org.checkerframework</groupId>
								<artifactId>checker-qual</artifactId>
								<version>3.32.0</version>
								<scope>compile</scope>
							</dependency>
						</dependencies>
						<dependencyManagement>
							<dependencies>
								<dependency>
									<groupId>com.posco.reuse</groupId>
									<artifactId>reuse-dependencies</artifactId>
									<version>${posco-reuse.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
								<dependency>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-dependencies</artifactId>
									<version>${spring-boot.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
								<dependency>
									<groupId>org.springframework.cloud</groupId>
									<artifactId>spring-cloud-dependencies</artifactId>
									<version>${spring-cloud.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
							</dependencies>
						</dependencyManagement>
					</project>

				pom-store.xml
				
					<?xml version="1.0" encoding="UTF-8"?>
					<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
						<modelVersion>4.0.0</modelVersion>
						<parent>
							<groupId>com.posco.base</groupId>
							<artifactId>posco-comp-jar</artifactId>
							<version>1.0.0-SNAPSHOT</version>
						</parent>
						<groupId>com.poscodx.odc</groupId>
						<artifactId>ampro015-store</artifactId>
						<version>1.0-SNAPSHOT</version>
						<properties>
						</properties>
						<dependencies>
							<dependency>
								<groupId>com.poscoict.base.share</groupId>
								<artifactId>share-store</artifactId>
							</dependency>
							<dependency>
								<groupId>com.posco.reuse</groupId>
								<artifactId>posco-reuse-compensation-util</artifactId>
							</dependency>
							<dependency>
								<groupId>com.poscodx.odc</groupId>
								<artifactId>ampro015-domain</artifactId>
								<version>1.0-SNAPSHOT</version>
							</dependency>
							<dependency>
								<groupId>org.springframework.boot</groupId>
								<artifactId>spring-boot-starter-data-jpa</artifactId>
							</dependency>
							<dependency>
								<groupId>com.h2database</groupId>
								<artifactId>h2</artifactId>
							</dependency>
							<dependency>
								<groupId>org.mariadb.jdbc</groupId>
								<artifactId>mariadb-java-client</artifactId>
								<version>3.3.0</version>
							</dependency>
							<dependency>
								<groupId>org.projectlombok</groupId>
								<artifactId>lombok</artifactId>
							</dependency>
						</dependencies>
						<dependencyManagement>
							<dependencies>
								<dependency>
									<groupId>com.posco.reuse</groupId>
									<artifactId>reuse-dependencies</artifactId>
									<version>${posco-reuse.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
								<dependency>
									<groupId>org.springframework.boot</groupId>
									<artifactId>spring-boot-dependencies</artifactId>
									<version>${spring-boot.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
								<dependency>
									<groupId>org.springframework.cloud</groupId>
									<artifactId>spring-cloud-dependencies</artifactId>
									<version>${spring-cloud.version}</version>
									<type>pom</type>
									<scope>import</scope>
								</dependency>
							</dependencies>
						</dependencyManagement>
					</project>
					
	Kafka--Spring:

		ConsumerFactory--Spring kafka:
		
			Trong Spring, ConsumerFactory là một interface cung cấp cơ chế để tạo ra các instance của Consumer trong các ứng dụng sử dụng Kafka. Kafka Consumer là một phần quan trọng trong việc đọc các thông
			điệp từ các topics trong Kafka. ConsumerFactory giúp quản lý việc tạo các consumer và cung cấp cấu hình cần thiết cho chúng.
			
			Các thành phần chính liên quan đến ConsumerFactory:
			
				ConsumerFactory Interface:
				
					Đây là interface định nghĩa một phương thức duy nhất là createConsumer, được sử dụng để tạo một KafkaConsumer.
					
					Thông qua ConsumerFactory, bạn có thể tùy chỉnh cách mà KafkaConsumer được tạo ra, bao gồm các cài đặt cấu hình như bootstrap.servers, group.id, key.deserializer, value.deserializer, và nhiều hơn nữa.
					
				DefaultKafkaConsumerFactory:
				
					Đây là một triển khai mặc định của ConsumerFactory.
					
					Bạn có thể sử dụng lớp này để tạo các consumer với cấu hình chuẩn hoặc tùy chỉnh thông qua một Map<String, Object> chứa các properties của Kafka.
					
			Cấu hình các thuộc tính của Kafka Consumer:
			
				- ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG: Địa chỉ của Kafka broker, thông qua biến bootstrapAddress. Đây là danh sách các broker mà Kafka consumer sẽ kết nối để lấy dữ liệu.
				
				- ConsumerConfig.GROUP_ID_CONFIG: Được cấu hình với giá trị của groupId truyền vào. Đây là ID của nhóm consumer, giúp Kafka biết được các consumer nào cùng thuộc về một nhóm và cần
				chia sẻ công việc với nhau.
				
				- ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG và ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG: Cấu hình lớp deserializer để giải mã (deserialize) các khóa và giá trị từ chuỗi
				byte. Ở đây, StringDeserializer.class được sử dụng để giải mã dữ liệu từ chuỗi byte thành chuỗi (string).
				
				- ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG và ConsumerConfig.FETCH_MAX_BYTES_CONFIG: Cấu hình kích thước tối đa mà consumer có thể đọc từ mỗi phân vùng (partition) trong
				một lần truy vấn (fetch). Ở đây, nó được đặt thành 20 MB (20971520 bytes).
									
		ConcurrentKafkaListenerContainerFactory--Spring kafka:
		
			ConcurrentKafkaListenerContainerFactory là một lớp trong Spring Kafka, được sử dụng để tạo các container chịu trách nhiệm quản lý vòng đời của các Kafka listener. Nó đặc biệt hữu ích khi bạn cần
			xử lý các thông điệp từ Kafka một cách song song (concurrent) và hiệu quả trong các ứng dụng Spring.
			
			Chức năng của ConcurrentKafkaListenerContainerFactory:
			
				Tạo các Listener Containers:
				
					ConcurrentKafkaListenerContainerFactory tạo ra các listener containers có khả năng chạy nhiều KafkaListener cùng lúc, cho phép xử lý đồng thời nhiều thông điệp từ Kafka.
					
				Cấu hình Concurrency (Độ đồng thời):

					Bạn có thể cấu hình mức độ đồng thời (số lượng thread) để điều khiển số lượng luồng sẽ xử lý các thông điệp Kafka đồng thời.
					
					Điều này đặc biệt hữu ích trong các ứng dụng yêu cầu khả năng mở rộng và xử lý khối lượng lớn thông điệp.
					
				Tích hợp dễ dàng với Spring:
				
					ConcurrentKafkaListenerContainerFactory được tích hợp trực tiếp với cơ chế @KafkaListener trong Spring, cho phép bạn dễ dàng xác định các phương thức sẽ xử lý các thông điệp Kafka.
				
		ProducerFactory--Spring kafka:
		
			ProducerFactory trong Spring Kafka là một giao diện chịu trách nhiệm tạo các Kafka Producer. Tương tự như ConsumerFactory đối với Kafka Consumer, ProducerFactory cung cấp cơ chế để cấu hình
			và khởi tạo Kafka Producer với các thuộc tính cụ thể.
			
			Vai trò của ProducerFactory:
			
				Bạn có thể cấu hình ProducerFactory để tùy chỉnh các thuộc tính liên quan đến cách mà Producer hoạt động, chẳng hạn như địa chỉ Kafka broker, kiểu dữ liệu (serializer) cho khóa và giá
				trị, timeout, độ an toàn khi gửi dữ liệu (acks), và nhiều thứ khác.
				
			Các thuộc tính:
			
				ProducerConfig.BOOTSTRAP_SERVERS_CONFIG:
				
					Mô tả: Đây là địa chỉ của Kafka broker mà producer sẽ kết nối tới.
					
					Ví dụ: "localhost:9092".
				
				ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG và ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG:
					
					Mô tả: Xác định lớp serializer để chuyển đổi khóa và giá trị từ đối tượng Java sang chuỗi byte trước khi gửi tới Kafka.
					
					Ví dụ: StringSerializer.class (để serialize các khóa và giá trị là chuỗi string).
				
				ProducerConfig.ACKS_CONFIG:
					
					Mô tả: Xác định mức độ an toàn khi gửi dữ liệu. Cấu hình này chỉ định số lượng bản sao (replica) của Kafka broker cần phải xác nhận đã nhận được dữ liệu trước khi producer coi việc gửi là thành công.
					
					Giá trị:
					
						"all": Tất cả các bản sao đồng bộ phải xác nhận (an toàn nhất).
						
						"1": Chỉ cần một bản sao xác nhận.
						
						"0": Không cần xác nhận từ broker.
				
				ProducerConfig.RETRIES_CONFIG:
					
					Mô tả: Số lần tối đa mà producer sẽ thử gửi lại dữ liệu nếu việc gửi ban đầu thất bại.
					
					Ví dụ: 10 (Producer sẽ thử gửi lại dữ liệu tối đa 10 lần).
				
				ProducerConfig.BATCH_SIZE_CONFIG:
					
					Mô tả: Kích thước tối đa của một batch (lô) dữ liệu mà producer sẽ gửi trong một lần. Kafka producer sẽ cố gắng gộp các bản ghi thành các lô trước khi gửi đi.
					
					Ví dụ: 16384 (16 KB).
				
				ProducerConfig.LINGER_MS_CONFIG:
					
					Mô tả: Thời gian tối đa producer sẽ đợi trước khi gửi batch dữ liệu. Nếu thời gian đợi này hết trước khi batch đầy, producer sẽ gửi batch đi ngay cả khi batch chưa đầy.
					
					Ví dụ: 1 (Producer sẽ đợi 1 ms để gộp batch trước khi gửi).
				
				ProducerConfig.BUFFER_MEMORY_CONFIG:
					
					Mô tả: Tổng lượng bộ nhớ mà producer có thể sử dụng để lưu trữ các bản ghi chưa gửi. Khi bộ nhớ này đầy, producer sẽ chờ trước khi chấp nhận thêm các bản ghi mới.
					
					Ví dụ: 33554432 (32 MB).
					
				ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG
					
					Chỉ định lớp serializer được sử dụng để chuyển đổi giá trị (value) thành chuỗi byte trước khi gửi tới Kafka.
					
					StringSerializer.class là lớp serializer được chọn, phù hợp khi giá trị là một chuỗi (String).
					
				ProducerConfig.MAX_REQUEST_SIZE_CONFIG
				
					Xác định kích thước tối đa của một yêu cầu gửi từ Producer tới Kafka, tính bằng byte.
					
					20971520 là kích thước tối đa được đặt trong ví dụ này, tương đương với 20 MB. Điều này có nghĩa là Producer có thể gửi một yêu cầu có kích thước lên tới 20 MB.
					
		DefaultKafkaProducerFactory--Spring kafka:
		
			DefaultKafkaProducerFactory trong Spring Kafka là một lớp triển khai của giao diện ProducerFactory, được sử dụng để tạo các instance của Kafka Producer dựa trên cấu hình mà bạn
			cung cấp. Nó cung cấp khả năng khởi tạo và quản lý các Kafka Producer với các cấu hình chi tiết như các thuộc tính về broker, serializer, và các thông số hoạt động khác.
			
			Chức năng của DefaultKafkaProducerFactory:
			
				Tạo Kafka Producer: DefaultKafkaProducerFactory chịu trách nhiệm tạo và cung cấp các Kafka Producer được cấu hình trước.
				
				Quản lý tài nguyên: Nó có thể quản lý và tái sử dụng các Kafka Producer để tối ưu hóa tài nguyên.
				
				Tùy chỉnh cấu hình: Bạn có thể cung cấp các thuộc tính cấu hình khác nhau để tùy chỉnh cách mà Kafka Producer hoạt động.

		KafkaTemplate--Spring kafka:
		
			- KafkaTemplate trong Spring Kafka là một lớp tiện ích được sử dụng để gửi các thông điệp (messages) tới các topic trong Kafka. Nó đóng vai trò tương tự như JdbcTemplate trong Spring JDBC
			hoặc RestTemplate trong Spring REST, giúp đơn giản hóa quá trình tương tác với Kafka Producer bằng cách ẩn đi các chi tiết phức tạp.
			
			- Chức năng của KafkaTemplate:
			
				Gửi thông điệp (Send Messages):
				
					KafkaTemplate cung cấp nhiều phương thức để gửi thông điệp đồng bộ hoặc bất đồng bộ tới một hoặc nhiều topic trong Kafka.
					
				Tự động quản lý Producer:
				
					KafkaTemplate quản lý các Kafka Producer dưới lớp, bạn không cần phải tạo hay đóng chúng một cách thủ công.
					
				Xử lý kết quả:
				
					KafkaTemplate cung cấp các phương thức để xử lý kết quả gửi thông điệp, bao gồm việc nhận Future để theo dõi quá trình gửi thông điệp bất đồng bộ.
					
			- Các phương thức quan trọng của KafkaTemplate:
			
				send(String topic, String data):
				
					Gửi thông điệp tới một topic cụ thể.
					
					Trả về một đối tượng ListenableFuture<SendResult<K, V>> cho phép bạn theo dõi trạng thái gửi thông điệp.
				
				send(String topic, K key, V data):
					
					Gửi thông điệp tới một topic cụ thể với khóa và giá trị.
					
					Tương tự như trên, phương thức này cũng trả về một ListenableFuture.
				
				sendDefault(String data):
					
					Gửi thông điệp sử dụng topic mặc định đã cấu hình trước đó trong KafkaTemplate.
					
					Phương thức này hữu ích khi bạn chỉ làm việc với một topic.
				
				flush():
					
					Đẩy tất cả các thông điệp đã gửi nhưng chưa được xác nhận tới Kafka broker.
					
					Hữu ích khi bạn muốn đảm bảo rằng tất cả các thông điệp đã được gửi đi trước khi thực hiện các hành động khác.
				
				execute(ProducerCallback<K, V, T> callback):
					
					Cho phép thực thi các hoạt động tùy chỉnh với Kafka Producer.
					
					Bạn có thể sử dụng phương thức này khi cần thực hiện các thao tác đặc biệt với Producer không được hỗ trợ trực tiếp bởi KafkaTemplate.
			
			- Cách sử dụng KafkaTemplate:
			
				Để sử dụng KafkaTemplate, trước tiên bạn cần cấu hình ProducerFactory và sau đó tạo một instance của KafkaTemplate
				
				Gửi thông điệp sử dụng KafkaTemplate:
				
					import org.springframework.beans.factory.annotation.Autowired;
					import org.springframework.kafka.core.KafkaTemplate;
					import org.springframework.stereotype.Service;
					@Service
					public class KafkaProducerService {
						private final KafkaTemplate<String, String> kafkaTemplate;
						@Autowired
						public KafkaProducerService(KafkaTemplate<String, String> kafkaTemplate) {
							this.kafkaTemplate = kafkaTemplate;
						}
						public void sendMessage(String topic, String message) {
							kafkaTemplate.send(topic, message);
						}
					}
					
			- Xử lý kết quả và lỗi:
			
				Vì KafkaTemplate sử dụng các phương thức bất đồng bộ (send()), bạn có thể sử dụng ListenableFuture để theo dõi quá trình gửi thông điệp và xử lý kết quả:
				
					import org.springframework.kafka.support.SendResult;
					import org.springframework.util.concurrent.ListenableFuture;
					import org.springframework.util.concurrent.ListenableFutureCallback;
					public void sendMessageWithCallback(String topic, String message) {
						ListenableFuture<SendResult<String, String>> future = kafkaTemplate.send(topic, message);
						future.addCallback(new ListenableFutureCallback<SendResult<String, String>>() {
							@Override
							public void onSuccess(SendResult<String, String> result) {
								System.out.println("Sent message=[" + message + 
								  "] with offset=[" + result.getRecordMetadata().offset() + "]");
							}
							@Override
							public void onFailure(Throwable ex) {
								System.out.println("Unable to send message=[" 
								  + message + "] due to : " + ex.getMessage());
							}
						});
					}
					
		KafkaAdmin--Spring kafka:
		
			- KafkaAdmin trong Spring là một lớp hỗ trợ quản lý và cấu hình các tài nguyên Kafka, chẳng hạn như tạo, xóa, hoặc thay đổi cấu hình các topic. KafkaAdmin tự động thực thi các thao tác quản
			lý này khi ứng dụng Spring khởi động, dựa trên các cấu hình mà bạn đã định nghĩa.
			
			- Chức năng của KafkaAdmin:
			
				Tạo topic: KafkaAdmin cho phép bạn định nghĩa các topic Kafka trong cấu hình Spring, sau đó tự động tạo chúng khi ứng dụng khởi động.
				
				Xóa topic: Nó có thể tự động xóa các topic nếu được cấu hình.
				
				Thay đổi cấu hình topic: KafkaAdmin hỗ trợ thay đổi cấu hình của các topic đã tồn tại, chẳng hạn như số lượng bản sao (replicas) hoặc số lượng phân vùng (partitions).
				
				Tích hợp với Spring: KafkaAdmin tích hợp sâu với Spring, cho phép bạn quản lý các tài nguyên Kafka một cách khai báo thông qua các file cấu hình hoặc annotation.

			- Định cấu hình KafkaAdmin:
			
				AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG: Chỉ định địa chỉ của Kafka broker mà KafkaAdmin sẽ kết nối để quản lý các topic.
					
		Ví dụ--Spring kafka:
				
			KafkaHealthIndicator.java:
			
				package com.poscodx.odc.ampro015.config.kafka;
				import lombok.extern.slf4j.Slf4j;
				import org.apache.kafka.clients.admin.AdminClient;
				import org.apache.kafka.clients.admin.ListTopicsOptions;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.boot.actuate.health.Health;
				import org.springframework.boot.actuate.health.HealthIndicator;
				import org.springframework.kafka.core.KafkaAdmin;
				import org.springframework.stereotype.Component;
				import java.util.concurrent.TimeUnit;
				@Component("kafka_indicator")
				@Slf4j
				public class KafkaHealthIndicator implements HealthIndicator {
					@Autowired
					private KafkaAdmin kafkaAdmin;
					@Override
					public Health health() {
						try (AdminClient client = AdminClient.create(kafkaAdmin.getConfig())) {
							client.listTopics(new ListTopicsOptions().timeoutMs(1000)).listings().get(10, TimeUnit.SECONDS);
							return Health.up().build();
						} catch (Exception e) {
							return Health.down().withException(e).build();
						}
					}
				}
				
			KafkaProducerConfig.java:
			
				package com.poscodx.odc.ampro015.config.kafka;
				import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
				import org.apache.kafka.clients.producer.ProducerConfig;
				import org.apache.kafka.common.serialization.StringSerializer;
				import org.springframework.beans.factory.annotation.Value;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.kafka.core.DefaultKafkaProducerFactory;
				import org.springframework.kafka.core.KafkaTemplate;
				import org.springframework.kafka.core.ProducerFactory;
				import org.springframework.kafka.support.serializer.JsonSerializer;
				import java.util.HashMap;
				import java.util.Map;
				@Configuration
				public class KafkaProducerConfig {
					@Value(value = "${spring.kafka.bootstrap-servers}")
					private String bootstrapAddress;
					@Bean
					public ProducerFactory<String, String> producerFactory() {
						Map<String, Object> configProps = new HashMap<>();
						configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
						configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
						configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
						configProps.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, "20971520");
						return new DefaultKafkaProducerFactory<>(configProps);
					}
					@Bean
					public KafkaTemplate<String, String> kafkaTemplate() {
						return new KafkaTemplate<>(producerFactory());
					}
					@Bean
					public ProducerFactory<String, DeepFaceInfoRequest> userFaceProducerFactory() {
						Map<String, Object> configProps = new HashMap<>();
						configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
						configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
						configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
						return new DefaultKafkaProducerFactory<>(configProps);
					}
					@Bean
					public KafkaTemplate<String, DeepFaceInfoRequest> userFaceKafkaTemplate() {
						return new KafkaTemplate<>(userFaceProducerFactory());
					}
				}
				
			ProductProducer.java:
			
				package com.poscodx.odc.ampro015.config.kafka.producers;
				import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
				import lombok.NoArgsConstructor;
				import lombok.extern.slf4j.Slf4j;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.kafka.core.KafkaTemplate;
				import org.springframework.stereotype.Component;
				@Slf4j
				@NoArgsConstructor
				@Component
				public class ProductProducer {
					final String topic = "deepfake";
					@Autowired
					private KafkaTemplate<String, DeepFaceInfoRequest> kafkaTemplate;
					@Autowired
					private KafkaTemplate<String, String> kafkaTemplate2;
					public void sendMessage(String message) {
						kafkaTemplate2.send(topic, message);
						log.info("Send message String: {}", message);
					}
					public void sendMessage(DeepFaceInfoRequest message) {
						kafkaTemplate.send(topic, message);
						log.info("Send message UserFaceRequest: {}", message);
					}
				}				
				
			KafkaConsumerConfig.java:
			
				package com.poscodx.odc.ampro015.config.kafka;
				import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
				import lombok.extern.slf4j.Slf4j;
				import org.apache.kafka.clients.consumer.ConsumerConfig;
				import org.apache.kafka.common.serialization.StringDeserializer;
				import org.springframework.beans.factory.annotation.Value;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
				import org.springframework.kafka.core.ConsumerFactory;
				import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
				import org.springframework.kafka.support.serializer.JsonDeserializer;
				import java.util.HashMap;
				import java.util.Map;
				@Slf4j
				@Configuration
				public class KafkaConsumerConfig {
					@Value(value = "${spring.kafka.bootstrap-servers}")
					private String bootstrapAddress;
					public ConsumerFactory<String, String> consumerFactory(String groupId) {
						Map<String, Object> props = new HashMap<>();
						props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
						props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
						props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
						props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
						props.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, "20971520");
						props.put(ConsumerConfig.FETCH_MAX_BYTES_CONFIG, "20971520");
						return new DefaultKafkaConsumerFactory<>(props);
					}
					public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory(String groupId) {
						ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
						factory.setConsumerFactory(consumerFactory(groupId));
						return factory;
					}
					@Bean
					public ConcurrentKafkaListenerContainerFactory<String, String> deepFakeKafkaListenerContainerFactory() {
						return kafkaListenerContainerFactory("deep-fake");
					}
					public ConsumerFactory<String, DeepFaceInfoRequest> consumerFactory2(String groupId) {
						Map<String, Object> props = new HashMap<>();
						props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
						props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
						return new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(), new JsonDeserializer<>(DeepFaceInfoRequest.class));
					}
					@Bean
					public ConcurrentKafkaListenerContainerFactory<String, DeepFaceInfoRequest> deepFakeeKafkaListenerContainerFactory2() {
						ConcurrentKafkaListenerContainerFactory<String, DeepFaceInfoRequest> factory = new ConcurrentKafkaListenerContainerFactory<>();
						factory.setConsumerFactory(consumerFactory2("deep-fake"));
						return factory;
					}
				}				
				
			KafkaTopicConfig.java:
			
				package com.poscodx.odc.ampro015.config.kafka;
				import org.apache.kafka.clients.admin.AdminClientConfig;
				import org.apache.kafka.clients.admin.NewTopic;
				import org.springframework.beans.factory.annotation.Value;
				import org.springframework.context.annotation.Bean;
				import org.springframework.context.annotation.Configuration;
				import org.springframework.kafka.core.KafkaAdmin;
				import java.util.HashMap;
				import java.util.Map;
				@Configuration
				public class KafkaTopicConfig {
					@Value(value = "${spring.kafka.bootstrap-servers}")
					private String bootstrapAddress;
					@Bean
					public KafkaAdmin kafkaAdmin() {
						Map<String, Object> configs = new HashMap<>();
						configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
						return new KafkaAdmin(configs);
					}
				}
				
			MultiTypeKafkaListener.java:
			
				package com.poscodx.odc.ampro015.config.kafka.listeners;
				import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
				import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
				import org.apache.commons.lang3.time.DateUtils;
				import org.apache.kafka.clients.consumer.ConsumerRecord;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.kafka.annotation.KafkaHandler;
				import org.springframework.kafka.annotation.KafkaListener;
				import org.springframework.stereotype.Component;
				import java.util.Date;
				import java.util.concurrent.TimeoutException;
				@Component
				@KafkaListener(id = "multiGroup1", topics = "amface", groupId = "deep-fake", autoStartup = "false")
				public class MultiTypeKafkaListener {
					@Autowired
					ServiceLifecycle serviceLifecycle;
					@KafkaHandler
					public void handleUserFaceRequest(DeepFaceInfoRequest userFaceRequest) throws TimeoutException {
						try {
							System.out.println("User face received UserFaceRequest 1 (user-face): " + userFaceRequest);
						} catch (Exception e) {
							System.out.println("Handle kafka's message error: " + e.getMessage());
						}
					}
					@KafkaHandler
					public void handleUserFaceRequest2(String userFaceRequest) throws TimeoutException {
						try {
							System.out.println("User face received String 2 (user-face): " + userFaceRequest);
							DeepFaceInfoRequest receiver = DeepFaceInfoRequest.fromJson(userFaceRequest);
							System.out.println("User face received String 2 (Oject): " + receiver);
							serviceLifecycle.requestLevel2WorkingTimeService().createOrUpdateWorkingTime(serviceLifecycle, receiver.getId(), receiver.getAccessTime());
							serviceLifecycle.requestLevel2Service().sendCheckFaceTimeNotification(receiver, "/topic/check-face-time");
						} catch (Exception e) {
							System.out.println("Handle kafka's message error: " + e.getMessage());
						}
					}
					@KafkaHandler
					public void unknown(ConsumerRecord<String, Object> record) throws TimeoutException {
						try {
							System.out.println("User face received Object 2 (user-face): " + record.value());
						} catch (Exception e) {
							System.out.println("Handle kafka's message error: " + e.getMessage());
						}
					}
				}
				
			ProductApplication.java:
			
				package com.poscodx.odc.ampro015;
				import com.poscodx.odc.ampro015.config.kafka.KafkaHealthIndicator;
				import com.poscodx.odc.ampro015.service.rest.Pme00ScheduleNotificationResource;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.boot.CommandLineRunner;
				import org.springframework.boot.SpringApplication;
				import org.springframework.boot.actuate.health.Health;
				import org.springframework.boot.actuate.health.Status;
				import org.springframework.boot.autoconfigure.SpringBootApplication;
				import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
				import org.springframework.context.ConfigurableApplicationContext;
				import org.springframework.context.annotation.ComponentScan;
				import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
				import org.springframework.scheduling.annotation.EnableScheduling;
				import org.springframework.web.bind.annotation.RestController;
				import org.springframework.web.bind.annotation.GetMapping;
				import java.text.DateFormat;
				import java.text.SimpleDateFormat;
				import java.util.Date;
				@SpringBootApplication
				@ComponentScan(basePackages = { "com.poscodx.odc.ampro015", "com.posco.reuse.compensation.util", })
				@RestController
				@EnableDiscoveryClient
				@EnableScheduling
				public class ProductApplication implements CommandLineRunner {
					@Autowired
					private KafkaListenerEndpointRegistry kafkaListenerEndpointRegistry;
					@Autowired
					private KafkaHealthIndicator kafkaHealthIndicator;
					public static void main(String[] args) {
						ConfigurableApplicationContext context = SpringApplication.run(ProductApplication.class, args);
						//reschedule active schedule
						context.getBean(Pme00ScheduleNotificationResource.class).rescheduleTaskWhenRestartProject();
					}
					@Override
					public void run(String... args) throws Exception {
						// start listener
						Health result = kafkaHealthIndicator.health();
						if(result.getStatus().equals(Status.UP)){
							kafkaListenerEndpointRegistry.getListenerContainer("multiGroup1").start();
						}
					}
					@GetMapping("/health")
					public String health() {
						return "ok";
					}
				}
			
MySQL---:

									- Select là lựa chọn theo giá trị của các cột trong 1 row									
									- Bảng chứa khóa ngoại được gọi là bảng sở hữu (Owner, Child), bảng được bảng sở hữu liên kết đến gọi là bảng tham chiếu (reference table hoặc parent table), field trong bảng tham
									chiếu để liên kết được gọi là đối tượng tham chiếu (reference object)
									- Trong cơ sở dữ liệu, một entity thường tương đương với một bảng trong cơ sở dữ liệu. Mỗi hàng trong bảng đó đại diện cho một thực thể cụ thể, và các cột trong hàng đó chứa thông tin về
									các thuộc tính của thực thể đó.

	Nguyên tắc--MYSQL:
									Cập nhật bảng cha trước: Trong hầu hết các trường hợp, bạn nên cập nhật dữ liệu trong bảng cha trước, trước khi cập nhật bất kỳ dữ liệu nào trong
									                         bảng con. Điều này giúp đảm bảo rằng dữ liệu mới trong bảng cha sẽ có sẵn khi cập nhật dữ liệu trong bảng con.
									Xóa bảng con trước: Để đảm bảo tính toàn vẹn referential, bạn cần xóa dữ liệu từ bảng con trước rồi mới xóa dữ liệu từ bảng cha. Nếu bạn xóa dữ liệu từ bảng cha
									                    trước, có thể gây ra việc vi phạm ràng buộc referential integrity vì bảng con vẫn có thể chứa các bản ghi liên kết với bảng cha.
									Sử dụng các ràng buộc (constraints) và các hành động thực thi (trigger): Bạn có thể sử dụng các ràng buộc (constraints) như ON DELETE CASCADE hoặc ON
													                                                         UPDATE CASCADE để tự động cập nhật hoặc xóa các hàng trong bảng con khi các hàng tương ứng
																											 trong bảng cha được cập nhật hoặc xóa. Các trigger cũng có thể được sử dụng để thực hiện các
																											 hành động tùy chỉnh khi dữ liệu được cập nhật.
	Some of The Most Important SQL Commands--MYSQL:
			
			SELECT - extracts data from a database
																
				SELECT ... FROM ... WHERE ...
				
			UPDATE - updates data in a database
			
				UPDATE ... SET ... WHERE ...
			
			DELETE - deletes data from a database
			
				DELETE FROM ... WHERE ...
			
			INSERT INTO - inserts new data into a database
			
				INSERT INTO ...  VALUES ...
				
			CREATE DATABASE - creates a new database
			
				CREATE DATABASE ...
			
			ALTER DATABASE - modifies a database

				ALTER DATABASE ...
				MODIFY ... (
					...
				);
			
			CREATE TABLE - creates a new table
			
				CREATE TABLE ... (
					...
				);
			
			ALTER TABLE - modifies a table
			
				ALTER TABLE ...
				ADD COLUMN ...
			
			DROP TABLE - deletes a table
			
				DROP TABLE ...
				
			CREATE INDEX - creates an index (search key)
			
				CREATE INDEX ... ON ...
			
			DROP INDEX - deletes an index
			
				ALTER TABLE ...
				DROP INDEX ...
				
	Project--MYSQL:
									CREATE TABLE actor (
									  actor_id    SMALLINT     UNSIGNED NOT NULL AUTO_INCREMENT, -- 16-bit unsigned int in the range of [0, 65535]
									  first_name  VARCHAR(45)  NOT NULL,
									  last_name   VARCHAR(45)  NOT NULL,
									  last_update TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY (actor_id),
									  KEY idx_actor_last_name (last_name)   -- To build index (non-unique) on last_name
									) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- Use InnoDB Engine, which supports foreign key and transaction. Use Unicode 'utf8' character set for this table
										   
									CREATE TABLE language (
									  language_id  TINYINT    UNSIGNED NOT NULL AUTO_INCREMENT, -- 8-bit unsigned int [0, 255]
									  name         CHAR(20)   NOT NULL,
									  last_update  TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY (language_id)
									) ENGINE=InnoDB DEFAULT CHARSET=utf8;
										   
									CREATE TABLE film (
									  film_id              SMALLINT     UNSIGNED NOT NULL AUTO_INCREMENT,
									  title                VARCHAR(255) NOT NULL,
									  description          TEXT         DEFAULT NULL,       -- Up to 64KB
									  release_year         YEAR         DEFAULT NULL,       -- 'yyyy'
									  language_id          TINYINT      UNSIGNED NOT NULL,  -- 8-bit unsigned int [0, 255]
									  original_language_id TINYINT      UNSIGNED DEFAULT NULL,
									  rental_duration      TINYINT      UNSIGNED NOT NULL DEFAULT 3,
									  rental_rate          DECIMAL(4,2) NOT NULL DEFAULT 4.99, -- DECIMAL is precise and ideal for currency [99.99]. UNSIGNED?
									  length               SMALLINT     UNSIGNED DEFAULT NULL,  -- 16-bit unsigned int [0, 65535]
									  replacement_cost     DECIMAL(5,2) NOT NULL DEFAULT 19.99, -- [999.99], UNSIGNED??
									  rating               ENUM('G','PG','PG-13','R','NC-17') DEFAULT 'G',
									  special_features     SET('Trailers','Commentaries','Deleted Scenes','Behind the Scenes') DEFAULT NULL, -- Can take zero or more values from a SET. But only one value from ENUM
									  last_update          TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY (film_id),
									  KEY idx_title (title),
									  KEY idx_fk_language_id (language_id),
									  KEY idx_fk_original_language_id (original_language_id), -- To build index on title, language_id, original_language_id and film_id (primary key)
									  CONSTRAINT fk_film_language FOREIGN KEY (language_id) REFERENCES language (language_id)
										ON DELETE RESTRICT ON UPDATE CASCADE, -- Cannot delete parent record if there is any matching child record. Update the matching child records if parent record is updated
									  CONSTRAINT fk_film_language_original FOREIGN KEY (original_language_id) REFERENCES language (language_id)
										ON DELETE RESTRICT ON UPDATE CASCADE
									) ENGINE=InnoDB DEFAULT CHARSET=utf8;
									
									CREATE TABLE film_actor (
									  actor_id     SMALLINT UNSIGNED NOT NULL,
									  film_id      SMALLINT UNSIGNED NOT NULL,
									  last_update  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY  (actor_id, film_id),
									  KEY idx_fk_film_id (`film_id`),
									  CONSTRAINT fk_film_actor_actor FOREIGN KEY (actor_id) REFERENCES actor (actor_id) 
										ON DELETE RESTRICT ON UPDATE CASCADE,
									  CONSTRAINT fk_film_actor_film FOREIGN KEY (film_id) REFERENCES film (film_id) 
										ON DELETE RESTRICT ON UPDATE CASCADE
									) ENGINE=InnoDB DEFAULT CHARSET=utf8;
									
									CREATE TABLE category (
									  category_id  TINYINT      UNSIGNED NOT NULL AUTO_INCREMENT,
									  name         VARCHAR(25)  NOT NULL,
									  last_update  TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY  (category_id)
									) ENGINE=InnoDB DEFAULT CHARSET=utf8;
									
									CREATE TABLE film_category (
									  film_id      SMALLINT   UNSIGNED NOT NULL,
									  category_id  TINYINT    UNSIGNED NOT NULL,
									  last_update  TIMESTAMP  NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
									  PRIMARY KEY (film_id, category_id),
									  CONSTRAINT fk_film_category_film FOREIGN KEY (film_id) REFERENCES film (film_id) 
										ON DELETE RESTRICT ON UPDATE CASCADE,
									  CONSTRAINT fk_film_category_category FOREIGN KEY (category_id) REFERENCES category (category_id) 
										ON DELETE RESTRICT ON UPDATE CASCADE
									) ENGINE=InnoDB DEFAULT CHARSET=utf8;
							
	Defining Foreign Key--MYSQL:
									CREATE TABLE `instructor` (
									…
										CONSTRAINT `FK_DETAIL` FOREIGN KEY (`instructor_detail_id`) REFERENCES `instructor_detail` (`id`)
									);
	Kiểu dữ liệu chuỗi--MYSQL:
		String Data Types:
			CHAR(size):							
												A FIXED length string (can contain letters, numbers, and special characters). The size parameter specifies the column length in characters - can be from 0 to 255. Default is 1

												CREATE TABLE example_char (
													id INT AUTO_INCREMENT PRIMARY KEY,
													product_code CHAR(10)
												);
												INSERT INTO example_char (product_code) VALUES ('SKU123456'), ('SKU987654');
			VARCHAR(size):						
												A VARIABLE length string (can contain letters, numbers, and special characters). The size parameter specifies the maximum column length in characters - can be from 0 to 65535
												
												CREATE TABLE example_varchar (
													id INT AUTO_INCREMENT PRIMARY KEY,
													email VARCHAR(255)
												);
												INSERT INTO example_varchar (email) VALUES ('user@example.com'), ('info@example.com');
			BINARY(size):						
												Equal to CHAR(), but stores binary byte strings. The size parameter specifies the column length in bytes. Default is 1
												
												CREATE TABLE example_binary (
													id INT AUTO_INCREMENT PRIMARY KEY,
													hash BINARY(32)
												);
												INSERT INTO example_binary (hash) VALUES (UNHEX('1a2b3c4d...')), (UNHEX('5e6f7g8h...'));
			VARBINARY(size):					
												Equal to VARCHAR(), but stores binary byte strings. The size parameter specifies the maximum column length in bytes.
												
												CREATE TABLE example_varbinary (
													id INT AUTO_INCREMENT PRIMARY KEY,
													image VARBINARY(1000000)
												);
												INSERT INTO example_varbinary (image) VALUES (LOAD_FILE('/path/to/image1.jpg')), (LOAD_FILE('/path/to/image2.jpg'));
			TINYBLOB:							
												For BLOBs (Binary Large OBjects). Max length: 255 bytes
												
												CREATE TABLE example_tinyblob (
													id INT AUTO_INCREMENT PRIMARY KEY,
													data TINYBLOB
												);
												INSERT INTO example_tinyblob (data) VALUES ('Some short text'), ('Another short text');
			TINYTEXT:							
												Holds a string with a maximum length of 255 characters
												
												CREATE TABLE example_tinytext (
													id INT AUTO_INCREMENT PRIMARY KEY,
													text TINYTEXT
												);
												INSERT INTO example_tinytext (text) VALUES ('Some short text'), ('Another short text');
			TEXT(size):							
												Holds a string with a maximum length of 65,535 bytes
												
												CREATE TABLE example_text (
													id INT AUTO_INCREMENT PRIMARY KEY,
													message TEXT(5000)
												);
												INSERT INTO example_text (message) VALUES ('Long text message 1'), ('Long text message 2');
			BLOB(size):							
												For BLOBs (Binary Large OBjects). Holds up to 65,535 bytes of data
												
												CREATE TABLE example_blob (
													id INT AUTO_INCREMENT PRIMARY KEY,
													binary_data BLOB(100000)
												);
												INSERT INTO example_blob (binary_data) VALUES (LOAD_FILE('/path/to/file1')), (LOAD_FILE('/path/to/file2'));
			MEDIUMTEXT:							
												Holds a string with a maximum length of 16,777,215 characters
												
												CREATE TABLE example_mediumtext (
													id INT AUTO_INCREMENT PRIMARY KEY,
													medium_text MEDIUMTEXT
												);
												INSERT INTO example_mediumtext (medium_text) VALUES ('Medium text message 1'), ('Medium text message 2');
			MEDIUMBLOB:							
												For BLOBs (Binary Large OBjects). Holds up to 16,777,215 bytes of data
												
												CREATE TABLE example_mediumblob (
													id INT AUTO_INCREMENT PRIMARY KEY,
													medium_binary MEDIUMBLOB
												);
												INSERT INTO example_mediumblob (medium_binary) VALUES (LOAD_FILE('/path/to/file1')), (LOAD_FILE('/path/to/file2'));
			LONGTEXT:							
												Holds a string with a maximum length of 4,294,967,295 characters
												
												CREATE TABLE example_longtext (
													id INT AUTO_INCREMENT PRIMARY KEY,
													long_text LONGTEXT
												);
												INSERT INTO example_longtext (long_text) VALUES ('Long text message 1'), ('Long text message 2');
			LONGBLOB:							
												For BLOBs (Binary Large OBjects). Holds up to 4,294,967,295 bytes of data
												
												CREATE TABLE example_longblob (
													id INT AUTO_INCREMENT PRIMARY KEY,
													long_blob_data LONGBLOB
												);
												INSERT INTO example_longblob (long_blob_data) VALUES (LOAD_FILE('/path/to/large_file1')), (LOAD_FILE('/path/to/large_file2'));
			ENUM(val1, val2, val3, ...):		
												A string object that can have only one value, chosen from a list of possible values. You can list up to 65535 values in an ENUM list. If a value is inserted that is not in the list,
												a blank value will be inserted. The values are sorted in the order you enter them
												
												CREATE TABLE example_enum (
													id INT AUTO_INCREMENT PRIMARY KEY,
													status ENUM('active', 'inactive', 'pending')
												);
												INSERT INTO example_enum (status) VALUES ('active'), ('inactive'), ('pending');
			SET(val1, val2, val3, ...):			
												A string object that can have 0 or more values, chosen from a list of possible values. You can list up to 64 values in a SET list
												
												CREATE TABLE example_set (
													id INT AUTO_INCREMENT PRIMARY KEY,
													options SET('option1', 'option2', 'option3', 'option4')
												);
												INSERT INTO example_set (options) VALUES ('option1,option2'), ('option2,option3'), ('option1,option3,option4');
		Numeric Data Types:
			BIT(size):							
												A bit-value type. The number of bits per value is specified in size. The size parameter can hold a value from 1 to 64. The default value for size is 1.
												
												CREATE TABLE example_bit (
													id INT AUTO_INCREMENT PRIMARY KEY,
													bit_data BIT(8)
												);
												INSERT INTO example_bit (bit_data) VALUES (B'10101010'), (B'11110000');
			TINYINT(size):						
												A very small integer. Signed range is from -128 to 127. Unsigned range is from 0 to 255. The size parameter specifies the maximum display width (which is 255)
												
												CREATE TABLE example_tinyint (
													id INT AUTO_INCREMENT PRIMARY KEY,
													tinyint_data TINYINT(4)
												);
												INSERT INTO example_tinyint (tinyint_data) VALUES (10), (-5);
			BOOL/BOOLEAN:								
												Zero is considered as false, nonzero values are considered as true.
												
												CREATE TABLE example_boolean (
													id INT AUTO_INCREMENT PRIMARY KEY,
													is_active BOOLEAN
												);
												INSERT INTO example_boolean (is_active) VALUES (TRUE), (FALSE);
			SMALLINT(size):						
												A small integer. Signed range is from -32768 to 32767. Unsigned range is from 0 to 65535. The size parameter specifies the maximum display width (which is 255)
												
												CREATE TABLE example_smallint (
													id INT AUTO_INCREMENT PRIMARY KEY,
													smallint_data SMALLINT(6)
												);
												INSERT INTO example_smallint (smallint_data) VALUES (100), (-50);
			MEDIUMINT(size):					
												A medium integer. Signed range is from -8388608 to 8388607. Unsigned range is from 0 to 16777215. The size parameter specifies the maximum display width (which is 255)
												
												CREATE TABLE example_mediumint (
													id INT AUTO_INCREMENT PRIMARY KEY,
													mediumint_data MEDIUMINT(9)
												);
												INSERT INTO example_mediumint (mediumint_data) VALUES (100000), (-50000);
			INT(size)/INTEGER(size):							
												A medium integer. Signed range is from -2147483648 to 2147483647. Unsigned range is from 0 to 4294967295. The size parameter specifies the maximum display width (which is 255)
												
												CREATE TABLE example_integer (
													id INT AUTO_INCREMENT PRIMARY KEY,
													int_data INT(11)
												);
												INSERT INTO example_integer (int_data) VALUES (1000000), (-500000);
			BIGINT(size):						
												A large integer. Signed range is from -9223372036854775808 to 9223372036854775807. Unsigned range is from 0 to 18446744073709551615. The size parameter specifies the maximum display width
												(which is 255)
												
												CREATE TABLE example_bigint (
													id INT AUTO_INCREMENT PRIMARY KEY,
													bigint_data BIGINT(20)
												);
												INSERT INTO example_bigint (bigint_data) VALUES (1000000000), (-500000000);
			FLOAT(size, d):						
												A floating point number. The total number of digits is specified in size. The number of digits after the decimal point is specified in the d parameter. This syntax is deprecated
												in MySQL 8.0.17, and it will be removed in future MySQL versions
												
												CREATE TABLE example_float (
													id INT AUTO_INCREMENT PRIMARY KEY,
													float_data FLOAT(8, 2)
												);
												INSERT INTO example_float (float_data) VALUES (1234.56), (-789.01);
			DOUBLE(size, d):					
												A normal-size floating point number. The total number of digits is specified in size. The number of digits after the decimal point is specified in the d parameter
												
												CREATE TABLE example_double (
													id INT AUTO_INCREMENT PRIMARY KEY,
													double_data DOUBLE(16, 4)
												);
												INSERT INTO example_double (double_data) VALUES (123456.789), (-987654.321);
			DECIMAL(size, d)/DEC(size, d):					
												An exact fixed-point number. The total number of digits is specified in size. The number of digits after the decimal point is specified in the d parameter. The maximum number for
												size is 65. The maximum number for d is 30. The default value for size is 10. The default value for d is 0.
												
												CREATE TABLE example_decimal (
													id INT AUTO_INCREMENT PRIMARY KEY,
													decimal_data DECIMAL(10, 5)
												);
												INSERT INTO example_decimal (decimal_data) VALUES (123.456), (-789.012);
		Date and Time Data Types:
			DATE:								
												Format: YYYY-MM-DD.
												A date. The supported range is from '1000-01-01' to '9999-12-31'
												
												CREATE TABLE example_date (
													id INT AUTO_INCREMENT PRIMARY KEY,
													date_data DATE
												);
												INSERT INTO example_date (date_data) VALUES ('2024-02-29'), ('2024-12-25');
			DATETIME(fsp):						
												Format: YYYY-MM-DD hh:mm:ss. 
												A date and time combination. The supported range is from '1000-01-01 00:00:00' to '9999-12-31 23:59:59'. Adding DEFAULT and ON UPDATE in the column
												definition to get automatic initialization and updating to the current date and time
												
												CREATE TABLE example_datetime (
													id INT AUTO_INCREMENT PRIMARY KEY,
													datetime_data DATETIME(3)
												);
												INSERT INTO example_datetime (datetime_data) VALUES ('2024-02-29 12:34:56.789'), ('2024-12-25 09:00:00.000');
			TIMESTAMP(fsp):						
												Format: YYYY-MM-DD hh:mm:ss. 
												A timestamp. TIMESTAMP values are stored as the number of seconds since the Unix epoch ('1970-01-01 00:00:00' UTC). The supported range is from
												'1970-01-01 00:00:01' UTC to '2038-01-09 03:14:07' UTC. Automatic initialization and updating to the current date and time can be specified using DEFAULT CURRENT_TIMESTAMP and
												ON UPDATE CURRENT_TIMESTAMP in the column definition
												
												CREATE TABLE example_timestamp (
													id INT AUTO_INCREMENT PRIMARY KEY,
													timestamp_data TIMESTAMP(6)
												);
												INSERT INTO example_timestamp (timestamp_data) VALUES ('2024-02-29 12:34:56.789'), ('2024-12-25 09:00:00.000');
			TIME(fsp):							
												Format: hh:mm:ss.
												A time. The supported range is from '-838:59:59' to '838:59:59'
												
												CREATE TABLE example_time (
													id INT AUTO_INCREMENT PRIMARY KEY,
													time_data TIME(2)
												);
												INSERT INTO example_time (time_data) VALUES ('12:34:56.78'), ('09:00:00.00');
			YEAR:								
												format: 1901 to 2155, and 0000.
												A year in four-digit format. Values allowed in four-digit. MySQL 8.0 does not support year in two-digit format.
												
												CREATE TABLE example_year (
													id INT AUTO_INCREMENT PRIMARY KEY,
													year_data YEAR
												);
												INSERT INTO example_year (year_data) VALUES (2024), (2025);
	Aliases--MySQL:
		Alias Column:
												SELECT 
													CONCAT(first_name, ' ', last_name) AS full_name,
													employee_id
												FROM 
													employees;
		Alias Table:
												SELECT 
													e.employee_id,
													e.first_name,
													e.last_name,
													d.department_name
												FROM 
													employees AS e
												JOIN 
													departments AS d ON e.department_id = d.department_id;
	ALTER TABLE--MySQL:
												The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.
												The ALTER TABLE statement is also used to add and drop various constraints on an existing table.
		ALTER TABLE - ADD Column:
												ALTER TABLE Customers
												ADD Email varchar(255);
		ALTER TABLE - DROP COLUMN:
												ALTER TABLE Customers
												DROP COLUMN Email;
		ALTER TABLE - MODIFY COLUMN:
												ALTER TABLE Persons
												MODIFY COLUMN DateOfBirth year;
		ALTER TABLE - DROP COLUMN:
												ALTER TABLE Persons
												DROP COLUMN DateOfBirth;
	ANY and ALL Operators--MySQL:
												The ANY and ALL operators allow you to perform a comparison between a single column value and a range of other values.
		ANY:
			Syntax:								
												SELECT column_name(s)
												FROM table_name
												WHERE column_name operator ANY
												  (SELECT column_name
												  FROM table_name
												  WHERE condition);
			Example:									
												SELECT 
													product_id,
													product_name,
													selling_price
												FROM 
													products
												WHERE 
													selling_price >= ANY (SELECT selling_price FROM products WHERE product_id <> 1);
		ALL:
			Syntax:
												SELECT ALL column_name(s)
												FROM table_name
												WHERE condition;
			
												SELECT column_name(s)
												FROM table_name
												WHERE column_name operator ALL
												  (SELECT column_name
												  FROM table_name
												  WHERE condition);
	
			Example:
												SELECT 
													product_id,
													product_name,
													selling_price
												FROM 
													products
												WHERE 
													selling_price > ALL (SELECT selling_price FROM products WHERE product_id <> 1);
	NOT Operator--MySQL:
		Syntax:
												SELECT column1, column2, ...
												FROM table_name
												WHERE NOT condition;
		Example:
												SELECT 
													employee_id,
													first_name,
													last_name
												FROM 
													employees
												WHERE 
													NOT job_title = 'Manager';
	AUTO INCREMENT Field--MySQL:
												Auto-increment allows a unique number to be generated automatically when a new record is inserted into a table.
												By default, the starting value for AUTO_INCREMENT is 1, and it will increment by 1 for each new record.
												
												CREATE TABLE Persons (
													Personid int NOT NULL AUTO_INCREMENT,
													LastName varchar(255) NOT NULL,
													FirstName varchar(255),
													Age int,
													PRIMARY KEY (Personid)
												);
												ALTER TABLE Persons AUTO_INCREMENT=100;
	BETWEEN Operator--MySQL:
												The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates.
												The BETWEEN operator is inclusive: begin and end values are included.
	
												SELECT 
													order_id,
													order_amount,
													order_date
												FROM 
													orders
												WHERE 
													order_amount BETWEEN 100 AND 500;

												SELECT 
													employee_id,
													first_name,
													last_name,
													job_title
												FROM 
													employees
												WHERE 
													job_title BETWEEN 'A%' AND 'M%';

												SELECT 
													appointment_id,
													appointment_date,
													client_name
												FROM 
													appointments
												WHERE 
													appointment_date BETWEEN '2024-01-01' AND '2024-01-31';
	CASE Statement--MySQL:
												The CASE statement goes through conditions and returns a value when the first condition is met (like an if-then-else statement). So, once a condition is true, it will stop reading
												and return the result. If no conditions are true, it returns the value in the ELSE clause.
		Syntax:
												CASE
													WHEN condition1 THEN result1
													WHEN condition2 THEN result2
													WHEN conditionN THEN resultN
													ELSE result
												END;
		Example:
												SELECT 
													employee_id,
													first_name,
													last_name,
													salary,
													CASE
														WHEN salary < 30000 THEN 'Low'
														WHEN salary >= 30000 AND salary < 60000 THEN 'Medium'
														ELSE 'High'
													END AS salary_category
												FROM 
													employees;
													
	Constraint--MySQL:
	
		CHECK Constraint--Contraint MySQL:
		
												- The CHECK constraint is used to limit the value range that can be placed in a column.
												- If you define a CHECK constraint on a column it will allow only certain values for this column.
												- If you define a CHECK constraint on a table it can limit the values in certain columns based on values in other columns in the row.
			
			CHECK on CREATE TABLE:
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														CHECK (Age>=18)
													);
													
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														City varchar(255),
														CONSTRAINT CHK_Person CHECK (Age>=18 AND City='Sandnes')
													);
			
			CHECK on ALTER TABLE:
			
													ALTER TABLE Persons
													ADD CHECK (Age>=18);
													
													ALTER TABLE Persons
													ADD CONSTRAINT CHK_PersonAge CHECK (Age>=18 AND City='Sandnes');
			
			DROP a CHECK Constraint:
			
													ALTER TABLE Persons
													DROP CHECK CHK_PersonAge;
		
		DEFAULT Constraint--Contraint MySQL:
		
													- The DEFAULT constraint is used to set a default value for a column.
													- The default value will be added to all new records, if no other value is specified.
			
			DEFAULT on CREATE TABLE:
			
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														City varchar(255) DEFAULT 'Sandnes'
													);
				
													CREATE TABLE Orders (
														ID int NOT NULL,
														OrderNumber int NOT NULL,
														OrderDate date DEFAULT CURRENT_DATE()
													);
			
			DEFAULT on ALTER TABLE:
			
													ALTER TABLE Persons
													ALTER City SET DEFAULT 'Sandnes';
			
			DROP a DEFAULT Constraint:
			
													ALTER TABLE Persons
													ALTER City DROP DEFAULT;
		
		NOT NULL Constraint--Contraint MySQL:
		
													- By default, a column can hold NULL values.
													- The NOT NULL constraint enforces a column to NOT accept NULL values.
													- This enforces a field to always contain a value, which means that you cannot insert a new record, or update a record without adding a value to this field.
			
			NOT NULL on CREATE TABLE:
			
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255) NOT NULL,
														Age int
													);
			
			NOT NULL on ALTER TABLE:
			
													ALTER TABLE Persons
													MODIFY Age int NOT NULL;
		
		PRIMARY KEY Constraint--Contraint MySQL:
		
													- The PRIMARY KEY constraint uniquely identifies each record in a table.
													- Primary keys must contain UNIQUE values, and cannot contain NULL values.
													- A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields).
													- Nếu chúng ta thiết lập ràng buộc PRIMARY KEY cho một cột thì dữ liệu trên các hàng của cột đó tuyệt đối không được trùng nhau.
													- Nếu chúng ta thiết lập ràng buộc PRIMARY KEY cho một tập hợp các cột thì dữ liệu trên các hàng của một tập hợp các cột đó tuyệt đối không được trùng nhau.
													- Khóa chính có nhiệm vụ lưu trữ giá trị duy nhất hay còn gọi là cơ sở dữ liệu SQL duy nhất. Đây chính là yếu tố được lưu thông xuyên suốt giữa các table.
			
			PRIMARY KEY on CREATE TABLE:
			
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														PRIMARY KEY (ID)
													);
		
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
													);
			
			PRIMARY KEY on ALTER TABLE:
			
													ALTER TABLE Persons
													ADD PRIMARY KEY (ID);
													
													ALTER TABLE Persons
													ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);
			
			DROP a PRIMARY KEY Constraint:
			
													ALTER TABLE Persons
													DROP PRIMARY KEY;
			
			Vô hiệu hóa khóa chính:
			
													ALTER INDEX ten_rang_buoc ON ten_bang
													DISABLE;
			
			Kích hoạt khóa chính:
			
													ALTER INDEX ten_rang_buoc ON ten_bang
													REBUILD;
		
		FOREIGN KEY Constraint--Contraint MySQL:

											- Ràng buộc khóa ngoại là một điều kiện áp dụng cho một hoặc nhiều cột trong một bảng cơ sở dữ liệu, định rõ quan hệ giữa bảng đó và một bảng khác (bảng cha và bảng con). Nói
											cách khác, nếu trong bảng cha có một giá trị khóa chính (primary key) nào đó, thì trong bảng con sẽ có một hoặc nhiều giá trị trong các cột liên kết phải tương ứng với giá
											trị đó.
											- Nó định nghĩa một mối quan hệ giữa bảng cha (primary key) và bảng con (foreign key) để đảm bảo rằng dữ liệu trong bảng con phụ thuộc vào dữ liệu trong bảng cha.											
											- Một hàng trong bảng con (bảng tham chiếu) phải chứa các giá trị tồn tại trong bảng cha.											
											- The table with the foreign key is called the child table, and the table with the primary key is called the referenced or parent table.
											- Khi bạn thực hiện các hành động như chèn (insert), cập nhật (update) hoặc xóa (delete) dữ liệu trong bảng, hệ thống sẽ kiểm tra xem các hành động này có làm mất tính
											toàn vẹn của ràng buộc khóa ngoại hay không. Nếu một hành động làm mất điều kiện ràng buộc này, hệ thống sẽ phát sinh lỗi vi phạm ràng buộc khóa ngoại.
											- The FOREIGN KEY constraint is used to prevent actions that would destroy links between tables.
											- A FOREIGN KEY is a field (or collection of fields) in one table, that refers to the PRIMARY KEY in another table.
											- Khóa ngoại được sử dụng để đảm bảo tính toàn vẹn và liên kết dữ liệu giữa các bảng.
											- Khi chúng ta tạo ra một bảng, thì chỉ lấy được thông tin của duy nhất bảng đó.Tuy nhiên một số trường hợp cần liên kết giữa các bảng lại với nhau để lấy thông tin của 2 hoặc
											nhiều bảng.Lúc này chúng ta sử dụng khóa ngoại để nối bảng, lấy những thông tin cần thiết giữa các bảng.
											
											- Giá trị của khóa ngoại chỉ có thể tồn tại với giá trị tồn tại trong bảng cha hoặc là null
													
			Vi phạm ràng buộc khóa ngoại--FOREIGN KEY Constraint:
			
				Nguyên tắc chung:
				
													- Giá trị của cột trong bảng cha mà khóa ngoại trong bảng con tham chiếu đến phải có trước và giá trị này là quan trọng nhất
													- Cập nhật giá trị của foreign key trong bảng con là null hoặc là giá trị bằng với giá trị trong bảng cha thì không gây ra lỗi
			
				Chèn dữ liệu không hợp lệ:

													Khi bạn thêm một bản ghi mới vào bảng con và giá trị của các cột liên kết không có trong bảng cha, ràng buộc khóa ngoại sẽ bị vi phạm.
													
				Cập nhật giá trị không hợp lệ:
				
											- Trong hầu hết các trường hợp, bạn nên cập nhật dữ liệu từ bảng cha trước, sau đó mới cập nhật dữ liệu từ bảng con. Điều này giúp tránh việc cập nhật dữ liệu từ bảng con mà có
											thể dẫn đến việc mất dữ liệu liên quan trong bảng cha.
											- Sau khi đã cập nhật dữ liệu từ bảng cha, bạn có thể tiếp tục cập nhật dữ liệu từ bảng con mà không gặp phải các vấn đề về ràng buộc khóa ngoại.												
											- Nếu bạn cập nhật giá trị trong cột liên kết của bảng cha mà giá trị này đang được sử dụng bởi một hoặc nhiều bản ghi trong bảng con, và sau đó giá trị mới không tồn tại
											trong bảng cha, ràng buộc khóa ngoại sẽ bị vi phạm. Điều quan trọng ở đây là giá trị mới mà bạn đang cập nhật không còn tồn tại trong bảng cha sau khi cập nhật được thực hiện.
											- Giả sử chúng ta có hai bảng: "Students" (học sinh) và "Grades" (điểm số). Bảng "Grades" có một cột "student_id" liên kết với cột "id" trong bảng "Students" thông qua một
											ràng buộc khóa ngoại. Nếu bạn cập nhật giá trị trong cột "id" của bảng "Students" mà giá trị mới không còn tồn tại trong bảng "Students", ràng buộc khóa ngoại sẽ bị vi phạm.
											Ví dụ, nếu bạn cố gắng cập nhật "id" của một học sinh trong bảng "Students" thành một giá trị mới, nhưng giá trị mới đó không tồn tại trong bảng "Students", thì việc này
											sẽ làm vi phạm ràng buộc khóa ngoại nếu bảng "Grades" đang sử dụng giá trị cũ của "id" đó.												
													
				Xóa giá trị chính trong bảng cha:
				
											- Khi bạn cố gắng xóa một giá trị khóa chính từ bảng cha mà có các bản ghi trong bảng con đang tham chiếu đến nó, việc này sẽ vi phạm ràng buộc khóa ngoại.
											- Trong hầu hết các trường hợp, nếu có thể, bạn nên xóa dữ liệu từ bảng con trước. Điều này giúp tránh việc xóa dữ liệu từ bảng cha mà có thể dẫn đến mất mát dữ liệu quan trọng
											trong bảng con (xóa như vậy để khóa dữ liệu trong bảng này sẽ không gây ảnh hưởng đến bảng khác).
											- Điều quan trọng là phải hiểu rõ cấu trúc cơ sở dữ liệu của bạn và các mối quan hệ giữa các bảng, cũng như các ràng buộc và hành vi được cấu hình cho các quan hệ
											khóa ngoại. Trong một số trường hợp, việc xóa dữ liệu từ bảng cha trước có thể là lựa chọn phù hợp, đặc biệt nếu bạn đã cấu hình ràng buộc khóa ngoại với ON DELETE CASCADE và
											không có dữ liệu quan trọng trong bảng con.

			Tác dụng của khóa ngoại trong dữ liệu--FOREIGN KEY Constraint:
			
				Đảm bảo tính toàn vẹn dữ liệu:
																			Khóa ngoại đảm bảo tính toàn vẹn dữ liệu bằng cách đảm bảo rằng mối quan hệ giữa các bảng được duy trì. Nó ngăn chặn việc chèn hoặc cập nhật dữ liệu
																			không hợp lệ trong bảng con, bảo vệ sự nhất quán của cơ sở dữ liệu.
				Quản lý mối quan hệ giữa các bảng:		
																			Khóa ngoại giúp quản lý mối quan hệ giữa các bảng trong cơ sở dữ liệu. Nó cho phép bạn liên kết dữ liệu từ các bảng khác nhau dựa trên cột khóa ngoại,
																			giúp truy vấn và thu thập thông tin từ nhiều bảng dễ dàng.
				Hành vi xóa và cập nhật kiểm tra:		
																			Thông qua tùy chọn ON DELETE và ON UPDATE, bạn có thể xác định hành vi khi xóa hoặc cập nhật bản ghi trong bảng cha. Điều này giúp bạn quản lý cách dữ
																			liệu trong bảng con phản ánh thay đổi trong bảng cha. Ví dụ, bạn có thể xóa tất cả các bản ghi con khi xóa một bản ghi cha (CASCADE) hoặc đặt các cột
																			khóa ngoại trong bảng con thành NULL khi xóa bản ghi cha (SET NULL).
				Ngăn chặn dữ liệu không hợp lệ:		
																			Khóa ngoại ngăn chặn dữ liệu không hợp lệ được chèn vào bảng con. Điều này đảm bảo rằng chỉ dữ liệu hợp lệ và thỏa mãn ràng buộc sẽ được thêm vào bảng
																			con, giúp bảo vệ tính toàn vẹn dữ liệu.
				Duyệt qua và thực hiện các thao tác dữ liệu liên quan:
																			Mối quan hệ khóa ngoại giúp bạn dễ dàng duyệt qua và thực hiện các thao tác dữ liệu liên quan. Ví dụ, bạn có thể lấy tất cả các đơn đặt hàng của một
																			khách hàng cụ thể, tính tổng giá trị đơn đặt hàng của họ hoặc tìm tất cả các đơn đặt hàng liên quan đến một sản phẩm cụ thể.
																			
			FOREIGN KEY on CREATE TABLE--FOREIGN KEY Constraint:
			
													CREATE TABLE Orders (
														OrderID int NOT NULL,
														OrderNumber int NOT NULL,
														PersonID int,
														PRIMARY KEY (OrderID),
														FOREIGN KEY (PersonID) REFERENCES Persons(PersonID) // Mỗi giá trị trong cột "PersonID" của bảng "Orders" phải tồn tại trong cột "PersonID" của bảng "Persons".
													);
													
			FOREIGN KEY on ALTER TABLE--FOREIGN KEY Constraint:
			
													ALTER TABLE Orders
													ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
													
													ALTER TABLE Orders
													ADD CONSTRAINT FK_PersonOrder
													FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
													
			DROP a FOREIGN KEY Constraint--FOREIGN KEY Constraint:
			
													ALTER TABLE Orders
													DROP FOREIGN KEY FK_PersonOrder;
													
			Tạo khóa ngoại trường hợp tham chiếu chính nó--FOREIGN KEY Constraint:
			
																	CREATE TABLE Employee(
																		id INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,
																		fullname VARCHAR(50) NOT NULL,
																		email VARCHAR (50) NOT NULL,
																		leader_id INT (11) NOT NULL,
																		CONSTRAINT pk_self FOREIGN KEY (leader_id) REFERENCES Employee(id) 
																	);
																	
			Tùy chọn ON DELETE khi thiết lập khóa ngoại--FOREIGN KEY Constraint:
			
													Lựa chọn hành động xảy ra trên các row của bảng con khi row trong bảng cha bị xóa đi
			
				DELETE NO ACTION:

										- NO ACTION là tùy chọn mặc định cho hành động DELETE trong ràng buộc khóa ngoại trong MySQL. Khi NO ACTION được sử dụng, hệ thống sẽ không thực hiện bất kỳ hành động nào mà có
										thể gây ra vi phạm ràng buộc khóa ngoại khi có thay đổi trong hàng cha. Tuy nhiên, hệ thống cũng sẽ không báo lỗi nếu xảy ra vi phạm.
										- Khi sử dụng DELETE NO ACTION, không có thứ tự xóa cụ thể đặc biệt được áp đặt. Thay vào đó, hệ thống sẽ không thực hiện bất kỳ hành động xóa nào trên dữ liệu khi có một
										hoặc nhiều dòng trong bảng cha (parent table, bảng chứa primary key, không chứa foreign key) được xóa.				
										- Specifies that the row in the parent table can be deleted if no other row depends on it. If a dependent row exists in the relationship, the DELETE fails. The check for
										dependent rows is performed at the end of the statement.
										
										CREATE TABLE OrderDetails (
											DetailID INT PRIMARY KEY,
											OrderID INT,
											ProductName VARCHAR(50),
											Quantity INT,
											FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE NO ACTION
										);
													
				DELETE RESTRICT:

										- Khi RESTRICT được sử dụng với hành động DELETE, nếu có một hoặc nhiều hàng con tham chiếu đến hàng cha mà sẽ bị xóa (chú ý là đang nói xóa dữ liệu ở bảng cha), hệ thống sẽ từ
										chối hành động xóa và báo lỗi.
										- RESTRICT yêu cầu không được phép thực hiện hành động xóa nếu nó có thể gây ra vi phạm ràng buộc khóa ngoại.
										- Trong hầu hết các trường hợp, RESTRICT và NO ACTION sẽ có hành vi tương tự khi xảy ra hành động DELETE. Tuy nhiên, RESTRICT là một lựa chọn rõ ràng hơn nếu bạn muốn hệ thống
										báo lỗi ngay lập tức khi có thay đổi dẫn đến vi phạm ràng buộc khóa ngoại.
										- Khi sử dụng DELETE RESTRICT, quy trình xóa dữ liệu giống như khi sử dụng DELETE NO ACTION, nghĩa là không có thứ tự xóa cụ thể được áp đặt. 													
										- Specifies that the row in the parent table can be deleted if no other row depends on it. If a dependent row exists in the relationship, the DELETE fails. The check for
										dependent rows is performed immediately.
										- For example, you cannot delete a department from the department table if it is still responsible for some project that is described by a dependent row in the project table.
										
										CREATE TABLE OrderDetails (
											DetailID INT PRIMARY KEY,
											OrderID INT,
											ProductName VARCHAR(50),
											Quantity INT,
											FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE RESTRICT
										);
													
				DELETE CASCADE:
													
										- Xóa 1 dòng trong bảng cha thì các row của bảng con có liên kết đến foreign key chứa trong bảng cha sẽ bị xóa , xóa riêng từng row trong bảng con vẫn không sao
										- DELETE CASCADE là một điều kiện trong các quan hệ cơ sở dữ liệu mà khi một dòng dữ liệu trong bảng cha (parent table) được xóa (deleted), tất cả các dòng dữ liệu trong
										bảng con (child table) liên quan sẽ được tự động xóa (deleted) theo.
										- Nói cách khác, khi bạn xóa một dòng dữ liệu từ bảng cha, tất cả các dòng dữ liệu trong bảng con mà có liên kết với dòng đó sẽ được xóa tự động mà không cần phải thực
										hiện thêm bất kỳ hành động nào.
										- Điều này thường được sử dụng khi bạn muốn đảm bảo tính toàn vẹn dữ liệu giữa các bảng và không muốn để lại dữ liệu không liên kết (orphans) trong cơ sở dữ liệu khi xóa
										dữ liệu từ bảng cha.
										- Specifies that first the designated rows in the parent table are deleted. Then, the dependent rows are deleted.
										- For example, you can delete a department by deleting its row in the department table. Deleting the row from the department table also deletes.								
										
										CREATE TABLE OrderDetails (
											DetailID INT PRIMARY KEY,
											OrderID INT,
											ProductName VARCHAR(50),
											Quantity INT,
											FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE CASCADE
										);
													
					Quy trình xóa theo DELETE CASCADE sẽ được thực hiện theo thứ tự sau:
					
						Xóa dữ liệu từ các bảng con (child tables):

													Trước tiên, hệ thống sẽ xóa dữ liệu từ các bảng con mà có ràng buộc khóa ngoại đến bảng cha (parent table) mà bạn đang xóa. Điều này đảm bảo rằng không có dữ liệu từ các
													bảng con được liên kết với bản ghi trong bảng cha sau khi bản ghi cha bị xóa.
													
						Xóa dữ liệu từ bảng cha (parent table):
						
													Sau khi xóa dữ liệu từ các bảng con, hệ thống sẽ tiếp tục xóa dữ liệu từ bảng cha.													
				DELETE SET NULL:
				
										- Xóa 1 dòng trong bảng cha thì các row của bảng con có liên kết đến foreign key chứa trong bảng cha sẽ được đưa về giá trị mặc định , xóa riêng từng row trong bảng con vẫn không sao
										- DELETE SET NULL là một điều kiện trong các quan hệ cơ sở dữ liệu (database) mà khi một dòng dữ liệu (record) trong một bảng cha (parent table) được xóa (deleted), các
										giá trị trong các cột liên kết với bảng con (child table) sẽ được đặt thành NULL.
										- Nói cách khác, khi bạn xóa một dòng dữ liệu từ bảng cha, các giá trị của các cột liên kết trong bảng con mà liên kết đến dòng dữ liệu đã bị xóa sẽ được đặt thành NULL tự động.
										- Điều này thường được sử dụng khi có mối quan hệ cha con giữa các bảng và bạn muốn duy trì tính toàn vẹn của dữ liệu.
										
										CREATE TABLE OrderDetails (
											DetailID INT PRIMARY KEY,
											OrderID INT,
											ProductName VARCHAR(50),
											Quantity INT,
											FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE SET NULL
										);
													
					Quy trình xóa theo DELETE SET NULL sẽ được thực hiện theo thứ tự sau:
					
						Cập nhật các cột liên kết trong các bảng con (child tables):
						
													Thay vì xóa dữ liệu từ các bảng con, hệ thống sẽ cập nhật các cột liên kết trong các bảng con để đặt giá trị của chúng thành NULL. Điều này sẽ làm mất mối quan hệ giữa
													các bản ghi trong bảng cha và bảng con.
													
						Xóa dữ liệu từ bảng cha (parent table):
						
													Sau khi cập nhật các cột liên kết trong các bảng con thành NULL, hệ thống sẽ tiếp tục xóa dữ liệu từ bảng cha.
													
				DELETE SET DEFAULT:			
				
													Specifies that each column of the foreign key in each dependent row is set to its default value. This means that the column is only set to its default value if it is a member
													of a foreign key that references the row being deleted. Only the dependent rows that are immediate descendants are affected.
													
													CREATE TABLE OrderDetails (
														DetailID INT PRIMARY KEY,
														OrderID INT,
														ProductName VARCHAR(50),
														Quantity INT,
														FOREIGN KEY (OrderID) REFERENCES Orders(OrderID) ON DELETE SET DEFAULT
													);
													
					Thứ tự xóa dữ liệu khi sử dụng DELETE SET DEFAULT:
					
						Cập nhật các cột liên kết trong các bảng con (child tables):
						
													Thay vì xóa dữ liệu từ các bảng con, hệ thống sẽ cập nhật các cột liên kết trong các bảng con thành giá trị mặc định được định nghĩa cho cột đó.
													
						Xóa dữ liệu từ bảng cha (parent table):
						
													Sau khi cập nhật các cột liên kết trong các bảng con thành giá trị mặc định, hệ thống sẽ tiếp tục xóa dữ liệu từ bảng cha.
													
			Cập Nhật Dữ Liệu (UPDATE)--FOREIGN KEY Constraint:
			
				NO ACTION:
				
											- Nếu một hàng trong bảng cha được cập nhật, hệ thống sẽ kiểm tra xem có bất kỳ hàng nào trong bảng con tham chiếu đến hàng đó hay không.
											- Nếu không có hàng nào trong bảng con tham chiếu đến hàng được cập nhật trong bảng cha, thì hệ thống sẽ cho phép cập nhật đó.
											- Tuy nhiên, nếu có bất kỳ hàng nào trong bảng con tham chiếu đến hàng đó, hệ thống sẽ từ chối thực hiện cập nhật và báo lỗi.
											- NO ACTION là tùy chọn mặc định cho hành động UPDATE trong ràng buộc khóa ngoại trong MySQL. Khi NO ACTION được sử dụng, hệ thống sẽ không thực hiện bất kỳ hành động nào mà có
											thể gây ra vi phạm ràng buộc khóa ngoại khi có thay đổi trong hàng cha. Tuy nhiên, hệ thống cũng sẽ không báo lỗi nếu xảy ra vi phạm.
											- Khi sử dụng UPDATE NO ACTION, không có thứ tự cập nhật cụ thể đặc biệt được áp đặt. Thay vào đó, hệ thống sẽ không thực hiện bất kỳ hành động cập nhật nào trên dữ liệu
											khi có một hoặc nhiều dòng trong bảng cha (parent table) được cập nhật.
											
											CREATE TABLE parents (
												id INT PRIMARY KEY
											);
											CREATE TABLE children (
												id INT PRIMARY KEY,
												parent_id INT,
												FOREIGN KEY (parent_id) REFERENCES parents(id) ON DELETE NO ACTION ON UPDATE NO ACTION
											);
											-- Khi cố gắng cập nhật hoặc xóa một hàng trong bảng "parents" mà có các hàng con tương ứng trong bảng "children":
											-- Hệ thống sẽ từ chối hành động và báo lỗi.
											INSERT INTO parents (id) VALUES (1), (2);
											INSERT INTO children (id, parent_id) VALUES (101, 1), (102, 1), (103, 2);
													
				RESTRICT:
				
											- Khi một hàng trong bảng cha được cập nhật (update), hệ thống sẽ kiểm tra xem có bất kỳ hàng nào trong bảng con tham chiếu đến hàng đó hay không.
											- Nếu có bất kỳ hàng nào trong bảng con tham chiếu đến hàng đó, hệ thống sẽ từ chối thực hiện cập nhật và báo lỗi.
											- Điều này đảm bảo rằng tính nhất quán của dữ liệu giữa các bảng được duy trì, và bạn phải giải quyết vấn đề ràng buộc trước khi thực hiện cập nhật.
											- Khi RESTRICT được sử dụng với hành động UPDATE, nếu có một hàng con tham chiếu đến hàng cha mà có giá trị được cập nhật, hệ thống sẽ từ chối hành động cập nhật và báo lỗi.
											RESTRICT yêu cầu không được phép thực hiện hành động cập nhật nếu nó có thể gây ra vi phạm ràng buộc khóa ngoại.
											- Trong hầu hết các trường hợp, RESTRICT và NO ACTION sẽ có hành vi tương tự khi xảy ra hành động UPDATE. Tuy nhiên, RESTRICT là một lựa chọn rõ ràng hơn nếu bạn muốn hệ thống
											báo lỗi ngay lập tức khi có thay đổi dẫn đến vi phạm ràng buộc khóa ngoại.
											- Khi sử dụng UPDATE RESTRICT, hệ thống không thực hiện bất kỳ thao tác cập nhật nào trên dữ liệu trong trường hợp có một hoặc nhiều dòng trong bảng cha (parent table)
											được cập nhật.
											
											CREATE TABLE departments (
												id INT PRIMARY KEY,
												name VARCHAR(100)
											);

											CREATE TABLE employees (
												id INT PRIMARY KEY,
												name VARCHAR(100),
												department_id INT,
												FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE RESTRICT ON UPDATE RESTRICT
											);
											INSERT INTO departments (id, name) VALUES (1, 'IT'), (2, 'HR');
											INSERT INTO employees (id, name, department_id) VALUES (101, 'John Doe', 1), (102, 'Jane Smith', 1), (103, 'Mike Johnson', 2);													
											UPDATE departments SET id = 10 WHERE id = 1; -- Khi cố gắng cập nhật giá trị id của phòng ban có id = 1 thành 10:
																								 -- Kết quả: Hệ thống sẽ từ chối cập nhật và báo lỗi vì có nhân viên thuộc phòng ban đó.					
				
				CASCADE:
				
											- Khi một hàng trong bảng cha được cập nhật (update), hệ thống sẽ tự động cập nhật các giá trị tham chiếu trong các hàng tương ứng của bảng con.
											- Cụ thể, tất cả các hàng trong bảng con mà tham chiếu đến hàng được cập nhật trong bảng cha sẽ cùng được cập nhật để phản ánh các thay đổi mới của hàng cha.
											- Hành động cập nhật này sẽ lan truyền xuống tất cả các hàng tham chiếu từ hàng cha, tạo ra một chuỗi các cập nhật tự động.
											- Thay đổi giá trị khóa chính trong bảng cha thì các giá trị khóa ngoại trong bảng con sẽ cập nhật bằng với giá trị đó
											
											CREATE TABLE departments (
												id INT PRIMARY KEY,
												name VARCHAR(100)
											);
											CREATE TABLE employees (
												id INT PRIMARY KEY,
												name VARCHAR(100),
												department_id INT,
												FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE CASCADE ON UPDATE CASCADE
											);
											INSERT INTO departments (id, name) VALUES (1, 'IT'), (2, 'HR');
											INSERT INTO employees (id, name, department_id) VALUES (101, 'John Doe', 1), (102, 'Jane Smith', 1), (103, 'Mike Johnson', 2);												
											UPDATE departments SET id = 10 WHERE id = 1; -- Khi cố gắng cập nhật giá trị id của phòng ban có id = 1 thành 10:
																								 -- Kết quả: Tất cả các nhân viên thuộc phòng ban có id = 1 sẽ được cập nhật tự động với department_id = 10.
																								 
					Thứ tự cập nhật dữ liệu sẽ là:
					
						Cập nhật dữ liệu trong bảng cha (parent table):
						
											Đầu tiên, hệ thống sẽ thực hiện cập nhật dữ liệu trong bảng cha theo các thay đổi được áp dụng. Điều này có nghĩa là nếu có bất kỳ thay đổi nào xảy ra trong các cột khóa
											chính hoặc các cột mà có liên kết khóa ngoại với bảng con, các dòng tương ứng trong bảng con sẽ được cập nhật theo.
													
						Cập nhật dữ liệu trong bảng con (child table):
						
											Sau khi dữ liệu trong bảng cha đã được cập nhật, hệ thống sẽ tiếp tục cập nhật dữ liệu trong bảng con nếu có bất kỳ thay đổi nào trong các cột mà liên kết với bảng cha
											thông qua ràng buộc khóa ngoại.
																						 
				SET NULL:
				
											- Khi một hàng trong bảng cha được cập nhật (update), hệ thống sẽ tự động đặt các giá trị tham chiếu trong các hàng tương ứng của bảng con thành NULL.
											- Cụ thể, tất cả các hàng trong bảng con mà tham chiếu đến hàng được cập nhật trong bảng cha sẽ có các giá trị tham chiếu của chúng đặt thành NULL.
											- Điều này đảm bảo rằng các hàng trong bảng con không còn liên kết với hàng cha sau khi hàng cha được cập nhật, và dữ liệu vẫn duy trì được tính nhất quán.
											- Thay đổi giá trị khóa chính trong bảng cha thì các giá trị khóa ngoại trong bảng con sẽ cập nhật là null
											
											CREATE TABLE departments (
												id INT PRIMARY KEY,
												name VARCHAR(100)
											);
											CREATE TABLE employees (
												id INT PRIMARY KEY,
												name VARCHAR(100),
												department_id INT,
												FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE SET NULL ON UPDATE SET NULL
											);
											INSERT INTO departments (id, name) VALUES (1, 'IT'), (2, 'HR');
											INSERT INTO employees (id, name, department_id) VALUES (101, 'John Doe', 1), (102, 'Jane Smith', 1), (103, 'Mike Johnson', 2);												
											UPDATE departments SET id = 10 WHERE id = 1; -- Khi cố gắng cập nhật giá trị id của phòng ban có id = 1 thành 10:
																								 -- Kết quả: Tất cả các nhân viên thuộc phòng ban có id = 1 sẽ được cập nhật tự động với department_id = NULL.
																								 
					Thứ tự cập nhật dữ liệu sẽ là:
					
						Cập nhật dữ liệu trong bảng cha (parent table):
						
											Đầu tiên, hệ thống sẽ thực hiện cập nhật dữ liệu trong bảng cha theo các thay đổi được áp dụng. Nếu giá trị của các cột khóa chính hoặc các cột mà có liên kết khóa ngoại với
											bảng con thay đổi, các dòng tương ứng trong bảng con sẽ được cập nhật để đặt các giá trị liên kết thành NULL.
													
						Cập nhật dữ liệu trong bảng con (child table):
						
											Sau khi dữ liệu trong bảng cha đã được cập nhật và các giá trị liên kết đã được đặt thành NULL, hệ thống sẽ không thực hiện bất kỳ thay đổi nào trên dữ liệu trong bảng con.																																											 

		UNIQUE Constraint--Contraint MySQL:
		
													The UNIQUE constraint ensures that all values in a column are different.
													Both the UNIQUE and PRIMARY KEY constraints provide a guarantee for uniqueness for a column or set of columns.
													A PRIMARY KEY constraint automatically has a UNIQUE constraint.
													However, you can have many UNIQUE constraints per table, but only one PRIMARY KEY constraint per table.
													
			UNIQUE Constraint on CREATE TABLE:
			
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														UNIQUE (ID)
													);
													
													CREATE TABLE Persons (
														ID int NOT NULL,
														LastName varchar(255) NOT NULL,
														FirstName varchar(255),
														Age int,
														CONSTRAINT UC_Person UNIQUE (ID,LastName)
													);
													
			UNIQUE Constraint on ALTER TABLE:
			
													ALTER TABLE Persons
													ADD UNIQUE (ID);
													
													ALTER TABLE Persons
													ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);
			DROP a UNIQUE Constraint:
													ALTER TABLE Persons
													DROP INDEX UC_Person;
	COUNT(), AVG() and SUM() Functions--MySQL:
		COUNT():
					Syntax:
												SELECT COUNT(column_name)
												FROM table_name
												WHERE condition;
					Example:
												SELECT COUNT(student_id) AS total_adults
												FROM students
												WHERE age >= 18;
		AVG():
					Syntax:
												SELECT AVG(column_name)
												FROM table_name
												WHERE condition;
					Example:
												SELECT subject, AVG(score) AS average_score
												FROM grades
												GROUP BY subject;
		SUM():
					Syntax:
												SELECT SUM(column_name)
												FROM table_name
												WHERE condition;
	
					Example:
												SELECT SUM(sale_amount) AS total_sales
												FROM sales;
	CREATE DATABASE Statement--MySQL:
												The CREATE DATABASE statement is used to create a new SQL database.
		Syntax:									CREATE DATABASE databasename;
		Example:								CREATE DATABASE testDB;
	CREATE INDEX Statement--MySQL::
												The CREATE INDEX statement is used to create indexes in tables.
												Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.
		CREATE INDEX:
			Syntax:								
												CREATE INDEX index_name
												ON table_name (column1, column2, ...);
			Example:									
												CREATE INDEX idx_lastname
												ON Persons (LastName);
												
												CREATE INDEX idx_pname
												ON Persons (LastName, FirstName);
		CREATE UNIQUE INDEX Syntax:
			Syntax:								
												CREATE UNIQUE INDEX index_name
												ON table_name (column1, column2, ...);
			Example:
												CREATE UNIQUE INDEX unique_name_index
												ON employees (first_name, last_name);
		DROP INDEX Statement:
												ALTER TABLE table_name
												DROP INDEX index_name;
	CREATE TABLE Statement--MySQL:
												The CREATE TABLE statement is used to create a new table in a database.
		Syntax:
												CREATE TABLE table_name (
													column1 datatype,
													column2 datatype,
													column3 datatype,
												   ....
												);
		Example:
												CREATE TABLE Persons (
													PersonID int,
													LastName varchar(255),
													FirstName varchar(255),
													Address varchar(255),
													City varchar(255)
												);
		Create Table Using Another Table:
			Syntax:
												CREATE TABLE new_table_name AS
												SELECT column1, column2,...
												FROM existing_table_name
												WHERE ....;
			Example:
												CREATE TABLE TestTable AS
												SELECT customername, contactname
												FROM customers;
	JOIN Keyword--MySQL:
	
												- Với join thì phần khác sẽ là 1, phần trùng là cấp nhân
												- JOIN là phép kết nối dữ liệu từ nhiều bảng lại với nhau, nối 2 bảng, 3 bảng.. với nhau. Khi bạn cần truy vấn các cột dữ liệu từ nhiều bảng khác nhau để trả về trong cùng một
												tập kết quả , bạn cần dùng JOIN. 2 bảng kết nối được với nhau khi có 1 trường chung giữa 2 bảng này.
												- Khi bạn sử dụng mệnh đề JOIN, bạn thường xuyên kết hợp dữ liệu từ các bảng dựa trên giá trị của các khóa ngoại và khóa chính
												- Sử dụng các câu lệnh JOIN trong SQL là cần thiết khi bạn cần truy vấn dữ liệu từ nhiều bảng cùng một lúc và kết hợp dữ liệu từ các bảng đó dựa trên các điều kiện.
												- Khi sử dụng 2 bảng trong mệnh đề FROM, SQL sẽ thực hiện một CROSS JOIN theo mặc định. Điều này có nghĩa là nó sẽ tạo ra một kết quả là tích Descartes của hai bảng, tức là nó
												sẽ kết hợp mọi hàng từ bảng này với mọi hàng từ bảng kia.
												- Trong các trường hợp phức tạp, bạn có thể cần kết hợp dữ liệu từ nhiều bảng và áp dụng các điều kiện phức tạp để trả về kết quả mong muốn.
												- JOIN bản chất là lọc ra các hàng theo như giá trị của các cột điều kiện
												- Nhìn chung, các bảng có liên quan với nhau qua các ràng buộc foreign key.
												- Một trong nhưng lợi ích chính của SQL là khả năng kết hợp dữ liệu từ hai hay nhiều bảng lại với nhau. Việc kết hợp các bảng lại như vậy gọi là JOIN, SQL sẽ tạo ra một bảng
												tạm thời chứa dữ liệu kết quả từ JOIN.
												- Trước khi tìm hiểu cú pháp mệnh đề join, trong một số trường hợp có thể lấy dữ liệu kết hợp của các bảng chỉ bằng cách đơn giản là dùng mệnh đề where
	
		Sử dụng WHERE::
		
												- Khi bạn muốn lọc dữ liệu dựa trên một điều kiện cụ thể.
												- Khi không cần kết hợp dữ liệu từ nhiều bảng, chỉ cần áp dụng điều kiện lọc cho một bảng cụ thể.
												- Khi bạn muốn thực hiện các phép so sánh đơn giản như bằng, lớn hơn, nhỏ hơn, khác nhau, vv.
		
		Sử dụng JOIN:
		
												- Khi bạn cần kết hợp dữ liệu từ hai hoặc nhiều bảng dựa trên một điều kiện liên kết.
												- Khi có mối quan hệ giữa các bảng và bạn muốn lấy thông tin từ cả hai bảng.
												- Khi cần thực hiện kết hợp theo nhiều điều kiện phức tạp hơn.
												- Chú ý 1 điều là JOIN hỗ trợ nhiều loại nối khác (left join, right join, inner join...) nhau nếu như chúng ta cần nối phức tạp, trong khi where thì không
		
		CROSS JOIN:								
												The CROSS JOIN keyword returns all records from both tables (table1 and table2).
			Syntax:
												SELECT column_name(s)
												FROM table1
												CROSS JOIN table2;
			Example:
												SELECT 
													e.first_name,
													e.last_name,
													d.department_name
												FROM 
													employees e
												CROSS JOIN 
													departments d;
													
												SELECT 
													employees.employee_id,
													employees.first_name,
													employees.last_name,
													departments.department_name,
													roles.role_name
												FROM 
													employees
												CROSS JOIN 
													departments
												CROSS JOIN 
													roles;
		INNER JOIN:
												The INNER JOIN keyword selects records that have matching values in both tables.
			Syntax:
												SELECT column_name(s)
												FROM table1
												INNER JOIN table2
												ON table1.column_name = table2.column_name;
			Example:
												SELECT 
													orders.order_id,
													orders.order_date,
													customers.first_name,
													customers.last_name
												FROM 
													orders
												INNER JOIN 
													customers ON orders.customer_id = customers.customer_id;
													
												SELECT 
													orders.order_id,
													customers.first_name AS customer_first_name,
													customers.last_name AS customer_last_name,
													products.product_name
												FROM 
													orders
												INNER JOIN 
													customers ON orders.customer_id = customers.customer_id
												INNER JOIN 
													products ON orders.product_id = products.product_id;
		LEFT JOIN:
												The LEFT JOIN keyword returns all records from the left table (table1), and the matching records (if any) from the right table (table2).
			Syntax:
												SELECT column_name(s)
												FROM table1
												LEFT JOIN table2
												ON table1.column_name = table2.column_name;
			Example:
												SELECT 
													employees.employee_id,
													employees.first_name,
													employees.last_name,
													departments.department_name
												FROM 
													employees
												LEFT JOIN 
													departments ON employees.department_id = departments.department_id;
		RIGHT JOIN:
												The RIGHT JOIN keyword returns all records from the right table (table2), and the matching records (if any) from the left table (table1).
			Syntax:
												SELECT column_name(s)
												FROM table1
												RIGHT JOIN table2
												ON table1.column_name = table2.column_name;
			Example:
												SELECT 
													orders.order_id, 
													customers.first_name, 
													customers.last_name, 
													orders.order_date
												FROM 
													orders
												RIGHT JOIN 
													customers ON orders.customer_id = customers.customer_id;
		Self Join:
												A self join is a regular join, but the table is joined with itself.
			Syntax:
												SELECT column_name(s)
												FROM table1 T1, table1 T2
												WHERE condition;
			Example:
												SELECT 
													e.employee_id,
													e.employee_name AS employee_name,
													m.employee_name AS manager_name
												FROM 
													employees T1,
													employees T2
												WHERE 
													T1.manager_id = T2.employee_id;
	DELETE Statement--MySQL:
												The DELETE statement is used to delete existing records in a table.
		Syntax:
												DELETE FROM table_name WHERE condition;
		Example:
												DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste';
												
												DELETE FROM Customers;
	DROP DATABASE Statement--MySQL:
												The DROP DATABASE statement is used to drop an existing SQL database.
		Syntax:
												DROP DATABASE databasename;
												Tip: Make sure you have admin privilege before dropping any database. Once a database is dropped, you can check it in the list of databases with the following SQL
												command: SHOW DATABASES;
		Example:
												DROP DATABASE testDB;
	DROP TABLE Statement--MySQL:	
												The DROP TABLE statement is used to drop an existing table in a database.
		Syntax:
												DROP TABLE table_name;
												Note: Be careful before dropping a table. Deleting a table will result in loss of complete information stored in the table!
		Example:
												DROP TABLE Shippers;
	TRUNCATE TABLE--MySQL:
												The TRUNCATE TABLE statement is used to delete the data inside a table, but not the table itself.
		Syntax:
												TRUNCATE TABLE table_name;
		Example:
												TRUNCATE TABLE employees;
	EXISTS Operator--MySQL:
												The EXISTS operator is used to test for the existence of any record in a subquery.
												The EXISTS operator returns TRUE if the subquery returns one or more records.
		Syntax:
												SELECT column_name(s)
												FROM table_name
												WHERE EXISTS
												(SELECT column_name FROM table_name WHERE condition);
		Example:
												// kiểm tra xem có khách hàng nào đã đặt hàng hay không.
												SELECT CustomerName
												FROM Customers
												WHERE EXISTS (
													SELECT *
													FROM Orders
													WHERE Customers.CustomerID = Orders.CustomerID // kiểm tra từng Customers.CustomerID trong Customers thỏa điều kiện
												);
												
	GROUP BY Statement và Aggregate Functions--MySQL:
	
						- Group by là nhóm các giá trị bằng nhau trong 1 cột về 1 row duy nhất
						- Hàm tổng hợp trong mệnh đề có group by sẽ tính theo nhóm group by, trong mệnh đề không có group by sẽ tính với tất cả row. Nếu trong group by mà select không theo hàm tổng hợp
						hoặc không phải cột được group by sẽ gây ra lỗi, trừ trường hợp nếu nó chỉ có 1 kết quả duy nhất theo cột group by thì mới không gây ra lỗi
						- Nếu đã có group by thì bất kì select nào cũng phải thuộc group by hoặc aggregate function.
						- Trong SQL, khi bạn sử dụng các hàm tổng hợp (aggregate functions) như SUM(), COUNT(), AVG(), MAX(), MIN(), nhưng không có câu lệnh GROUP BY, thì hàm tổng hợp sẽ áp dụng trên
						toàn bộ tập kết quả của truy vấn, không phân nhóm dữ liệu. Kết quả trả về sẽ là một giá trị duy nhất đại diện cho tất cả các hàng trong tập dữ liệu.
						- Nếu bạn muốn tính toán tổng hợp trên toàn bộ bảng hoặc một phần của bảng mà không cần phân nhóm, bạn có thể sử dụng các hàm tổng hợp mà không cần câu lệnh GROUP BY. Trong
						trường hợp này, hàm tổng hợp sẽ được áp dụng cho toàn bộ tập hợp kết quả.
						- Chỉ các cột GROUP BY có thể được dùng bao gồm trong mệnh đề SELECT. Để dùng các cột khác trong SELECT, dùng hàm tổng hợp.
						- Bất kỳ một cột hay biểu thức trong danh sách của SELECT không phải là hàm nhóm dữ liệu thì phải có mệnh đề GROUP BY (nếu không có thì trong 1 group by của 1 cột sẽ có nhiều
						giá trị của một cột SELECT khác mà không có group by, lúc đó tạo nên nhiều row với các giá trị khác nhau phá vỡ nguyên tắc group by)
						- Trong hệ quản trị cơ sở dữ liệu, các hàm tổng hợp là một hàm trong đó các giá trị của nhiều hàng được gom nhóm lại với nhau để làm đầu vào cho các tiêu chí nhất định để tạo
						thành một giá trị duy nhất có ý nghĩa quan trọng hơn.
						- The GROUP BY statement is often used with aggregate functions (COUNT(), MAX(), MIN(), SUM(), AVG()) to group the result-set by one or more columns.																
						- Không thể sử dụng mệnh đề WHERE để giới hạn bớt các nhóm; Sử dụng mệnh đề HAVING để lọc bớt các nhóm; Không được phép sử dụng các hàm nhóm dữ liệu trong mệnh đề WHERE.
						- Đứng sau mệnh đề WHERE nếu có và trước HAVING.
						- Có thể bao gồm một hoặc nhiều cột để tạo thành một hoặc nhiều nhóm dựa trên cột đó.
						- Những cột nào select mới theo nguyên tắc, còn những cột mà không select thì sẽ không bị ảnh hưởng
						- Hàm tổng hợp sẽ được tính toán theo vùng của từng nhóm group by
						- Đôi khi có thể select 1 cột bình thường khi cột đó không phải là hàm tổng hợp hay là group by trong câu sql có group by nếu cột đó có giá trị riêng biệt đối với mỗi phần của cột group by
						- Where không check theo group by mà chỉ là lọc dữ liệu trước khi group by, để lọc dữ liệu sau khi group by ta dùng having
						- Mệnh đề group by cũng phải thỏa điều kiện chứa cột group by hoặc là hàm tổng hợp với 1 cột thường
												
		Syntax:
												
												SELECT column_name(s)
												FROM table_name
												WHERE condition
												GROUP BY column_name(s)
												ORDER BY column_name(s);
		
		Example:
												
												SELECT 
													product_id,
													product_name,
													SUM(sale_amount) AS total_sales
												FROM sales
												GROUP BY product_id, product_name
												HAVING SUM(sale_amount) > 1000;
		
												select code30.CD_TP_ID, count(code20.FK_CD_TP_ID)
												from tb_m00_codes030 code30 
												join tb_m00_codes020 code20
													on code30.CD_TP_ID = code20.CD_TP_ID
												group by code30.CD_TP_ID
												
												--Sai:
												SELECT DEPARTMENT_ID, AVG(SALARY)
												FROM EMPLOYEES
												 
												--Đúng:
												SELECT DEPARTMENT_ID, AVG(SALARY)
												FROM EMPLOYEES
												GROUP BY DEPARTMENT_ID
												
												SELECT DEPARTMENT_ID, SUM(SALARY)
												FROM EMPLOYEES
												WHERE DEPARTMENT_ID IN(10, 20, 30)
												GROUP BY DEPARTMENT_ID
												HAVING SUM(SALARY) > 10000
												ORDER BY DEPARTMENT_ID
			
			Ví dụ với Aggregate function:
			
												+------------+----------+-------------+-------+
												|IDChuyenmuc |  Muccon  |Chuyenmuclon | Sobai |
												+------------+----------+-------------+-------+
												|    1       |SQL Server|Lap trinh    | 101   |
												|    2       |Facebook  |Mang xa hoi  | 152   |
												|    3       |Python    |Lap trinh    | 101   |
												|    4       |JavaScript|Lap trinh    | 122   |
												|    5       |Chrome    |Web          | 94    |
												|    6       |Instagram |Mang xa hoi  | 165   |
												+------------+----------+-------------+-------+								
				
				Dùng hàm SUM:

												SELECT Chuyenmuclon, SUM(Sobai) AS "Tong"
												FROM [Quantrimang.com]
												GROUP BY Chuyenmuclon;
												
												+--------------+------+
												| Chuyenmuclon | Tong |
												+--------------+------+
												|Lap trinh     | 324  |
												|Mang xa hoi   | 317  |
												|Web           | 94   |
												+--------------+------+
												
				Dùng hàm COUNT:
											
												SELECT COUNT(Chuyenmuclon), Chuyenmuclon
												FROM [Quantrimang.com]
												WHERE Chuyenmuclon = 'Lap trinh'
												GROUP BY Chuyenmuclon;
												
												+------+--------------+
												|      | Chuyenmuclon |
												+------+--------------+
												|  3   |  Lap trinh   |
												+------+--------------+
												
				Dùng hàm MIN:
				
												SELECT Chuyenmuclon, MIN(Sobai) AS 'So luong it nhat'
												FROM [Quantrimang.com]
												GROUP BY Chuyenmuclon;

												+--------------+------------------+
												| Chuyenmuclon | So luong it nhat |
												+--------------+------------------+
												|Lap trinh     | 101              |
												|Mang xa hoi   | 152              |
												|Web           | 94               |
												+--------------+------------------+	

				Dùng hàm MAX:

												SELECT Chuyenmuclon, MAX(Sobai) AS 'So bai cao nhat'
												FROM [Quantrimang.com]
												GROUP BY Chuyenmuclon;

												+--------------+------------------+
												| Chuyenmuclon | So bai cao nhat  |
												+--------------+------------------+
												|Lap trinh     | 122              |
												|Mang xa hoi   | 165              |
												|Web           | 94               |
												+--------------+------------------+	

				Dùng với mệnh đề HAVING:

												SELECT r.name, COUNT(*) AS albums
												FROM albums l, artists r
												WHERE artist_id=r.id
												GROUP BY artist_id
												HAVING albums > 1;
												
												+------------+--------+
												| name       | albums |
												+------------+--------+
												| Pink Floyd | 2      |
												| Adele      | 2      |
												+------------+--------+			

				Các ví dụ khác:
				
					Ví dụ 1:

												Tính toán miễn là cột còn lại có trong hàm tổng hợp là vẫn thỏa điều kiện
												
												SELECT Request_at as Day,
													   ROUND(COUNT(IF(Status != 'completed', TRUE, NULL)) / COUNT(*), 2) AS 'Cancellation Rate'
												FROM Trips // Chú ý việc code sẽ đi từ đây thay vì bắt đầu từ select, select luôn là cuối cùng
												WHERE (Request_at BETWEEN '2013-10-01' AND '2013-10-03')
													  AND Client_id NOT IN (SELECT Users_Id FROM Users WHERE Banned = 'Yes')
												GROUP BY Request_at;
												
												select t.Request_at Day, 
													   round(sum(case when t.Status like 'cancelled_%' then 1 else 0 end)/count(*),2) Rate
												from Trips t 
												inner join Users u 
												on t.Client_Id = u.Users_Id and u.Banned='No'
												where t.Request_at between '2013-10-01' and '2013-10-03'
												group by t.Request_at
												
												SELECT T.request_at AS Day,
													ROUND(SUM(CASE
															WHEN T.status = 'cancelled_by_driver' OR T.status = 'cancelled_by_client' THEN 1
															ELSE 0
														END) / SUM(1), 2) AS 'Cancellation Rate' // SUM(1) sẽ tính tổng của giá trị 1 cho mỗi hàng trong tập kết quả của truy vấn, tương tự như COUNT(*).
												FROM Trips AS T, Users AS U1, Users AS U2
												WHERE   (T.driver_id =  U1.users_id AND U1.role = 'driver' AND U1.banned = 'No')
														AND (T.client_id =  U2.users_id AND U2.role = 'client' AND U2.banned = 'No')
														AND T.request_at BETWEEN '2013-10-01' AND '2013-10-03'
												GROUP BY T.request_at
												ORDER BY T.request_at
												
												select distinct product_id, 10 as price
												from Products
												group by product_id
												having (min(change_date) > "2019-08-16")
												union
												select p2.product_id, new_price
												from Products p2
												where (p2.product_id, p2.change_date) in
												(
													select product_id, max(change_date) as recent_date
													from Products
													where change_date <= "2019-08-16"
													group by product_id
												)
												
												select requester_id as id,
													(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
												from RequestAccepted
												group by requester_id
												union 
												select accepter_id as id,
													(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
												from RequestAccepted
												group by accepter_id
												order by num desc limit 1;
												
												// group by sau chỉ cho phần select trong (), select đầu không theo group by nên sẽ tính cho tất cả row
												SELECT ROUND(COUNT(t2.player_id)/COUNT(t1.player_id),2) AS fraction
												FROM
												(SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id) t1
												LEFT JOIN Activity t2
												ON t1.player_id = t2.player_id AND t1.first_login = t2.event_date - 1
												
												// mỗi id sẽ có mỗi name riêng nên không cần hàm tổng hợp cho cột name
												Select m.name
												from employee as e
												inner join employee as m
												on e.managerId=m.id
												group by e.managerId 
												having count(e.id)>=5

												
												
												
	Window Functions--MySQL:
													
							- Mysql hỗ trợ window functions, tức là đối với mỗi hàng từ câu truy vấn, thực hiện phép tính bằng cách sử dụng các hàng liên quan đến hàng đó. Hầu hết các Aggregate Function
							(COUNT, SUM, MAX, MIN, . . .) cũng có thể sử dụng như các Window Functions khi kết hợp với OVER().
							- Chú ý PARTITION BY tạo thành 1 phạm vi mới, nghĩa là khi mới vào phạm vi sẽ bắt đầu lại, khi ra khỏi phạm vi sẽ kết thúc cho phạm vi đó
							- Khi bạn sử dụng window function với mệnh đề OVER() mà không có PARTITION BY, window function đó sẽ được áp dụng trên toàn bộ tập kết quả của truy vấn, tương tự như cách mà
							một hàm tổng hợp hoạt động trên toàn bộ dữ liệu khi không có GROUP BY.
							- Vẫn đầy đủ các row chứ không gom row theo group như group by
		
		Phân tích thành phần Window Functions--Window Functions MySQL:
		
							- Một Window Function được định nghĩa khi có mệnh đề OVER() đi kèm sau lệnh gọi hàm.
													
		OVER([partition_clause] [order_clause] [frame_clause])--Window Functions MySQL:
		
							- Chú ý: khi đã sử dụng frame_clause thì bắt buộc phải sử dụng order_clause nếu không MYSQL sẽ không biết vị trị thứ tự các row để tạo ra Frame
							
							partiiton_clause: 	
							
												Đối với Aggregate Functions khi muốn nhóm các row liên quan lại với nhau thì chúng ta sử dụng GROUP BY, thì ở Window Functions cũng có, đó chính là
												PARTITION BY , partition sẽ nhóm các rows liên quan đến row hiện tại thành 1 cửa sổ làm việc(window) để thực hiện tính toán. Như ví dụ ở Query3 mình có sử
												dụng [partition by category].
												
							order_clause: 		cũng giống như ORDER BY bình thường, sắp xếp các rows trong cửa sổ làm việc
							frame_clause: 		sử dụng trong trường hợp bạn muốn giới hạn các rows trong partition --> Window Frame
							
							OVER (
								PARTITION BY category 
								ORDER BY id 
								ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
							)
							
							SELECT
								student_id,
								test_id,
								score,
								AVG(score) OVER(PARTITION BY student_id) AS average_score,
								AVG(score) OVER() AS class_average
							FROM
								scores;
							
							select *, sum(quantity_warehouse) over(partition by category) as total_warehouse
							from products
													
			Trường hợp OVER empty:
			
							- OVER( ) --> toàn bộ dữ liệu của bảng được coi là 1 khối - window
													
		Mệnh đề partition--Window Functions MySQL:
		
							- Mệnh đề này dùng để lọc bảng dựa trên các thuộc tính thành các vùng. Windown funtion được hoạt động trong từng vùng, khi vượt qua ranh giới của vùng đó, nó sẽ được khởi
							tạo lại.
							- Dưới đây là cú pháp của mệnh đề:
										PARTITION BY <expression>[{,<expression>...}]
										Trong cú pháp này, chúng ta có thể truyền 1 hay nhiều biểu thức ngăn cách nhau bởi dấu phẩy.
		
		Mệnh đề order by--Window Functions MySQL:
		
							Mệnh đề này dùng để sắp xếp các hàng trong một vùng với cú pháp:
										ORDER BY <expression> [ASC|DESC], [{,<expression>...}]
										Chúng ta có thể sắp xếp nhiều trường theo các thứ tự khác nhau. Mệnh đề có thể định nghĩa với một hay nhiều điều kiện ngăn cách nhau bởi dấu phẩy.
		
		ROW_NUMBER()--Window Functions MySQL:
		
							- Tên hàm đã nói lên tất cả, đánh số thứ tự các bản ghi theo thứ tự order với từng partition. Ví dụ: đánh số thứ tự học sinh theo từng lớp chẳng hạn.
							- Đánh số thứ tự học sinh theo class_id, nghĩa là trong 1 class_id sẽ bắt đầu từ 1, sang class_id khác lại bắt đầu từ 1
							
							SELECT row_number() over(PARTITION BY s.class_id ORDER BY s.name) AS STT,
								   c.name AS class_name,
								   s.*
							FROM students AS s
							JOIN classes AS c ON s.class_id = c.id
		
		RANK()--Window Functions MySQL:
		
							Xếp rank, vâng. Thật sự là trong quá trình làm việc, mình rất hay ĐƯỢC Khách hàng yêu cầu lấy data để điều tra, tracking, xếp rank trao thưởng, bla bla. . . Xếp rank ở đây
							không đơn giản là chỉ order nó ra là xong đâu, còn phải lấy vị trí xếp rank rồi xếp rank theo tiêu chí gì gì nữa cơ.
							
							// lấy vị trí ranking
							Select *, rank() over(order by score_AVG DESC) as ranking from students
							
							// xếp rank theo lớp
							SELECT c.name,
								   s.*,
								   rank() over(PARTITION BY s.class_id ORDER BY s.score_AVG DESC) AS ranking
							FROM students AS s
							JOIN classes AS c ON s.class_id = c.id
		
		dense_rank()--Window Functions MySQL:
		
													Nó tương tự như hàm Rank() nhưng thứ tự xếp rank sẽ theo thứ tự lần lượt chứ không có nhảy cóc từ 1 -> 3
													
													SELECT c.name,
														   s.*,
														   dense_rank() over(PARTITION BY s.class_id  ORDER BY s.score_AVG DESC) AS ranking
													FROM students AS s
													JOIN classes AS c ON s.class_id = c.id
													
		LAG() và LEAD()--Window Functions MySQL:
		
													- 2 hàm này khá hữu ích cho việc tracking sự phát triển, doanh thu của một công ty theo tháng, hay tiến độ học tập của học sinh qua từng năm theo từng môn học.
													- Bằng cách so sánh row hiện tại với các row trước - LAG() hay các row sau - LEAD().
													- LAG(heighs, 2, -1) được sử dụng để tính toán giá trị của cột heighs ở hàng trước đó (cách đó là 2 hàng) trong mỗi nhóm được phân vùng bởi cột name, sắp xếp theo
													cột years tăng dần. Nếu không có giá trị trước đó (ví dụ, nếu hàng hiện tại là hàng đầu tiên trong phân vùng), thì giá trị mặc định sẽ là -1.
													- Chú ý select lần lượt theo cùng 1 row chung
			
													SELECT *,
														   LAG(heighs) OVER(PARTITION BY name ORDER BY years ASC) AS LAG_heigh,
														   (heighs - LAG(heighs) OVER(PARTITION BY name ORDER BY years ASC)) AS LAG_DIFF,
														   LEAD(heighs) OVER(PARTITION BY name ORDER BY years ASC) AS LEAD_heigh,
														   LAG(heighs, 2, -1) OVER(PARTITION BY name ORDER BY years ASC) AS LAG_heigh2
													FROM heigh_infos
			LAG(expr [, N[, default]]):
													Hàm trả về giá trị của n hàng trước kể từ row hiện tại, nếu không tồn tại hàng đó thì trả về giá trị default. Trường hợp để trống N & default thì mặc định N = 1 và
													default = NULL.
			LEAD(expr [, N[, default]]):
													Tương tự như hàm LAG nhưng là trả về giá trị của hàng sau tính từ row hiện tại.
		
		FIRST_VALUE() & LAST_VALUE() & NTH_VALUE()--Window Functions MySQL:
		
													2 hàm trước (LAG - LEAD) thì trả về giá trị của n hàng trước/sau kể từ row hiện tại
													3 hàm này thì trả về vị trí đầu, cuối hoặc bất kì của partition - window dựa vào thứ tự ORDER BY
				Syntax:
													FIRST_VALUE(expr)
													LAST_VALUE(expr)
													NTH_VALUE(exp, n)
				Example:
													SELECT *,
														   FIRST_VALUE(heighs) OVER(
																PARTITION BY name
																ORDER BY heighs ASC 
																ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS min_heigh,
														   LAST_VALUE(heighs) OVER(
																PARTITION BY name
																ORDER BY heighs ASC 
																ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS max_heigh,
														   NTH_VALUE(heighs, 3) OVER(
																PARTITION BY name
																ORDER BY heighs ASC 
																ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS random_heigh
													FROM heigh_infos
													
		Example--Window Functions MySQL:
		
													// Không có vùng partition by nên sẽ không khởi tạo lại giá trị
													| order_date | amount |
													|------------|--------|
													| 2024-01-01 | 100    |
													| 2024-02-01 | 200    |
													| 2024-03-01 | 150    |
													| 2024-04-01 | 300    |	
													SELECT 
														order_date,
														amount,
														SUM(amount) OVER (ORDER BY order_date) AS cumulative_sum
													FROM 
														sales;														
													| order_date | amount | cumulative_sum |
													|------------|--------|---------------|
													| 2024-01-01 | 100    | 100           |
													| 2024-02-01 | 200    | 300           |
													| 2024-03-01 | 150    | 450           |
													| 2024-04-01 | 300    | 750           |
													
													// Khi ra khỏi vùng partition by thì sẽ khởi tạo lại giá trị
													| order_date | customer_id | amount |
													|------------|-------------|--------|
													| 2024-01-01 | 1           | 100    |
													| 2024-02-01 | 2           | 200    |
													| 2024-03-01 | 1           | 150    |
													| 2024-04-01 | 3           | 300    |
													| 2024-05-01 | 2           | 50     |
													SELECT 
														order_date,
														customer_id,
														amount,
														SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS cumulative_sum_by_customer
													FROM 
														orders;
													| order_date | customer_id | amount | cumulative_sum_by_customer |
													|------------|-------------|--------|---------------------------|
													| 2024-01-01 | 1           | 100    | 100                       |
													| 2024-03-01 | 1           | 150    | 250                       |
													| 2024-02-01 | 2           | 200    | 200                       |
													| 2024-05-01 | 2           | 50     | 250                       |
													| 2024-04-01 | 3           | 300    | 300                       |

			Ví dụ khác:
			
				Ví dụ 1:

													SaleID	Salesperson	SaleAmount	SaleDate
													1		Alice		300			2023-01-01
													2		Bob			150			2023-01-02
													3		Alice		200			2023-01-03
													4		Charlie		250			2023-01-04
													5		Bob			300			2023-01-05
													6		Alice		100			2023-01-06
													7		Charlie		350			2023-01-07
													8		Alice		450			2023-01-08
													9		Bob			200			2023-01-09
													10		Charlie		400			2023-01-10
													11		Alice		150			2023-01-11
													12		Bob			250			2023-01-12
													13		Charlie		300			2023-01-13
													14		Alice		350			2023-01-14
													15		Bob			100			2023-01-15
													
													SELECT 
													  SaleID, 
													  Salesperson, 
													  SaleAmount, 
													  SaleDate, 
													  SUM(SaleAmount) OVER (ORDER BY SaleDate) AS RunningTotal
													FROM Sales;
													SaleID	SaleDate	Salesperson	SaleAmount	RunningTotal
													1		2023-01-01	Alice		300			300
													2		2023-01-02	Bob			150			450
													3		2023-01-03	Alice		200			650
													4		2023-01-04	Charlie		250			900
													5		2023-01-05	Bob			300			1200
													
													SELECT 
													  SaleID, 
													  Salesperson, 
													  SaleAmount, 
													  SaleDate, 
													  SUM(SaleAmount) OVER (PARTITION BY Salesperson ORDER BY SaleDate) AS CumulativeSalePerPerson
													FROM Sales;
													SaleID	SaleDate	Salesperson	SaleAmount	CumulativeSalePerPerson
													1		2023-01-01	Alice		300			300
													2		2023-01-02	Bob			150			150
													3		2023-01-03	Alice		200			500
													4		2023-01-04	Charlie		250			250
													5		2023-01-05	Bob			300			450
													
													SELECT 
													  SaleID, 
													  Salesperson, 
													  SaleAmount, 
													  SaleDate, 
													  RANK() OVER (ORDER BY SaleAmount DESC) AS SaleRank
													FROM Sales;
													SaleID	Salesperson	SaleAmount	SaleDate	MovingAverage
													1		Alice		300			2023-01-01	300.0
													2		Bob			150			2023-01-02	225.0
													3		Alice		200			2023-01-03	216.67
													4		Charlie		250			2023-01-04	200.0
													5		Bob			300			2023-01-05	250.0
													6		Alice		100			2023-01-06	216.67
													7		Charlie		350			2023-01-07	250.0
													8		Alice		450			2023-01-08	300.0
													9		Bob			200			2023-01-09	333.33
													10		Charlie		400			2023-01-10	350.0
													11		Alice		150			2023-01-11	250.0
													12		Bob			250			2023-01-12	266.67
													13		Charlie		300			2023-01-13	233.33
													14		Alice		350			2023-01-14	300.0
													15		Bob			100			2023-01-15	250.0
													
													SELECT SaleID, SaleDate, Salesperson, SaleAmount, 
														   AVG(SaleAmount) OVER (
																		ORDER BY SaleDate 
																		ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
																				) AS MovingAverage
													FROM Sales;
													SaleID	Salesperson	SaleAmount	SaleDate	MovingAverage
													1		Alice		300			2023-01-01	300.0
													2		Bob			150			2023-01-02	225.0
													3		Alice		200			2023-01-03	216.67
													4		Charlie		250			2023-01-04	200.0
													5		Bob			300			2023-01-05	250.0
													6		Alice		100			2023-01-06	216.67
													7		Charlie		350			2023-01-07	250.0
													8		Alice		450			2023-01-08	300.0
													9		Bob			200			2023-01-09	333.33
													10		Charlie		400			2023-01-10	350.0
													11		Alice		150			2023-01-11	250.0
													12		Bob			250			2023-01-12	266.67
													13		Charlie		300			2023-01-13	233.33
													14		Alice		350			2023-01-14	300.0
													15		Bob			100			2023-01-15	250.0
													
				Ví dụ 2:

													
													SaleID	Salesperson	Amount
													1		John		300
													2		Jane		200
													3		John		150
													4		Jane		200
													5		Mary		400
													
													SELECT 
														Salesperson, 
														Amount, 
														RANK() OVER (ORDER BY Amount DESC) AS RankAmount,
														DENSE_RANK() OVER (ORDER BY Amount DESC) AS DenseRankAmount
													FROM 
														Sales;
													Salesperson	Amount	RankAmount	DenseRankAmount
													Mary		400		1			1
													John		300		2			2
													Jane		200		3			3
													Jane		200		3			3
													John		150		5			4
														
	HAVING Clause--MySQL:
												The HAVING clause was added to SQL because the WHERE keyword cannot be used with aggregate functions.
		Syntax
												SELECT column_name(s)
												FROM table_name
												WHERE condition
												GROUP BY column_name(s)
												HAVING condition
												ORDER BY column_name(s);
		Example:
												SELECT 
													product_id,
													product_name,
													SUM(sale_amount) AS total_sales
												FROM 
													sales
												GROUP BY 
													product_id, product_name
												HAVING 
													total_sales > 1000;
	IN Operator--MySQL:
												The IN operator allows you to specify multiple values in a WHERE clause.
												The IN operator is a shorthand for multiple OR conditions.
		Syntax:
												SELECT column_name(s)
												FROM table_name
												WHERE column_name IN (value1, value2, ...);
												
												SELECT column_name(s)
												FROM table_name
												WHERE column_name IN (SELECT STATEMENT);
		Example:
												SELECT 
													product_id,
													product_name,
													category
												FROM 
													products
												WHERE 
													category IN ('Electronics', 'Clothing');

												SELECT 
													employee_id,
													first_name,
													last_name,
													department_id
												FROM 
													employees
												WHERE 
													department_id IN (SELECT department_id FROM departments WHERE department_name IN ('IT', 'Finance'));
	INSERT INTO--MySQL:
												The INSERT INTO statement is used to insert new records in a table.
		Syntax:
												INSERT INTO table_name (column1, column2, column3, ...)
												VALUES (value1, value2, value3, ...);
												
												INSERT INTO table_name
												VALUES (value1, value2, value3, ...);
		Example:
												INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
												VALUES ('Cardinal', 'Tom B. Erichsen', 'Skagen 21', 'Stavanger', '4006', 'Norway');
												
												INSERT INTO products
												VALUES (101, 'Laptop', 1200.00);
	INSERT INTO SELECT Statement--MySQL:
												The INSERT INTO SELECT statement copies data from one table and inserts it into another table.
												The INSERT INTO SELECT statement requires that the data types in source and target tables matches.
		Syntax:
												INSERT INTO table2
												SELECT * FROM table1
												WHERE condition;
												
												INSERT INTO table2 (column1, column2, column3, ...)
												SELECT column1, column2, column3, ...
												FROM table1
												WHERE condition;
		Example:
												INSERT INTO employees_department_1
												SELECT * FROM employees
												WHERE department_id = 1;
												
												INSERT INTO Customers (CustomerName, City, Country)
												SELECT SupplierName, City, Country FROM Suppliers;
												
												INSERT INTO Customers (CustomerName, ContactName, Address, City, PostalCode, Country)
												SELECT SupplierName, ContactName, Address, City, PostalCode, Country FROM Suppliers;
												
												INSERT INTO Customers (CustomerName, City, Country)
												SELECT SupplierName, City, Country FROM Suppliers
												WHERE Country='Germany';
	LIKE Operator--MySQL:
												The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
												The percent sign (%) represents zero, one, or multiple characters
												The underscore sign (_) represents one, single character
		Syntax:
												SELECT column1, column2, ...
												FROM table_name
												WHERE columnN LIKE pattern;
		Example:
												SELECT 
													product_id,
													product_name
												FROM 
													products
												WHERE 
													product_name LIKE '%phone'; // chứa tất cả các sản phẩm có tên kết thúc bằng từ "phone"
	
												SELECT 
													employee_id,
													employee_name
												FROM 
													employees
												WHERE 
													employee_name LIKE 'J_'; // tất cả các nhân viên có tên bắt đầu bằng chữ "J" và có một ký tự tiếp theo là bất kỳ
	LIMIT Clause--MySQL:
												The LIMIT clause is used to specify the number of records to return.
												The LIMIT clause is useful on large tables with thousands of records. Returning a large number of records can impact performance.
		Syntax:
												SELECT column_name(s)
												FROM table_name
												WHERE condition
												LIMIT number;
		Example:
												SELECT * FROM Customers
												WHERE Country='Germany'
												LIMIT 3;
	MIN() and MAX() Functions--MySQL:
												The MIN() function returns the smallest value of the selected column.
												The MAX() function returns the largest value of the selected column.
		MIN():
				Syntax:
												SELECT MIN(column_name)
												FROM table_name
												WHERE condition;
				Example:
												SELECT MIN(salary) AS min_salary
												FROM employees;
		MAX():
				Syntax:
												SELECT MAX(column_name)
												FROM table_name
												WHERE condition;
				Example:
												SELECT MAX(salary) AS max_salary
												FROM employees;
	NULL Functions--MySQL:
		IFNULL():
												The MySQL IFNULL() function lets you return an alternative value if an expression is NULL.
					Syntax:
												IFNULL(value, replacement)
					Example:
												SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
												FROM Products;
		COALESCE():
												Hàm COALESCE trong MySQL được sử dụng để trả về giá trị đầu tiên không NULL từ danh sách các biểu thức được cung cấp. Nếu tất cả các biểu thức đều NULL, hàm COALESCE sẽ trả về
												giá trị NULL.
												So với IFNULL() thì Hàm COALESCE() có thể nhận nhiều hơn hai đối số. Nó sẽ trả về giá trị đầu tiên không phải NULL từ danh sách các đối số. Nếu tất cả các đối số đều là NULL, nó sẽ
												trả về NULL.
					Syntax:
												COALESCE(value1, value2, ...)
					Example:
												SELECT 
													employee_id,
													CONCAT(first_name, ' ', COALESCE(middle_name, 'N/A'), ' ', last_name) AS full_name // nếu middle_name là NULL, thì nó sẽ được thay thế bằng chuỗi 'N/A'.
												FROM 
													employees;
													
												SELECT 
													employee_id,
													COALESCE(CONCAT(first_name, ' ', middle_name, ' ', last_name), 'N/A') AS full_name // trả về giá trị đầu tiên không phải là NULL từ danh sách các đối số. Trong trường hợp này,
																																	   // nếu first_name, middle_name và last_name đều là NULL, thì giá trị trả về sẽ là 'N/A'.
												FROM 
													employees;		
												SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0))
												FROM Products;
	NULL Values--MySQL:
												A field with a NULL value is a field with no value.
												If a field in a table is optional, it is possible to insert a new record or update a record without adding a value to this field. Then, the field will be saved with a NULL value.
												It is not possible to test for NULL values with comparison operators, such as =, <, or <>.
												We will have to use the IS NULL and IS NOT NULL operators instead.
		IS NULL:
						Syntax:
												SELECT column_names
												FROM table_name
												WHERE column_name IS NULL;
						Example:
												SELECT * 
												FROM employees
												WHERE last_name IS NULL; // kiểm tra xem giá trị trong cột "last_name" có là NULL không
		IS NOT NULL:
						Syntax:
												SELECT column_names
												FROM table_name
												WHERE column_name IS NOT NULL;
						Example:
												SELECT * 
												FROM employees
												WHERE last_name IS NOT NULL; // kiểm tra xem giá trị trong cột "last_name" có khác NULL không
	ORDER BY Keyword--MySQL:
												The ORDER BY keyword is used to sort the result-set in ascending or descending order.
												The ORDER BY keyword sorts the records in ascending order by default. To sort the records in descending order, use the DESC keyword.
		Syntax:
												SELECT column1, column2, ...
												FROM table_name
												ORDER BY column1, column2, ... ASC|DESC;
		Example:
												SELECT student_id, first_name, last_name, age
												FROM students
												ORDER BY age ASC, last_name DESC;
	UNION Operator--MySQL:
												
												- Toán tử UNION được sử dụng để kết hợp tập hợp kết quả của hai hoặc nhiều câu lệnh SELECT. Mỗi câu lệnh SELECT với UNION phải có cùng số lượng cột, các cột phải có cùng kiểu
												dữ liệu, các cột trong mỗi câu lệnh SELECT phải có cùng trật tự.
												- The UNION operator is used to combine the result-set of two or more SELECT statements.
												- The UNION operator selects only distinct values by default. To allow duplicate values, use UNION ALL.
		
		UNION:
					Syntax:
												SELECT column_name(s) FROM table1
												UNION
												SELECT column_name(s) FROM table2;
					Example:
												SELECT student_name AS name FROM students
												UNION // selects only distinct values by default
												SELECT teacher_name AS name FROM teachers;
		UNION ALL:
					Syntax:
												SELECT column_name(s) FROM table1
												UNION ALL // allow duplicate values
												SELECT column_name(s) FROM table2;
					Example:
	UPDATE Statement--MySQL:
												The UPDATE statement is used to modify the existing records in a table.
												Be careful when updating records. If you omit the WHERE clause, ALL records will be updated!
		Syntax:
												UPDATE table_name
												SET column1 = value1, column2 = value2, ...
												WHERE condition;
		Example:
												UPDATE Customers
												SET ContactName = 'Alfred Schmidt', City = 'Frankfurt'
												WHERE CustomerID = 1;
	
												UPDATE Customers
												SET PostalCode = 00000
												WHERE Country = 'Mexico';
	Views--MySQL:
												In SQL, a view is a virtual table based on the result-set of an SQL statement.
												A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.
												You can add SQL statements and functions to a view and present the data as if the data were coming from one single table.
		CREATE VIEW:
							Syntax:
												CREATE VIEW view_name AS
												SELECT column1, column2, ...
												FROM table_name
												WHERE condition;
							Example:
												CREATE VIEW [Brazil Customers] AS
												SELECT CustomerName, ContactName
												FROM Customers
												WHERE Country = 'Brazil';
												
												SELECT * FROM [Brazil Customers];
												
												CREATE VIEW [Products Above Average Price] AS
												SELECT ProductName, Price
												FROM Products
												WHERE Price > (SELECT AVG(Price) FROM Products);
		Updating a View:
							Syntax:
												CREATE OR REPLACE VIEW view_name AS
												SELECT column1, column2, ...
												FROM table_name
												WHERE condition;
							Example:
												CREATE OR REPLACE VIEW [Brazil Customers] AS
												SELECT CustomerName, ContactName, City
												FROM Customers
												WHERE Country = 'Brazil';
		Dropping a View:
							Syntax:				DROP VIEW view_name;
							Example:			DROP VIEW [Brazil Customers];	
											
	Wildcards--MySQL:
												A wildcard character is used to substitute one or more characters in a string.
												Wildcard characters are used with the LIKE operator. The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.
												% represents zero or more characters.
												_ represents a single character.
												
												SELECT * 
												FROM employees 
												WHERE first_name LIKE 'John%'; // sau từ "John" có thể là bất kỳ ký tự nào

												SELECT * 
												FROM employees 
												WHERE first_name LIKE 'Jo_'; // phải có một ký tự bất kỳ ở vị trí thứ ba của từ "Jo"
	Working With Dates--MySQL:
												The most difficult part when working with dates is to be sure that the format of the date you are trying to insert, matches the format of the date column in the database.
												As long as your data contains only the date portion, your queries will work as expected. However, if a time portion is involved, it gets more complicated.
		DATE - Format YYYY-MM-DD:										
													SELECT *
													FROM Orders
													WHERE OrderDate = '2008-11-11';
		DATETIME - Format: YYYY-MM-DD HH:MI:SS:												
													SELECT *
													FROM Orders
													WHERE OrderDateTime = '2008-11-11 12:30:45';
		TIMESTAMP - Format: YYYY-MM-DD HH:MI:SS:											
													SELECT *
													FROM Orders
													WHERE OrderTimestamp = '2008-11-11 12:30:45';
		YEAR - Format YYYY or YY:											
													SELECT *
													FROM Orders
													WHERE YEAR(OrderYear) = 2008;

	N + 1 query--MySQL:
	
		N + 1 query là gì ?
			
			Câu chuyện xảy ra khi chúng ta, những coder viết code chưa khéo, sinh ra nhiều truy vấn vào cơ sở dữ liệu làm giảm performance của hệ thống. Khi đồng nghiệp đọc code thường thì sẽ bình luận ngay: fix N + 1
		
		Ví dụ về N + 1
		
			Mình viết ví dụ tựa như mã giả thui nhé, không đặt nặng vấn đề cú pháp
			
			Giả sử ta có một cơ sở dữ liệu, trong đó table post có khóa ngoại user_id, nói theo kiểu mã giả là một post thuộc về một user
			
			Thực hiện truy vấn vào cơ sở dữ liệu và lấy tất cả User kèm theo các Post của User đó:
				
				User.all.each do |user|
				  user.posts
				end
			
			Các câu lệnh SQL sinh ra như sau
				  
				  User Load (0.2ms)  SELECT "users".* FROM "users"
		  
				  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ?  [["user_id", 1]]
				  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ?  [["user_id", 2]]
				  Post Load (0.1ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" = ?  [["user_id", 3]]
				
				Mình cần dùng 4 câu truy vấn:
					
					Một truy vấn để lấy ra tất cả users => đây chính là 1 trong "N+1"
					
					Ba truy vấn để lấy ra các post tương ứng với ba user trong cơ sở dữ liệu => đây chính là N trong "N+1"
				
				Đối với những hệ thống có số lượng bản ghi lớn (cỡ như phải trả về 1000 user thì chúng ta phải thực hiện 1001 truy vấn) hoặc có database với độ trễ cao (thời gian thực thi truy vấn cao) thì ắt hẳn sẽ làm
				giảm performance của hệ thống.
				
				Vậy làm sao để có thể lấy ra dữ liệu tương đương như vậy nhưng với số lượng truy vấn bé hơn ?
		
		Cách khắc phục
			
			Sử dụng select in ()
				
				Tối ưu câu lệnh SQL ngay và luôn.
					
					User Load (0.2ms)  SELECT "users".* FROM "users"
					Post Load (0.4ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
				
				Chúng ta cần 2 truy vấn:
				
					Truy vấn đầu tiên để load toàn bộ user
					
					Truy vấn thứ 2 để load các post tương ứng với những users đó.
			
			Sử dụng joins
				
				Joins là gì ?
					
					Mệnh đề joins trong SQL được sử dụng để kết hợp các bản ghi từ hai hoặc nhiều bảng trong một cơ sở dữ liệu bằng cách sử dụng các giá trị chung của mỗi bảng.
				
				Ta có một ví dụ như này:
					
					Bảng User:
					Bảng Post:
					Trong ví dụ trên bạn có thể dùng joins để tạo ra bảng mới chứa tên, email của user và những tên bài đăng mà user đó tạo ra.
						
						SELECT User.name, User.email, Post.title
						FROM User
						INNER JOIN Post ON User.id = Post.user_id

					Như vậy, joins sẽ tem tém hai bảng lại rồi truy vấn trên kết quả đó nên joins chỉ tốn một query duy nhất đã cho ra kết quả.
			
			Lựa chọn cái nào
				
				Hãy so sánh truy vấn do joinsvà select in() tạo ra, bạn sẽ nhận thấy ngay select in() đơn giản, dễ hiểu và ngắn gọn hơn joins rất nhiều.
				
				Trong trường hợp hai bảng cần joins có số lượng record lớn thì select in() sẽ vượt trội hơn hẳn.
				
				Thế tại sao còn sinh ra joins trong khi select in() đã ngon, bổ, rẻ.
				
				Vậy thì hãy xem 3 ví dụ sau:
					
					Không có điều kiện where
						
						# Mọi thứ bình yên vô sự
						2.3.1 :092 > User.all.includes(:posts)
						  User Load (0.2ms)  SELECT "users".* FROM "users"
						  Post Load (0.4ms)  SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
					
					Có thêm điều kiện where trong bảng bên trái (Tức là bảng User)
						
						# Lỗi rồi, ahihi
						2.3.1 :099 > User.all.includes(:posts).where("posts.title  = ?" , "Hoa")
						  User Load (0.6ms)  SELECT "users".* FROM "users" WHERE (posts.title  = 'Hoa')
						ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "users".* FROM "users" WHERE (posts.title  = 'Hoa')
					
					Có thêm điều kiện where trong bảng bên phải (Tức là bảng Post)
						
						# Lỗi rồi, ahihi
						2.3.1 :099 > User.all.includes(:posts).where("posts.title  = ?" , "Hoa")
						  User Load (0.6ms)  SELECT "users".* FROM "users" WHERE (posts.title  = 'Hoa')
						ActiveRecord::StatementInvalid: SQLite3::SQLException: no such column: posts.title: SELECT "users".* FROM "users" WHERE (posts.title  = 'Hoa')
					
					Lý do lỗi ở đây là gì ? Tại sao where với bảng bên trái thì không gặp lỗi mà bảng bên phải lại gặp lỗi no such column
					
					Bởi vì select in() sẽ không load trước được dữ liệu từ bảng post, nên nó không hiểu trường title là gì.
					
					Còn trường name nằm ngay trong table user rồi nên không gặp lỗi.
					
					Khi where với bảng bên phải thì đây là đất để joins dụng võ rồi, vì hai bảng được kết hợp với nhau nên luôn có đầy đủ thông tin các trường của mỗi bảng.
						# Query succeeded rồi, ahihi.
						User.all.includes(:posts).references(:posts).where("posts.title  = ?" , "Hoa")
						  SQL (0.6ms)  SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, "users"."created_at" AS t0_r2, "users"."updated_at" AS t0_r3, "users"."post_id" AS t0_r4, "posts"."id" AS t1_r0, "posts"."title"
						  AS t1_r1, "posts"."created_at" AS t1_r2, "posts"."updated_at" AS t1_r3, "posts"."user_id" AS t1_r4 FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE (posts.title  = 'Hoa')
					
					Các bạn đừng quá quan tâm includes và references là gì, cứ hiểu mình dùng nó để ép kiểu truy vấn thành select in() hoặc joins là được. Phần sau mình sẽ giải thích kĩ hơn.
					
					Vậy trong trường hợp có điều kiện where ở bảng bên phải thì phải sài joins nhé, còn ngược lại thì cứ sài select in() cho ngon, bổ, rẻ.
		
		Tính năng hay bug
			
			Từ đầu tới giờ ta tìm hiểu thì có vẻ như N + 1 là điều không tốt cho performance của chương trình.
			
			Nhưng chưa hẳn, hãy xem xét ví dụ sau:
				
				Bạn truy cập vào trang chủ của website bán hàng, có tính năng phân trang nên chỉ load ra 20 sản phẩm đầu tiên (có kèm theo nơi sản xuất ở Hà Nội)
				
				Dễ thấy rằng ở đây dễ xuất hiện N + 1 query:
					1 truy vấn đầu tiên để lấy ra 20 sản phẩm từ bảng Product.
					20 truy vấn tiếp theo lấy ra nơi sản xuất của 20 sản phẩm đó tư bảng Company.
				
				Có thêm điều kiện where("company.product.id = ?", "Hà Nội") ở bảng bên phải
				
				Vậy chúng ta cần 20 + 1 = 21 truy vấn và chúng ta sử dụng joins để khử N + 1.
				
				Trong trường hợp đối với một cơ sở dữ liệu khủng, với hàng triệu record cho mỗi bảng thì việc joins hai bảng khủng như vậy sẽ tiêu tốn tài nguyên hơn 21 câu truy vấn ngắn rất nhiều lần.
				
				Bản chất của joins là sẽ duyệt qua từng bản ghi của bảng thứ nhất, đối chiếu với từng bản ghi của bảng thứ 2, nếu điều kiện được thỏa mãn thì kết hợp thành một hàng, duyệt 2 vòng lặp, tiêu tốn nhiều thời
				gian và tài nguyên.
	
	Function--MySQL:
	
		String Functions--MySQL Function:
		
			ASCII--MySQL String Functions:
			
				Returns the ASCII value for the specific character
				
				ASCII(character)
					character: Required. The character to return the ASCII value for. If more than one character is entered, it will only return the value for the first character
				
				Example
					
					// Return the ASCII value of the first character in "CustomerName"
					SELECT ASCII(CustomerName) AS NumCodeOfFirstChar
					FROM Customers;
						
			CHAR_LENGTH--MySQL String Functions:
			
				Returns the length of a string (in characters)
				
				CHAR_LENGTH(string)
					string: Required. The string to count the length for
				
				Example
				
					SELECT CHAR_LENGTH("SQL Tutorial") AS LengthOfString; // Return the length of the string
					
					// Return the length of the text in the "CustomerName" column
					SELECT CustomerName, CHAR_LENGTH(CustomerName) AS LengthOfName
					FROM Customers;
						
			
			CHARACTER_LENGTH()--MySQL String Functions:
			
				The CHARACTER_LENGTH() function return the length of a string (in characters).
				
				CHARACTER_LENGTH(string)
					
					string: Required. The string to count the length for
				
				Note: This function is equal to the CHAR_LENGTH() function.
				
				Example
					
					SELECT CHARACTER_LENGTH("SQL Tutorial") AS LengthOfString; // Return the length of the string
					
					// Return the length of the text in the "CustomerName" column
					SELECT CustomerName, CHARACTER_LENGTH(CustomerName) AS LengthOfName
					FROM Customers;
						
			
			CONCAT--MySQL String Functions:
			
				The CONCAT() function adds two or more expressions together.
					
				CONCAT(expression1, expression2, expression3,...)
					expression1, expression2, expression3, etc.: Required. The expressions to add together.
			
				Note: If any of the expressions is a NULL value, it returns NULL
				
				Example
					
					SELECT CONCAT("SQL ", "Tutorial ", "is ", "fun!") AS ConcatenatedString; // Add several strings together
					
					// Add three columns into one "Address" column
					SELECT CustomerName, CONCAT(Address, " ", PostalCode, " ", City) AS Address
					FROM Customers;					
			
			CONCAT_WS--MySQL String Functions:
			
				The CONCAT_WS() function adds two or more expressions together with a separator.
				
				CONCAT_WS(separator, expression1, expression2, expression3,...)
					separator: Required. The separator to add between each of the expressions. If separator is NULL, this function returns NULL
					expression1, expression2, expression3, etc.: Required. The expressions to add together. An expression with a NULL value will be skipped
				
				Example
				
					SELECT CONCAT_WS("-", "SQL", "Tutorial", "is", "fun!") AS ConcatenatedString; // SQL-Tutorial-is-fun! Add several expressions together, and add a "-" separator between them
					
					// Add three columns (and add a space between them) into one "Address" column
					SELECT CustomerName, CONCAT_WS(" ", Address, PostalCode, City) AS Address
					FROM Customers;			
			
			FIELD--MySQL String Functions:
			
				The FIELD() function returns the index position of a value in a list of values.

				This function performs a case-insensitive search.

				Note: If the specified value is not found in the list of values, this function will return 0. If value is NULL, this function will return 0.
					
				FIELD(value, val1, val2, val3, ...)
					value: Required. The value to search for in the list
					val1, val2, val3, ....: Required. The list of values to search
				
				Example
				
					SELECT FIELD("q", "s", "q", "l"); // 2. Return the index position of  "q" in the string list
					
					SELECT FIELD("Q", "s", "q", "l"); // 2. Return the index position of "Q" in the string list
					
					SELECT FIELD(5, 0, 1, 2, 3, 4, 5); // 6. Return the index position of 5 in the numeric list
			
			FIND_IN_SET--MySQL String Functions:
			
				The FIND_IN_SET() function returns the position of a string within a list of strings.
				
				FIND_IN_SET(string, string_list)
					string: Required. The string to search for
					string_list: Required. The list of string values to be searched (separated by commas)
				
				If string is not found in string_list, this function returns 0
				If string or string_list is NULL, this function returns NULL
				If string_list is an empty string (""), this function returns 0
				
				Example
					
					SELECT FIND_IN_SET("q", "s,q,l"); // 2. Search for "q" within the list of strings
					
					SELECT FIND_IN_SET("a", "s,q,l"); // 0. Search for "a" within the list of strings
					
					SELECT FIND_IN_SET("q", null); // Search for "q" within the list of strings (string list is NULL)
			
			FORMAT--MySQL String Functions:
			
				The FORMAT() function formats a number to a format like "#,###,###.##", rounded to a specified number of decimal places, then it returns the result as a string.
				
				FORMAT(number, decimal_places)
					number: Required. The number to be formatted
					decimal_places: Required. The number of decimal places for number. If this parameter is 0, this function returns a string with no decimal places
				
				Example
				
					SELECT FORMAT(250500.5634, 2); // 250,500.56. Format the number as "#,###,###.##" (and round with two decimal places)
					
					SELECT FORMAT(250500.5634, 0); // 250,501. Format the number as a format of "#,###,###.##" (and round with 0 decimal places)
			
			INSERT--MySQL String Functions:
			
				The INSERT() function inserts a string within a string at the specified position and for a certain number of characters.
				
				INSERT(string, position, number, string2)
					string: Required. The string that will be modified
					position: Required. The position where to insert string2
					number: Required. The number of characters to replace
					string2: Required. The string to insert into string
					
					If position is outside the length of string, this function returns string
					If number is higher than the length of the rest of the string, this function replaces string from position until the end of string
				
				Example
				
					SELECT INSERT("W3Schools.com", 1, 9, "Example"); // Example.com. Insert the string "Example" into the string "W3Schools.com". Replace the first nine characters
					
					SELECT INSERT("W3Schools.com", 11, 3, "no"); // W3Schools.no. Insert the string "no" into the string "W3Schools.com". Replace three characters, starting from position 11
		
			INSTR--MySQL String Functions:
			
				The INSTR() function returns the position of the first occurrence of a string in another string.

				This function performs a case-insensitive search.
					INSTR(string1, string2)
						string1: Required. The string that will be searched
						string2: Required. The string to search for in string1. If string2 is not found, this function returns 0
				Example
					SELECT INSTR("W3Schools.com", "3") AS MatchPosition; // 2
						Search for "3" in string "W3Schools.com", and return position
					SELECT INSTR("W3Schools.com", "COM") AS MatchPosition; // 11
						Search for "COM" in string "W3Schools.com", and return position
					SELECT CustomerName, INSTR(CustomerName, "a")
				FROM Customers;
						Search for "a" in CustomerName column, and return position
			
			LCASE()--MySQL String Functions:
			
				The LCASE() function converts a string to lower-case.

				Note: The LOWER() function is a synonym for the LCASE() function.
					LCASE(text)
						text: Required. The string to convert
				Example
					SELECT LCASE("SQL Tutorial is FUN!") AS LowercaseText; // sql tutorial is fun!
						Convert the text to lower-case
					SELECT LCASE(CustomerName) AS LowercaseCustomerName
				FROM Customers;
						Convert the text in "CustomerName" to lower-case
			
			LEFT()--MySQL String Functions:
			
				The LEFT() function extracts a number of characters from a string (starting from left).
					LEFT(string, number_of_chars)
						string: Required. The string to extract from
						number_of_chars: Required. The number of characters to extract. If this parameter is larger than the number of characters in string, this function will return string
				Example
					SELECT LEFT("SQL Tutorial", 3) AS ExtractString; // SQL
						Extract 3 characters from a string (starting from left)
					SELECT LEFT(CustomerName, 5) AS ExtractString
				FROM Customers;
						Extract 5 characters from the text in the "CustomerName" column (starting from left)
			
			LENGTH()--MySQL String Functions:
			
				The LENGTH() function returns the length of a string (in bytes).
					LENGTH(string)
						string: Required. The string to count the length for
				Example
					SELECT LENGTH("SQL Tutorial") AS LengthOfString; // 12
						Return the length of the string, in bytes
					SELECT CustomerName, LENGTH(CustomerName) AS LengthOfName
				FROM Customers;
						Return the length of the text in the "CustomerName" column, in bytes
			
			LOCATE()--MySQL String Functions:
			
				The LOCATE() function returns the position of the first occurrence of a substring in a string.

				If the substring is not found within the original string, this function returns 0.

				This function performs a case-insensitive search.

				Note: This function is equal to the POSITION() function.
					LOCATE(substring, string, start)
						substring: Required. The substring to search for in string
						string: Required. The string that will be searched
						start: Optional. The starting position for the search. Position 1 is default
				Example
					SELECT LOCATE("3", "W3Schools.com") AS MatchPosition; // 2
						Search for "3" in string "W3Schools.com", and return position
					SELECT LOCATE("com", "W3Schools.com", 3) AS MatchPosition; // 11
						Search for "com" in string "W3Schools.com" (start at position 3), and return position
					SELECT CustomerName, LOCATE("a", CustomerName)
				FROM Customers;
						Search for "a" in CustomerName column, and return position
				LOWER()
				The LOWER() function converts a string to lower-case.

				Note: The LCASE() function is equal to the LOWER() function.
					LOWER(text)
						text: Required. The string to convert
				Example
					SELECT LOWER("SQL Tutorial is FUN!") AS LowercaseText; // sql tutorial is fun!
						Convert the text to lower-case
					SELECT LOWER(CustomerName) AS LowercaseCustomerName
				FROM Customers;
						Convert the text in "CustomerName" to lower-case
			
			LPAD()--MySQL String Functions:
			
				The LPAD() function left-pads a string with another string, to a certain length.
					LPAD(string, length, lpad_string)
						string: Required. The original string. If the length of the original string is larger than the length parameter, this function removes the overfloating characters from string
						length: Required. The length of the string after it has been left-padded
						lpad_string: Required. The string to left-pad to string
				Example
					SELECT LPAD("SQL Tutorial", 20, "ABC"); // ABCABCABSQL Tutorial
						Left-pad the string with "ABC", to a total length of 20
					SELECT LPAD(CustomerName, 30, "ABC") AS LeftPadCustomerName
				FROM Customers; 
						Left-pad the text in "CustomerName" with "ABC", to a total length of 30
			
			LTRIM()--MySQL String Functions:
			
				The LTRIM() function removes leading spaces from a string.
					string: Required. The string to remove leading spaces from
				Example
					SELECT LTRIM("    SQL Tutorial") AS LeftTrimmedString; // SQL Tutorial
						Remove leading spaces from a string
			
			MID()--MySQL String Functions:
			
				The MID() function extracts a substring from a string (starting at any position).

				Note: The MID() and SUBSTR() functions equals the SUBSTRING() function.
				
				MID(string, start, length)
					string: Required. The string to extract from
					start: Required. The start position. Can be both a positive or negative number. If it is a positive number, this function extracts from the beginning of the string. If it is a negative number, this function extracts from the end of the string
					length: Required. The number of characters to extract
				
				Example
					SELECT MID("SQL Tutorial", 5, 3) AS ExtractString; // Tut. Extract a substring from a string (start at position 5, extract 3 characters)
					
					SELECT MID("SQL Tutorial", -5, 5) AS ExtractString; // orial. Extract a substring from a string (start from the end, at position -5, extract 5 characters)
					
					// Extract a substring from the text in a column (start at position 2, extract 5 characters)
					SELECT MID(CustomerName, 2, 5) AS ExtractString
					FROM Customers;						
			
			POSITION()--MySQL String Functions:
			
				The POSITION() function returns the position of the first occurrence of a substring in a string.

				If the substring is not found within the original string, this function returns 0.

				This function performs a case-insensitive search.

				Note: The LOCATE() function is equal to the POSITION() function.
				
				POSITION(substring IN string)
					
					substring: Required. The substring to search for in string
					string: Required. The original string that will be searched
				
				Example
					
					SELECT POSITION("3" IN "W3Schools.com") AS MatchPosition; // 2. Search for "3" in string "W3Schools.com", and return position
					
					SELECT POSITION("COM" IN "W3Schools.com") AS MatchPosition; // 11. Search for "COM" in string "W3Schools.com", and return position
					
					// Search for "a" in CustomerName column, and return position
					SELECT CustomerName, POSITION("a" IN CustomerName)
					FROM Customers;						
			
			REPEAT()--MySQL String Functions:
			
				The REPEAT() function repeats a string as many times as specified.
				
				REPEAT(string, number)
					string: Required. The string to repeat
					number: Required. The number of times to repeat the string
				
				Example
					
					SELECT REPEAT("SQL Tutorial", 3); // SQL TutorialSQL TutorialSQL Tutorial. Repeat a string 3 times
					
					// Repeat the text in CustomerName 2 times
					SELECT REPEAT(CustomerName, 2)
					FROM Customers;
						
					SELECT REPEAT("SQL Tutorial", 0); // Repeat the string 0 times
			
			REPLACE()--MySQL String Functions:
			
				The REPLACE() function replaces all occurrences of a substring within a string, with a new substring.

				Note: This function performs a case-sensitive replacement.
				
				REPLACE(string, substring, new_string)
					string: Required. The original string
					substring: Required. The substring to be replaced
					new_string
							Required. The new replacement substring
				Example
				
					SELECT REPLACE("SQL Tutorial", "SQL", "HTML"); // HTML Tutorial. Replace "SQL" with "HTML
					
					SELECT REPLACE("XYZ FGH XYZ", "X", "M"); // MYZ FGH MYZ. Replace "X" with "M"
					
					SELECT REPLACE("XYZ FGH XYZ", "X", "m"); // mYZ FGH mYZ. Replace "X" with "m"
					
					SELECT REPLACE("XYZ FGH XYZ", "x", "m"); // XYZ FGH XYZ. Replace "x" with "m"
			
			REVERSE()--MySQL String Functions:
			
				The REVERSE() function reverses a string and returns the result.
				
				REVERSE(string)
					string: Required. The string to reverse
				
				Example
					
					SELECT REVERSE("SQL Tutorial"); // lairotuT LQS. Reverse a string
					
					// Reverse the text in CustomerName
					SELECT REVERSE(CustomerName)
					FROM Customers;					
			
			RIGHT()--MySQL String Functions:
			
				The RIGHT() function extracts a number of characters from a string (starting from right).
				
				RIGHT(string, number_of_chars)
					string: Required. The string to extract from
					number_of_chars: Required. The number of characters to extract. If this parameter is larger than the number of characters in string, this function will return string
				
				Example
					
					SELECT RIGHT("SQL Tutorial is cool", 4) AS ExtractString; // cool. Extract 4 characters from a string (starting from right)
					
					// Extract 5 characters from the text in the "CustomerName" column (starting from right)
					SELECT RIGHT(CustomerName, 5) AS ExtractString
					FROM Customers;					
			
			RPAD()--MySQL String Functions:
			
				Example
					
					SELECT RPAD("SQL Tutorial", 20, "ABC"); // SQL TutorialABCABCAB. Right-pad the string with "ABC", to a total length of 20
					
					// Right-pad the text in "CustomerName" with "ABC", to a total length of 30
					SELECT RPAD(CustomerName, 30, "ABC") AS RightPadCustomerName
					FROM Customers; 
						
				The RPAD() function right-pads a string with another string, to a certain length.
				
				RPAD(string, length, rpad_string)
					string: Required. The original string. If the length of the original string is larger than the length parameter, this function removes the overfloating characters from string
					length: Required. The length of the string after it has been right-padded
					rpad_string: Required. The string to right-pad to string
			
			RTRIM()--MySQL String Functions:
			
				The RTRIM() function removes trailing spaces from a string.
				
				RTRIM(string)
					string: Required. The string to remove trailing spaces from
				
				Example
					
					SELECT RTRIM("SQL Tutorial    ") AS RightTrimmedString; // SQL Tutorial. Remove trailing spaces from a string
			
			SPACE()--MySQL String Functions:
			
				The SPACE() function returns a string of the specified number of space characters.
				
				SPACE(number)
					number: Required. The number of space characters to return
				
				Example
				
					SELECT SPACE(10); // Return a string with 10 space characters
			
			POSITION()--MySQL String Functions:
			
				The POSITION() function returns the position of the first occurrence of a substring in a string.

				If the substring is not found within the original string, this function returns 0.

				This function performs a case-insensitive search.

				Note: The LOCATE() function is equal to the POSITION() function.
				
				POSITION(substring IN string)
					substring: Required. The substring to search for in string
					string: Required. The original string that will be searched
			
			REPEAT()--MySQL String Functions:
				
				The REPEAT() function repeats a string as many times as specified.
				
				REPEAT(string, number)
					string: Required. The string to repeat
					number: Required. The number of times to repeat the string
				
				Example
					
					SELECT REPEAT("SQL Tutorial", 3); // SQL TutorialSQL TutorialSQL Tutorial. Repeat a string 3 times
					
					// Repeat the text in CustomerName 2 times
					SELECT REPEAT(CustomerName, 2)
					FROM Customers;
						
					SELECT REPEAT("SQL Tutorial", 0); // Repeat the string 0 times
			
			REPLACE()--MySQL String Functions:
			
				The REPLACE() function replaces all occurrences of a substring within a string, with a new substring.

				Note: This function performs a case-sensitive replacement.
				
				REPLACE(string, substring, new_string)
					string: Required. The original string
					substring: Required. The substring to be replaced
					new_string: Required. The new replacement substring
				
				Example
					
					SELECT REPLACE("SQL Tutorial", "SQL", "HTML"); // HTML Tutorial. Replace "SQL" with "HTML
					
					SELECT REPLACE("XYZ FGH XYZ", "X", "M"); // MYZ FGH MYZ. Replace "X" with "M"
					
					SELECT REPLACE("XYZ FGH XYZ", "X", "m"); // mYZ FGH mYZ. Replace "X" with "m"
					
					SELECT REPLACE("XYZ FGH XYZ", "x", "m"); // XYZ FGH XYZ. Replace "x" with "m"
			
			REVERSE()--MySQL String Functions:
			
				The REVERSE() function reverses a string and returns the result.
				
				REVERSE(string)
					string: Required. The string to reverse
				
				Example
					
					SELECT REVERSE("SQL Tutorial"); // lairotuT LQS. Reverse a string
					
					// Reverse the text in CustomerName
					SELECT REVERSE(CustomerName)
					FROM Customers;
						
			RIGHT()--MySQL String Functions:
			
				The RIGHT() function extracts a number of characters from a string (starting from right).
				
				RIGHT(string, number_of_chars)
					string: Required. The string to extract from
					number_of_chars: Required. The number of characters to extract. If this parameter is larger than the number of characters in string, this function will return string
				
				Example
					
					SELECT RIGHT("SQL Tutorial is cool", 4) AS ExtractString; // cool. Extract 4 characters from a string (starting from right)
					
					// Extract 5 characters from the text in the "CustomerName" column (starting from right)
					SELECT RIGHT(CustomerName, 5) AS ExtractString
					FROM Customers;					
			
			RPAD()--MySQL String Functions:
			
				The RPAD() function right-pads a string with another string, to a certain length.
					
				RPAD(string, length, rpad_string)
					string: Required. The original string. If the length of the original string is larger than the length parameter, this function removes the overfloating characters from string
					length: Required. The length of the string after it has been right-padded
					rpad_string: Required. The string to right-pad to string
				
				Example
					
					SELECT RPAD("SQL Tutorial", 20, "ABC"); // SQL TutorialABCABCAB. Right-pad the string with "ABC", to a total length of 20
					
					// Right-pad the text in "CustomerName" with "ABC", to a total length of 30
					SELECT RPAD(CustomerName, 30, "ABC") AS RightPadCustomerName
					FROM Customers; 					
			
			RTRIM()--MySQL String Functions:
			
				The RTRIM() function removes trailing spaces from a string.
				
				RTRIM(string)
					string: Required. The string to remove trailing spaces from
				
				Example
					
					SELECT RTRIM("SQL Tutorial    ") AS RightTrimmedString; // SQL Tutorial
			
			SPACE()--MySQL String Functions:
			
				Example
					
					SELECT SPACE(10); // Return a string with 10 space characters
				
				The SPACE() function returns a string of the specified number of space characters.
					SPACE(number)
						number: Required. The number of space characters to return
			
			STRCMP()--MySQL String Functions:
			
				Example
					SELECT STRCMP("SQL Tutorial", "SQL Tutorial"); // 0. Compare two strings
					
					SELECT STRCMP("SQL Tutorial", "HTML Tutorial"); // 1. Compare two strings
				
				The STRCMP() function compares two strings.
					string1, string2: Required. The two strings to be compared
				
				If string1 = string2, this function returns 0
				If string1 < string2, this function returns -1
				If string1 > string2, this function returns 1
			
			SUBSTR()--MySQL String Functions:
			
				The SUBSTR() function extracts a substring from a string (starting at any position).

				Note: The SUBSTR() and MID() functions equals to the SUBSTRING() function.
				
				SUBSTR(string, start, length)
				SUBSTR(string FROM start FOR length)
					string: Required. The string to extract from
					start: Required. The start position. Can be both a positive or negative number. If it is a positive number, this function extracts from the beginning of the string. If it is a negative number, this
					function extracts from the end of the string
					length: Optional. The number of characters to extract. If omitted, the whole string will be returned (from the start position)
				
				Example
				
					SELECT SUBSTR("SQL Tutorial", 5, 3) AS ExtractString; // Tut. Extract a substring from a string (start at position 5, extract 3 characters)
					
					SELECT SUBSTR("SQL Tutorial", -5, 5) AS ExtractString; // orial. Extract a substring from a string (start from the end, at position -5, extract 5 characters)
					
					// Extract a substring from the text in a column (start at position 2, extract 5 characters)
					SELECT SUBSTR(CustomerName, 2, 5) AS ExtractString
					FROM Customers;
					
			SUBSTRING()--MySQL Function:
			
				The SUBSTRING() function extracts a substring from a string (starting at any position).

				Note: The SUBSTR() and MID() functions equals to the SUBSTRING() function.
				
				SUBSTRING(string, start, length)
				OR
				SUBSTRING(string FROM start FOR length)
							string: Required. The string to extract from
							start: Required. The start position. Can be both a positive or negative number. If it is a positive number, this function extracts from the beginning of the string. If it is a negative number, this
							function extracts from the end of the string
							length: Optional. The number of characters to extract. If omitted, the whole string will be returned (from the start position)
				
				Example
				
						SELECT SUBSTRING("SQL Tutorial", 5, 3) AS ExtractString; // Tut. Extract a substring from a string (start at position 5, extract 3 characters)
						
						// Extract a substring from the text in a column (start at position 2, extract 5 characters)
						SELECT SUBSTRING(CustomerName, 2, 5) AS ExtractString
						FROM Customers;
							
						SELECT SUBSTRING("SQL Tutorial", -5, 5) AS ExtractString; // orial. Extract a substring from a string (start from the end, at position -5, extract 5 characters)
							
			SUBSTRING_INDEX()--MySQL Function:
			
				The SUBSTRING_INDEX() function returns a substring of a string before a specified number of delimiter occurs.
				
				SUBSTRING_INDEX(string, delimiter, number)
					string: Required. The original string
					delimiter: Required. The delimiter to search for
					number: Required. The number of times to search for the delimiter. Can be both a positive or negative number. If it is a positive number, this function returns all to the left of the delimiter.If it is
					a negative number, this function returns all to the right of the delimiter.
				
				Example
				
					SELECT SUBSTRING_INDEX("www.w3schools.com", ".", 1); // www. Return a substring of a string before a specified number of delimiter occurs
					
					SELECT SUBSTRING_INDEX("www.w3schools.com", ".", 2); // www.w3schools. Return a substring of a string before a specified number of delimiter occurs
						
			TRIM()--MySQL Function:
			
				The TRIM() function removes leading and trailing spaces from a string.
				
				TRIM(string)
					string: Required. The string to remove leading and trailing spaces from
				
				Example
				
					SELECT TRIM("    SQL Tutorial    ") AS TrimmedString; // SQL Tutorial. Remove leading and trailing spaces from a string
						
			UCASE()--MySQL Function:
			
				The UCASE() function converts a string to upper-case.

				Note: This function is equal to the UPPER() function.
				
				UCASE(text)
					text: Required. The string to convert
			
				Example
				
					SELECT UCASE("SQL Tutorial is FUN!") AS UppercaseText; // SQL TUTORIAL IS FUN!
					
					// Convert the text in "CustomerName" to upper-case
					SELECT UCASE(CustomerName) AS UppercaseCustomerName
					FROM Customers;				

			UPPER()--MySQL Function:
			
				Example
				
					SELECT UPPER("SQL Tutorial is FUN!") AS UppercaseText; // SQL TUTORIAL IS FUN!
					
					// Convert the text in "CustomerName" to upper-case
					SELECT UPPER(CustomerName) AS UppercaseCustomerName
					FROM Customers;
						
				The UPPER() function converts a string to upper-case.

				Note: This function is equal to the UCASE() function.
					
				UPPER(text)
					text: Required. The string to convert
					
		Numeric Functions--MySQL Function:
						
			ABS()--MySQL Numeric Functions:
			
				The ABS() function returns the absolute (positive) value of a number.
				
				ABS(number)
					number: Required. A numeric value
				
				Example
					SELECT ABS(-243.5); // 243.5. Return the absolute value of a number
						
			ACOS()--MySQL Numeric Functions:
			
				The ACOS() function returns the arc cosine of a number.

				The specified number must be between -1 to 1, otherwise this function returns NULL.
					ACOS(number)
						number: Required. A numeric value
				Example
					SELECT ACOS(0.25); // 1.318116071652818. Return the arc cosine of a number
					SELECT ACOS(-0.8); // 2.498091544796509. Return the arc cosine of a number
						
			ASIN()--MySQL Numeric Functions:
			
				The ASIN() function returns the arc sine of a number.

				The specified number must be between -1 to 1, otherwise this function returns NULL.
				
				ASIN(number)
					number: Required. A numeric value
				
				Example
					SELECT ASIN(0.25); // 0.25268025514207865
					SELECT ASIN(-0.8); //-0.9272952180016123
					
			ATAN()--MySQL Numeric Functions:
			
				The ATAN() function returns the arc tangent of one or two numbers.
				
				ATAN(number)
					number: A numeric value
				ATAN(a, b)
					a, b: Two numeric values to calculate the arc tangent of
				
				Example
					SELECT ATAN(-0.8, 2); //-0.3805063771123649
					
					SELECT ATAN(2.5); //1.1902899496825317
			
			ATAN2()--MySQL Numeric Functions:
			
				The ATAN2() function returns the arc tangent of two numbers.
				
				ATAN2(a, b)
					a, b: Required. Two numeric values to calculate the arc tangent of
				
				Example
					
					SELECT ATAN2(0.50, 1); //0.4636476090008061
					
					SELECT ATAN2(-0.8, 2); // -0.3805063771123649
			
			AVG()--MySQL Numeric Functions:
			
				The AVG() function returns the average value of an expression.

				Note: NULL values are ignored.
				
				AVG(expression)
					expression: Required. A numeric value (can be a field or a formula)
				
				Example
				
					SELECT AVG(Price) AS AveragePrice FROM Products; // 28.866364
					
					SELECT * FROM Products
					WHERE Price > (SELECT AVG(Price) FROM Products);
			
			CEIL()--MySQL Numeric Functions:
			
				The CEIL() function returns the smallest integer value that is bigger than or equal to a number.

				Note: This function is equal to the CEILING() function.
				
				CEIL(number)
					number: Required. A numeric value
				
				Example
				
					SELECT CEIL(25.75); // 26
					
					SELECT CEIL(25); // 25
					
			CEILING()--MySQL Numeric Functions:
			
				The CEILING() function returns the smallest integer value that is bigger than or equal to a number.

				Note: This function is equal to the CEIL() function.
				
				CEILING(number)
					number: Required. A numeric value
				
				Example
					
					SELECT CEILING(25.75); // 26
					
					SELECT CEILING(25); // 25
			COS()--MySQL Numeric Functions:
			
				The COS() function returns the cosine of a number.
					COS(number)
						number: Required. A numeric value
				Example
					SELECT COS(2);
						-0.4161468365471424
					SELECT COS(PI());
						-1
			COT()--MySQL Numeric Functions:
			
				The COT() function returns the cotangent of a number.
					COT(number)
						number: Required. A numeric value. If number is 0, an error or NULL is returned
				Example
					SELECT COT(6);
						-3.436353004180128
					SELECT COT(-2);
						0.45765755436028577
						
			COUNT()--MySQL Numeric Functions:
			
				The COUNT() function returns the number of records returned by a select query.

				Note: NULL values are not counted.
				
				COUNT(expression)
					expression: Required. A field or a string value
				
				Example
					
					SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; // 77
					
			DEGREES()--MySQL Numeric Functions:
				
				The DEGREES() function converts a value in radians to degrees.
					DEGREES(number)
						number: Required. A numeric value
				Example
					SELECT DEGREES(1.5);
						85.94366926962348
					SELECT DEGREES(PI()*2);
						360
			
			DIV--MySQL Numeric Functions:
			
				The DIV function is used for integer division (x is divided by y). An integer value is returned.
				
				x DIV y
					x: Required. A value that will be divided by y
					y: Required. The divisor
				
				Example
					
					SELECT 10 DIV 5; // 2
					
					SELECT 8 DIV 3; // 2
			
			EXP()--MySQL Numeric Functions:
			
				The EXP() function returns e raised to the power of the specified number.

				The constant e (2.718281...), is the base of natural logarithms.

				Tip: Also look at the LOG() and LN() functions.
				
				EXP(number)
					number: Required. The power number
				
				Example
					
					SELECT EXP(1); // 2.718281828459045
					
					SELECT EXP(2); // 7.38905609893065
			
			FLOOR()--MySQL Numeric Functions:
			
				The FLOOR() function returns the largest integer value that is smaller than or equal to a number.
				
				FLOOR(number)
					number: Required. A numeric value
					
				Example
					
					SELECT FLOOR(25.75); // 25
					
					SELECT FLOOR(25); // 25
			
			GREATEST()--MySQL Numeric Functions:
			
				The GREATEST() function returns the greatest value of the list of arguments.
				
				GREATEST(arg1, arg2, arg3, ...)
					Required. The list of arguments to be evaluated
				
				Example
					
					SELECT GREATEST(3, 12, 34, 8, 25); // 34
					
					SELECT GREATEST("w3Schools.com", "microsoft.com", "apple.com"); // w3Schools.com
			
			LEAST()--MySQL Numeric Functions:
			
				The LEAST() function returns the smallest value of the list of arguments.
					
				LEAST(arg1, arg2, arg3, ...)
					arg1, arg2, arg3, ...: Required. The list of arguments to be evaluated
				
				Example
					
					SELECT LEAST(3, 12, 34, 8, 25); // 3
					
					SELECT LEAST("w3Schools.com", "microsoft.com", "apple.com"); // apple.com
			
			LN()--MySQL Numeric Functions:
			
				The LN() function returns the natural logarithm of a number.
				
				LN(number)
					number: Required. A number. Must be greater than 0
				
				Example
					
					SELECT LN(2); // 0.6931471805599453
					
					SELECT LN(1); // 0
			
			LOG()--MySQL Numeric Functions:
			
				The LOG() function returns the natural logarithm of a specified number, or the logarithm of the number to the specified base.
					
				LOG(number)
					number: Required. A number. Must be greater than 0
					
				LOG(base, number)
					number: Required. A number. Must be greater than 0
					base: The base of number. Must be greater than 1
				
				Example
					
					SELECT LOG(2); // 0.6931471805599453
					
					SELECT LOG(2, 4); // 2		
					
			LOG10()--MySQL Numeric Functions:
			
				The LOG10() function returns the natural logarithm of a number to base-10.
				
				LOG10(number)
					number: A number greater than 0
				
				Example
					
					SELECT LOG10(2); // 0.3010299956639812
					
					SELECT LOG10(4.5); // 0.6532125137753437
			
			LOG2()--MySQL Numeric Functions:
			
				The LOG2() function returns the natural logarithm of a number to base-2.
				
				LOG2(number)
					number: A number. Must be greater than 0
				
				Example
					
					SELECT LOG2(6); // 2.584962500721156
					
					SELECT LOG2(64); // 6
			
			MAX()--MySQL Numeric Functions:
			
				The MAX() function returns the maximum value in a set of values.
				
				MAX(expression)
					expression: Required. A numeric value (can be a field or a formula)
				
				Example
					
					SELECT MAX(Price) AS LargestPrice FROM Products; // Find the price of the most expensive product in the "Products" table:
			
			MIN()--MySQL Numeric Functions:
			
				The MIN() function returns the minimum value in a set of values.
				
				MIN(expression)
					expression: Required. A numeric value (can be a field or a formula)
				
				Example
					SELECT MIN(Price) AS SmallestPrice FROM Products; // 2.50
			
			MOD()--MySQL Numeric Functions:
			
				The MOD() function returns the remainder of a number divided by another number.
					MOD(x, y)
					x MOD y
					x % y
					x: Required. A value that will be divided by y
					y: Required. The divisor
				
				Example
					
					SELECT MOD(18, 4); // 2
					
					SELECT 18 MOD 4; // 2
					
					SELECT 18 % 4; // 2
			
			PI()--MySQL Numeric Functions:
			
				The PI() function returns the value of PI.
				
				Example
					
					SELECT PI(); // 3.141593
			
			POW()--MySQL Numeric Functions:
			
				The POW() function returns the value of a number raised to the power of another number.
				
				POW(x, y)
					x: Required. A number (the base)
					y: Required. A number (the exponent)
				
				Example
					
					SELECT POW(4, 2); // 16
					
					SELECT POW(8, 3); // 512
			
			POWER()--MySQL Numeric Functions:
			
				The POWER() function returns the value of a number raised to the power of another number.
					
				POWER(x, y)
					x: Required. A number (the base)
					y: Required. A number (the exponent)
				
				Example
					
					SELECT POWER(4, 2); // 16
					
					SELECT POWER(8, 3); // 512		
					
			RADIANS()--MySQL Numeric Functions:
			
				The RADIANS() function converts a degree value into radians.
					RADIANS(number)
						number: Required. A number in degrees
				Example
					SELECT RADIANS(180);
						3.141592653589793
					SELECT RADIANS(-45);
						-0.7853981633974483
			
			RAND()--MySQL Numeric Functions:
			
				The RAND() function returns a random number between 0 (inclusive) and 1 (exclusive).
					RAND(seed)
						seed: Optional. If seed is specified, it returns a repeatable sequence of random numbers. If no seed is specified, it returns a completely random number
				Example
					SELECT RAND();
						0.4184526134454204
							Return a random decimal number (no seed value - so it returns a completely random number >= 0 and <1)
					SELECT RAND(6);
						0.6563190842571847
							Return a random decimal number (with seed value of 6)
					SELECT RAND()*(10-5)+5;
						8.310752160205276
							Return a random decimal number >= 5 and <10
					SELECT FLOOR(RAND()*(10-5+1)+5);
						10
			
			ROUND()--MySQL Numeric Functions:
			
				The ROUND() function rounds a number to a specified number of decimal places.
					ROUND(number, decimals)
						number: Required. The number to be rounded
						decimals: Optional. The number of decimal places to round number to. If omitted, it returns the integer (no decimals)
				Example
					SELECT ROUND(135.375, 2);
						135.38
							Round the number to 2 decimal places
					SELECT ROUND(345.156, 0);
						345
							Round the number to 0 decimal places
					SELECT ProductName, Price, ROUND(Price, 1) AS RoundedPrice
			FROM Products;
						Round the Price column (to 1 decimal) in the "Products" table
			
			SIGN()--MySQL Numeric Functions:
			
				The SIGN() function returns the sign of a number.
				This function will return one of the following:
					If number > 0, it returns 1
			If number = 0, it returns 0
			If number < 0, it returns -1
				SIGN(number)
					number: Required. The number to return the sign for
				Example
					SELECT SIGN(255.5);
						1
					SELECT SIGN(-12);
						-1
			
			SIN()--MySQL Numeric Functions:
			
				The SIN() function returns the sine of a number.
					SIN(number)
						number: Required. A numeric value
				Example
					SELECT SIN(2);
						0.9092974268256817
					SELECT SIN(-1);
						-0.8414709848078965
			
			SQRT()--MySQL Numeric Functions:
			
				The SQRT() function returns the square root of a number.
					SQRT(number)
						number: Required. A number to calculate the square root of. Must be greater than 0
				Example
					SELECT SQRT(64);
						8
					SELECT SQRT(13);
						3.605551275463989
			
			SUM()--MySQL Numeric Functions:
			
				The SUM() function calculates the sum of a set of values.

			Note: NULL values are ignored.
					SUM(expression)
						expression: Required. A field or a formula
				Example
					SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;
						51317
							Return the sum of the "Quantity" field in the "OrderDetails" table
			
			TAN()--MySQL Numeric Functions:
			
				The TAN() function returns the tangent of a number.
					TAN(number)
						number: Required. A numeric value
				Example
					SELECT TAN(1.75);
						-5.52037992250933
					SELECT TAN(-3);
						0.1425465430742778
			
			TRUNCATE()--MySQL Numeric Functions:
			
				The TRUNCATE() function truncates a number to the specified number of decimal places.

				Note: See also the FLOOR(), CEIL(), CEILING(), and ROUND() functions.
				
				TRUNCATE(number, decimals)
					number: Required. The number to be truncated
					decimals: Required. The number of decimal places to truncate to
				
				Example
					
					SELECT TRUNCATE(135.375, 2); // 135.37
					
					SELECT TRUNCATE(345.156, 0);
					
					SELECT TRUNCATE(345.156, 0);		
					
		Date Functions--MySQL Function:

			ADDDATE()--MySQL Date Functions:
			
				The ADDDATE() function adds a time/date interval to a date and then returns the date.
				
				ADDDATE(date, INTERVAL value addunit)			
				ADDDATE(date, days)
					date: Required.  The date to be modified
					days: Required. The number of days to add to date
					value: Required. The value of the time/date interval to add. Both positive and negative values are allowed
					addunit: Required. The type of interval to add. Can be one of the following values:
						MICROSECOND
						SECOND
						MINUTE
						HOUR
						DAY
						WEEK
						MONTH
						QUARTER
						YEAR
						SECOND_MICROSECOND
						MINUTE_MICROSECOND
						MINUTE_SECOND
						HOUR_MICROSECOND
						HOUR_SECOND
						HOUR_MINUTE
						DAY_MICROSECOND
						DAY_SECOND
						DAY_MINUTE
						DAY_HOUR
						YEAR_MONTH
				
				Example
					
					SELECT ADDDATE("2017-06-15", INTERVAL 10 DAY); // 2017-06-25. Add 10 days to a date and return the date
					
					SELECT ADDDATE("2017-06-15 09:34:21", INTERVAL 15 MINUTE); // 2017-06-15 09:49:21. Add 15 minutes to a date and return the date
					
					SELECT ADDDATE("2017-06-15 09:34:21", INTERVAL -3 HOUR); // 2017-06-15 06:34:21. Subtract 3 hours to a date and return the date
					
					SELECT ADDDATE("2017-06-15", INTERVAL -2 MONTH); // 2017-04-15. Subtract 2 months to a date and return the date
			
			ADDTIME()--MySQL Date Functions:
			
				The ADDTIME() function adds a time interval to a time/datetime and then returns the time/datetime.
				
				ADDTIME(datetime, addtime)
					datetime: Required.  The time/datetime to be modified
					addtime: Required. The time interval to add to datetime. Both positive and negative values are allowed
				
				Example
					
					SELECT ADDTIME("2017-06-15 09:34:21", "2"); // 2017-06-15 09:34:23. Add 2 seconds to a time and return the datetime
					
					SELECT ADDTIME("2017-06-15 09:34:21.000001", "5.000003"); // 2017-06-15 09:34:26.000004. Add 5 seconds and 3 microseconds to a time and return the datetime
					
					SELECT ADDTIME("2017-06-15 09:34:21.000001", "2:10:5.000003"); // 2017-06-15 11:44:26.000004. Add 2 hours, 10 minutes, 5 seconds, and 3 microseconds to a time and return the datetime
					
					SELECT ADDTIME("2017-06-15 09:34:21.000001", "5 2:10:5.000003"); // 2017-06-20 11:44:26.000004. Add 5 days, 2 hours, 10 minutes, 5 seconds, and 3 microseconds to a time and return the datetime
					
					SELECT ADDTIME("09:34:21.000001", "2:10:5.000003"); // 11:44:26.000004. Add 2 hours, 10 minutes, 5 seconds, and 3 microseconds to a time and return the time
			
			CURDATE()--MySQL Date Functions:
			
				The CURDATE() function returns the current date.

				Note: The date is returned as "YYYY-MM-DD" (string) or as YYYYMMDD (numeric).

				Note: This function equals the CURRENT_DATE() function.
					
				CURDATE()
				
				Example
					
					SELECT CURDATE(); // 2024-04-27
					
					SELECT CURDATE() + 1; // 20240428
			
			CURRENT_DATE()--MySQL Date Functions:
			
				The CURRENT_DATE() function returns the current date.

				Note: The date is returned as "YYYY-MM-DD" (string) or as YYYYMMDD (numeric).

				Note: This function equals the CURDATE() function.
				
				CURRENT_DATE()
				
				Example
					
					SELECT CURRENT_DATE(); // 2024-04-27
					
					SELECT CURRENT_DATE() + 1; // 20240428
			
			CURRENT_TIME()--MySQL Date Functions:
			
				The CURRENT_TIME() function returns the current time.

				Note: The time is returned as "HH-MM-SS" (string) or as HHMMSS.uuuuuu (numeric).

				Note: This function equals the CURTIME() function.
					
				CURRENT_TIME()
				
				Example
					
					SELECT CURRENT_TIME(); // 23:59:32
					
					SELECT CURRENT_TIME() + 1; // 235947
			
			CURRENT_TIMESTAMP()--MySQL Date Functions:
			
				The CURRENT_TIMESTAMP() function returns the current date and time.

				Note: The date and time is returned as "YYYY-MM-DD HH-MM-SS" (string) or as YYYYMMDDHHMMSS.uuuuuu (numeric).
				
				CURRENT_TIMESTAMP()
				
				Example
					
					SELECT CURRENT_TIMESTAMP(); // 2024-04-28 00:24:44
					
					SELECT CURRENT_TIMESTAMP() + 1; // 20240428002502
			
			CURTIME()--MySQL Date Functions:
			
				The CURTIME() function returns the current time.

				Note: The time is returned as "HH-MM-SS" (string) or as HHMMSS.uuuuuu (numeric).

				Note: This function equals the CURRENT_TIME() function.
				
				CURTIME()
				
				Example
					
					SELECT CURTIME(); // 00:26:03
					
					SELECT CURTIME() + 1; // 2621
			
			DATE()--MySQL Date Functions:
			
				The DATE() function extracts the date part from a datetime expression.
				
				DATE(expression)
					expression: Required.  A valid date/datetime value. Returns NULL if expression is not a date or a datetime
				
				Example
					
					SELECT DATE("2017-06-15"); // 2017-06-15
					
					SELECT DATE("2017-06-15 09:34:21"); // 2017-06-15
					
					SELECT DATE("The date is 2017-06-15"); // Extract the date part (will return NULL)
					
					SELECT DATE(OrderDate) FROM Orders;
			
			DATEDIFF()--MySQL Date Functions:
			
				The DATEDIFF() function returns the number of days between two date values.
				
				DATEDIFF(date1, date2)
					date1, date2
						Required. Two dates to calculate the number of days between. (date1 - date2)
				
				Example
					
					SELECT DATEDIFF("2017-06-25", "2017-06-15"); // 10
					
					SELECT DATEDIFF("2017-06-25 09:34:21", "2017-06-15 15:25:35"); // 10
					
					SELECT DATEDIFF("2017-01-01", "2016-12-24"); // 8
			
			DATE_ADD()--MySQL Date Functions:
			
				The DATE_ADD() function adds a time/date interval to a date and then returns the date.
				
				DATE_ADD(date, INTERVAL value addunit)
					date: Required. The date to be modified
					value: Required. The value of the time/date interval to add. Both positive and negative values are allowed
					addunit: Required. The type of interval to add. Can be one of the following values:
						MICROSECOND
						SECOND
						MINUTE
						HOUR
						DAY
						WEEK
						MONTH
						QUARTER
						YEAR
						SECOND_MICROSECOND
						MINUTE_MICROSECOND
						MINUTE_SECOND
						HOUR_MICROSECOND
						HOUR_SECOND
						HOUR_MINUTE
						DAY_MICROSECOND
						DAY_SECOND
						DAY_MINUTE
						DAY_HOUR
						YEAR_MONTH
				
				Example
					
					SELECT DATE_ADD("2017-06-15", INTERVAL 10 DAY); // 2017-06-25
					
					SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL 15 MINUTE); // 2017-06-15 09:49:21
					
					SELECT DATE_ADD("2017-06-15 09:34:21", INTERVAL -3 HOUR); // 2017-06-15 06:34:21
					
					SELECT DATE_ADD("2017-06-15", INTERVAL -2 MONTH); // 2017-04-15
			
			DATE_FORMAT()--MySQL Date Functions:
			
				The DATE_FORMAT() function formats a date as specified.
				
				DATE_FORMAT(date, format)
					date: Required. The date to be formatted
					format: Required. The format to use. Can be one or a combination of the following values:
						%a	Abbreviated weekday name (Sun to Sat)
						%b	Abbreviated month name (Jan to Dec)
						%c	Numeric month name (0 to 12)
						%D	Day of the month as a numeric value, followed by suffix (1st, 2nd, 3rd, ...)
						%d	Day of the month as a numeric value (01 to 31)
						%e	Day of the month as a numeric value (0 to 31)
						%f	Microseconds (000000 to 999999)
						%H	Hour (00 to 23)
						%h	Hour (00 to 12)
						%I	Hour (00 to 12)
						%i	Minutes (00 to 59)
						%j	Day of the year (001 to 366)
						%k	Hour (0 to 23)
						%l	Hour (1 to 12)
						%M	Month name in full (January to December)
						%m	Month name as a numeric value (00 to 12)
						%p	AM or PM
						%r	Time in 12 hour AM or PM format (hh:mm:ss AM/PM)
						%S	Seconds (00 to 59)
						%s	Seconds (00 to 59)
						%T	Time in 24 hour format (hh:mm:ss)
						%U	Week where Sunday is the first day of the week (00 to 53)
						%u	Week where Monday is the first day of the week (00 to 53)
						%V	Week where Sunday is the first day of the week (01 to 53). Used with %X
						%v	Week where Monday is the first day of the week (01 to 53). Used with %x
						%W	Weekday name in full (Sunday to Saturday)
						%w	Day of the week where Sunday=0 and Saturday=6
						%X	Year for the week where Sunday is the first day of the week. Used with %V
						%x	Year for the week where Monday is the first day of the week. Used with %v
						%Y	Year as a numeric, 4-digit value
						%y	Year as a numeric, 2-digit value
				
				Example
				
					SELECT DATE_FORMAT("2017-06-15", "%Y"); // 2017
					
					SELECT DATE_FORMAT("2017-06-15", "%M %d %Y"); // June 15 2017
					
					SELECT DATE_FORMAT("2017-06-15", "%W %M %e %Y"); // Thursday June 15 2017
					
					SELECT DATE_FORMAT(BirthDate, "%W %M %e %Y") FROM Employees;
			
			DATE_SUB()--MySQL Date Functions:
			
				The DATE_SUB() function subtracts a time/date interval from a date and then returns the date.
				
				DATE_SUB(date, INTERVAL value interval)
					date: Required. The date to be modified
					value: Required. The value of the time/date interval to subtract. Both positive and negative values are allowed
					interval: Required. The type of interval to subtract. Can be one of the following values:
						MICROSECOND
						SECOND
						MINUTE
						HOUR
						DAY
						WEEK
						MONTH
						QUARTER
						YEAR
						SECOND_MICROSECOND
						MINUTE_MICROSECOND
						MINUTE_SECOND
						HOUR_MICROSECOND
						HOUR_SECOND
						HOUR_MINUTE
						DAY_MICROSECOND
						DAY_SECOND
						DAY_MINUTE
						DAY_HOUR
						YEAR_MONTH
				
				Example
					
					SELECT DATE_SUB("2017-06-15", INTERVAL 10 DAY); // 2017-06-05
					
					SELECT DATE_SUB("2017-06-15 09:34:21", INTERVAL 15 MINUTE); // 2017-06-15 09:19:21
					
					SELECT DATE_SUB("2017-06-15 09:34:21", INTERVAL 3 HOUR); // 2017-06-15 06:34:21
					
					SELECT DATE_SUB("2017-06-15", INTERVAL -2 MONTH); // 2017-08-15			
					
			DAY()--MySQL Date Functions:
			
				The DAY() function returns the day of the month for a given date (a number from 1 to 31).

				Note: This function equals the DAYOFMONTH() function.
				
				DAY(date)
					date: Required. The date to extract the day from
				
				Example
					
					SELECT DAY("2017-06-15"); // 15
					
					SELECT DAY("2017-06-15 09:34:21"); // 15
					
					SELECT DAY(CURDATE()); // 28
			
			DAYNAME()--MySQL Date Functions:
			
				The DAYNAME() function returns the weekday name for a given date.
				
				DAYNAME(date)
					date: Required.  The date to extract the weekday name from
				
				Example
					
					SELECT DAYNAME("2017-06-15"); // Thursday
					
					SELECT DAYNAME("2017-06-15 09:34:21"); // Thursday
					
					SELECT DAYNAME(CURDATE()); // Sunday
			
			DAYOFMONTH()--MySQL Date Functions:
			
				The DAYOFMONTH() function returns the day of the month for a given date (a number from 1 to 31).

				Note: This function equals the DAY() function.
				
				DAYOFMONTH(date)
					date: Required. The date to extract the day from
				
				Example
					
					SELECT DAYOFMONTH("2017-06-15"); // 15. Return the day of the month for a date
					
					SELECT DAYOFMONTH("2017-06-15 09:34:21"); // 15. Return the day of the month for a date
					
					SELECT DAYOFMONTH(CURDATE()); // 28. Return the day of the month for the current system date
			
			DAYOFWEEK()--MySQL Date Functions:
			
				The DAYOFWEEK() function returns the weekday index for a given date (a number from 1 to 7).

				Note: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday.
				
				DAYOFWEEK(date)
					date: Required. The date to return the weekday index from
				
				Example
					
					SELECT DAYOFWEEK("2017-06-15"); // 5. Return the weekday index for a date
					
					SELECT DAYOFWEEK("2017-06-15 09:34:21"); // 5. Return the weekday index for a date
					
					SELECT DAYOFWEEK(CURDATE()); // 1. Return the weekday index for the current system date
			
			DAYOFYEAR()--MySQL Date Functions:
			
				The DAYOFYEAR() function returns the day of the year for a given date (a number from 1 to 366).
				
				DAYOFYEAR(date)
					date: Required. The date to return the day of the year from
				
				Example
					
					SELECT DAYOFYEAR("2017-06-15"); // 166
					
					SELECT DAYOFYEAR("2017-01-01"); // 1
					
					SELECT DAYOFYEAR(CURDATE()); // 119
			
			EXTRACT()--MySQL Date Functions:
			
				The EXTRACT() function extracts a part from a given date.
				
				EXTRACT(part FROM date)
					part: Required. The part to extract. Can be one of the following:
						MICROSECOND
						SECOND
						MINUTE
						HOUR
						DAY
						WEEK
						MONTH
						QUARTER
						YEAR
						SECOND_MICROSECOND
						MINUTE_MICROSECOND
						MINUTE_SECOND
						HOUR_MICROSECOND
						HOUR_SECOND
						HOUR_MINUTE
						DAY_MICROSECOND
						DAY_SECOND
						DAY_MINUTE
						DAY_HOUR
						YEAR_MONTH
						date: Required. The date to extract a part from
				
				Example
					
					SELECT EXTRACT(MONTH FROM "2017-06-15"); // 6. Extract the month from a date
					
					SELECT EXTRACT(WEEK FROM "2017-06-15"); // 24. Extract the week from a date
					
					SELECT EXTRACT(MINUTE FROM "2017-06-15 09:34:21"); // 34. Extract the minute from a datetime
					
					SELECT EXTRACT(YEAR_MONTH FROM "2017-06-15 09:34:21"); // 201706. Extract the year and month from a datetime		
			
			FROM_DAYS()--MySQL Date Functions:
			
				The FROM_DAYS() function returns a date from a numeric datevalue.

				The FROM_DAYS() function is to be used only with dates within the Gregorian calendar.

				Note: This function is the opposite of the TO_DAYS() function.
				
				FROM_DAYS(number)
					number: Required.  The numeric day to convert to a date
				
				Example
					
					SELECT FROM_DAYS(685467); // 1876-09-29. Return a date from a numeric representation of the day
					
					SELECT FROM_DAYS(780500); // 2136-12-08. Return a date from a numeric representation of the day
			
			HOUR()--MySQL Date Functions:
			
				The HOUR() function returns the hour part for a given date (from 0 to 838).
				
				HOUR(datetime)
					datetime: Required. The datetime value to extract the hour from
				
				Example
					
					SELECT HOUR("2017-06-20 09:34:00"); // 9. Return the hour part of a datetime
					
					SELECT HOUR("838:59:59"); // 838. Return the hour part of a datetime
			
			LAST_DAY()--MySQL Date Functions:
			
				The LAST_DAY() function extracts the last day of the month for a given date.
				
				LAST_DAY(date)
					date: Required. The date to extract the last day of the month from
				
				Example
					
					SELECT LAST_DAY("2017-06-20");// 2017-06-30. Extract the last day of the month for the given date
					
					SELECT LAST_DAY("2017-02-10 09:34:00"); // 2017-02-28. Extract the last day of the month for the given date
			
			LOCALTIME()--MySQL Date Functions:
			
				The LOCALTIME() function returns the current date and time.

				Note: The date and time is returned as "YYYY-MM-DD HH-MM-SS" (string) or as YYYYMMDDHHMMSS.uuuuuu (numeric).
				
				LOCALTIME()
				
				Example
					
					SELECT LOCALTIME(); // 2024-04-28 05:41:40. Return current date and time
					
					SELECT LOCALTIME() + 1; // 20240428054211. Return current date and time + 1
			
			LOCALTIMESTAMP()--MySQL Date Functions:
			
				The LOCALTIMESTAMP() function returns the current date and time.

				Note: The date and time is returned as "YYYY-MM-DD HH-MM-SS" (string) or as YYYYMMDDHHMMSS.uuuuuu (numeric).
				
				LOCALTIMESTAMP()
				
				Example
					
					SELECT LOCALTIMESTAMP(); // 2024-04-28 05:45:00. Return current date and time
					
					SELECT LOCALTIMESTAMP() + 1; // 20240428055460. Return current date and time + 1
			
			MAKEDATE()--MySQL Date Functions:
			
				The MAKEDATE() function creates and returns a date based on a year and a number of days value.
				
				MAKEDATE(year, day)
					year: Required. A year (4-digits)
					day: Required. A number that indicates the day of the year
				
				Example
					
					SELECT MAKEDATE(2017, 3); // 2017-01-03.Create and return a date based on  a year and a number of days value
					
					SELECT MAKEDATE(2017, 175); // 2017-06-24
					
					SELECT MAKEDATE(2017, 100); // 2017-04-10
					
					SELECT MAKEDATE(2017, 366); // 2018-01-01
			
			MAKETIME()--MySQL Date Functions:
			
				The MAKETIME() function creates and returns a time based on an hour, minute, and second value.
				
				MAKETIME(hour, minute, second)
					hour: Required. The hour value
					minute: Required. The minute value
					second: Required. The seconds value
				
				Example
					
					SELECT MAKETIME(11, 35, 4); // 11:35:04. Create and return a time value based on an hour, minute, and second value
					
					SELECT MAKETIME(16, 1, 0); // 16:01:00
					
					SELECT MAKETIME(21, 59, 59); // 21:59:59
					
					SELECT MAKETIME(838, 59, 59); // 838:59:59			
					
			MICROSECOND()--MySQL Date Functions:
			
				The MICROSECOND() function returns the microsecond part of a time/datetime (from 0 to 999999).
				
				MICROSECOND(datetime)
					datetime: Required. The time or datetime to extract the microsecond from
				
				Example
					
					SELECT MICROSECOND("2017-06-20 09:34:00.000023"); // 23. Return the microsecond part of a datetime
					
					SELECT MICROSECOND("23:59:59.000045"); // 45
			
			MINUTE()--MySQL Date Functions:
			
				The MINUTE() function returns the minute part of a time/datetime (from 0 to 59).
				
				MINUTE(datetime)
					datetime: Required. The time or datetime extract the minute from
				
				Example
					
					SELECT MINUTE("2017-06-20 09:34:00"); // 34. Return the minute part of a datetime value
					
					SELECT MINUTE("23:59:59"); // 59
			
			MONTH()--MySQL Date Functions:
			
				The MONTH() function returns the month part for a given date (a number from 1 to 12).
				
				MONTH(date)
					date: Required. The date or datetime to extract the month from
				
				Example
					
					SELECT MONTH("2017-06-15"); // 6
					
					SELECT MONTH("2017-06-15 09:34:21"); // 6
			
			MONTHNAME()--MySQL Date Functions:
			
				The MONTHNAME() function returns the name of the month for a given date.
				
				MONTHNAME(date)
					date: Required. The date or datetime value to extract the month name from 
				
				Example
					
					SELECT MONTHNAME("2017-06-15"); // June
					
					SELECT MONTHNAME("2017-06-15 09:34:21"); // June
					
					SELECT MONTHNAME(CURDATE()); // April
			
			NOW()--MySQL Date Functions:
			
				The NOW() function returns the current date and time.

				Note: The date and time is returned as "YYYY-MM-DD HH:MM:SS" (string) or as YYYYMMDDHHMMSS.uuuuuu (numeric).
				
				NOW()
				
				Example
					
					SELECT NOW(); // 2024-04-28 07:17:26
					
					SELECT NOW() + 1; // 20240428071748
			
			PERIOD_ADD()--MySQL Date Functions:
			
				The PERIOD_ADD() function adds a specified number of months to a period.

				The PERIOD_ADD() function will return the result formatted as YYYYMM.
				
				PERIOD_ADD(period, number)
					period: Required. A period. Format: YYMM or YYYYMM
					number: Required. The number of months to add to period. Both positive and negative values are allowed
				
				Example
					
					SELECT PERIOD_ADD(201703, 5); // 201708. Add a specified number of months to a period
					
					SELECT PERIOD_ADD(201703, 15); // 201806
					
					SELECT PERIOD_ADD(201703, -2);
					
					SELECT PERIOD_ADD(201703, -2);
			
			PERIOD_DIFF()--MySQL Date Functions:
			
				The PERIOD_DIFF() function returns the difference between two periods. The result will be in months.

				Note: period1 and period2 should be in the same format.
				
				PERIOD_DIFF(period1, period2)
					period1: Required. A period. Format: YYMM or YYYYMM
					period2: Required. Another period. Format: YYMM or YYYYMM
				
				Example
					
					SELECT PERIOD_DIFF(201710, 201703); // 7. Return the difference between two periods
					
					SELECT PERIOD_DIFF(201703, 201803); // -12
					
					SELECT PERIOD_DIFF(1703, 1612);3					
					
			QUARTER()--MySQL Date Functions:
				
				The QUARTER() function returns the quarter of the year for a given date value (a number from 1 to 4).
					January-March returns 1
					April-June returns 2
					July-Sep returns 3
					Oct-Dec returns 4
				
				QUARTER(date)
					date: Required. The date or datetime to extract the quarter from
				
				Example
					
					SELECT QUARTER("2017-06-15"); // 2
					
					SELECT QUARTER("2017-01-01 09:34:21"); // 1
					
					SELECT QUARTER(CURDATE()); // 2
			
			SECOND()--MySQL Date Functions:
				
				The SECOND() function returns the seconds part of a time/datetime (from 0 to 59).
				
				SECOND(datetime)
					datetime: Required. The time or datetime to extract the second from
				
				Example
					
					SELECT SECOND("2017-06-20 09:34:00.000023"); // 0
					
					SELECT SECOND("23:59:59"); // 59
			
			SEC_TO_TIME()--MySQL Date Functions:
			
				The SEC_TO_TIME() function returns a time value (in format HH:MM:SS) based on the specified seconds.
				
				SEC_TO_TIME(seconds)
					seconds: Required. The number of seconds. Both positive or negative values are allowed
				
				Example
					
					SELECT SEC_TO_TIME(1); // 00:00:01
					
					SELECT SEC_TO_TIME(-6897); // -01:54:57
			
			STR_TO_DATE()--MySQL Date Functions:
			
				The STR_TO_DATE() function returns a date based on a string and a format.
				
				STR_TO_DATE(string, format)
					string: Required. The string to be formatted to a date
					format: Required. The format to use. Can be one or a combination of the following values:
						%a	Abbreviated weekday name (Sun to Sat)
						%b	Abbreviated month name (Jan to Dec)
						%c	Numeric month name (0 to 12)
						%D	Day of the month as a numeric value, followed by suffix (1st, 2nd, 3rd, ...)
						%d	Day of the month as a numeric value (01 to 31)
						%e	Day of the month as a numeric value (0 to 31)
						%f	Microseconds (000000 to 999999)
						%H	Hour (00 to 23)
						%h	Hour (00 to 12)
						%I	Hour (00 to 12)
						%i	Minutes (00 to 59)
						%j	Day of the year (001 to 366)
						%k	Hour (0 to 23)
						%l	Hour (1 to 12)
						%M	Month name in full (January to December)
						%m	Month name as a numeric value (01 to 12)
						%p	AM or PM
						%r	Time in 12 hour AM or PM format (hh:mm:ss AM/PM)
						%S	Seconds (00 to 59)
						%s	Seconds (00 to 59)
						%T	Time in 24 hour format (hh:mm:ss)
						%U	Week where Sunday is the first day of the week (00 to 53)
						%u	Week where Monday is the first day of the week (00 to 53)
						%V	Week where Sunday is the first day of the week (01 to 53). Used with %X
						%v	Week where Monday is the first day of the week (01 to 53). Used with %X
						%W	Weekday name in full (Sunday to Saturday)
						%w	Day of the week where Sunday=0 and Saturday=6
						%X	Year for the week where Sunday is the first day of the week. Used with %V
						%x	Year for the week where Monday is the first day of the week. Used with %V
						%Y	Year as a numeric, 4-digit value
						%y	Year as a numeric, 2-digit value
				
				Example
					
					SELECT STR_TO_DATE("August 10 2017", "%M %d %Y"); // 2017-08-10
					
					SELECT STR_TO_DATE("August,5,2017", "%M %e %Y");
					
					SELECT STR_TO_DATE("Monday, August 14, 2017", "%W %M %e %Y");
					
					SELECT STR_TO_DATE("2017,8,14 10,40,10", "%Y,%m,%d %h,%i,%s"); // 2017-08-14 10:40:10
			
			SUBDATE()--MySQL Date Functions:
			
				The SUBDATE() function subtracts a time/date interval from a date and then returns the date.
				
				SUBDATE(date, INTERVAL value unit)			
				SUBDATE(date, days)
					date: Required. The original date
					days: Required. The number of days to subtract from date
					value: Required. The value of the time/date interval to subtract. Both positive and negative values are allowed
					unit: Required. The type of interval. Can be one of the following values:
						MICROSECOND
						SECOND
						MINUTE
						HOUR
						DAY
						WEEK
						MONTH
						QUARTER
						YEAR
						SECOND_MICROSECOND
						MINUTE_MICROSECOND
						MINUTE_SECOND
						HOUR_MICROSECOND
						HOUR_SECOND
						HOUR_MINUTE
						DAY_MICROSECOND
						DAY_SECOND
						DAY_MINUTE
						DAY_HOUR
						YEAR_MONTH
				
				Example
					
					SELECT SUBDATE("2017-06-15", INTERVAL 10 DAY); // 2017-06-05. Subtract 10 days from a date and return the date
					
					SELECT SUBDATE("2017-06-15 09:34:21", INTERVAL 15 MINUTE); // 2017-06-15 09:19:21
					
					SELECT SUBDATE("2017-06-15 09:34:21", INTERVAL 3 HOUR); // 2017-06-15 06:34:21
					
					SELECT SUBDATE("2017-06-15", INTERVAL -2 MONTH); // 2017-08-15
			
			SUBTIME()--MySQL Date Functions:
			
				The SUBTIME() function subtracts time from a time/datetime expression and then returns the new time/datetime.
				
				SUBTIME(datetime, time_interval)
					datetime: Required. The time or datetime to be modified
					time_interval: Required. The time interval to subtract from datetime. Both positive and negative values are allowed
				
				Example
					
					SELECT SUBTIME("2017-06-15 10:24:21.000004", "5.000001"); // 2017-06-15 10:24:16.000003. Subtract 5.000001 seconds and return the datetime
					
					SELECT SUBTIME("2017-06-15 10:24:21.000004", "3:2:5.000001"); // 2017-06-15 07:22:16.000003. Subtract 3 hours, 2 minutes, 5.000001 seconds and return the datetime
					
					SELECT SUBTIME("10:24:21", "5"); // 10:24:16. Subtract 5 seconds and return the time
					
					SELECT SUBTIME("10:24:21", "300"); // 10:21:21. Subtract 3 minutes and return the time
					
					SELECT SUBTIME("10:24:21", "-3:2:5"); // 13:26:26					
					
			SYSDATE()--MySQL Date Functions:
			
				The SYSDATE() function returns the current date and time.

				Note: The date and time is returned as "YYYY-MM-DD HH:MM:SS" (string) or as YYYYMMDDHHMMSS (numeric).
				
				SYSDATE()
				
				Example
					
					SELECT SYSDATE(); // 2024-04-28 08:21:41. Return the current date and time
					
					SELECT SYSDATE() + 1; // 20240428082205. Return the current date and time + 1
			
			TIME()--MySQL Date Functions:
			
				The TIME() function extracts the time part from a given time/datetime.

				Note: This function returns "00:00:00" if expression is not a datetime/time, or NULL if expression is NULL.
				
				TIME(expression)
					expression: Required. The time/datetime to extract the time from
				
				Example
					
					SELECT TIME("19:30:10"); // 19:30:10. Extract the time part from a time expression
					
					SELECT TIME("2017-08-15 19:30:10"); // 19:30:10
					
					SELECT TIME("2017-08-15 19:30:10.000001"); // 19:30:10.000001
					
					SELECT TIME(NULL);
			
			TIME_FORMAT()--MySQL Date Functions:
			
				The TIME_FORMAT() function formats a time by a specified format.
				
				TIME_FORMAT(time, format)
					time: Required. The time to be formatted
					format: Required. The format to use. Can be one or a combination of the following:
						%f	Microseconds (000000 to 999999)
						%H	Hour (00 to 23)
						%h	Hour (00 to 12)
						%I	Hour (00 to 12)
						%i	Minutes (00 to 59)
						%p	AM or PM
						%r	Time in 12 hour AM or PM format (hh:mm:ss AM/PM)
						%S	Seconds (00 to 59)
						%s	Seconds (00 to 59)
						%T	Time in 24 hour format (hh:mm:ss)
				
				Example
					
					SELECT TIME_FORMAT("19:30:10", "%H %i %s"); // 19 30 10
					
					SELECT TIME_FORMAT("19:30:10", "%h %i %s %p"); // 07 30 10 PM
					
					SELECT TIME_FORMAT("19:30:10", "%r"); // 07:30:10 PM
					
					SELECT TIME_FORMAT("19:30:10", "%T"); // 19:30:10
			
			TIME_TO_SEC()--MySQL Date Functions:
			
				The TIME_TO_SEC() function converts a time value into seconds.
				
				TIME_TO_SEC(time)
					time: Required. The time value
				
				Example
					
					SELECT TIME_TO_SEC("19:30:10"); // 70210. Convert a time value into seconds
					
					SELECT TIME_TO_SEC("00:00:05"); // 5
					
					SELECT TIME_TO_SEC("03:30:00.999999"); // 12600
					
					SELECT TIME_TO_SEC("-03:30:00"); // -12600
			
			TIMEDIFF()--MySQL Date Functions:
			
				The TIMEDIFF() function returns the difference between two time/datetime expressions.

				Note: time1 and time2 should be in the same format, and the calculation is time1 - time2.
					
				TIMEDIFF(time1, time2)
					time1: Required. A time value
					time2: Required. Another time value
				
				Example
					
					SELECT TIMEDIFF("13:10:11", "13:10:10"); // 00:00:01
					
					SELECT TIMEDIFF("2017-06-25 13:10:11", "2017-06-15 13:10:10"); // 240:00:01
			
			TIMESTAMP()--MySQL Date Functions:
			
				The TIMESTAMP() function returns a datetime value based on a date or datetime value.

				Note: If there are specified two arguments with this function, it first adds the second argument to the first, and then returns a datetime value.
				
				TIMESTAMP(expression, time)
					expression: Required. A date or datetime value
					time: Optional. A time value to add to expression
				
				Example
					
					SELECT TIMESTAMP("2017-07-23",  "13:10:11"); // 2017-07-23 13:10:11
					
					SELECT TIMESTAMP("2017-07-23"); // 2017-07-23 00:00:00
			
			TO_DAYS()--MySQL Date Functions:
			
				The TO_DAYS() function returns the number of days between a date and year 0 (date "0000-00-00").

				The TO_DAYS() function can be used only with dates within the Gregorian calendar.

				Note: This function is the opposite of the FROM_DAYS() function.
				
				TO_DAYS(date)
					date: Required. The given date
				
				Example
				
					SELECT TO_DAYS("2017-06-20"); // 736865. Return the number of days between the date and year 0
					
					SELECT TO_DAYS("2017-06-20 09:34:00"); // 736865					
					
			WEEK()--MySQL Date Functions:
			
				The WEEK() function returns the week number for a given date (a number from 0 to 53).
				
				WEEK(date, firstdayofweek)
					date: Required.  The date or datetime to extract the week number form
					firstdayofweek: Optional. Specifies what day the week starts on. Can be one of the following:
						0 - First day of week is Sunday
						1 - First day of week is Monday and the first week of the year has more than 3 days
						2 - First day of week is Sunday
						3 - First day of week is Monday and the first week of the year has more than 3 days
						4 - First day of week is Sunday and the first week of the year has more than 3 days
						5 - First day of week is Monday
						6 - First day of week is Sunday and the first week of the year has more than 3 days
						7 - First day of week is Monday
				
				Example
				
					SELECT WEEK("2017-06-15"); // 24. Return the week number for a date
					
					SELECT WEEK("2017-10-25"); // 43
					
					SELECT WEEK(CURDATE()); // 17. Return the week number for the current system date
			
			WEEKDAY()--MySQL Date Functions:
			
				The WEEKDAY() function returns the weekday number for a given date.

				Note: 0 = Monday, 1 = Tuesday, 2 = Wednesday, 3 = Thursday, 4 = Friday, 5 = Saturday, 6 = Sunday.
				
				WEEKDAY(date)
					date: Required.  The date or datetime to extract the weekday number from
				
				Example
					
					SELECT WEEKDAY("2017-06-15"); // 3
					
					SELECT WEEKDAY("2017-01-01"); // 6
					
					SELECT WEEKDAY(CURDATE()); // 0
			
			WEEKOFYEAR()--MySQL Date Functions:
			
				The WEEKOFYEAR() function returns the week number for a given date (a number from 1 to 53).

				Note: This function assumes that the first day of the week is Monday and the first week of the year has more than 3 days.
				
				WEEKOFYEAR(date)
				
				Example
					
					SELECT WEEKOFYEAR("2017-06-15"); // 24
					
					SELECT WEEKOFYEAR("2017-01-01"); // 52
					
					SELECT WEEKOFYEAR(CURDATE()); // 18
			
			YEAR()--MySQL Date Functions:
			
				The YEAR() function returns the year part for a given date (a number from 1000 to 9999).
				
				YEAR(date)
					date: Required.  The date/datetime to extract the year from
				
				Example
					
					SELECT YEAR("2017-06-15"); // 2017
					
					SELECT YEAR("2017-06-15 09:34:21"); // 2017
					
					SELECT YEAR(CURDATE()); // 2024
			
			YEARWEEK()--MySQL Date Functions:
			
				The YEARWEEK() function returns the year and week number (a number from 0 to 53) for a given date.
				
				YEARWEEK(date, firstdayofweek)
					date: Required.  The date or datetime value to extract the year and week number from
					firstdayofweek
						Optional. Specifies what day the week starts on. Can be one of the following:
							0 - First day of week is Sunday
							1 - First day of week is Monday and the first week has more than 3 days
							2 - First day of week is Sunday
							3 - First day of week is Monday and the first week has more than 3 days
							4 - First day of week is Sunday and the first week has more than 3 days
							5 - First day of week is Monday
							6 - First day of week is Sunday and the first week has more than 3 days
							7 - First day of week is Monday
				
				Example
					
					SELECT YEARWEEK("2017-06-15"); // 201724. Return the year and week number for a date
					
					SELECT YEARWEEK("2017-10-25"); // 201743
					
					SELECT YEARWEEK(CURDATE()); // 202417					
					
		Advanced Functions--MySQL Function:

			BIN()--MySQL Advanced Functions:
				
				The BIN() function returns a binary representation of a number, as a string value.
				
				BIN(number)
					number: Required. A number
				
				Example
					
					SELECT BIN(15); // 1111
					
					SELECT BIN(111); // 1101111
					
					SELECT BIN(8); // 1000			
					
			BINARY--MySQL Function:
			
				The BINARY function converts a value to a binary string.

				This function is equivalent to using CAST(value AS BINARY).
				
				BINARY value
					value: Required. The value to convert
				
				Example
					
					SELECT BINARY "W3Schools.com"; // W3Schools.com
					
					SELECT "HELLO" = "hello"; // 1. Here MySQL performs a character-by-character comparison of  "HELLO" and "hello" and return 1 (because on a character-by-character basis, they are equivalent)
					
					SELECT BINARY "HELLO" = "hello"; // 0
			
			CASE--MySQL Function:
			
				The CASE statement goes through conditions and return a value when the first condition is met (like an IF-THEN-ELSE statement). So, once a condition is true, it will stop reading and return the result.

				If no conditions are true, it will return the value in the ELSE clause.

				If there is no ELSE part and no conditions are true, it returns NULL.
				
				CASE
					WHEN condition1 THEN result1
					WHEN condition2 THEN result2
					WHEN conditionN THEN resultN
					ELSE result
				END;
						condition1, condition2, ...conditionN: Required. The conditions. These are evaluated in the same order as they are listed
						result1, result2, ...resultN: Required. The value to return once a condition is true
				
				Example
					
					// Go through conditions and return a value when the first condition is met
					SELECT OrderID, Quantity,
					CASE
						WHEN Quantity > 30 THEN "The quantity is greater than 30"
						WHEN Quantity = 30 THEN "The quantity is 30"
						ELSE "The quantity is under 30"
					END
					FROM OrderDetails;
							
					SELECT CustomerName, City, Country
					FROM Customers
					ORDER BY
					(CASE
						WHEN City IS NULL THEN Country
						ELSE City
					END);
				
			CAST()--MySQL Function:
				
				The CAST() function converts a value (of any type) into the specified datatype.

				Tip: See also the CONVERT() function.
				
				CAST(value AS datatype)
					value: Required. The value to convert
					datatype: Required. The datatype to convert to. Can be one of the following:
						DATE	Converts value to DATE. Format: "YYYY-MM-DD"
						DATETIME	Converts value to DATETIME. Format: "YYYY-MM-DD HH:MM:SS"
						DECIMAL	Converts value to DECIMAL. Use the optional M and D parameters to specify the maximum number of digits (M) and the number of digits following the decimal point (D).
						TIME	Converts value to TIME. Format: "HH:MM:SS"
						CHAR	Converts value to CHAR (a fixed length string)
						NCHAR	Converts value to NCHAR (like CHAR, but produces a string with the national character set)
						SIGNED	Converts value to SIGNED (a signed 64-bit integer)
						UNSIGNED	Converts value to UNSIGNED (an unsigned 64-bit integer)
						BINARY	Converts value to BINARY (a binary string)
				
				Example
					
					SELECT CAST("2017-08-29" AS DATE); // 2017-08-29. Convert a value to a DATE datatype
					
					SELECT CAST(150 AS CHAR); // 150. Convert a value to a CHAR datatype
					
					SELECT CAST("14:06:10" AS TIME); // 14:06:10. Convert a value to a TIME datatype
					
					SELECT CAST(5-10 AS SIGNED); // -5. Convert a value to a SIGNED datatype
			
			COALESCE()--MySQL Function:
			
				- The COALESCE() function returns the first non-null value in a list.
				- Khi :groups là một mảng rỗng, thì COALESCE(:groups) sẽ trả về NULL
				
				COALESCE(val1, val2, ...., val_n)
					val1, val2, val_n: Required. The values to test
				
				Example
					
					SELECT COALESCE(NULL, NULL, NULL, 'W3Schools.com', NULL, 'Example.com'); // W3Schools.com. Return the first non-null value in a list
					
					SELECT COALESCE(NULL, 1, 2, 'W3Schools.com'); // 1
			
			CONNECTION_ID()--MySQL Function:
			
				The CONNECTION_ID() function returns the unique connection ID for the current connection.
				
				CONNECTION_ID()
				
				Example
					
					SELECT CONNECTION_ID(); // 3002772. Return the unique connection ID for the current connection
			
			CONV()--MySQL Function:
			
				The CONV() function converts a number from one numeric base system to another, and returns the result as a string value.

				Note: This function returns NULL if any of the parameters are NULL.
				
				CONV(number, from_base, to_base)
					number: Required. A number
					from_base: The numeric base system of number (a number between 2 and 36)
					to_base
						The numeric base system to convert to (a number between 2 and 36 or -2 and -36)
				
				Example
					
					SELECT CONV(15, 10, 2); // 1111. Convert a number from numeric base system 10 to numeric base system 2
					
					SELECT CONV(1111, 2, 10); // 15. Convert a number from numeric base system 2 to numeric base system 10
					
					SELECT CONV(88, 10, 16); // 58. Convert a number from numeric base system 10 to numeric base system 16
			
			CONVERT()--MySQL Function:
			
				The CONVERT() function converts a value into the specified datatype or character set.
				
				CONVERT(value, type)
					CONVERT(value USING charset)
					value: Required. The value to convert
					type: Required. The datatype to convert to. Can be one of the following:
						DATE	Converts value to DATE. Format: "YYYY-MM-DD"
						DATETIME	Converts value to DATETIME. Format: "YYYY-MM-DD HH:MM:SS"
						DECIMAL	Converts value to DECIMAL. Use the optional M and D parameters to specify the maximum number of digits (M) and the number of digits following the decimal point (D).
						TIME	Converts value to TIME. Format: "HH:MM:SS"
						CHAR	Converts value to CHAR (a fixed length string)
						NCHAR	Converts value to NCHAR (like CHAR, but produces a string with the national character set)
						SIGNED	Converts value to SIGNED (a signed 64-bit integer)
						UNSIGNED	Converts value to UNSIGNED (an unsigned 64-bit integer)
						BINARY	Converts value to BINARY (a binary string)
					charset: Required. The character set to convert to
				
				Example
					
					SELECT CONVERT("2017-08-29", DATE); // 2017-08-29. Convert a value to a DATE datatype
					
					SELECT CONVERT(150, CHAR); // 150. Convert a value to a CHAR datatype
					
					SELECT CONVERT("14:06:10", TIME); // 14:06:10. Convert a value to a TIME datatype
					
					SELECT CONVERT("W3Schools.com" USING latin1); // W3Schools.com.Convert a value to LATIN1 character set					
					
			CURRENT_USER()--MySQL Function:
			
				The CURRENT_USER() function returns the user name and host name for the MySQL account that the server used to authenticate the current client.

				The result is returned as a string in the UTF8 character set.
				
				CURRENT_USER()
				
				Example
					
					SELECT CURRENT_USER(); // guest@%
						
			DATABASE()--MySQL Function:
			
				The DATABASE() function returns the name of the current database.

				If there is no current database, this function returns NULL or "".
				
				DATABASE()
				
				Example
					
					SELECT DATABASE(); // northwind
			
			IF()--MySQL Function:
			
				The IF() function returns a value if a condition is TRUE, or another value if a condition is FALSE.
				
				IF(condition, value_if_true, value_if_false)
					condition: Required. The value to test
					value_if_true: Required. The value to return if condition is TRUE
					value_if_false: Required. The value to return if condition is FALSE
				
				Example
					
					SELECT IF(500<1000, "YES", "NO"); // YES
					
					SELECT IF(500<1000, 5, 10); // 5
					
					SELECT IF(STRCMP("hello","bye") = 0, "YES", "NO"); // NO. Test whether two strings are the same and return "YES" if they are, or "NO" if not
					
					// Return "MORE" if the condition is TRUE, or "LESS" if the condition is FALSE
					SELECT OrderID, Quantity, IF(Quantity>10, "MORE", "LESS")
					FROM OrderDetails;					
			
			IFNULL()--MySQL Function:
			
				The IFNULL() function returns a specified value if the expression is NULL.

				If the expression is NOT NULL, this function returns the expression.
				
				IFNULL(expression, alt_value)
					expression: Required. The expression to test whether is NULL
					alt_value: Required. The value to return if expression is NULL
				
				Example
					
					SELECT IFNULL(NULL, "W3Schools.com"); // W3Schools.com. Return the specified value IF the expression is NULL, otherwise return the expression
					
					SELECT IFNULL("Hello", "W3Schools.com"); // Hello
					
					SELECT IFNULL(NULL, 500); // 500
			
			ISNULL()--MySQL Function:
			
				The ISNULL() function returns 1 or 0 depending on whether an expression is NULL.

				If expression is NULL, this function returns 1. Otherwise, it returns 0.
					
				ISNULL(expression)
					expression: Required. The value to test
				
				Example
					
					SELECT ISNULL(NULL); // 1
					
					SELECT ISNULL(""); // 0
					
					SELECT ISNULL(350); // 0
					
					SELECT ISNULL("Hello world!"); // 0
			
			LAST_INSERT_ID()--MySQL Function:
			
				The LAST_INSERT_ID() function returns the AUTO_INCREMENT id of the last row that has been inserted or updated in a table.
					
				LAST_INSERT_ID(expression)
					expression: Optional. An expression
				
				Example
					
					SELECT LAST_INSERT_ID(); // 0
			
			NULLIF()--MySQL Function:
			
				The NULLIF() function compares two expressions and returns NULL if they are equal. Otherwise, the first expression is returned.
				
				NULLIF(expr1, expr2)
					expr1, expr2: Required. The two expressions to be compared
				
				Example
					
					SELECT NULLIF(25, 25);
					
					SELECT NULLIF(25, "Hello"); // 25
					
					SELECT NULLIF("Hello", "world"); // Hello
					
					SELECT NULLIF("2017-08-25", "2017-08-25");
			
			SESSION_USER()--MySQL Function:
			
				The SESSION_USER() function returns the current user name and host name for the MySQL connection.

				Note: This function is equal to the SYSTEM_USER() and the USER() function.
				
				SESSION_USER()
				
				Example
					
					SELECT SESSION_USER(); // guest@35.192.20.199					
					
			SYSTEM_USER()--MySQL Function:
				
				The SYSTEM_USER() function returns the current user name and host name for the MySQL connection.

				Note: This function is equal to the SESSION_USER() function and the USER() function.
				
				SYSTEM_USER()
				
				Example
					
					SELECT SYSTEM_USER(); // guest@35.192.20.199
			
			USER()--MySQL Function:
				
				The USER() function returns the current user name and host name for the MySQL connection.

				Note: This function is equal to the SESSION_USER() function and the SYSTEM_USER() function.
				
				USER()
				
				Example
					
					guest@35.192.20.199 // Return the current user name and host name for the MySQL connection
			
			VERSION()--MySQL Function:
			
				The VERSION() function returns the current version of the MySQL database, as a string.
				
				VERSION()
				
				Example
					
					SELECT VERSION(); // 5.7.44										
	
	Example--MySQL:
	
								- Chú ý trong cùng 1 bảng mỗi lần chạy chỉ qua 1 row duy nhất
								- Code chạy từ FROM trước, cuối cùng mới đến SELECT
								- Chú ý khi table a có 3 row, table b có 3 row, thì khi FROM a, b sẽ tạo ra table có 3 x 3 = 9 row, có thể xem là từ 1 row của bảng a chiếu lần lượt với từng row của bảng b tạo thành
								3 row, nếu từ bảng b chiếu ngược lại đến bảng a thì cũng thành 3 row đó, nên để dễ hình dung cứ lấy theo bảng a là base rồi nối đến bảng b
								- Bản chất các thao tác được thực hiện trên tên của cột trong bảng, riêng FROM là theo table
								- Đã dùng group by thì sẽ nhóm cùng giá trị về 1 row
								- Bất kỳ một cột hay biểu thức trong danh sách của SELECT không phải là hàm nhóm dữ liệu thì phải có mệnh đề GROUP BY (nếu không có thì trong 1 group by của 1 cột sẽ có nhiều
								giá trị của một cột SELECT khác mà không có group by, lúc đó tạo nên nhiều row với các giá trị khác nhau phá vỡ nguyên tắc group by)													
								- Aggregate Functions thường được sử dụng để tính toán trên một tập hợp các hàng và trả về một giá trị duy nhất.
								- Window Functions cho phép bạn thực hiện tính toán trên một tập hợp các hàng trong một phạm vi cửa sổ được xác định, không làm thay đổi số lượng các hàng.
								- Chuỗi dùng '' thay vì ""
								- Điều kiện P1.id <> P1.id sẽ luôn là FALSE, vì nó so sánh một giá trị với chính nó. Do đó, không có bản ghi nào sẽ được loại bỏ. Câu truy vấn đang cố gắng so sánh email của
								mỗi người trong cùng bảng Person (P1) với tất cả các người khác trong cùng bảng, nhưng không phải là với chính họ (vì điều kiện P1.id <> P2.id đã bị loại bỏ). Có thể hiểu
								là nó sẽ lặp qua từng row, khi cùng 1 bảng thì nó sẽ là cùng 1 row, nên cần thêm 1 bảng nữa để khi lặp có thể với 2 row khác nhau
								- WHERE (product_id, change_date) in...nếu một cặp (product_id, change_date) trong bảng chính khớp với một cặp (product_id, change_date) trong kết quả của câu truy vấn con,
								thì hàng đó sẽ được bao gồm trong kết quả cuối cùng của truy vấn.
								- khi bạn kiểm tra CONCAT(:projectNumber) IS NULL, bạn đang kiểm tra xem danh sách projectNumber có rỗng hoặc null không.
								- Các hàm như SUM...thì sẽ tính dựa theo kết quả của nhiều row nên bắt buộc phải dùng chung với group by (window function) hoặc over (Aggregation)
								- Với join thì phần trùng là cấp nhân
								- Khi sử dụng 2 bảng trong mệnh đề FROM, SQL sẽ thực hiện một CROSS JOIN theo mặc định. Điều này có nghĩa là nó sẽ tạo ra một kết quả là tích Descartes của hai bảng, tức là nó sẽ kết hợp mọi
								hàng từ bảng này với mọi hàng từ bảng kia.
								- Trong sql thì (a, b) in (c, d) để true thì a = c và b = d
								- Toán tử UNION được sử dụng để kết hợp tập hợp kết quả của hai hoặc nhiều câu lệnh SELECT. Mỗi câu lệnh SELECT với UNION phải có cùng số lượng cột, các cột phải có cùng kiểu dữ liệu, các cột
								trong mỗi câu lệnh SELECT phải có cùng trật tự.
								- Chú ý mỗi lần select thì chỉ chạy trên 1 row duy nhất của kết quả sau khi đã from, where
								- Thứ tự thực hiện FROM -> WHERE -> GROUP BY -> SELECT -> HAVING -> ORDER BY
								- Cứ mỗi lần group by thì sẽ gom nhóm các row có cùng giá trị về 1 row duy nhất
								- Khóa ngoại sẽ nằm trong bảng Many và sẽ tham chiếu đến khóa chính của bảng One. Bằng cách đặt khóa ngoại ở bảng Many (Orders), chúng ta có thể liên kết mỗi đơn hàng với một khách hàng
								cụ thể, nhưng mỗi khách hàng có thể có nhiều đơn hàng.

		Second Highest Salary--MySQL example:
		
													Sắp xếp salary theo thứ tự giảm dần rồi mình select giá trị thứ 2 trong đó, dùng hàm IFNULL để kiểm tra xem giá trị thứ 2 sau khi sắp xếp có hay không, nếu không (đồng nghĩa
													với biểu thức ở tham số thứ 1 của IFNULL là null) thì giá trị thay thế của nó sẽ là null
													
													SELECT
													IFNULL(
													  (SELECT DISTINCT Salary // distinct ở đây có tác dụng nếu có lương trùng thì chỉ lấy 1 cái
													   FROM Employee
													   ORDER BY Salary DESC
														LIMIT 1 OFFSET 1), // OFFSET 1 ở đây nghĩa là lấy từ phần từ thứ 2, LIMIT 1 là chỉ lấy duy nhất kết quả đấy
													NULL) AS SecondHighestSalary
													
		Movie Rating--MySQL example:
		
													- Hoàn lại tên của user trong bảng Users đánh giá các phim nhiều nhất, nếu trùng số lượng đánh giá thì lấy tên đứng trước trong bảng chữ cái
													- Tìm tên phim có đánh giá trung bình vào Feb 2020 cao nhất, nếu trùng giá trị trung bình thì lấy tên đứng trước trong bảng chữ cái
													- Tính từng trường hợp rồi sử dụng UNION ALL để kết hợp 2 kết quả vào trong 1 bảng. Dùng LIKE để lặp ngày theo yêu cầu, tính với kết quả mong muốn rồi sắp xếp theo thứ tự
													giảm dần, dùng giới hạn để chỉ lấy 1 phần tử đầu tiên của kết quả, đó là phần tử lớn
													- Khi sử dụng toán tử UNION trong SQL, kết quả sẽ được ghép theo thứ tự cột của truy vấn đầu tiên. Điều này có nghĩa là tên cột và kiểu dữ liệu của kết quả sẽ giống với truy
													vấn đầu tiên trong phép UNION. Các truy vấn sau đó cũng phải tuân thủ cùng số lượng cột và kiểu dữ liệu.												
													
													(Select u.name as results
													from MovieRating as m, Users as u
													where u.user_id = m.user_id
													Group By m.user_id // Group By và Order By đi chung 1 cặp ở đây để thực hiện việc count theo user_id
													Order by count(m.user_id) desc, u.name limit 1)
													union all
													(Select m.title as results
													from MovieRating as r, Movies as m
													where m.movie_id = r.movie_id 
													and r.created_at like "2020-02-%"
													Group By r.movie_id  // Group By và Order By đi chung 1 cặp ở đây để thực hiện việc tính trung bình rating theo theo movie_id
													Order by avg(r.rating) desc, m.title limit 1);
													
		Top Travellers--MySQL example:
		
													- Liệt kê các tên với tổng khoảng cách lớn nhất, nếu cùng khoảng cách thì sắp theo tên
													- Lựa chọn 1 cột theo tên, 1 cột để tính tổng distance với việc lặp qua distance với IFNULL phía trong dùng SUM OVER, nếu khác NULL thì trả về giá trị đó, nếu NULL thì trả
													về 0, dùng RIGHT JOIN để lọc điều kiện 2 id (id của Users và user_id của Rides) của 2 table bằng nhau, cuối cùng sắp xếp với ORDER BY theo distance giảm, tiếp theo sẽ
													theo name tăng
													- SUM(distance) OVER (PARTITION BY user_id): Đây là một cửa sổ (window) function trong SQL. Nó tính tổng (SUM) của cột distance dựa trên một phân vùng được xác định bởi
													PARTITION BY user_id. Cụ thể, nó tính tổng distance cho mỗi user_id riêng biệt. Chú ý nó thực hiện trong SELECT nên sẽ chạy sau khi các câu lệnh khác thực thi. Tạo
													thành 1 row duy nhất
													
													SELECT DISTINCT u.name, // lựa chọn chỉ 1 tên không bị trùng các kết quả
													IFNULL(SUM(distance) OVER (PARTITION BY user_id), 0) as travelled_distance // tổng khoảng cách lặp thông qua user_id
													FROM Rides r 
													RIGHT JOIN Users u // RIGHT JOIN là Users để lấy tất cả distance của user 
														ON r.user_id = u.id // điều kiện để match JOIN là  id 2 bảng bằng nhau
													ORDER BY travelled_distance DESC, name // sắp xếp giảm theo khoảng cách, sau đó tăng theo tên
													
		Average Selling Price--MySQL example:
		
													- Tính tổng trung bình giá
													
													SELECT u.product_id,
														   ROUND(SUM(p.price * u.units) / SUM(u.units), 2) AS average_price// SUM theo group by, p.price * u.units mỗi đợt chỉ thực hiện trên 1 row
													FROM unitssold u 
													JOIN prices p ON p.product_id = u.product_id AND u.purchase_date BETWEEN p.start_date AND p.end_date // lọc thành 1 bảng với điều kiện được thỏa bởi on
													GROUP BY u.product_id // nhóm lại để phục vụ cho phần select
													
		Capital Gain/Loss--MySQL example:
		
													- Lựa chọn theo nhóm tên với sell là cộng, buy thì trừ thông qua hàm sum kết hợp với group by hoặc sum với over
					
			Aggregation (GROUP BY):
			
													SELECT stock_name,
														   SUM(CASE WHEN operation = 'Sell' THEN price
															   ELSE -price END) AS capital_gain_loss
													FROM Stocks
													GROUP BY stock_name
													
			Window Function (SUM OVER):
			
													SELECT DISTINCT stock_name, 
														   SUM(CASE WHEN operation = 'Sell' THEN price ELSE -price END)
														   OVER(PARTITION BY stock_name) AS capital_gain_loss
													FROM Stocks
													
		Replace Employee ID With The Unique Identifier--MySQL example:
		
													Lựa chọn dùng JOIN theo bảng của Employees (vì kết quả bảng này có đầy đủ theo mong đợi) với điều kiện ON là id 2 bảng bằng nhau
													
													select eu.unique_id as unique_id, e.name as name
													from Employees e left join EmployeeUNI eu on e.id = eu.id
													
		Find Users With Valid E-Mails--MySQL example:
		
													Sử dụng REGEXP để lọc các điều kiện của tên
													
													SELECT *
													FROM Users
													WHERE mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode[.]com$';
													
		Product Sales Analysis I--MySQL example:
		
													SELECT các cột cần thiết rồi cuối cùng lựa chọn với điều kiện ON của JOIN là giá trị product_id ở 2 bảng là bằng nhau, chú ý kết quả không có SAMSUNG nên không thể lấy
													Product Table làm bảng JOIN gốc
													
													SELECT P.product_name ,S.year  ,S.price 
													FROM Sales  S
													LEFT JOIN Product P // LEFT JOIN để lấy tất cả các data của Sales
													ON S.product_id = P.product_id
													
		Product Price at a Given Date--MySQL example:
		
													- Cái này yêu cầu tìm giá sản phẩm vào ngày 16/08/2019, nếu giá sản phẩm có cái nào chỉ có sau ngày 16 thì lấy giá trị là 10, nếu cái nào từ 16 trở về trước thì lấy cái nào
													có ngày lớn nhất tính từ ngày 16 trở về trước.
													- Chỗ này chưa rõ sao phải có GROUP BY product_id thì mới chạy đúng kết quả
													
													select distinct product_id, 10 as price
													from Products
													where product_id not in(select distinct product_id from Products where change_date <='2019-08-16' )
													union 
													select product_id, new_price as price
													from Products
													where
														(product_id,change_date) in (select product_id , max(change_date) as date from Products where change_date <='2019-08-16' group by product_id)
														
		findWorkingTime--MySQL example:
		
													- Chú ý nhiều WHEN khác nhau trong 1 CASE
													- CASE WHEN THEN sẽ trả về 1 kết quả theo WHEN, ta có thể để nó vào trong AND để check điều kiện
		
													@Query(value =
															"SELECT A.*" +
																	", E.NAME" +
																	", E.PHOTO" +
																	", CASE WHEN  E.START_WORKING_TIME IS NULL OR  E.START_WORKING_TIME = '' THEN 0 " +
																			"ELSE E.START_WORKING_TIME END AS START_WORKING_TIME " +
																	"FROM tb_pme00_working_time AS A " +
																	"JOIN tb_m00_employee AS E " +
																	"ON A.EMP_ID = E.EMP_ID " +
																	"WHERE 1=1 " +
																	"AND (:empId IS NULL OR :empId = '' OR A.EMP_ID = :empId) " +
																	"AND (:fromDate IS NULL OR A.REGISTER_DATE >= :fromDate) " +
																	"AND (:toDate IS NULL OR A.REGISTER_DATE <= :toDate) " +
																	"AND (:fromArrive IS NULL OR DATE_FORMAT(A.ARRIVE_TIME, '%H:%i:%s') >= :fromArrive) " +
																	"AND (:toArrive IS NULL OR DATE_FORMAT(A.ARRIVE_TIME,'%H:%i:%s') <= :toArrive) " +
																	"AND (:fromLeave IS NULL OR DATE_FORMAT(A.LEAVE_TIME, '%H:%i:%s') >= :fromLeave) " +
																	// on time
																	"AND CASE WHEN :status = 1 then " +
																		"(A.ARRIVE_TIME is not NULL AND A.LEAVE_TIME is not NULL) \n" +
																		"AND ((HOUR(A.ARRIVE_TIME) = E.START_WORKING_TIME AND MINUTE(A.ARRIVE_TIME) = 0) \n" +
																		"OR (HOUR(A.ARRIVE_TIME) < E.START_WORKING_TIME)) \n" +
																		"AND ((E.START_WORKING_TIME = 8 AND HOUR(A.LEAVE_TIME) >= 17) \n" +
																		"OR (E.START_WORKING_TIME = 7 AND HOUR(A.LEAVE_TIME) >= 16))\n" +
																	//late time
																	"WHEN  :status = 2 THEN " +
																		"((A.ARRIVE_TIME is NULL OR A.LEAVE_TIME is null) \n" +
																		"OR (HOUR(A.ARRIVE_TIME) = E.START_WORKING_TIME AND MINUTE(A.ARRIVE_TIME) > 0) \n" +
																		"OR (HOUR(A.ARRIVE_TIME) > E.START_WORKING_TIME)\n" +
																		"OR (E.START_WORKING_TIME = 8 AND HOUR(A.LEAVE_TIME) < 17) \n" +
																		"OR (E.START_WORKING_TIME = 7 AND HOUR(A.LEAVE_TIME) < 16))\n" +
																	"WHEN :status = 0 THEN \n" +
																		"1=1\n" +
																	"END \n" +
																	"AND (:toLeave IS NULL OR DATE_FORMAT(A.LEAVE_TIME,'%H:%i:%s') <= :toLeave)",
															nativeQuery = true)
													List<Object[]> findWorkingTime(@Param("empId") String empId,
																				   @Param("fromDate") Date fromDate, @Param("toDate") Date toDate,
																				   @Param("fromArrive") String fromArrive, @Param("toArrive") String toArrive,
																				   @Param("fromLeave") String fromLeave, @Param("toLeave") String toLeave, @Param("status") Integer status, Pageable pageable);
		
		findDailyReport--MySQL example:
		
													- Trong SQL, câu lệnh CONCAT thường được sử dụng để nối các chuỗi. Khi áp dụng CONCAT vào một danh sách các giá trị, nó sẽ nối tất cả các giá trị trong danh sách lại với
													nhau thành một chuỗi duy nhất.
													- Tuy nhiên, nếu danh sách đó là một danh sách rỗng hoặc null, kết quả của CONCAT sẽ là null. Do đó, khi bạn kiểm tra CONCAT(:projectNumber) IS NULL, bạn đang kiểm tra
													xem danh sách projectNumber có rỗng hoặc null không.
		
													@Query(value =
															"SELECT\n" +
																	" DR.SEQ,\n" +
																	" DR.EMPLOYEE_ID,\n" +
																	" DR.REGISTER_DATE,\n" +
																	" DR.PROJECT_NUMBER,\n" +
																	" DR.CONTENTS,\n" +
																	" DR.REMARKS,\n" +
																	" DR.ATTC_FILE_NM,\n" +
																	" DR.OP_SAT_DT,\n" +
																	" DR.OP_DN_DT,\n" +
																	" DR.CREATION_TIMESTAMP,\n" +
																	" DR.LAST_UPDATE_TIMESTAMP,\n" +
																	" DR.STATUS,\n" +
																	" EMP.NAME as empName,\n" +
																	" EMP.PHOTO\n" +
																	"FROM\n" +
																	"tb_m99_daily_report AS DR\n" +
																	"JOIN tb_m00_employee AS EMP\n" +
																	"ON DR.EMPLOYEE_ID = EMP.EMP_ID\n" +
																	"WHERE 1= 1\n" +
																	"AND (:employeeId IS NULL OR DR.EMPLOYEE_ID = :employeeId)\n" +
																	"AND CASE \n" +
																	"WHEN COALESCE(:projectNumber) IS NOT NULL \n" +
																	"THEN DR.PROJECT_NUMBER IN (:projectNumber) \n" +
																	"WHEN CONCAT(:projectNumber) IS NULL \n" +
																	"THEN DR.PROJECT_NUMBER LIKE '%%' OR DR.PROJECT_NUMBER IS NULL \n" +
																	"END \n" +
																	"AND ((:fromDate IS NULL) OR (DR.REGISTER_DATE >= :fromDate))\n" +
																	"AND ((:toDate IS NULL) OR  (DR.REGISTER_DATE <= :toDate))" +
																	"AND ((:contents IS NULL) OR (DR.CONTENTS LIKE CONCAT('%', :contents, '%')))\n" +
																	"AND ((:remarks IS NULL) OR (DR.REMARKS LIKE CONCAT('%', :remarks, '%')))\n"
															, nativeQuery = true)
													List<Object[]> findDailyReport(@Param("employeeId") String employeeId,
																				   @Param("projectNumber") List<String> projectNumber,
																				   @Param("fromDate") Date fromDate,
																				   @Param("toDate") Date toDate,
																				   @Param("contents") String contents,
																				   @Param("remarks") String remarks,
																				   Pageable pageable);
		
		searchPmeEmployee--MySQL example:
						
													@Query(value = "SELECT E.*\n" +
															",E1.NAME AS CREATE_USER_NAME\n" +
															",E1.PHOTO AS CREATE_USER_PHOTO\n" +
															",CODE1.CD_V_MEANING AS SITE\n" +
															",CODE2.CD_V_MEANING AS STATUS\n" +
															" FROM\n" +
															" TB_M00_EMPLOYEE AS E\n" +
															" JOIN TB_M00_CODES030 CODE1\n" +
															" ON CODE1.CD_V = E.SITE_CODE \n" +
															" JOIN TB_M00_CODES030 CODE2\n" +
															" ON CODE2.CD_V = E.EMP_STATUS \n" +
															" LEFT JOIN TB_M00_EMPLOYEE AS E1\n" +
															" ON E.CREATE_BY = E1.EMP_ID \n" +
															" JOIN TB_M00_CODES030 CODE3 \n" +
															" ON CODE3.CD_V = E.GENDER\n" +
															" WHERE 1=1\n" +
															" AND CODE1.CD_TP_ID = 51" +
															" AND CODE2.CD_TP_ID = 99" +
															" AND CODE3.CD_TP_ID = 68" +
															" AND (:siteAll = TRUE OR (CODE1.CD_V_EXPLAIN IN (:site)))" +
															" AND (:status IS NULL OR :status = '' OR (CODE2.CD_V =:status))" +
															" AND (:name IS NULL OR :name = '' OR (E.NAME =:name))" +
															" AND (:empId IS NULL OR :empId = '' OR (E.EMP_ID =:empId))" +
															" AND (:joinDateFrom IS NULL OR (select tmp.JD  from (" +
															"                                      SELECT CAST(E4.JOIN_DATE AS DATE) as JD" +
															"                                             ,E4.emp_id as id " +
															"                                      FROM TB_M00_EMPLOYEE as E4) as tmp " +
															"                                            where" +
															"                                                tmp.JD >= :joinDateFrom and tmp.id = E.emp_id) >=:joinDateFrom)\n" +
															" AND (:joinDateTo IS NULL OR (select tmp.JD" +
															"                                 from (" +
															"                                      SELECT CAST(E5.JOIN_DATE AS DATE) as JD" +
															"                                             ,E5.emp_id as id " +
															"                                      FROM" +
															"                                          TB_M00_EMPLOYEE as E5) as tmp " +
															"                                      where tmp.JD <= :joinDateTo and tmp.id = E.emp_id) <=:joinDateTo)\n" +
															" AND (:genderAll = TRUE OR (CODE3.CD_V IN (:gender))) \n" +
															" AND (:birthdayAll = TRUE OR (SELECT SUBSTRING(E2.BIRTH_DATE, 5, 2) AS tmp " +
															"                                    FROM" +
															"                                        TB_M00_EMPLOYEE E2 " +
															"                                    where" +
															"                                        E2.emp_id = E.emp_id) IN (:birthday)) \n" +
															" AND (:mobile is NULL OR :mobile= '' OR (E.MOBILE LIKE CONCAT('%', :mobile, '%'))) \n" +
															" AND (:address is NULL OR :address = '' OR (E.ADDRESS LIKE CONCAT('%', :address, '%'))) \n" +
															" ORDER BY E.EMP_ID\n"
															, nativeQuery = true)
													List<Object[]> searchPmeEmployee(@Param("siteAll") boolean siteAll,
																					 @Param("site") List<String> site,
																					 @Param("status") String status,
																					 @Param("name") String name,
																					 @Param("empId") String empId,
																					 @Param("joinDateFrom") Date joinDateFrom,
																					 @Param("joinDateTo") Date joinDateTo,
																					 @Param("genderAll") boolean genderAll,
																					 @Param("gender") List<String> gender,
																					 @Param("birthdayAll") boolean birthdayAll,
																					 @Param("birthday") List<String> birthday,
																					 @Param("mobile") String mobile,
																					 @Param("address") String address);
		
		getMediaList--MySQL example:
		
													@Query(value = "select * \n" +
															"from TB_CMS06_MEDIA \n" +
															"where 1=1 \n" +
															"  AND (ID = :id or :id = 0) \n" +
															"  AND NAME like %:name% \n" +
															"  AND (CREATE_BY  = :createBy or :createBy = '') \n" +
															"  AND ((TO_CHAR(CREATE_AT , 'YYYY-MM-DD')  between :fromDate and :toDate ) \n" +
															"  or (:fromDate = '' and :toDate = '') \n" +
															"  or(:fromDate <> '' and :toDate = '' and (TO_CHAR(CREATE_AT , 'YYYY-MM-DD')  >= :fromDate ) ) \n" +
															"  or(:fromDate = '' and :toDate <> '' and (TO_CHAR(CREATE_AT , 'YYYY-MM-DD')  <= :toDate ) )) \n" +
															"  AND (COALESCE(:types) IS NULL or `TYPE` in (:types)) \n" +
															"  AND (STATUS = :status or :status = -1) \n" +
															"  AND (COALESCE(:categoryIds) IS NULL or CATEGORY_ID in (:categoryIds))"
															, nativeQuery = true)
													List<Cms06MediaJpo> getMediaList(
															@Param("id") Integer id,
															@Param("name") String name,
															@Param("fromDate") String fromDate,
															@Param("toDate") String toDate,
															@Param("createBy") String createBy,
															@Param("status") Integer status,
															@Param("types") List<Integer> types,
															@Param("categoryIds") List<String> categoryIds);
															
		Another example--MySQL example:
		
			Example 1:
			
													
													- union để nối các kết quả ở vị trí tương ứng lại với nhau
													
													select distinct product_id, 10 as price
													from Products
													group by product_id
													having (min(change_date) > "2019-08-16")
													union
													select p2.product_id, new_price
													from Products p2
													where (p2.product_id, p2.change_date) in
													(
													select product_id, max(change_date) as recent_date
													from Products
													where change_date <= "2019-08-16"
													group by product_id
													)
													
			Example 2:
			
													- tạo các select con để tạo thành các table để sử dụng
													
													SELECT distinct a.product_id,ifnull(temp.new_price,10) as price 
													FROM products as a
													LEFT JOIN
													(SELECT * 
													FROM products 
													WHERE (product_id, change_date) in (select product_id,max(change_date) from products where change_date<="2019-08-16" group by product_id)) as temp
													on a.product_id = temp.product_id;
			
			Example 3:
			
													- lựa chọn 3 bảng để có thể cùng 1 select với 3 row khác nhau, với điều kiện where bên dưới thì sẽ là 3 row liên tiếp
													
													select distinct log1.num as ConsecutiveNums
													from logs as log1, logs as log2, logs as log3
													where
														(log1.id + 1 = log2.id and log1.id + 2 = log3.id)
														and log1.num = 1 and log2.num = 1 and log3.num = 1
			Example 4:
			
													- đếm vị trí xuất hiện cao nhất nếu là requester_id, accepter_id
			
													select requester_id as id,
														(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
													from RequestAccepted
													group by requester_id
													union 
													select accepter_id as id,
														(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
													from RequestAccepted
													group by accepter_id
													order by num desc limit 1;
			
			Example 5:	
			
													select requester_id as id,
														(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
													from RequestAccepted
													group by requester_id
													union 
													select accepter_id as id,
														(select count(*) from RequestAccepted  where (requester_id = id or accepter_id = id)) as num
													from RequestAccepted
													group by accepter_id
													order by num desc limit 1;
			
-			Example 6:

													- tạo bảng mới nhóm theo player_id, rồi lấy ngày sớm nhất, rồi lọc nó với bảng cũ
			
													SELECT ROUND(COUNT(t2.player_id)/COUNT(t1.player_id),2) AS fraction
													FROM
													(SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id) t1
													LEFT JOIN Activity t2
													ON t1.player_id = t2.player_id AND t1.first_login = t2.event_date - 1
			
			Example 7:
			
													- tạo bảng mới, chú ý phạm vi của từng select
													- Nếu có bất kỳ cặp nào (player_id, ngày 1 ngày trước event_date) xuất hiện trong tập kết quả của truy vấn con, thì nó sẽ được coi là "true" (đúng).
													
													SELECT
													  ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity), 2) AS fraction
													FROM
													  Activity
													WHERE
													  (player_id, DATE_SUB(event_date, INTERVAL 1 DAY))
													  IN (
														SELECT player_id, MIN(event_date) AS first_login FROM Activity GROUP BY player_id
													  )
			
			Example 8:		
			
													Select m.name
													from employee as e
													inner join employee as m on e.managerId=m.id
													group by e.managerId 
													having count(e.id)>=5
			
			Example 9:
			
													- tạo bảng con để lấy id với đúng điều kiện rồi kiểm tra id có chứa trong đó không
													
													select name from employee 
													where id in 
													(select managerId from Employee
													group by managerId
													having count(managerId)>=5)
			
			Example 10:
			
													- Mỗi lần SELECT là sẽ theo từng row của table trong FROM
													- Vì CNT1, CNT2 có nằm trong bảng TBL nên có thể sử dụng cho điều kiện WHERE CNT1 >= 2 AND CNT2 = 1
													- Mỗi cột CNT1, CNT2 sẽ count theo từng PARTITION BY khác nhau
													
													SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016
													FROM
													(SELECT *,
													COUNT(*) OVER(PARTITION BY TIV_2015) AS CNT1,
													COUNT(*) OVER(PARTITION BY LAT, LON) AS CNT2
													FROM INSURANCE
													) AS TBL
													WHERE CNT1 >= 2 AND CNT2 = 1
			
			Example 11:	
			
													- lựa chọn theo điều kiện select
													
													select sum(TIV_2016) TIV_2016
													from insurance a
													where 1 = (select count(*) from insurance b where a.LAT=b.LAT and a.LON=b.LON) 
													and 1 < (select count(*) from insurance c where a.TIV_2015=c.TIV_2015)
			
			Example 12:
			
													- id ở đây là alias
													- câu lệnh OVER() không đi kèm với bất kỳ phân vùng nào, điều này có nghĩa là lặp qua 1 lần nguyên table
													
													SELECT ROW_NUMBER() OVER() id, student
													FROM seat
													ORDER BY IF(MOD(id, 2) = 0, id-1, id+1)
			
			Example 13:
			
													- id mod 2=0: id này lấy theo bảng seat ở from seat
													
													if(id < (select count(*) from seat), if(id mod 2=0, id-1, id+1), if(id mod 2=0, id-1, id)) as id, student
													from seat
													order by id asc;
			
			Example 14:
			
													- from nhiều bảng khác nhau từ 1 bảng base là Seat
													
													/* get all the even numbered rows as odd numbered rows */
													SELECT s1.id - 1 as id, s1.student
													FROM Seat s1
													WHERE s1.id MOD 2 = 0
													UNION
													/* get all the odd numbered rows as even numbered rows */
													SELECT s2.id + 1 as id, s2.student
													FROM Seat s2
													WHERE s2.id MOD 2 = 1 AND s2.id != (SELECT MAX(id) FROM Seat)
													/* Just don't get the last row as we will handle it in the next UNION */
													UNION
													/* get the last row if odd and don't change the id value */
													SELECT s3.id, s3.student
													FROM Seat s3
													WHERE s3.id MOD 2 = 1 AND s3.id = (SELECT MAX(id) FROM Seat)
													/* Order the result by id */
													ORDER BY id ASC;
			
			Example 15:
			
													- lựa chọn theo điều kiện having của group by
													
													select customer_id
													from customer c
													group by customer_id
													having count(distinct product_key)=(select count(distinct product_key) from product)
			
			Example 16:
			
													SELECT customer_id FROM Customer GROUP BY customer_id
													HAVING COUNT(distinct product_key) = (SELECT COUNT(product_key) FROM Product)
			
			Example 17:
			
													- tạo bảng con với select dùng group by
													
													SELECT product_id, year AS first_year, quantity, price
													FROM Sales
													WHERE (product_id, year) IN (
													SELECT product_id, MIN(year) as year
													FROM Sales
													GROUP BY product_id)
			
			Example 18:	
			
													SELECT product_id, year AS first_year, quantity, price
													FROM Sales
													WHERE (product_id, year) in (
														SELECT product_id, MIN(year) 
														FROM Sales
														GROUP BY product_id
													)
			
			Example 19:
			
													select product_id, year as first_year, quantity, price
													from(
													select *,
													rank() over(partition by product_id order by year) as year_rnk
													from sales) as tbl
													where year_rnk = 1
			
			Example 20:
			
													- join bảng rồi group by để select
													
													SELECT u.user_id AS buyer_id, join_date, 
													IFNULL(COUNT(order_date), 0) AS orders_in_2019 
													FROM Users as u
													LEFT JOIN
													Orders as o
													ON u.user_id = o.buyer_id
													AND YEAR(order_date) = '2019'
													GROUP BY u.user_id
			
			Example 21:
													
													- đọc từ from thay vì select để dễ hình dung hơn
													
													CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
													BEGIN
													SET N = N-1;
													  RETURN (
														  SELECT DISTINCT(salary) from Employee order by salary DESC
														  LIMIT 1 OFFSET N
														  
													  );
													END
			
			Example 22:
			
													- having là để lọc cho aggregate function
													- chú ý code đi từ from đầu tiên
													- lọc theo điều kiện lấy giá trị đầu tiên của bảng đầu tiên có turn lớn hơn các turn mà có tổng weight nhỏ hơn 1000
													- đầu tiên tạo thành bảng từ from và join, từ bảng đó thì mới tiếp tục group by rồi having sum để lọc tiếp thành bảng cuối cùng
													- GROUP BY được dùng để sử dụng cho mệnh đề having
													
													SELECT q1.person_name
													FROM Queue q1
													JOIN Queue q2 ON q1.turn >= q2.turn
													GROUP BY q1.turn
													HAVING SUM(q2.weight) <= 1000
													ORDER BY SUM(q2.weight) DESC
													LIMIT 1

			Example 23:
			
													- vì 2 bảng a, b nằm trong from nên có thể sử dụng với điều kiện WHERE DATEDIFF(a.visited_on, b.visited_on) BETWEEN 0 AND 6
													- WHERE DATEDIFF(a.visited_on, b.visited_on) BETWEEN 0 AND 6: với chỉ điều kiện sau sẽ cho ra rất nhiều row, vậy nên ta cần kết hợp với having để lọc row
													- aggregate function trong having dựa vào kết quả của group by
													- GROUP BY cuối cùng chủ yếu để sử dụng cho mệnh đề having
													
													SELECT a.visited_on AS visited_on, SUM(b.day_sum) AS amount,
														   ROUND(AVG(b.day_sum), 2) AS average_amount
													FROM
													  (SELECT visited_on, SUM(amount) AS day_sum FROM Customer GROUP BY visited_on ) a,
													  (SELECT visited_on, SUM(amount) AS day_sum FROM Customer GROUP BY visited_on ) b 
													WHERE DATEDIFF(a.visited_on, b.visited_on) BETWEEN 0 AND 6
													GROUP BY a.visited_on
													HAVING COUNT(b.visited_on) = 7
			
			Example 24:
			
													- sau khi from từ bảng cha thực hiện xong sẽ cho ra kết quả là 1 bảng dựa từ bảng cha với số row đã được lọc, rồi select trong bảng con có thể sử dụng from từ bảng cha để sử
													dụng. Điều này là đúng về mặt dữ liệu vì về bản chất sau from và where thực hiện xong cũng sẽ là chính bảng đó mà lọc bớt row
													- WHERE visited_on BETWEEN DATE_SUB(c.visited_on, INTERVAL 6 DAY) AND c.visited_on: bảng con có thể sử dụng dữ liệu trong bảng cha
													
													SELECT
														visited_on,
														(
															SELECT SUM(amount)
															FROM customer
															WHERE visited_on BETWEEN DATE_SUB(c.visited_on, INTERVAL 6 DAY) AND c.visited_on
														) AS amount,
														ROUND(
															(
																SELECT SUM(amount) / 7
																FROM customer
																WHERE visited_on BETWEEN DATE_SUB(c.visited_on, INTERVAL 6 DAY) AND c.visited_on
															),
															2
														) AS average_amount
													FROM customer c
													WHERE visited_on >= (
															SELECT DATE_ADD(MIN(visited_on), INTERVAL 6 DAY)
															FROM customer
														)
													GROUP BY visited_on;
			
-			Example 25:
			
													select distinct visited_on, amount, round(amount/7, 2) as average_amount
													from (select visited_on, 
														  sum(amount) over (order by visited_on range between interval 6 day preceding and current row) as amount,
														  dense_rank() over (order by visited_on) as rk
														  from Customer) as t
													where rk >= 7
			
			Example 26:
			
													- sum theo điều kiện
													
													SELECT "Low Salary" AS category,
														   sum(income < 20000) AS accounts_count
													  FROM Accounts
													UNION
													SELECT "Average Salary" AS category,
														   sum(income BETWEEN 20000 AND 50000) AS accounts_count
													  FROM Accounts
													UNION
													SELECT "High Salary" AS category,
														   sum(income > 50000) AS accounts_count
													  FROM Accounts;
			
			Example 27:
			
													WITH CTE AS(
													SELECT account_id,
														CASE 
															WHEN income < 20000 THEN "Low Salary"
															WHEN income > 50000 THEN "High Salary"
															ELSE "Average Salary"
														END AS category
													FROM Accounts),
													CTE_C AS(        
													SELECT "Low Salary" AS Category
													UNION 
													SELECT "Average Salary" AS Category
													UNION 
													SELECT "High Salary" AS Category
													) #need a table of category to make left join 
													#>>> prevent  those category without value in CTE from disappearing 
													SELECT CTE_C.Category, COUNT(account_id) AS  accounts_count
													FROM CTE_C
													LEFT JOIN CTE ON CTE_C.Category = CTE.Category
													GROUP BY CTE_C.Category
			
			Example 28:
			
													select s.user_id, round(avg(if(c.action="confirmed",1,0)),2) as confirmation_rate
													from Signups as s left join Confirmations as c on s.user_id= c.user_id group by user_id;
			
			Example 29:
			
													SELECT s.user_id, 
													  ROUND(AVG(IF(c.action='confirmed',1,0)),2) as confirmation_rate 
													FROM Signups s
													LEFT JOIN Confirmations c using (user_id)
													GROUP BY s.user_id
													
			Example 30:
			
													SELECT c.company_code, c.founder,
														COUNT(DISTINCT lm.lead_manager_code),
														COUNT(DISTINCT sm.senior_manager_code),
														COUNT(DISTINCT m.manager_code),
														COUNT(DISTINCT e.employee_code)
													FROM company c
													LEFT JOIN lead_manager lm ON c.company_code = lm.company_code
													LEFT JOIN senior_manager sm ON lm.company_code = sm.company_code
													LEFT JOIN manager m ON sm.company_code = m.company_code
													LEFT JOIN employee e ON m.company_code = e.company_code
													GROUP BY c.company_code, c.founder
													ORDER BY c.company_code ASC

			Example 31:
			
													SELECT
															ROUND(AVG(LAT_N),4) AS median
													FROM (
															SELECT
																	LAT_N,
																	ROW_NUMBER() OVER(ORDER BY LAT_N) AS row_num,
																	COUNT(LAT_N) OVER() AS total_rows
															FROM STATION) AS numbered
													WHERE 
															row_num IN (FLOOR((total_rows+1)/2.0), CEIL((total_rows+1)/2.0));
															
			Example 32:
			
													SELECT c.hacker_id, d.name
													FROM Difficulty a
													JOIN Challenges b ON a.difficulty_level = b. difficulty_level
													JOIN Submissions c ON c.challenge_id = b.challenge_id 
													JOIN Hackers  d ON d.hacker_id  = c.hacker_id 
													WHERE c.score = a.score
													GROUP BY c.hacker_id, d.name
													HAVING COUNT(c.challenge_id) > 1
													ORDER BY COUNT(c.challenge_id) DESC, c.hacker_id ASC
													
			Example 33:
			
													SELECT w.id, wp.age, w.coins_needed, w.power
													FROM Wands w
													JOIN Wands_Property wp 
													ON w.code = wp.code
													WHERE wp.is_evil = 0 AND w.coins_needed = (
														SELECT MIN(w2.coins_needed) FROM Wands w2 WHERE w2.code = w.code AND w2.power = w.power
													)
													ORDER BY w.power DESC, wp.age DESC;
													
			Example 34:
			
													SELECT w.id, wp.age, w.coins_needed, w.power
													FROM wands w
													JOIN wands_property wp 
													ON w.code = wp.code
													JOIN (
														SELECT wp1.age, MIN(w1.coins_needed) AS min_coins_needed, w1.power
														FROM wands w1
														JOIN wands_property wp1
														ON w1.code = wp1.code
														WHERE wp1.is_evil = 0
														GROUP BY wp1.age, w1.power
													) mc 
													ON w.power = mc.power AND wp.age = mc.age AND w.coins_needed = mc.min_coins_needed 
													WHERE wp.is_evil = 0
													ORDER BY w.power DESC, wp.age DESC;
													
			Example 35:
			
													WITH ChallengeCounts AS (
														SELECT
															h.hacker_id,
															h.name,
															COUNT(c.challenge_id) AS total_challenges
														FROM
															Hackers h
														JOIN
															Challenges c ON h.hacker_id = c.hacker_id
														GROUP BY
															h.hacker_id, h.name
													),
													MaxChallengeCount AS (
														SELECT
															MAX(total_challenges) AS max_challenges
														FROM
															ChallengeCounts
													),
													FilteredChallengeCounts AS (
														SELECT
															cc.hacker_id,
															cc.name,
															cc.total_challenges
														FROM
															ChallengeCounts cc
														JOIN
															MaxChallengeCount mcc ON cc.total_challenges = mcc.max_challenges
														OR cc.total_challenges IN (
															SELECT
																total_challenges
															FROM
																ChallengeCounts
															GROUP BY
																total_challenges
															HAVING
																COUNT(*) = 1
														)
													)
													SELECT
														hacker_id,
														name,
														total_challenges
													FROM
														FilteredChallengeCounts
													ORDER BY
														total_challenges DESC,
														hacker_id ASC;
														
			Example 36:
			
													WITH cte1 AS (
														SELECT hacker_id, COUNT(*) AS count
														FROM challenges
														GROUP BY hacker_id
													),
													cte2 AS (
														SELECT count
														FROM cte1
														WHERE count != (SELECT MAX(count) FROM cte1)
														GROUP BY count
														HAVING COUNT(*) > 1
													)
													SELECT h.hacker_id, h.name, count
													FROM cte1
													JOIN hackers h ON h.hacker_id = cte1.hacker_id
													WHERE count NOT IN (SELECT count FROM cte2)
													ORDER BY count DESC, hacker_id;
													
			Example 37:
			
													select h.hacker_id, h.name, sum(a.maxscore)
													from hackers h
													inner join (select s.hacker_id, s.challenge_id, max(s.score) as maxscore
																from submissions s
																group by s.hacker_id, s.challenge_id) as a
															on h.hacker_id = a.hacker_id
													group by h.hacker_id, h.name
													having sum(a.maxscore)> 0
													order by sum(a.maxscore) desc , h.hacker_id
													
			Example 38:
			
													with my_cte as
													( 	select s1.id, s1.name, f.friend_id, s2.name as friend_name, p.salary as salary
														from Students s1
														join Friends f on f.id = s1.id
														join students s2 on f.friend_id = s2.id
														join Packages p on s1.id = p.id 
													)
													select my_cte.name
													from my_cte
													join Packages p
													on my_cte.friend_id = p.id
													where my_cte.salary < p.salary
													order by p.salary
													
			Example 39:
			
													WITH ordered_list as
													(	SELECT ROW_NUMBER() OVER (ORDER BY x) pair_id, x, y
														FROM functions
													)
													SELECT DISTINCT f1.x, f1.y
													FROM ordered_list f1
													JOIN ordered_list f2 ON f1.x=f2.y AND f2.x=f1.y AND f1.pair_id != f2.pair_id
													WHERE f1.x<=f1.y
													ORDER BY f1.x
													
			Example 40:
			
													WITH RECURSIVE Series AS(
														SELECT 2 AS n 
														UNION 
														SELECT n+1 FROM Series 
														WHERE n<1000
													) 
													SELECT GROUP_CONCAT(n SEPARATOR '&') FROM(
														SELECT n FROM Series AS Numbers 
														WHERE NOT EXISTS(
															SELECT n FROM Series AS Divisors 
															WHERE Numbers.n%Divisors.n=0 AND Divisors.n<Numbers.n
													)
													) AS A;

Oracle---:
	Các hàm trong Oracle--Oracle:
		String/Char Functions
			ASCII( single_character ):
													Trong Oracle hàm ASCII dùng để lấy số thứ tự nằm trong bảng mã ASCI của một kí tự bất kì, nghĩa là bạn truyền kí tự vào và nó sẽ trả về số thứ tự của ký tự đó trong bảng mã
													ASCII.
			
													SELECT ASCII('c') AS ASCII_NUMBER
													
													ASCII('t')
													Result: 116
													
													ASCII('T')
													Result: 84
													
													ASCII('T2')
													Result: 84
			ASCIISTR( string ):
													Hàm ASCIISTR dùng để chuyển đổi các ký tự đặc biệt trong một chuỗi bất kì thành chuỗi kí tự trong bảng mã ASCII bằng cách sử dụng kiểu ký tự lưu trong database.
													
													ASCIISTR('A B C Ä Ê')
													Result: 'A B C \00C4 \00CA'
													 
													ASCIISTR('A B C Õ Ø')
													Result: 'A B C \00D5 \00D8'
													 
													ASCIISTR('A B C Ä Ê Í Õ Ø')
													Result: 'A B C \00C4 \00CA \00CD \00D5 \00D8'
			CHR( number_code ):
													Hàm CHR có công dụng ngược với hàm ASCII, nó sẽ chuyển đổi một số thành ký tự tương ứng trong bảng mã ASCII.
													
													CHR(116)
													Result: 't'
													 
													CHR(84)
													Result: 'T'
			COMPOSE( string ):
													Hàm COMPOSE chuyển đổi một chuỗi sang định dạng Unicode.
													
													COMPOSE('o' || unistr('\0308') )
													Result: ö
													 
													COMPOSE('a' || unistr('\0302') )
													Result: â
													 
													COMPOSE('e' || unistr('\0301') )
													Result: é
			CONCAT( string1, string2 ):
													Hàm CONCAT dùng để nối hai chuỗi lại với nhau và trả về một chuỗi là tổng của của hai chuỗi đó.
													
													CONCAT('Tech on', ' Freetuts')
													Result: 'Tech on Freetuts'
													 
													CONCAT('a', 'b')
													Result: 'ab'
			CONVERT( string1, char_set_to [, char_set_from] ):
																		Hàm CONVERT dùng để chuyển đổi định dạng của một chuỗi từ bộ kí tự này sang bộ kí tự khác.
																		
																		CONVERT('A B C D E Ä Ê Í Õ Ø', 'US7ASCII', 'WE8ISO8859P1')
																		Result: 'A B C D E A E I ? ?'
			DECOMPOSE:
													Hàm này có tác dụng ngược với hàm COMPOSE
													
													DECOMPOSE('Très bien')
													Result: 'Tre`s bien'
													 
													DECOMPOSE('é')
													Result: 'e´'
													 
													DECOMPOSE('olé')
													Result: 'ole´'
			DUMP( expression [, return_format] [, start_position] [, length] ):
																						Hàm DUM dùng để xem thông tin chi tiết của một giá trị biểu thức, nó sẽ trả về một chuỗi gồm các thông tin: datatype code, the length in
																						bytes, và hệ biểu diễn của giá trị đó. Hàm này thường dùng để debug.
		
																						DUMP('Tech')
																						Result: 'Typ=96 Len=4: 84,101,99,104'
																						 
																						DUMP('Tech', 10)
																						Result: 'Typ=96 Len=4: 84,101,99,104'
																						 
																						DUMP('Tech', 16)
																						Result: 'Typ=96 Len=4: 54,65,63,68'
																						 
																						DUMP('Tech', 1016)
																						Result: 'Typ=96 Len=4 CharacterSet=US7ASCII: 54,65,63,68'
																						 
																						DUMP('Tech', 1017)
																						Result: 'Typ=96 Len=4 CharacterSet=US7ASCII: T,e,c,h'
			INITCAP( string1 ):
													Hàm INITCAP dùng để chuyển đuổi ký tự đầu tiên của mỗi từ sang chữ hoa, còn các ký tự còn lại sang chữ thường. Hàm này khá thú vị và dễ sử dụng.
													
													INITCAP('tech on the net');
													Result: 'Tech On The Net'
													 
													INITCAP('GEORGE BURNS');
													Result: 'George Burns'
			INSTR( string, substring [, start_position [, th_appearance ] ] ):
																						Đây là hàm khá đặc biệt, nó dùng để kiểm tra xem chuỗi con có xuất hiện trong chuỗi cha không, nếu có thì trả về vị trí xuất hiện, nếu không
																						thì trả về 0.
																						
																						INSTR('Tech on the net', 'e')
																						Result: 2   (the first occurrence of 'e')
																						 
																						INSTR('Tech on the net', 'e', 1, 1)
																						Result: 2   (the first occurrence of 'e')
																						 
																						INSTR('Tech on the net', 'e', 1, 2)
																						Result: 11  (the second occurrence of 'e')
																						 
																						INSTR('Tech on the net', 'e', 1, 3)
																						Result: 14  (the third occurrence of 'e')
																						 
																						INSTR('Tech on the net', 'e', -3, 2)
																						Result: 2
			INSTR2( string, substring [, start_position [, th_appearance ] ] ):
																						Hàm INSTR2 dùng để tìm vị trí xuất hiện của chuỗi con trong chuỗi cha, nó giống như hàm INSTR, chỉ khác là nó sử dụng UCS2 code point.
																						
																						INSTR2('freetuts.net', 'e')
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTR2('freetuts.net', 'e, 1, 1)
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTR2('freetuts.net', 'e', 1, 2)
																						Result: 4   (the second occurrence of 'e')
																						 
																						INSTR2('freetuts.net', 'e', 1, 3)
																						Result: 11  (the third occurrence of 'e')
																						 
																						INSTR2('freetuts.net', 'e', -3, 2)
																						Result: 10
			INSTR4( string, substring [, start_position [, th_appearance ] ] ):
																						Hàm INSTR4 dùng để tìm vị trí xuất hiện của chuỗi con trong chuỗi cha, nó giống như hàm INSTR, chỉ khác là nó sử dụng UCS4 code point.
																						
																						INSTR4('freetuts.net', 'e')
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTR4('freetuts.net', 'e, 1, 1)
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTR4('freetuts.net', 'e', 1, 2)
																						Result: 4   (the second occurrence of 'e')
																						 
																						INSTR4('freetuts.net', 'e', 1, 3)
																						Result: 11  (the third occurrence of 'e')
																						 
																						INSTR4('freetuts.net', 'e', -3, 2)
																						Result: 10
			INSTRB( string, substring [, start_position [, th_appearance ] ] ):
																						Hàm INSTRB dùng để tìm vị trí xuất hiện của chuỗi con trong chuỗi cha, nó giống như hàm INSTR, chỉ khác là nó sử dụng Byte thay cho ký tự.
																						
																						INSTRB('freetuts.net', 'e')
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTRB('freetuts.net', 'e, 1, 1)
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTRB('freetuts.net', 'e', 1, 2)
																						Result: 4   (the second occurrence of 'e')
																						 
																						INSTRB('freetuts.net', 'e', 1, 3)
																						Result: 11  (the third occurrence of 'e')
																						 
																						INSTRB('freetuts.net', 'e', -3, 2)
																						Result: 10
			INSTRC( string, substring [, start_position [, th_appearance ] ] ):
																						Hàm INSTRC dùng để tìm vị trí xuất hiện của chuỗi con trong chuỗi cha, nó giống như hàm INSTR, chỉ khác là nó sử dụng các ký tự Unicode.
																						
																						INSTRC('freetuts.net', 'e')
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTRC('freetuts.net', 'e, 1, 1)
																						Result: 3   (the first occurrence of 'e')
																						 
																						INSTRC('freetuts.net', 'e', 1, 2)
																						Result: 4   (the second occurrence of 'e')
																						 
																						INSTRC('freetuts.net', 'e', 1, 3)
																						Result: 11  (the third occurrence of 'e')
																						 
																						INSTRC('freetuts.net', 'e', -3, 2)
																						Result: 10
			LENGTH( string1 ):
													Hàm LENGTH dùng để tính độ dài của một chuỗi, hay nói cách khác nó dùng để đếm tổng số ký tự có trong chuỗi, kể cả ký tự khoảng trắng (space).
													
													LENGTH(NULL)
													Result: NULL
													 
													LENGTH('')
													Result: NULL
													 
													LENGTH(' ')
													Result: 1
													 
													LENGTH('Tech on the Net')
													Result: 15
													 
													LENGTH('Tech on the Net ')
													Result: 16
																						
			LENGTH2( string1 ):
													Hàm LENGTH2 dùng để tính độ dài của một chuỗi, hay nói cách khác nó dùng để đếm tổng số ký tự có trong chuỗi, kể cả ký tự khoảng trắng (space). Nó giống với hàm LENGTH, chỉ
													khác là dùng UCS2.
													
													LENGTH2(NULL)
													Result: NULL
													 
													LENGTH2('')
													Result: NULL
													 
													LENGTH2(' ')
													Result: 1
													 
													LENGTH2('Tech on the Net')
													Result: 15
													 
													LENGTH2('Tech on the Net ')
													Result: 16
			LOWER( string1 ):
													Hàm LOWER có tác dụng chuyển đổi chữ hoa thành chữ thường, nó sẽ chuyển đổi tất cả ký tự có trong chuỗi mà bạn truyền vào.
													
													LOWER('freetuts.NET');
													Result: 'freetuts.net'
													 
													LOWER('Freetuts.net   ');
													Result: 'freetuts.net'
			LPAD( string1, padded_length [, pad_string] ):
																		Hàm này có công dụng là đệm vào bên trái của chuỗi với tập ký tự được xác định trong tham số của nó.
																		
																		LPAD('freetuts', 10);
																		Result: '  freetuts'
																		 
																		LPAD('freetuts', 8);
																		Result: 'freetuts'
																		 
																		LPAD('freetuts', 11, '0');
																		Result: '000freetuts'
																		 
																		LPAD('freetuts', 4);
																		Result: 'free'
																		 
																		LPAD('freetuts', 5, 'z');
																		Result: 'freet'
			LTRIM( string1 [, trim_string] ):
																		Đây là hàm dùng để xóa đi những kí tự được chỉ định nằm phía bên trái của chuỗi.
																		
																		LTRIM('   tech')
																		Result: 'tech'
																		 
																		LTRIM('   tech', ' ')
																		Result: 'tech'
																		 
																		LTRIM('000123', '0')
																		Result: '123'
																		 
																		LTRIM('123123Tech', '123')
																		Result: 'Tech'
																		 
																		LTRIM('123123Tech123', '123')
																		Result: 'Tech123'
																		 
																		LTRIM('xyxzyyyTech', 'xyz')
																		Result: 'Tech'
																		 
																		LTRIM('6372Tech', '0123456789')
																		Result: 'Tech'
			NCHR( number_code ):
																		NCHR(116)
																		Result: 't'
																		 
																		NCHR(84)
																		Result: 'T'
																		 
																		NCHR(82)
																		Result: 'R'
			REGEXP_INSTR:												
																		Một hàm rất hay dùng để xử lý chuỗi nâng cao dựa vào chuỗi pattern, đó là hàm REGEXP_INSTR. hàm này có công dụng là tìm một chuỗi con nằm trong chuỗi cha
																		dựa vào mẫu so khớp pattern, hay còn gọi là mẫu Regular Expression.
				Cú pháp:
																		REGEXP_INSTR( 
																			STRING, 
																			pattern [,
																			start_position [, 
																			nth_appearance [, 
																			return_option [, 
																			match_parameter [, s
																			ub_expression ] ] ] ] ]
																		)
				Ví dụ
																		SELECT REGEXP_INSTR ('Freetuts is a great resource', 't')
																		FROM message;																	
																		Result: 5
																						
																		SELECT REGEXP_INSTR ('FReetuts is a great resource', 'r', 1, 1, 0, 'i')
																		FROM message;																	 
																		Result: 2				
																						
																		SELECT REGEXP_INSTR ('Freetuts is a great resource', 'a|b|s', 1, 1, 0, 'i')
																		FROM message;																		 
																		Result: 8				
		CONVERSION FUNCTIONS:
			TO_CHAR( value [, format_mask] [, nls_language] ):
																		Hàm TO_CHAR dùng để chuyển đổi một số hoặc ngày tháng sang kiểu chuỗi.
																		
																		TO_CHAR(1210.73, '9999.9')
																		# Kết quả: ' 1210.7'
																		 
																		TO_CHAR(-1210.73, '9999.9')
																		# Kết quả: '-1210.7'
																		 
																		TO_CHAR(1210.73, '9,999.99')
																		# Kết quả: ' 1,210.73'
																		 
																		TO_CHAR(1210.73, '$9,999.00')
																		# Kết quả: ' $1,210.73'
																		 
																		TO_CHAR(21, '000099')
																		# Kết quả: ' 000021'
			TO_DATE( string1 [, format_mask] [, nls_language] ):
																		Hàm TO_DATE có tác dụng chuyển định dạng của một chuỗi hoặc một dãy số sang định dạng ngày tháng
																		
																		TO_DATE('2003/07/09', 'yyyy/mm/dd')
																		# Kết quả: date value of July 9, 2003
																		 
																		TO_DATE('070903', 'MMDDYY')
																		# Kết quả: date value of July 9, 2003
																		 
																		TO_DATE('20020315', 'yyyymmdd')
																		# Kết quả: date value of Mar 15, 2002
																		
																		SELECT TO_DATE('2015/05/15 8:30:25', 'YYYY/MM/DD HH:MI:SS')
																		FROM dual;
																		Kết quả: 2015/05/15 8:30:25
			ABS( number ):
																		Hàm ABS có công dụng là chuyển đổi một số thành giá trị tuyệt đối của chính nó, tức là nó chuyển số âm thành số dương, và số dương vẫn được giữ nguyên.
																		
																		ABS(-23)
																		Result: 23
																		 
																		ABS(-23.6)
																		Result: 23.6
																		 
																		ABS(-23.65)
																		Result: 23.65
																		 
																		ABS(23.65)
																		Result: 23.65
																		 
																		ABS(23.65 * -1)
																		Result: 23.65
			ACOS( number ):
																		Hàm ACOS dùng để lấy giá trị cosin của một số cho trước.
																		
																		ACOS(0.2)
																		# Result: 1.36943840600457
																		 
																		ACOS(0.35)
																		# Result: 1.21322522314939
																		 
																		ACOS(-0.15)
																		# Result: 1.72136459957158
			CEIL( number ):
																		CEIL là hàm dùng để làm tròn một số với số được làm tròn luôn lấy số ở trên. Số ở trên tức là số có giá trị lớn hơn số cần làm tròn, ví dụ 3.2 thì làm
																		tròn là 4 chứ không phải là 3.
																		
																		CEIL(32.63)
																		# Kết quả: 33
																		 
																		CEIL(32.12)
																		# Kết quả: 33
																		 
																		CEIL(32)
																		# Kết quả: 32
																		 
																		CEIL(-32.61)
																		# Kết quả: -32
																		 
																		CEIL(-33)
																		# Kết quả: -33
			COUNT:
																		Hàm COUNT dùng để đếm số lượng records trả về của một biểu thức, và thường được sử dụng trong câu lệnh Select để đếm tổng số record của table.
				Cú pháp:
																		SELECT COUNT(aggregate_expression)
																		FROM tables
																		[WHERE conditions];
				Ví dụ:
																		SELECT COUNT(employee_id) AS total 
																		FROM employees
																		WHERE salary > '5000000'
			FLOOR( number ):
																		Hàm FLOOR dùng để làm tròn một số vơí số làm tròn ở cận dưới, tức số sau khi làm tròn luôn luôn bé hơn hoặc bằng số cần làm tròn. Ví dụ với số 5.8 thì sau
																		khi làm tròn sẽ là 5 chứ không phải 6.
																		
																		FLOOR(5.9)
																		# Kết quả: 5
																		 
																		FLOOR(34.29)
																		# Kết quả: 34
																		 
																		FLOOR(-5.9)
																		# Kết quả: -6
																		 
																		FLOOR(7)
																		# Kết quả: 7
		NUMERIC/MATH FUNCTION:
			MAX:
																		Hàm MAX dùng để lấy giá trị lớn nhất trong một của một field của table, hàm này thường dùng trong lệnh SELECT và những field có giá trị là number hoặc ngày\
																		tháng.
				Cú pháp:
																		SELECT MAX(aggregate_expression)
																		FROM tables
																		[WHERE conditions];
				Ví dụ:
																		SELECT MAX(salary) AS "Highest Salary"
																		FROM employees;
																		
																		SELECT department, MAX(salary) AS "Highest salary"
																		FROM employees
																		GROUP BY department;
			MIN:
																		Ngược lại với hàm MAX, hàm MIN dùng để lấy giá trị nhỏ nhất của một column hoặc một biểu thức, thường được dùng để lấy số hoặc ngày tháng.
				Cú pháp:
																		SELECT MIN(aggregate_expression)
																		FROM tables
																		[WHERE conditions];
				Ví dụ:
																		SELECT MIN(salary) AS "Lowest Salary"
																		FROM employees;
																		
																		SELECT department, MIN(salary) AS "Lowest salary"
																		FROM employees
																		GROUP BY department;
			SQRT( n ):
																		Hàm SQRT dùng để lấy giá trị căn bậc hai của một số tự nhiên bất kì, nó sẽ trả về giá trị căn bậc hai của số đó.
																		Hàm này rất ít khi sử dụng trong Oracle, tuy nhiên bạn cũng nên biết vì có thể sau này sẽ cần.
																		
																		SQRT(9)
																		# Kết quả: 3
																		 
																		SQRT(37)
																		# Kết quả: 6.08276253029822
																		 
																		SQRT(5.617)
																		# Kết quả: 2.37002109695251
			TRUNC( number [, decimal_places] ):
																		TRUNC là viết tắt của chữ TRUNCATE.
																		Hàm TRUNC dùng để thu gọn một số đến một vị trí nào đó sau dấu phẩy, vị trí sẽ được chỉ định bởi tham số truyền vào. Ví dụ với số 8.12 thì ta có thể chuyển
																		thành 8.1 hoặc 8 bằng cách sử dụng hàm TRUNC.

																		TRUNC(125.815)
																		# Kết quả: 125
																		 
																		TRUNC(125.815, 0)
																		# Kết quả: 125
																		 
																		TRUNC(125.815, 1)
																		# Kết quả: 125.8
																		 
																		TRUNC(125.815, 2)
																		# Kết quả: 125.81
																		 
																		TRUNC(125.815, 3)
																		# Kết quả: 125.815
																		 
																		TRUNC(-125.815, 2)
																		# Kết quả: -125.81
																		 
																		TRUNC(125.815, -1)
																		# Kết quả: 120
																		 
																		TRUNC(125.815, -2)
																		# Kết quả: 100
																		 
																		TRUNC(125.815, -3)
																		# Kết quả: 0
		DATE/TIME FUNCTION:
			ADD_MONTHS( date1, number_months ):
																		Hàm ADD_MONTHS có tác dụng thêm hoặc bớt đi một hoặc nhiều tháng dựa vào tham số truyền vào, nếu bạn truyền số dương thì sẽ thêm tháng và số âm thì sẽ trừ
																		tháng. Ví dụ hôm nay ngày 30/5 và bạn bạn muốn cộng vào 3 tháng nữa thì sẽ thay đổi thành 30/8.
																		
																		ADD_MONTHS('01-Aug-03', 3)
																		# Kết quả: '01-Nov-03'
																		 
																		ADD_MONTHS('01-Aug-03', -3)
																		# Kết quả: '01-May-03'
																		 
																		ADD_MONTHS('21-Aug-03', -3)
																		# Kết quả: '21-May-03'
																		 
																		ADD_MONTHS('31-Jan-03', 1)
																		# Kết quả: '28-Feb-03'
			CURRENT_DATE:
																		Hàm CURRENT_DATE sẽ trả về ngày - tháng - giờ hiện tại, giá trị của nó sẽ phụ thuộc vào time_zone mà bạn đã thiết lập bằng cách sử dụng lệnh ALTER SESSION.
																		
																		ALTER SESSION SET TIME_ZONE = '-7:0'; // Trước khi bắt đầu thì mình sẽ chạy lệnh sau để thiết lập time_zone.
																		SELECT CURRENT_DATE
																		FROM DUAL;
																		Kết quả trên máy tính của mình như sau: 29/12/2018 10:58:24 PM

	Example--Oracle:

		Customers Who Never Order:
		
																		Tìm name trong bảng Customers mà không có customerId order trong bảng Orders
																		
																		SELECT name AS Customers
																		FROM Customers
																		WHERE Customers.id NOT IN (SELECT customerId FROM Orders) // Một kết quả không nằm trong một kết quả khác
																		
		Duplicate Emails:

																		- Điều kiện P1.id <> P1.id sẽ luôn là FALSE, vì nó so sánh một giá trị với chính nó. Do đó, không có bản ghi nào sẽ được loại bỏ.
																		- Câu truy vấn này không thực sự so sánh các bản ghi khác nhau. Vì P1 được sử dụng cho cả hai bảng, nó chỉ so sánh các bản ghi của Person với chính nó,
																		không có ý nghĩa.
																		
																		SELECT DISTINCT P1.Email FROM Person P1,Person P2 // distinct ở đây để loại phần tử trùng ví dụ như email phần tử 1 của P1 giống  với phần tử 3,
																														  // của P2 nhưng email của phần tử 3 của P1 cũng giống email của phần tử thứ 1 của P2
																		WHERE P1.id <> P2.id AND P1.Email=P2.Email
																		
																		SELECT DISTINCT P1.Email
																		FROM Person P1, Person P1
																		WHERE P1.id <> P1.id AND P1.Email = P1.Email;

		Department Top Three Salaries:
		
																		
																		SELECT DEPT.name AS Department, EMP.name AS Employee, EMP.salary AS Salary 
																		FROM Department DEPT JOIN Employee EMP ON EMP.DepartmentId=DEPT.id 
																		WHERE 3 > // Lọc để lấy các row 0, 1, 2 giá trị lớn hơn nó
																		  (SELECT COUNT(DISTINCT EMP1.salary) // đếm số lượng giá trị duy nhất (distinct) trong cột salary của bảng Employee với điều kiện được xác định trong
																											  // mệnh đề WHERE của câu truy vấn con. Nghĩa là với where ta sẽ lọc các row khác nhau, khi count sẽ chỉ đếm với 
																											  // có salary khác nhau không trùng, lọc hàng trước rồi mới select
																		  FROM Employee EMP1 WHERE EMP1.salary > EMP.salary AND // điều kiện với salary nào đó lớn hơn salary hiện tại, trường hợp chính nó thì bằng sẽ không
																																// nằm trong này
																		  EMP.departmentId = EMP1.departmentId) // tổng hợp thì select phần count với điều kiện có employee khác có salary lớn hơn









		
Thymeleaf---:
	Add Thymeleaf to Maven POM file--Thymeleaf:
																						<dependency>
																							<groupId>org.springframework.boot</groupId>
																							<artifactId>spring-boot-starter-thymeleaf</artifactId>
																						</dependency>
	Spring Boot - Spring MVC with Thymeleaf and CSS--Thymeleaf:							<link rel="stylesheet" th:href="@{/css/demo.css}" />
	Spring Boot will search following directories for static resources--Thymeleaf::
																						1. /META-INF/resources
																						2. /resources
																						3. /static
																						4. /public
	Thymeleaf XML namespace:															<html xmlns:th="http://www.thymeleaf.org">
	Add Employees--Thymeleaf:
		Add Employee:
			Add Employee button for list-employees.html:
																	<a th:href="@{/employees/showFormForAdd}"
																		class="btn btn-primary btn-sm mb-3">
																		Add Employee
																	</a>
			Create HTML form for new employee:	
																	<form action="#" th:action="@{/employees/save}" th:object="${employee}" method="POST">
																		<input type="text" th:field="*{firstName}" placeholder="First name" class="form-control mb-4 w-25">
																		...
																		<button type="submit" class="btn btn-info col-2">Save</button>
																	</form>
			Process form data to save employee:	
																	@Controller
																	@RequestMapping("/employees")
																	public class EmployeeController {
																		private EmployeeService employeeService;
																		public EmployeeController(EmployeeService theEmployeeService) {
																			employeeService = theEmployeeService;
																		}
																		@PostMapping("/save")
																		public String saveEmployee(@ModelAttribute("employee") Employee theEmployee) {																								
																			employeeService.save(theEmployee); // save the employee																							   
																			return "redirect:/employees/list"; // use a redirect to prevent duplicate submissions
																		}
																		…
																	}
		Controller code to show form:	
																	@GetMapping("/showFormForAdd")
																	public String showFormForAdd(Model theModel) {																							
																		Employee theEmployee = new Employee(); // create model attribute to bind form data
																		theModel.addAttribute("employee", theEmployee);
																		return "employees/employee-form";
																	}
	Update Employee--Thymeleaf:																
		Update button:	
																	<tr th:each="tempEmployee : ${employees}">
																	…
																		<td>
																			<a th:href="@{/employees/showFormForUpdate(employeeId=${tempEmployee.id})}" // Appends to URL ?employeeId=xxx
																				class="btn btn-info btn-sm">
																				Update
																		</a>
																	</td>
																	</tr>
		Pre-populate the form:	
																	@GetMapping("/showFormForUpdate")
																	public String showFormForUpdate(@RequestParam("employeeId") int theId,
																															Model theModel) {
																		// get the employee from the service
																		Employee theEmployee = employeeService.findById(theId);
																		// set employee as a model attribute to pre-populate the form
																		theModel.addAttribute("employee", theEmployee);
																		// send over to our form
																		return "employees/employee-form";
																	}
																	
																	<form action="#" th:action="@{/employees/save}" th:object="${employee}" method="POST"> // th:action là @{/employees/save},
																																						   // nghĩa là form sẽ được gửi đến URL "/employees/save" khi được submit.
																																						   // th:object xác định đối tượng mô hình (model object) mà form sẽ sử
																																						   // dụng để binding dữ liệu.
																																						   // th:field được sử dụng để đặt giá trị của thuộc tính name và value của
																																						   // trường input dựa trên thuộc tính id của đối tượng "employee".
																		<!-- Add hidden form field to handle update -->								
																		<input type="hidden" th:field="*{id}" />
																		<input type="text" th:field="*{firstName}"
																			class="form-control mb-4 w-25" placeholder="First name">
																		...
																		<button type="submit" class="btn btn-info col-2">Save</button>
																	</form>
	Delete Employee--Thymeleaf:
		“Delete” button/link on page:
																	<tr th:each="tempEmployee : ${employees}">
																	…
																		<td>
																			<a th:href="@{/employees/delete(employeeId=${tempEmployee.id})}"
																			 class="btn btn-danger btn-sm"
																			 onclick="if (!(confirm('Are you sure you want to delete this employee?'))) return   false"
																			>
																				Delete
																			</a>
																		</td>
																	</tr>
		Add controller code for “Delete”:
																	@Controller
																	@RequestMapping("/employees")
																	public class EmployeeController {
																	…
																		@GetMapping("/delete")
																		public String delete(@RequestParam("employeeId") int theId) {																			
																			employeeService.deleteById(theId); // delete the employee																			
																			return "redirect:/employees/list"; // redirect to /employees/list
																		}
																		…
																	}
	Thymeleaf Security support--Thymeleaf:
																	<dependency>
																		<groupId>org.thymeleaf.extras</groupId>
																		<artifactId>thymeleaf-extras-springsecurity6</artifactId>
																	</dependency>
	Spring MVC Security - Custom Login Form--Thymeleaf:																					
		Modify Spring Security Configuration to reference custom login form:				
																							@Bean
																							public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
																								http.authorizeHttpRequests(configurer -> configurer.anyRequest().authenticated())
																									.formLogin(form -> form.loginPage("/showMyLoginPage")
																														   .loginProcessingUrl("/authenticateTheUser")
																														   .permitAll()
																								); 
																								return http.build();
																							}
		Develop a Controller to show the custom login form:
																							@Controller
																							public class LoginController {
																								@GetMapping("/showMyLoginPage")
																								public String showMyLoginPage() {
																									return "plain-login"; // We need to create this file src/main/resources/templates/plain-login.html
																								}
																							}
		Create custom login form:
																							<form action="#" th:action="@{/authenticateTheUser}" method="POST"> // Send data to login processing URL: /authenticateTheUser
																																								// Must POST the data
																																								// The @ symbol: Context Path is same thing as Context Root
																								<p>
																									User name: <input type="text" name="username" />
																								</p>
																								<p>
																									Password: <input type="password" name="password" />
																								</p>
																								<input type="submit" value="Login" />
																							</form>																																												
			
	Các loại biểu thức--Thymeleaf:
																						${...}:				biểu thức thay giá trị của biến vào template
																						*{...}:				biểu thức thay thuộc tính của biến vào template. Hay dùng với form post
																						#{...}:				message expression, biểu thức thay chuỗi đa ngôn ngữ từ file resource.
																						@{...}:				link expression, biểu thức liên kết
																						~{...}:				fragement expression, biểu thức mảnh
																						th:action           Location to send form data
																						th:object           Reference to model attribute
																						th:field            Bind input field to a property on model attribute
	Fragment--Thymeleaf:
		Cú pháp để mô tả vị trí của một Fragment thuộc một Template nào đó:				~{/path-to-template/template-name :: selector}
		Nếu bạn muốn mô tả vị trí của Fragment thuộc Template hiện tại:					~{:: selector}
																						~{this :: selector}
		Lựa chọn fragment theo tên:														~{templatename: fragmentname}  (th:fragment)
		
																						~{/fragments/my-template::my-fragment1} // lựa chọn theo tên của fragment
		Lựa chọn fragment theo tên của thẻ:												
																						~{templatename: tagname}  (Tag Name)
		
																						~{/fragments/my-template::link} // lựa chọn thẻ link
																						
																						~{/fragments/my-template::head/script} // lựa chọn thẻ script nằm trong thẻ head
		Lựa chọn fragment theo giá trị của thuộc tính (attribute) ID của thẻ:			~{templatename: #id}   (ID)
		
																						~{/fragments/my-template::#my-id1} // lựa chọn thẻ có id tên là my-id1
		Lựa chọn fragment theo Css Class:												
																						~{templatename: .classname},~{templatename: tagname.classname}   (Css Class)
		
																						~{/fragments/my-template::p.my-class} // lựa chọn thẻ p có class tên là my-class
		Lựa chọn tất cả trong Template:													~{templatename}  (Everything)
		
																						~{/fragments/my-template} // lựa chọn tất cả các thẻ trong /fragments/my-template.html
		Fragment với các tham số:
			Tham số tường minh:															
																						<div th:fragment="person (firstName, lastName)" class="box">
																							<p>First Name: <span th:utext="${firstName}"></span></p>
																							<p>Last Name: <span th:utext="${lastName}"></span></p>
																							<p>Full Name: <span th:utext="${firstName} + ' '+ ${lastName}"></span></p>
																						</div>
																						
																						<div th:replace="~{fragments/my-template2 :: person('Donald', 'Trump') }"></div>
																						<div th:replace="~{fragments/my-template2 :: person( firstName='Donald', lastName= 'Trump') }"></div>
																						<div th:replace="~{fragments/my-template2 :: person( ${u.firstName}, ${u.lastName}) }"></div>
																						<div th:replace="~{fragments/my-template2 :: person( firstName=${u.firstName}, lastName= ${u.lastName}) }"></div>
			Tham số không tường minh:													
																						<!-- Fragment with implicit parameters. -->
																						<div th:fragment="greeting" class="box">
																							<p>Hello
																							   <span th:utext="${title}"></span>
																							   <span th:utext="${name} ?: 'There'"></span>
																							</p>
																						</div>
														
																						<div th:replace="~{fragments/my-template2 :: greeting(title='Mr.', name = 'Tom') }"></div>       
																						<div th:replace="~{fragments/my-template2 :: greeting }"></div>
																						
		Các ví dụ khác:																	~{fragments/my-template :: #tagId/text() }
																						~{fragments/my-template :: fragmentName/text() }
																						~{fragments/my-template :: tagName/text() }

	th:insert, th:replace, th:include--Thymeleaf:					
																	<!DOCTYPE HTML>
																	<html xmlns:th="http://www.thymeleaf.org">
																	<head>
																	<meta charset="UTF-8" />
																	<title th:replace = "~{fragments/my-template :: title}">Title</title> // th:replace sẽ thay thế thẻ mục tiêu bởi Fragment.
																	<th:block th:insert="~{fragments/my-template :: link}"></th:block>
																	<th:block th:insert="~{fragments/my-template :: head/script}"></th:block>
																	</head>
																	<body>
																	<h1>My Page</h1>
																	<p>Some Content of My Page</p>
																	<div th:insert="~{fragments/my-template :: my-fragment1}"></div> // th:insert sẽ chèn Fragment vào thành con của thẻ mục
																																		// tiêu (Target tag).
																	<div th:insert="~{fragments/my-template :: my-fragment2}"></div>
																	<div th:insert="~{fragments/my-template :: #my-id1}"></div>
																	<div th:insert="~{fragments/my-template :: p.my-class }"></div>
																	</body>
																	</html>
	th:assert--Thymeleaf:								
														<div th:fragment="employee (firstName, lastName)" class="box"
															th:assert= "${!#strings.isEmpty(firstName)}, ${!#strings.isEmpty(lastName)}"> // Nếu tất cả các biểu thức được đánh giá là true (đúng) sẽ không có vấn đề gì xảy ra
																																		  // nếu có 1 biểu thức bị đánh giá là false (sai) một ngoại lệ sẽ được ném ra																						
															<p>First Name: <span th:utext="${firstName}"></span></p>
															<p>Last Name: <span th:utext="${lastName}"></span></p>
															<p>Full Name: <span th:utext="${firstName} + ' '+ ${lastName}"></span></p>
														</div>
	Đổ dữ liệu sử dụng ${...}, th:text và th:utext--Thymeleaf:				
																			@GetMapping("/text")
																			public String demoText(Model model) {
																				Person tom = new Person("Tom", "USA", "1976-12-01", "male");
																				model.addAttribute("person", tom);
																				model.addAttribute("message", "<h2>Display <span style='color:red'>HTML</span> inside</h2>");
																				return "text";
																			}															

																			<div th:text="${person.name + ' : ' + person.nationality}"></div> // th:text đổ text thuần không thẻ HTML vào view template
																																			  // "${person.name + ' : ' + person.nationality}" biểu thức cộng 2 hai biến
																			<div th:text="${person.name} + ' : ' + ${person.nationality}"></div>
																			<div th:text="|${person.name}  :  ${person.nationality}|"></div> // Cú pháp thay thế biến. Chú ý hai ký tự pipe | ở hai đầu
																			<div th:utext="${message}"></div> // th:utext đổ text có thẻ HTML, CSS vào view template
																			<div th:text="${person}"></div> // xuất chuỗi chứa thẻ HTML, CSS. Xuất ra cả person.toString()
	Link expression, biểu thức đường dẫn--Thymeleaf:						
																@GetMapping("/link")
																public String linkExpression(Model model) {
																	model.addAttribute("dynamiclink", "products");
																	return "link";
																}
																
																<a th:href="@{/about}">Abosolute Link</a><br> // <a href="/about">Abosolute Link</a><br>
																<a th:href="@{~/topic/thymeleaf}">Relative link 1</a><br> // <a href="/topic/thymeleaf">Relative link 1</a><br>
																<a th:href="@{topic/thymeleaf}">Relative link 2</a><br> // <a href="topic/thymeleaf">Relative link 2</a><br>
																<a th:href="@{/about(foo='bar',tom='jerry')}">Query string parameters</a><br> // <a href="/about?foo=bar&amp;tom=jerry">Query string parameters</a><br>
																<a th:href="|/${dynamiclink}|">dynamic link 1</a><br> // <a href="/products">dynamic link 1</a><br>
																<a th:href="@{${dynamiclink}}">dynamic link 2</a><br> // <a href="products">dynamic link 2</a><br>
																<a th:href="@{/page/(id=${dynamiclink})}">dynamic link 3</a><br> // <a href="/page/?id=products">dynamic link 3</a><br>
	Điều kiện th:if, th:unless--Thymeleaf:
																<td>
																	<span th:if="${person.gender == 'female'}">‍♀️</span>
																	<span th:unless="${person.gender == 'female'}">‍♂️</span>
																</td>
	Switch th:switch và th:case--Thymeleaf:
																<td th:switch="${user.role}">
																	<span th:case="admin">Quản lý hệ thống</span>
																	<span th:case="editor">Duyệt bài</span>
																	<span th:case="author">Tác giả</span>
																	<span th:case="user">Người dùng</span>
																</td>
	Đổ dữ liệu List Box, Check Box, Radio Box--Thymeleaf:
																@GetMapping("/travel")
																public String showTravelForm(Model model) {
																	model.addAttribute("countries", repo.getCountries());
																	model.addAttribute("travelTypes", TravelType.values());
																	model.addAttribute("travelRequest", new TravelRequest());
																	return "travel";
																}
		Hiển thị List Box:
																<label for="countries">Nationality</label>
																<select name="nationality" id="nationality">
																	<option
																	th:each="country:${countries}"
																	th:text="${country.name}"
																	th:value="${country.code}"
																	th:selected="${travelRequest.nationality==country.code}">China</option>
																</select>
		Hiển thị Check Box:
																<label for="visitedCountries">Tick countries you have visited</label><br>
																<span th:each="country:${countries}">
																	<input type="checkbox" name="visitedCountries"
																	th:value="${country.code}"
																	th:checked="${#lists.contains(travelRequest.visitedCountries, country.code)}">
																	<label th:text="${country.name}" for="visitedCountries"></label><br>
																</span>
		Hiển thị Radio Box:
																<label for="travelType">Choose one travel type</label><br>
																<span th:each="travel_type:${travelTypes}">
																	<input type="radio" name="travelType"
																	th:value="${travel_type}"
																	th:checked="${travelRequest.travelType.value==travel_type.value}">
																	<label th:text="${travel_type.value}" for="travelType"></label><br>
																</span>
	Hiển thị Form và gửi Form lên server: th:action, th:object, th:field--Thymeleaf:
								<form action="#" th:action="@{/bmi}" th:object="${bmiRequest}" method="post"> // th:action viết biểu thức đường dẫn mà Form sẽ gửi lên server.
																											  // Nó khác thuộc tính action vốn có của Form ở chỗ, bạn có thể viết biểu thức, biến, so sánh, điều kiện...
																											  // để động hoá đường dẫn.
																											  // th:object khai báo đối tượng chứa dữ liệu các trường để điền vào form.
									<input type="text" placeholder="Your name" th:field="*{name}"/><br><br> // th:field lấy dữ liệu trong từng thuộc tính của đối tượng đổ vào một trường text.
									<input type="text" placeholder="Your email" th:field="*{email}"/><br><br>
									<input type="text" placeholder="Your height" th:field="*{height}"/> (m)<br><br>
									<input type="text" placeholder="Your weight" th:field="*{weight}"/> (kg)<br><br>
									<button type="submit">Calculate BMI</button>
								</form>

								@PostMapping("/path")
								public String handleForm(@ModelAttribute Request request, BindingResult bindingResult, Model model) {
									if (! bindingResult.hasErrors()) {
										//Logic xử lý nếu không có lỗi
										//Ghi hoặc cập nhật vào CSDL
									}
									model.addAttribute("key", formObject); //formObject có thể là chính request nếu chúng ta muốn hiển thị lại
									model.addAttribute("foo", valuesForListBox); //đổ dữ liệu vào Listbox
									model.addAttribute("bar", valuesForCheckBox); //đổ dữ liệu vào Checkbox
								}
	th:block--Thymeleaf:
								<ul>
									<th:block th:each="travel_type : ${travelTypes}" th:switch="${travel_type.value}"> // Nó hữu ích khi chúng ta muốn thực hiện logic loop, condition ở cấp độ thẻ HTML chứ không ở cấp độ
																													   // thuộc tính trong thẻ. Ví dụ ở file thblock.html, nhờ có th:block, chúng ta đặt được điều khiển
																													   // vòng lặp th:each và th:switch ra ngoài thẻ li code trong sáng hơn nhiều
										<li th:case="Premium">
											<span th:text="${travel_type.value}">Premium</span>
											<input type="checkbox" name="Premium" th:value="jet"><label>Private Jet</label>
											<input type="checkbox" name="Premium" th:value="champaign"><label>Champaign</label>
										</li>
										<li th:case="Luxury">
											<span th:text="${travel_type.value}">Luxury</span>
											<input type="checkbox" name="Luxury" th:value="swimmingpool"><label>Swimming Pool</label>
											<input type="checkbox" name="Luxury" th:value="taxi"><label>Airport taxi</label>
										</li>
										<li th:case="*">
											<span th:text="${travel_type.value}">Other</span>
										</li>
									</th:block>
								</ul>
	Cú pháp bật tắt thuộc tính theo biểu thức--Thymeleaf:
																	th:async       		th:autofocus    th:autoplay
																	th:checked    		th:controls    	th:declare
																	th:default    		th:defer    	th:disabled
																	th:formnovalidate   th:hidden    	th:ismap
																	th:loop    			th:multiple    	th:novalidate
																	th:nowrap    		th:open    		th:pubdate
																	th:readonly    		th:required    	th:reversed
																	th:scoped    		th:seamless    	th:selected
	Login Form Error Message--Thymeleaf:
		Append an error parameter: ?error							http://localhost:8080/myapp/showMyLoginPage?error // When login fails, by default Spring Security will … Send user back to your login page
		Modify custom login form:
																	<form …>
																		<div th:if="${param.error}"> // http://localhost:8080/myapp/showMyLoginPage?error
																			<i>Sorry! You entered invalid username/password.</i>
																		</div>
																		User name: <input type="text" name="username" />
																		Password: <input type="password" name="password" />
																	</form>
	Logout--Thymeleaf:
		Add logout support to Spring Security Configuration:
																	@Bean
																	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
																	  ...
																	 .formLogin(form -> form.loginPage("/showMyLoginPage")
																							.loginProcessingUrl("/authenticateTheUser")
																							.permitAll()
																	 )
																	 .logout(logout -> logout.permitAll());
																	 return http.build();
																	}
		Add logout button to home page:
																	<form action="#" th:action="@{/logout}" method="POST">
																		<input type="submit" value="Logout" />
																	</form>
	Display User ID and Roles--Thymeleaf:
		Display User ID:											User: <span sec:authentication="principal.username"></span>															
		Display User Roles:											Role(s): <span sec:authentication="principal.authorities"></span>
	Custom Access Denied Page--Thymeleaf:
																	@Bean
																	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
																		http.authorizeHttpRequests(configurer -> configurer.requestMatchers(“/").hasRole("EMPLOYEE"))
																			 .exceptionHandling(configurer -> configurer.accessDeniedPage("/access-denied")
																		);
																		…
																	}
	Display Content Based on Roles--Thymeleaf:
																	<div sec:authorize="hasRole('MANAGER')">
																		<p>
																			<a th:href="@{/leaders}">
																				Leadership Meeting
																			</a>
																			 (Only for Manager peeps)
																		</p>
																	</div>



	
	MUI---:	
		DataGrid--MUI:					
									Đối tượng params có thể chứa các thuộc tính như:
										params.value: Giá trị của ô (cell) hiện tại.
										params.row: Thông tin về hàng (row) hiện tại.
										params.column: Thông tin về cột (column) hiện tại.
										params.api: Tham chiếu đến API của bảng (table).
										params.rowIndex: Chỉ mục của hàng (row) hiện tại.
										params.colIndex: Chỉ mục của cột (column) hiện tại.
										Và nhiều thuộc tính khác tùy thuộc vào framework hoặc thư viện sử dụng.
		
									<DataGrid
										rows={data?.dailyReportData?.info === undefined ? [] : data?.dailyReportData?.info}
										columns={columns}
										pagination
										onRowDoubleClick={handleDoubleClick}
										disableSelectionOnClick
										style={{marginTop: '8px'}}
										getRowId={(row) => row.seq}
										sx={DataGridStyle}
										page={pageNo}
										pageSize={pageSize}
										rowsPerPageOptions={[15, 30, 50, 100]}
										rowCount={data?.dailyReportData?.total === undefined ? 0 : data?.dailyReportData?.total}
										onPageChange={handleChangePage}
										onPageSizeChange={handleChangeRowsPerPage}
										paginationMode='server'
										rowHeight={55}
										getRowClassName={(params) =>
											params.indexRelativeToCurrentPage === data.length - 1 ? 'last-row' : ''
										}
									/>
									
									const handleChangePage = (e) => {
										setPage(e);
									}


									const handleChangeRowsPerPage = async (event) => {
										setRowsPerPage(event);
									};

									const DataGridStyle = () => {
										return {
										  boxShadow: 2,
										  borderRadius: 1,
										  "& .MuiDataGrid-columnHeaders": {
											backgroundColor: "rgba(192, 192, 192, 0.7)",
										  },
										  "& .MuiDataGrid-virtualScrollerRenderZone": {
											"& .MuiDataGrid-row": {
											  "&:nth-of-type(2n)": {
												backgroundColor: "rgba(192, 192, 192, 0.24)",
											  },
											  "& .MuiDataGrid-cell": {
												"&:nth-of-type(n)": {
												  borderRight: "groove 1px rgba(235, 235, 235, 0.45)",
												},
											  },
											},
										  },
										  "& .MuiDataGrid-footerContainer": {
											backgroundColor: "rgba(235, 235, 235, 0.9)",
										  },
										  "& .MuiDataGrid-selectedRowCount": {
											visibility: "hidden",
										  },
										};
									};									
									
									{
										field: "assign",
										headerName: "Assign",
										headerAlign: "center",
										align: "left",
										width: 260,
										renderCell: renderAssign, // renderCell: Định nghĩa một hàm để tạo nội dung trong ô dữ liệu của cột
										valueGetter: (params) => params.row.members, // valueGetter: Định nghĩa một hàm để trích xuất giá trị cho cột từ dữ liệu hàng (row)
																					 // giá trị của cột được lấy từ thuộc tính members của đối tượng params.row
									}
									
									{
									  headerName: "Project Manager",
									  field: "koreaPM",
									  // flex: 1.5,
									  align: "left",
									  headerAlign: "center",
									  width: 200,
									  renderCell: (params) => {
										return (
										  <div style={{ display: 'flex', alignItems: 'center' }}>
											<UserAvatar avatar={params.row.koreaPmImage} size={40} /> // đối tượng params.row, đại diện cho hàng (row) hiện tại
											<Tooltip style={{ marginLeft: '10px' }} title={params.row.koreaPM} arrow>
											  <Typography noWrap>{params.row.koreaPM}</Typography>
											</Tooltip>
										  </div>
										)
									  }
									},
					
									{
										id: 1,
										field: "name",
										headerName: "Name",
										editable: true,
										width: 360,
										minWidth: 110,
										maxWidth: 360,
										flex: 1,
									},	
		LinearProgress--MUI:
								<Box className="time-wrapper" position="relative" style={{ width: "100%", display: 'flex', alignItems: 'center' }}>
									<LinearProgress
									  variant="determinate"
									  value={calculatePercentagePassed(params.row.startDate, params.row.endDate) === undefined ? 0
										: calculatePercentagePassed(params.row.startDate, params.row.endDate)}
									  sx={{ width: '100%', height: '23px', borderRadius: "4px" }}
									/>
									<Box
									  top={0}
									  left={0}
									  bottom={0}
									  right={0}
									  position="absolute"
									  display="flex"
									  alignItems="center"
									  justifyContent="center"
									  sx={{
										backgroundColor:
										  countdownFunction(params.row.endDate) >= 0 ? ''
											: (countdownFunction(params.row.endDate) < 0 && (params.row.status === 'O' ||
											  params.row.status === 'C')
											) ? ''
											  : 'rgba(255, 0, 0, 0.75)',
										borderRadius: '4px',
									  }}
									>
									  <Typography color="#FFFFFF" variant="body2">
										{
										  countdownFunction(params.row.endDate) >= 0 ? countdownFunction(params.row.endDate)
											: (
											  countdownFunction(params.row.endDate) < 0 &&
											  (
												params.row.status === 'O' || params.row.status === 'C'
											  )
											) ? '0'
											  : Math.abs(countdownFunction(params.row.endDate))
										}
										{' '}
										{countdownFunction(params.row.endDate) >= 0 ? 'Day(s)'
										  : (countdownFunction(params.row.endDate) < 0 && (params.row.status === 'O' ||
											params.row.status === 'C')) ? 'Day(s)'
											: 'Day(s) Overdue'
										}
									  </Typography>
									</Box>
								 </Box>	

		

		Select--MUI:
								<FormControl sx={{ margin: "8px 16px 8px 8px", minWidth: 120 }} className="checkbox">
									<InputLabel id="demo-controlled-open-select-label">Project Name</InputLabel>
									<Select
									  labelId="demo-multiple-checkbox-label"
									  id="demo-multiple-checkbox"
									  multiple
									  value={searchProject}
									  onChange={(event) => {
										if (event.target.value.includes("All")) {
										  setSearchProject(listProName?.map(item => item?.pme00ProjectInfo?.cdV));
										} else {
										  setSearchProject(event.target.value);
										}
									  }}
									  renderValue={(selected) => {
										const selectedValue = selected.map(item => {
										  const selectedItem = listProName.find(e => e?.pme00ProjectInfo?.cdV === item);
										  return selectedItem ? selectedItem?.m00Codes030?.cdvMeaning : ""
										});
										return selectedValue.join(", ");
									  }}
									  MenuProps={MenuProps}
									  style={{ width: '358px', height: '40px', backgroundColor: 'white'}}
									  label="Project Name"
									>
									  <MenuItem value={searchAllProject}>
										<Checkbox
										  checked={searchProject?.length === listProName?.length} 
										  onChange={(e) => {
											if (!e.target.checked) {
											  setSearchProject([]);
											}
										  }}
										/>
										<ListItemText primary="All" />
									  </MenuItem>
									  {listProName?.map((field) => {
										return (
										  <MenuItem key={field?.pme00ProjectInfo?.cdV} value={field?.pme00ProjectInfo?.cdV}>
											<Checkbox
											  checked={searchProject?.length === listProName?.length || searchProject?.indexOf(field?.pme00ProjectInfo?.cdV) > -1} />
											<ListItemText primary={field?.m00Codes030?.cdvMeaning} />
										  </MenuItem>
										);
									  })}
									</Select>
								</FormControl>
								
								const ITEM_HEIGHT = 48;
								const ITEM_PADDING_TOP = 4;
								const MenuProps = {
									PaperProps: {
									  style: {
										maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,
										width: 200,
									  },
									},
								};

		TextField--MUI:
								<div class="container-field">
									<TextField className="txtPM" label="Project Manager"
										id="pmSearch"
										value={searchPMName}
										readOnly
										disabled
										size="small"
										style={{ width: 200 }}
										margin="dense"
										sx={{									
											"& .MuiOutlinedInput-root": {
												backgroundColor: "white",
												height: "37px",
											},
										}}
										InputProps={{
											endAdornment: (
												<IconButton
													color="default"
													size="small"
													sx={{ visibility: searchPMName ? "visible" : "hidden" }}
													onClick={() => {
														setSearchPM("");
														setSearchPMName("");
													}}
												>
													<Clear fontSize="small" />
												</IconButton>
											),
										}}
									/>
									<Button className="btnPM" variant="contained" size='medium' sx={{
										marginRight: 2, marginTop: 1,
									}}
										onClick={() => setIsChoosePmOpen(true)}
									>
										Choose
									</Button>
								</div>						
								
								<TextField label="Start date"
								  id="startDate"
								  value={startDate}
								  defaultValue={now}
								  type="date"
								  datatype="dd-MM-yyyy"
								  size="small"
								  format="dd-MM-yyyy"
								  onChange={(e) => setStartDate(e.target.value)}
								/>						
		Button--MUI:
								<Button
								  className="project-popup-assignBtn"
								  variant="contained"
								  sx={{ height: 40, marginLeft: -1, width: 80 }}
								  onClick={() => setIsChooseAssignOpen(true)}>
								  Choose
								</Button>

		PieChart--MUI:
								<PieChart
									colors={[
									  "#0d57f7",
									  "#ffa500cc",
									  "#64c864cc",
									  "#00bfff",
									  "#008000cc",
									  "#8B008B",
									  "pink",
									]}
									series={[
									  {
										data: [
										  { value: [totalNewTasks], label: "New" },
										  {
											value: [totalInProgressTasks],
											label: "In Progress",
										  },
										  { value: [totalTestingTasks], label: "Testing" },
										  { value: [totalDeliveredTasks], label: "Delivered" },
										  { value: [totalCompletedTasks], label: "Completed" },
										  { value: [totalCancelTasks], label: "Cancel" },
										],
										innerRadius: 80,
										cx: 150,
										cy: 110,
									  },
									]}
									margin={{ right: 50 }}
									width={450}
									height={250}>
									<PieCenterLabel>{totalTask} Task(s)</PieCenterLabel>
								</PieChart>

		BarChart--MUI:
								<BarChart
									colors={["#228ce2", "#53bb58", "#d11b85"]}
									xAxis={[
									  {
										scaleType: "band",
										data: [row?.m00Codes030?.cdvMeaning !== undefined ? row?.m00Codes030?.cdvMeaning : cdV],
										tickFontSize: 18,
									  },
									]}
									yAxis={[
									  {
										label: "Number of Tasks",
										labelStyle: {
										  fontSize: 18,
										},
										tickLabelStyle: {
										  fontSize: 14,
										},
									  },
									]}
									series={[
									  { data: [totalTask], label: "Total" },
									  { data: [totalRemainTasks], label: "Remain" },
									  { data: [totalDelayedTasks], label: "Delayed" },
									]}
									width={500}
									height={400}
									margin={{ left: 130, top: 50 }}
									sx={{
									  [`.${axisClasses.left} .${axisClasses.label}`]: {
										transform: "translate(-15px, 0)",
									  },
									}}
									slotProps={{
									  legend: {
										direction: "row",
										position: {
										  vertical: "top",
										  horizontal: { padding: 50 },
										},
										label: { padding: 50 },
										padding: 0,
									  },
									}}
								/>
	Dialog:
							  <Dialog open={confirmDeleteOpen} onClose={handleCloseConfirmDelete}>
								<DialogTitle>Confirm Delete</DialogTitle>
								<DialogContent>
								  <DialogContentText>
									{currentEmpID === selectedTask?.empId ? (
									  "Are you sure you want to delete this task?"
									) : (
									  <>
										Enter the password to delete the task: <br />
										<TextField
										  label="Current Password"
										  sx={{
											marginBottom: 1.7,
											marginTop: 1.6,
											input: {
											  color: "black",
											  background: "white",
											  height: "20px",
											},
										  }}
										  type={"password"}
										  id="outlined-password-input"
										  size="small"
										  style={{ width: 320, backgroundColor: "white", height: 25 }}
										  inputProps={{
											style: {
											  height: 20,
											},
										  }}
										  onChange={(newValue) => {
											setPassword(newValue.target.value);
										  }}
										/>
									  </>
									)}
								  </DialogContentText>
								</DialogContent>
								<DialogActions>
								  <Button onClick={handleCloseConfirmDelete} variant="outlined">
									Cancel
								  </Button>
								  <Button
									onClick={handleConfirmDelete}
									color="error"
									variant="outlined">
									Yes
								  </Button>
								</DialogActions>
							  </Dialog>								


Axios---:
							Axios là một thư viện HTTP Client dựa trên Promise. Cơ bản thì nó cung cấp một API cho việc xử lý XHR (XMLHttpRequests).
							Một trong những đặc điểm lớn ta có thể thấy đó là cách mà 2 thư viện xử lý với các HTTP error code. Khi sử dụng Fetch, nếu khi server trả về các mã lỗi 4xx hay 5xx, thì hàm
							catch() của bạn sẽ không được gọi đến và người lập trình viên sẽ có nhiệm vụ phải tự kiểm tra trạng thái của mã trả về để xác định xem liệu request đó có thành công hay không.
							Trong khi đó, Axios sẽ reject tất cả các promise của request nếu một trong các mã lỗi trên được trả về.
	Response Object:
							Khi một request được thực hiện thành công, thì hàm then() của bạn sẽ nhận được một response object với các thuộc tính như sau:
								data: 			Payload được trả về từ server. Mặc định, Axios mong chờ JSON và sẽ parse nó trở thành một Javascript Object cho bạn.
								status: 		mã HTTP được trả về từ server.
								statusText: 	message của HTTP status được trả về bởi server.
								headers: 		tất cả các header được gửi về từ server.
								config: 		thiết lập ban đầu của request.
								request: 		một object XMLHttpRequest thực khi request được thực hiện ở trình duyệt.
	Error Object:
							Nếu có bất kỳ vấn đề gì xảy ra với request, promise sẽ bị reject với một error object chứa những thuộc tính sau đây:
								message: 		message của error ở dạng text.
								response: 		response object được trả về.
								config: 		thiết lập ban đầu của request.
								request: 		một object XMLHttpRequest thực khi request được thực hiện ở trình duyệt.
	Dữ liệu trả về cho một request sẽ mang các thông tin sau:
																		{																	  
																		  data: {}, // `data` là dữ liệu trả về được cung cấp bởi server
																		  status: 200, // `status` là mã HTTP status trả về từ server
																		  statusText: 'OK', // `statusText` là thông điệp HTTP status trả về từ server
																		  headers: {}, // `headers` là các header mà server phản hồi. Các tên của header được viết thường toàn bộ
																		  config: {}, // `config` là các cấu hình khi thực hiện request
																		  request: {} // `request` là request thực hiện để nhận được response này
																		}
	Bắt đầu xây dựng truy vấn với axios:
		Các alias cho việc tạo ra các request với phương thức tương ứng:
																				// Khi sử dụng các alias này thì url, method, và data không phải cần phải chỉ định trong config nữa.
																				axios.request(config)
																				axios.get(url[, config])
																				axios.delete(url[, config])
																				axios.head(url[, config])
																				axios.options(url[, config])
																				axios.post(url[, data[, config]])
																				axios.put(url[, data[, config]])
																				axios.patch(url[, data[, config]])
	Xây dựng truy vấn với axios:
												
												const config = { // Định nghĩa cấu hình cho yêu cầu
												  method: 'get', // Phương thức HTTP, ở đây là GET
												  url: 'https://api.example.com/data', // URL mục tiêu
												  params: { // Các tham số yêu cầu (nếu có)
													id: 123,
													sortBy: 'name'
												  },
												  headers: { // Các tiêu đề yêu cầu (nếu có)
													'Authorization': 'Bearer token',
													'Content-Type': 'application/json'
												  },
												  timeout: 5000 // Thời gian chờ tối đa (ms)
												};												
												axios(config) // Gửi yêu cầu sử dụng cấu hình đã định nghĩa
												  .then(response => {
													console.log('Dữ liệu nhận được:', response.data);
												  })
												  .catch(error => {
													console.error('Lỗi khi gửi yêu cầu:', error);
												  });
												  
												const instance = axios.create({
												    baseURL: `${Constants.Api.BASE_URL}/author`
												});
												
												export const SigninRepository = {
												    signIn: async (employeeId, pass) => {
												        const body = {
												            id: employeeId,
												            password: pass
												        };
												        const config = {
												            headers: {
												                'Content-Type': "application/json",
												                'Access-Control-Allow-Origin': '*',
												            }
												        };
												        return instance.post(`/signin`, body, config)
												            .then(res => {
												                if (res.status === 200) {
												                    localStorage.setItem('JWT Token', res.data.token);
												                    localStorage.setItem('Token', res.data.token);
												
												                    let userList = [];
												                    userList.push(res.data.userInfo);
												                    localStorage.setItem('LoginUserInfo', JSON.stringify(res.data.userInfo));
												                    localStorage.setItem('userAuthData', JSON.stringify(userList));
												
												                    localStorage.setItem("sectionID", res.data.userInfo.id);
												                    localStorage.setItem("empNameStorage", res.data.userInfo.username);
												
												                    localStorage.setItem("AuthRole", JSON.stringify(res.data.userInfo.listRole));
												                    localStorage.setItem('Permissions', JSON.stringify(res.data.permissions));
												                    return res.data;
												                } else {
												                    return null;
												                }
												            })
												            .catch(error => {
												                console.log("error: ", error);
												                return null;
												            });
												    },
												};
		axios get:
												axios.get('/user?ID=12345')
													.then(function (response) {
														onsole.log(response);
													})
													.catch(function (error) {
														onsole.log(error);
													});

												axios.get('/user', {
												  params: {
													ID: 12345
												  }
												})
												.then(function (response) {
												  console.log(response);
												})
												.catch(function (error) {
												  console.log(error);
												});
		axios post:
												axios.post('/users', {
												  firstName: 'First name',
												  lastName: 'Last name'
												})
												.then(function (response) {
												  console.log(response);
												})
												.catch(function (error) {
												  console.log(error);
												});
												
												const data = {
												  username: 'exampleUser',
												  password: 'examplePassword'
												};

												axios.post('https://api.example.com/login', data)
												  .then(response => {
													console.log('Kết quả:', response.data);
												  })
												  .catch(error => {
													console.error('Lỗi:', error);
												  });
												  
												const axios = require('axios');
												const FormData = require('form-data');
												const fs = require('fs');
												const formData = new FormData();
												formData.append('file', fs.createReadStream('path/to/file.txt'));
												axios.post('https://api.example.com/upload', formData, {
												  headers: {
													...formData.getHeaders()
												  }
												})
												.then(response => {
												  console.log('Kết quả:', response.data);
												})
												.catch(error => {
												  console.error('Lỗi:', error);
												});
		axios put:
												const newData = {
												  name: 'Updated Name',
												  description: 'Updated Description'
												};											
												const itemId = 123; // ID của mục cần cập nhật											
												const apiUrl = `https://api.example.com/items/${itemId}`; // URL đích												
												axios.put(apiUrl, newData) // Gửi yêu cầu PUT
												  .then(response => {
													console.log('Kết quả:', response.data);
												  })
												  .catch(error => {
													console.error('Lỗi:', error);
												  });
		axios delete:
												const itemId = 123;
												const apiUrl = `https://api.example.com/items/${itemId}`; // URL đích
												axios.delete(apiUrl) // Gửi yêu cầu DELETE
												  .then(response => {
													console.log('Mục đã được xóa thành công');
												  })
												  .catch(error => {
													console.error('Lỗi khi xóa mục:', error);
												  });
		axios create:
												const instance = axios.create({
													baseURL: process.env.REACT_APP_BASE_URL,
													headers: {
														'Content-Type': "application/json",
														'Access-Control-Allow-Origin': '*',
													}
												});
		Thực hiện nhiều truy cập đồng thời:										
												function getUserAccount() {
												  return axios.get('/user/12345');
												}

												function getUserPermissions() {
												  return axios.get('/user/12345/permissions');
												}

												axios.all([getUserAccount(), getUserPermissions()])
												.then(axios.spread(function (acct, perms) {
												  // Tất cả request đều đã được thực hiện xong
												}));
	Tạo ra một đối tượng axios với các config của mình bằng hàm axios.create([config]):
																								var instance = axios.create({
																								  baseURL: 'https://some-domain.com/api/',
																								  timeout: 1000,
																								  headers: {'X-Custom-Header': 'foobar'}
																								});
		Khi đó, đối tượng này có thể sử dụng các phương thức sau để thực hiện việc gửi request:
																										axios#request(config)
																										axios#get(url[, config])
																										axios#delete(url[, config])
																										axios#head(url[, config])
																										axios#options(url[, config])
																										axios#post(url[, data[, config]])
																										axios#put(url[, data[, config]])
																										axios#patch(url[, data[, config]])
	Ví dụ:
						import axios from 'axios';
						// Tạo một request bằng Axios
						axios.get('https://api.example.com/data')
						  .then(response => {
							// Xử lý response thành công
							console.log('Response thành công:', response.data);
						  })
						  .catch(error => {
							// Xử lý lỗi khi request thất bại
							if (error.response) {
							  // Request đã được gửi đi và nhận được response có status code không phải 2xx
							  console.log('Response lỗi:', error.response.data);
							  console.log('Status code:', error.response.status);
							} else if (error.request) {
							  // Request đã được gửi đi nhưng không nhận được response (ví dụ: mất kết nối)
							  console.log('Không nhận được response:', error.request);
							} else {
							  // Có lỗi xảy ra trong quá trình thiết lập request
							  console.log('Lỗi:', error.message);
							}
						  });							

Styled---:
															import TableCell, { tableCellClasses } from "@mui/material/TableCell";
															import { styled } from "@mui/material/styles";														  
															// styled table
															const StyledTableCell = styled(TableCell)(({ theme }) => ({
																[`&.${tableCellClasses.head}`]: {
																  backgroundColor: "#d3d3d3",
																  color: theme.palette.common.black,
																},
																[`&.${tableCellClasses.body}`]: {
																  fontSize: 14,
																},
																[`&.${tableCellClasses.alignCenter}`]: {
																  // fontSize: 14,
																  // textAlign: 'center',
																  display: 'flex',
																  alignItems: 'center',
																  justifyContent: 'center',
																},
															}));
															<TableRow>
															  {columns.map((column) => (
																<StyledTableCell key={column.field} className={tableCellClasses.head}>
																  {column.headerName}
																</StyledTableCell>
															  ))}
															</TableRow>

															const StyledText = styled("text")(({ theme }) => ({
																fill: theme.palette.text.primary,
																textAnchor: "middle",
																dominantBaseline: "central",
																fontSize: 25,
															}));
															function PieCenterLabel({ children }) {
																const { width, height, left, top } = useDrawingArea();
																return (
																  <StyledText x={left + width / 2.6} y={(top + height) / 2.1}>
																	{children}
																  </StyledText>
																);
															}
															
															
ReactJS---:

								- Trong ReactJS, khi bạn gán một mảng vào một biến, đó là việc gán tham chiếu, chứ không phải gán giá trị.
								
								let a = [];
								let b = a;
								a.push(1); // Thêm 1 vào mảng của a
								console.log(a); // [1]
								console.log(b); // [1]

	Props--REACTJS:
	
								- Chú ý props luôn luôn là 1 object duy nhất, khi gọi component và truyền đối số vào thì đối số đó chính là thuộc tính của object duy nhất đó
								
		props.children:
		
								- props.children là một thuộc tính đặc biệt của props trong React, chứa tất cả các phần tử con được bao bọc bên trong một component khi nó được sử dụng.
								- Nó cho phép các component trở thành "containers" (bao chứa) và chứa các phần tử con mà không cần biết trước những phần tử con đó là gì.
								
			Ví dụ:

								function Box(props) {
								  return (
									<div className="box">
									  {props.children}
									</div>
								  );
								}
								
								function App() {
								  return (
									<div>
									  <Box>
										<h1>Hello, World!</h1>
										<p>This is a simple example of using props.children in React.</p>
									  </Box>
									</div>
								  );
								}
								
								Kết quả sẽ là:
								
									<div>
									  <div class="box">
										<h1>Hello, World!</h1>
										<p>This is a simple example of using props.children in React.</p>
									  </div>
									</div>

								
								

								
								


	useState--REACTJS:
								- The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value
								that was on the screen before your call.
								- If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its
								children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.
								- React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders
								during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.
								- Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to
								render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders.
								- Trong quá trình phát triển ứng dụng React, React có thể gọi các "updaters" (các hàm cập nhật) của bạn hai lần để kiểm tra xem chúng có đủ "pure" không. Trong ngữ cảnh của React, một hàm được
								coi là "pure" nếu nó không gây ra các hiệu ứng phụ (side effects) và trả về kết quả dựa trên đầu vào của nó mà không thay đổi trạng thái của ứng dụng. Điều này giúp đảm bảo rằng việc gọi các hàm
								cập nhật sẽ không gây ra sự thay đổi không mong muốn đối với trạng thái của ứng dụng.
								- If you do multiple updates within the same event, updaters can be helpful
								- If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any
								type. React will call your initializer function when initializing the component, and store its return value as the initial state.
								- The set function returned by useState lets you update the state to a different value and trigger a re-render.
	
								const [name, setName] = useState('Edward'); // Edward là giá trị khởi tạo cho state. This argument is ignored after the initial render.
								function handleClick() {
									setName('Taylor');
								// ...
								}
								
								const increment = () => {
									setCount(count + 1); // Đây là updaters
								};
								
		Updating state based on the previous state--useState:
		
															function handleClick() {
															  setAge(age + 1); // setAge(42 + 1)
															  setAge(age + 1); // setAge(42 + 1)
															  setAge(age + 1); // setAge(42 + 1) // setState chi có thể update giá trị cho next state => state trong đoạn code hiện tại chắc chắn sẽ không bị ảnh hưởng
															}
														
															function handleClick() {
															  setAge(a => a + 1); // setAge(42 => 43)
															  setAge(a => a + 1); // setAge(43 => 44)
															  setAge(a => a + 1); // setAge(44 => 45) // a => a + 1 is your updater function. It takes the pending state and calculates the next state from it.
															}
															
															import { useState } from 'react';
															export default function Counter() {
															  const [age, setAge] = useState(42);
															  function increment() {
																setAge(a => a + 1);
															  }
															  return (
																<>
																  <h1>Your age: {age}</h1>
																  <button onClick={() => {
																	increment();
																	increment();
																	increment();
																  }}>+3</button> // “+3” button works. Update state theo giá trị của pending state
																  <button onClick={() => {
																	increment();
																  }}>+1</button>
																</>
															  );
															}
															import { useState } from 'react';
															export default function Counter() {
															  const [age, setAge] = useState(42);
															  function increment() {
																setAge(age + 1);
															  }
															  return (
																<>
																  <h1>Your age: {age}</h1>
																  <button onClick={() => {
																	increment();
																	increment();
																	increment();
																  }}>+3</button> // “+3” button doesn’t work as intended. Không update state theo giá trị của pending state
																  <button onClick={() => {
																	increment();
																  }}>+1</button>
																</>
															  );
															}
															
															const [age, setAge] = useState(42);
															setAge(age => age + 1); // 42 + 1
															setAge(age + 1); // 42. Giá trị của age không thay đổi trực tiếp khi bạn gọi setAge với một giá trị mới. Không updat dựa theo state pending mà lại theo state hiện tại
															setAge(age => age + 1); // 42 + 1
		Updating objects and arrays in state--useState:
			Update Object:
															  const [form, setForm] = useState({
																firstName: 'Barbara',
																lastName: 'Hepworth',
																email: 'bhepworth@sculpture.com',
															  });
															  onChange={e => {
																setForm({
																  ...form,
																  firstName: e.target.value
																});
															  }}
															  
															  const [person, setPerson] = useState({
																name: 'Niki de Saint Phalle',
																artwork: {
																  title: 'Blue Nana',
																  city: 'Hamburg',
																  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
																}
															  });
															  function handleTitleChange(e) {
																setPerson({
																  ...person,
																  artwork: {
																	...person.artwork,
																	title: e.target.value
																  }
																});
															  }
			Update Array:												  
															  let nextId = 3;
																const initialTodos = [
																  { id: 0, title: 'Buy milk', done: true },
																  { id: 1, title: 'Eat tacos', done: false },
																  { id: 2, title: 'Brew tea', done: false },
															  ];
															  const [todos, setTodos] = useState(initialTodos);
															  function handleAddTodo(title) {
																setTodos([
																  ...todos,
																  {
																	id: nextId++,
																	title: title,
																	done: false
																  }
																]);
															  }
															  function handleChangeTodo(nextTodo) {
																setTodos(todos.map(t => {
																  if (t.id === nextTodo.id) {
																	return nextTodo;
																  } else {
																	return t;
																  }
																}));
															  }
															  function handleDeleteTodo(todoId) {
																setTodos(
																  todos.filter(t => t.id !== todoId)
																);
															  }
															  
		Avoiding recreating the initial state--useState:
															  React saves the initial state once and ignores it on the next renders.
															  function TodoList() {
																  const [todos, setTodos] = useState(createInitialTodos());
																  // ...
															  }
															  
															  To solve this, you may pass it as an initializer function to useState instead:
															  function TodoList() {
																  const [todos, setTodos] = useState(createInitialTodos); // React will only call it during initialization. 
																  // ...
															  }
															  
															  React may call your initializers twice in development to verify that they are pure.
		Storing information from previous renders--useState:
															  import { useState } from 'react';
															  import CountLabel from './CountLabel.js';
															  
															  export default function App() {
															    const [count, setCount] = useState(0);
															    return (
															  	<>
															  	  <button onClick={() => setCount(count + 1)}>
															  		Increment
															  	  </button>
															  	  <button onClick={() => setCount(count - 1)}>
															  		Decrement
															  	  </button>
															  	  <CountLabel count={count} />
															  	</>
															    );
															  }
															  import { useState } from 'react';
															  export default function CountLabel({ count }) {
															    const [prevCount, setPrevCount] = useState(count);
															    const [trend, setTrend] = useState(null);
															    if (prevCount !== count) {
																	setPrevCount(count);
																	setTrend(count > prevCount ? 'increasing' : 'decreasing');
															    }
															    return (
															  	<>
															  	  <h1>{count}</h1>
															  	  {trend && <p>The count is {trend}</p>}
															  	</>
															    );
															  }
															  
		I’ve updated the state, but logging gives me the old value--useState:
		
															function handleClick() {
															  console.log(count);  // 0
															  setCount(count + 1); // Request a re-render with 1
															  console.log(count);  // Still 0!
															  setTimeout(() => {
																console.log(count); // Also 0!
															  }, 5000);
															}
															
			If you need to use the next state, you can save it in a variable before passing it to the set function--useState:
			
															const nextCount = count + 1;
															setCount(nextCount);
															console.log(count);     // 0
															console.log(nextCount); // 1
		
		I’m getting an error: “Too many re-renders”--useState:
															- Your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on.
															- Khi bạn truyền hàm dưới dạng handleClick (ví dụ: onClick={handleClick}), bạn chỉ truyền tham chiếu đến hàm. Điều này có nghĩa là hàm không được gọi ngay lập tức
															trong quá trình render. Thay vào đó, hàm sẽ được gọi chỉ khi sự kiện (ví dụ: người dùng nhấp chuột) xảy ra.
															- Khi bạn truyền hàm dưới dạng handleClick() (ví dụ: onClick={handleClick()}), bạn thực hiện một cuộc gọi hàm ngay trong quá trình render. Điều này có nghĩa là hàm sẽ
															được gọi mỗi khi thành phần được render lại, thay vì chỉ khi sự kiện xảy ra. Điều này có thể gây ra các vấn đề không mong muốn và làm cho hàm được gọi nhiều lần không
															cần thiết.																												
															
															return <button onClick={handleClick()}>Click me</button> //  Wrong: calls the handler during render												
															return <button onClick={handleClick}>Click me</button> // ✅ Correct: passes down the event handler													
															return <button onClick={(e) => handleClick(e)}>Click me</button> // ✅ Correct: passes down an inline function
															
															function MyComponent() {
															  const handleClick = () => {
																console.log('Button clicked!');
															  };
															  return <button onClick={handleClick()}>Click me</button>; // hàm handleClick sẽ được gọi ngay trong quá trình render, không chờ đến sự kiện xảy ra. Kết quả là, mỗi
																														// khi thành phần được render lại, hàm sẽ được gọi một lần, dẫn đến việc in ra "Button clicked!" nhiều lần
																														// không mong muốn.
															}
															
		My initializer or updater function runs twice--useState:	

															- In Strict Mode, React will call some of your functions twice instead of once
															- This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your
															component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.
															- Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call
															them and store the result. To actually store a function, you have to put () => before them in both cases. Then React will store the functions you pass.
															
															function TodoList() { // This component function will run twice for every render.														  
															  const [todos, setTodos] = useState(() => {
																// This initializer function will run twice during initialization.
																return createTodos();
															  });
															  function handleClick() {
																setTodos(prevTodos => {
																  // This updater function will run twice for every click.
																  return [...prevTodos, createTodo()];
																});
															  }
															  // ...
															
															const [fn, setFn] = useState(someFunction); // You can’t put a function into state like this
															function handleClick() {
															  setFn(someOtherFunction); // You can’t put a function into state like this
															}
															
															const [fn, setFn] = useState(() => someFunction); // React will store the functions you pass
															function handleClick() {
															  setFn(() => someOtherFunction); // React will store the functions you pass
															}
	useEffect--REACTJS:
							
							- useEffect is a React Hook that lets you synchronize a component with an external system. If you’re not trying to synchronize with some external system, you probably don’t need an Effect.
							- useEffect() là function nắm bắt tất cả các sự thay đổi của code. Nó giúp chúng ta xử lý các side effects, useEffect sẽ tương đương với các hàm componentDidMount, componentDidUpdate và
							componentWillUnMount trong LifeCycle
							- Để quản lý các tác dụng phụ như lệnh gọi API, đăng ký, bộ tính giờ, đột biến, v.v.
							- Không có dependency: luôn luôn gọi sau khi render.
							- Dependency là mảng rỗng: phần setup chỉ được gọi 1 lần duy nhất khi component mounted.
							- Dependency là 1 mảng đầy đủ: setup sẽ được gọi khi component mounted và được gọi lại khi dependency thay đổi
							- Phần setup trong useEffect được chạy sau mỗi lần render của component, bao gồm cả lần render đầu tiên. Nó chạy ngay sau khi component đã được render lại hoặc lần đầu tiên khi component
							được mount lên DOM.
							- Phần cleanup trong useEffect được chạy trước khi component bị unmount hoặc trước khi nó chạy lại lần tiếp theo. Nó chạy trước khi phần setup mới của useEffect được thực thi.
							
							import { useEffect } from 'react';
							import { createConnection } from './chat.js';
							function ChatRoom({ roomId }) {
							  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
							  useEffect(() => {
								// Phần setup
								const connection = createConnection(serverUrl, roomId);
								connection.connect();
								// Phần cleanup
								return () => {
								  connection.disconnect();
								};
							  }, [serverUrl, roomId]);
							  // ...
							}
							
	useRef--REACTJS:
										- useRef is a React Hook that lets you reference a value that’s not needed for rendering.
										- useRef hook là một function trả về một object với thuộc tính current được khởi tạo thông qua tham số truyền vào. Object được trả về này có thể mutate và sẽ tồn tại xuyên suốt vòng đời của
										component. Nó chủ yếu được sử dụng để truy cập một cách ngầm định một thành phần con.
										- Thuộc tính ref sẽ tham chiếu đến chính xác element cần dùng.
										- Giả dụ tình huống là thế này, bạn làm gì đó mà nó ko liên quan đến UI, không cần re-render, nhưng vẫn muốn giá trị này cố định giữa các lần render? useState có thể cố định giá trị,
										nhưng ngặt nỗi nó sẽ trigger re-render nếu bị thay đổi.
										
										import { useRef } from 'react';
										export default function Counter() {
										  let ref = useRef(0);
										  function handleClick() {
											ref.current = ref.current + 1;
											alert('You clicked ' + ref.current + ' times!');
										}
										return (
										  <button onClick={handleClick}>
											Click me!
										  </button>
										  );
										}
										
										
										import React, { useRef, useEffect } from 'react';
										function ExampleComponent() {
										  const myRef = useRef(null);
										  useEffect(() => {									
											myRef.current.focus(); // Gán thuộc tính focus cho element khi component được mount
										  }, []);
										  return (
											<div>
											  <input type="text" ref={myRef} /> //Sử dụng useRef để tạo ra một ref
											  <button onClick={() => myRef.current.focus()}>Focus Input</button>
											</div>
										  );
										}
										export default ExampleComponent;
										
										
										Trong useEffect với dependency array rỗng (đánh dấu quá trình initialization), việc ghi vào ref.current là an toàn, vì nó chỉ xảy ra một lần khi component được khởi tạo.
										Tuy nhiên, trong phần return của component, việc ghi vào ref.current trong JSX hoặc đọc ref.current trong hàm render không nên được thực hiện. Việc này có thể dẫn đến hành vi không đoán
										được hoặc các vấn đề khác nhau khi React tái render component. Thay vào đó, các thao tác này nên được thực hiện trong các hàm lifecycle hoặc useEffect hook.
										import React, { useRef, useEffect } from 'react';
										function ExampleComponent() {
										  const ref = useRef(null);							  
										  useEffect(() => {
											// Trong phần initialization, việc ghi vào ref.current là an toàn
											ref.current = 'Initialized';
										  }, []);
										  // Trong quá trình rendering, đọc hoặc ghi vào ref.current không nên được thực hiện
										  console.log(ref.current); // Không nên đọc trong quá trình rendering
										  return (
											<div ref={ref}>
											  {/* Ghi vào ref.current trong JSX cũng không được khuyến khích */}
											</div>
										  );
										}
		
		.current.contains trong useRef:
		
										Là một phương thức của một tham chiếu DOM (thông qua .current) và được sử dụng để kiểm tra xem một phần tử DOM có nằm trong phạm vi của một phần tử khác không. Phương thức này trả về giá trị boolean true nếu phần tử DOM
										được xem xét nằm trong phạm vi của phần tử khác, và false nếu không.
										
		Kiểm tra việc người dùng đã nhấp chuột bên ngoài phần tử:
										
										Kiểm tra xem phần tử hiện tại được tham chiếu bởi ref.current có chứa phần tử mà sự kiện mousedown xảy ra hay không (!ref.current.contains(e.target)). Nếu phần tử không chứa phần tử mà sự kiện xảy ra, tức là người dùng
										đã nhấp chuột bên ngoài phần tử
		
										if (ref.current && !ref.current.contains(e.target))
	useReducer--REACTJS:
										- useReducer is a React Hook that lets you add a reducer to your component.
										- Thực tế khi sử dụng useState thì nó sẽ trả về 1 phiên bản đơn giản của useReducer, vậy nên chúng ta có thể coi useReducer như một phiên bản nâng cao hơn dùng để thay thế cho việc sử dụng
										useState.
										- Khi gọi dispatch(action), nó sẽ chạy qua reducer và truyền action cùng với trạng thái hiện tại vào hàm reducer. Sau đó, hàm reducer sẽ kiểm tra hành động và trả về một phiên bản mới
										của trạng thái dựa trên hành động đó.
										- Trong hàm reducer sẽ có biến state và biến action, biến action được lấy từ dispatch.
										- The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was
										on the screen before your call.
										- If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an
										optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.
										- React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event.
										In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.
	
										// Define reducer function
										const reducer = (state, action) => {
										  switch (action.type) {
											case 'INCREMENT':
											  return { count: state.count + 1 };
											case 'DECREMENT':
											  return { count: state.count - 1 };
											case 'RESET':
											  return { count: 0 };
											default:
											  return state;
										  }
										};
										import React, { useReducer } from 'react';
										import reducer from './Reducer';
										// Component
										function Counter() {
										  // Sử dụng useReducer với reducer function và initialState
										  const [state, dispatch] = useReducer(reducer, { count: 0 });
										  // Handlers
										  const increment = () => dispatch({ type: 'INCREMENT' });
										  const decrement = () => dispatch({ type: 'DECREMENT' });
										  const reset = () => dispatch({ type: 'RESET' });
										  return (
											<div>
											  <p>Count: {state.count}</p>
											  <button onClick={increment}>Increment</button>
											  <button onClick={decrement}>Decrement</button>
											  <button onClick={reset}>Reset</button>
											</div>
										  );
										}
										export default Counter;
	useMemo--REACTJS:
										- useMemo is a React Hook that lets you cache the result of a calculation between re-renders.
										- useMemo giúp ta kiểm soát được việc render dư thừa của các component con, nó khá giống với hàm shouldComponentUpdate trong LifeCycle. Bằng cách truyền vào 1 tham số thứ 2 thì chỉ khi
										tham số này thay đổi thì thằng useMemo mới được thực thi.
										- useMemo là một react hooks giúp mình tạo ra một memoized value và chỉ tính toán ra value mới khi dependencies thay đổi.
										- useMemo giúp chúng ta hạn chế việc thực hiện những tính toán phức tạp mỗi lần component re-render. Bằng cách truyền dependencies ở đối số thứ 2, chỉ khi giá trị một trong các
										dependencies thay đổi thì việc tính toán mới thực hiện lại.
										- useMemo(calculateValue, dependencies)
												On the initial render, useMemo returns the result of calling calculateValue with no arguments.
												During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result
												that calculateValue has returned.
										
										import { useMemo } from 'react';
										function TodoList({ todos, tab }) {
										  const visibleTodos = useMemo(
											() => filterTodos(todos, tab),
											[todos, tab]
										  );
										  // ...
										}
	useCallback--REACTJS:
										- useCallback is a React Hook that lets you cache a function definition between re-renders.
										- useCallback có nhiệm vụ tương tự như useMemo nhưng khác ở chỗ function truyền vào useMemo bắt buộc phải ở trong quá trình render trong khi đối với useCallback đó lại là function callback của 1 event nào đó như là
										onClick chẳng hạn.
										- useCallback sử dụng cơ chế memorization – ghi nhớ kết quả của một function vào trong memory và sẽ trả về function được ghi nhớ trong trường hợp các dependencies này không thay đổi.
										- Tương tự như useMemo, nhưng useCallback có tác dụng là ngăn chặn việc một hàm bị khởi tạo lại mỗi lần re-render.
										- useCallback(fn, dependencies)
														On the initial render, useCallback returns the fn function you have passed.
														During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render
										
										import { useCallback } from 'react';
										function ProductPage({ productId, referrer, theme }) {
										  const handleSubmit = useCallback((orderDetails) => {
											post('/product/' + productId + '/buy', {
											  referrer,
											  orderDetails,
											});
										  }, [productId, referrer]);
										  // ...
	useContext--REACTJS:
										- Tóm tắt:
														Tạo 1 biến với createContext, ví dụ biến A,
														Trong 1 component cha khi render 1 component con khác (trong phần return) thì có thể truyền biến này qua thông qua <A.Provider value={...}>.
														Trong component con được gọi để sử dụng được biến này cần gọi useContext, tên biến giữa biến truyền và biến gán phải giống nhau, chú ý không phải là biến tạo bằng createContext
										- useContext là một hook được cung cấp bởi React để truy cập vào Context. Context là một cơ chế trong React cho phép truyền dữ liệu qua các thành phần con trong cây thành phần mà không cần truyền props qua từng cấp con.
										- React context API là một cách cơ bản để tạo các biến toàn cục có thể được truyền qua trong ứng dụng React. đây là phương pháp thay thế cho “prop drilling”, hoặc truyền props từ ông nội sang cha và sang con, v..v..
										Context thường được coi là đơn giản hơn, nhẹ nhàng hơn thay vì sử dụng Redux cho quản lý state.
										- Bạn có thể tạo một context để thêm những shared state và sau đó component nào cần thì bạn gọi context đó ra xài, không cần phải truyền từ cha xuống con nữa. Nó cũng giống như biến global được chia sẻ và sử dụng ở
										nhiều nơi
										- Trong React, để các component con có thể sử dụng Context thông qua useContext, thì các component con phải là con trực tiếp hoặc con của các component mà đã sử dụng Provider để cung cấp Context.
										- useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context.Provider> needs to be above the component doing the useContext() call.
										- React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison.
										Skipping rerenders with memo does not prevent the children receiving fresh context values.
										
										import React, { useContext } from 'react';								
										const ThemeContext = React.createContext('light'); // Khởi tạo context
										// Component cha cung cấp context
										function App() {
										  return (
											<ThemeContext.Provider value="dark">
											  <Toolbar />
											</ThemeContext.Provider>
										  );
										}
										// Component con sử dụng useContext để truy cập context
										function Toolbar() {
										  const theme = useContext(ThemeContext);
										  return (
											<div>
											  <h1>Current Theme: {theme}</h1>
											  <ThemedButton />
											</div>
										  );
										}
										// Component con khác sử dụng useContext để truy cập context
										function ThemedButton() {
										  const theme = useContext(ThemeContext);
										  return (
											<button style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#333' }}>
											  Click me
											</button>
										  );
										}
										export default App;
	Rendering Elements--REACTJS:
															To render a React element, first pass the DOM element to ReactDOM.createRoot(), then pass the React element to root.render():
															
															const root = ReactDOM.createRoot(document.getElementById('root'));
															const element = <h1>Hello, world</h1>;
															root.render(element);
															
															const root = ReactDOM.createRoot(document.getElementById('root'));
															function tick() {
															  const element = (
																<div>
																  <h1>Hello, world!</h1>
																  <h2>It is {new Date().toLocaleTimeString()}.</h2>
																</div>
															  );
															  root.render(element);
															}
															setInterval(tick, 1000);
															
															function Welcome(props)
															{
																return <h1>Hello, {props.name}</h1>;
															}
															const root = ReactDOM.createRoot(document.getElementById('root'));
															const element = <Welcome name="Sara" />;
															root.render(element);
	Conditional Rendering--REACTJS:
															return (
															  <div>
																<h1>Hello!</h1>
																{unreadMessages.length > 0 &&
																  <h2>
																	You have {unreadMessages.length} unread messages.
																  </h2>
																}
															  </div>
															);
															
															render() {
															  const isLoggedIn = this.state.isLoggedIn;
															  return (
																<div>
																  {isLoggedIn ? <LogoutButton onClick={this.handleLogoutClick} />
																	: <LoginButton onClick={this.handleLoginClick} /> }
																</div> );
															}
	Handling Events--REACTJS:
															function Form() {
															  function handleSubmit(e) {
																e.preventDefault(); console.log('You clicked submit.');
															  }
															  return (
																<form onSubmit={handleSubmit}>
																<button type="submit">Submit</button>
																</form>
															  );
															}
															
	JSX trong ReactJS--REACTJS:
	
											- JSX là viết tắt là Javascript XML, một template languges nhưng nó lại mang hầu hết tính năng của Javascript. Nó cho phép bạn viết các đoạn mã HTML trong React một cách dẽ dàng và có
											cấu trúc hơn. React sử dụng JSX cho việc xây dựng bố cục thay vì javascript thông thường. JSX giúp tạo ra các React 'elements'.
											- Nhiều dòng thì cần bao trong () (khi có nhiều thẻ HTML)
											- Với JSX nếu có biểu thức thì ta cần bao nó trong {}
											
		With JSX--REACTJS JSX:

											import React from 'react';
											import ReactDOM from 'react-dom/client';
											const myElement = <h1>I Love JSX!</h1>;
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(myElement);
											
		Without JSX--REACTJS JSX:
		
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											const myElement = React.createElement('h1', {}, 'I do not use JSX!');
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(myElement);
		
		
		Gán một biểu thức trong JSX--REACTJS JSX:
		
											const name = 'Freetuts.net';
											const element = <h1>Welcome to {name}</h1>;										
											ReactDOM.render(
											  element,
											  document.getElementById('root')
											);
											
											function formatName(user) {
											  return user.firstName + ' ' + user.lastName;
											}										 
											const user = {
											  firstName: 'Nguyễn',
											  lastName: 'Trí'
											};										 
											const element = (
											  <h1>
												Xin chào, {formatName(user)}!
											  </h1>
											);										 
											ReactDOM.render(
											  element,
											  document.getElementById('root')
											);
											
		JSX là một biểu thức--REACTJS JSX:
		
											Sau khi complie, các đoạn đoạn mã JSX sẽ như các object Javasript thông thường, cho phép bạn có thể gọi hoặc làm bất cứ gì với nó.
											Có nghĩa là bạn có thể sử dụng JSX bên trong if, for, function,...hay là chỉ định nó làm giá trị của một biến,..Trong ví dụ mình có một hàm trả về một JSX:
											
											function sayHi(name) {
												if(name) {
													return <p>Xin chào, {name} !</p>
												}else{
													return <p>Xin chào bạn !</p>
												}
											}
											
		Chỉ định attributes với JSX--REACTJS JSX:
		
											Bạn nên dùng dấu ngoặc kép ( "" ) cho giá trị chuỗi và ngoặc nhọn ( {} ) cho biểu thức như trong ví dụ trên, React khuyên chúng ta không nên dùng cả 2 cái lồng nhau
											
											const element = <div tabIndex="0"></div>;
											
											const element = <img src={user.avatarUrl}></img>;
											
											const element = <div tabIndex={"1"}></div>;
											
		Phần tử con trong JSX--REACTJS JSX:
		
											- Nếu chỉ có một tag bạn chỉ cần đóng nó bằng dấu />.
											- Trong trường hợp trong tag có nhiều phần tử con bạn cần phải bọc ngoài nó bằng một JSX tags:
											
											const element = <img src={user.avatarUrl} />;
											
											//Đúng cú pháp
											//Phải bọc nó bằng một tags
											const element = (
											  <div>
												<h1>Hello</h1>
												<p>Welcome to Freetuts</p>
											  </div>
											);										 
											//Viết sai
											//Các phần từ không được bọc
											const element = (
												<h1>Hello</h1>
												<p>Welcome to Freetuts</p>
											);
											
		JSX Object--REACTJS JSX:
		
											- Để complide một JSX object thành JSX thông thường chúng ta sử dụng React.createElement()
											- JSX object cho phép bạn tạo ra các JSX dễ dàng debug hơn
											
											const element = React.createElement(
											  "p",
											  { className: "welcome" },
											  "Welcome to Freetuts.net!"
											);										 
											const element = <p className="welcome">Welcome to Freetuts.net!</p>
											
											const element = {
											  type: "p",
											  props: {
												className: "welcome",
												children: "Welcome to Freetuts.net!"
											  }
											};										 
											const element = <p className="welcome">Welcome to Freetuts.net!</p>;
											
		Kết hợp JSX và string literal--REACTJS JSX:
		
											import React from 'react';
											function Greeting() {
											  const name = 'John';
											  const greeting = `Hello, ${name}!`;
											  return (
												<div>
												  <h1>Greeting</h1>
												  <p>{greeting}</p>
												</div>
											  );
											}
											export default Greeting;
											
											import React from 'react';
											function ItemList() {
											  const items = [
												{ id: 1, name: 'Item 1', description: 'Description for Item 1' },
												{ id: 2, name: 'Item 2', description: 'Description for Item 2' },
												{ id: 3, name: 'Item 3', description: 'Description for Item 3' }
											  ];
											  return (
												<div>
												  <h1>Item List</h1>
												  <ul>
													{items.map(item => (
													  <li key={item.id}>
														<h2>{item.name}</h2>
														<p>{`Description: ${item.description}`}</p> // Trong React, bạn cần sử dụng cặp dấu {} để nhúng biểu thức JavaScript vào JSX. 
													  </li>
													))}
												  </ul>
												</div>
											  );
											}
											export default ItemList;
											
											<p>{`Description: `}</p>
											
											import React from 'react';
											function MyComponent() {
											  const isActive = true;
											  const className = `button ${isActive ? 'active' : ''}`;
											  return (
												<button className={className}>
												  Click me
												</button>
											  );
											}
											export default MyComponent;
											
	ReactJS Class Component--REACTJS:

											- Before React 16.8, Class components were the only way to track state and lifecycle on a React component. Function components were considered "state-less".
											- Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, but work in isolation and return HTML via a render() function.
											- Components come in two types, Class components and Function components
											- The component has to include the extends React.Component statement, this statement creates an inheritance to React.Component, and gives your component access to
											React.Component's functions.
											- The component also requires a render() method, this method returns HTML.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Car extends React.Component {
											  render() {
												return <h2>Hi, I am a Car!</h2>;
											  }
											}
											ReactDOM.render(<Car />, document.getElementById('root'));
											
		Làm Thế Nào React Hook Có Thể Thay Thế Class Component--ReactJS Class Component:
		
											- Sử dụng useEffect để thay thế
											- Nếu chúng ta sử dụng useEffect như một hàm thông thường, không truyền bất kỳ tham số hay mảng dependencies nào, thì mặc định các lệnh trong hàm sẽ được thực hiện mỗi khi
											component được re-render.
											
			Mounting:
			
											Đây là quá trình component được khởi tạo và render lần đầu tiên, nó có phương thức chính là componentDidMount. Sau khi component xuất hiện ở DOM, những câu lệnh bên trong
											componentDidMount sẽ được thực hiện, nhưng chỉ một lần duy nhất. Để làm được như vậy với useEffect, ta cần truyền một mảng dependencies rỗng vào.
											
											import React, { useState, useEffect } from 'react';
											function Example() {
											  const [count, setCount] = useState(0);
											  useEffect(() => {
												console.log('I run only on the first render: mount.');
											  }, []);
											  return (
												<div>
												  <p>You clicked {count} times</p>
												  <button onClick={() => setCount(count + 1)}>Click me</button>
												</div>
											  );
											};
											
			Updating:
			
											- Nó có phương thức chính là componentDidUpdate
											- Trong trường hợp ta muốn thay đổi dữ liệu khi re-render, song chỉ giới hạn trong một vài phần tử trong component đó thì ta chỉ cần truyền vào một mảng dependencies các phần tử đấy,
											như thế này :
											
												import React, { useState, useEffect } from 'react';
												function Example() {
												  const [count, setCount] = useState(0);
												  const [countSub, setCountSub] = useState(0);
												  useEffect(() => {
													console.log(`You clicked ${count} times`);
												  }, [count]);
												  return (
													<div>
													  <p>You clicked {count} times</p>
													  <button onClick={() => setCount(count + 1)}>Click me</button>
													  <p>You clicked {countSub} times</p>
													  <button onClick={() => setCountSub(countSub + 1)}>Click your</button>
													</div>
												  );
												};		

			Unmounting:

											- Như vậy ta đã hiểu về cách useEffect thay thế componentDidMount() và componentDidUpdate() vậy còn componentWillUnMount() thì sao. Đât là lúc mà ta sử dụng đầy đủ cú pháp useEffect
											với hàm return mà nãy giờ vẫn chưa nhắc tới.
											- Như vậy là mỗi khi component sắp bị unmount nó sẽ báo console giống như componentWillUnMount().
											
											import React, { useState, useEffect } from 'react';
											function Example() {
											  const [count, setCount] = useState(0);
											  useEffect(() => {
												console.log(`You clicked ${count} times`);
												return(() => console.log('cleanup'))
											  }, [count]);
											  return (
												<div>
												  <p>You clicked {count} times</p>
												  <button onClick={() => setCount(count + 1)}>Click me</button>
												</div>
											  );
											};
		
		Component Constructor--ReactJS Class Component:
		
											- If there is a constructor() function in your component, this function will be called when the component gets initiated.
											- The constructor function is where you initiate the component's properties.
											- In React, component properties should be kept in an object called state.
											- The constructor function is also where you honor the inheritance of the parent component by including the super() statement, which executes the parent component's constructor
											function, and your component has access to all the functions of the parent component (React.Component).
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Car extends React.Component {
											  constructor() {
												super();
												this.state = {color: "red"};
											  }
											  render() {
												return <h2>I am a {this.state.color} Car!</h2>;
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Car />);
											
		Props--ReactJS Class Component:
		
											- Another way of handling component properties is by using props.
											- Props are like function arguments, and you send them into the component as attributes.
											- If your component has a constructor function, the props should always be passed to the constructor and also to the React.Component via the super() method.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Car extends React.Component {
											  render() {
												return <h2>I am a {this.props.color} Car!</h2>;
											  }
											}
											ReactDOM.render(<Car color="red"/>, document.getElementById('root'));
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Car extends React.Component {
											  constructor(props) {
												super(props);
											  }
											  render() {
												return <h2>I am a {this.props.model}!</h2>;
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Car model="Mustang"/>);
											
		React Class Component State--ReactJS Class Component:
		
											- React Class components have a built-in state object.
											- To change a value in the state object, use the this.setState() method.
											- The state object is where you store property values that belongs to the component.
											- The state object is initialized in the constructor
											- Refer to the state object anywhere in the component by using the this.state.propertyname syntax
											- When a value in the state object changes, the component will re-render, meaning that the output will change according to the new value(s).
											- Always use the setState() method to change the state object, it will ensure that the component knows its been updated and calls the render() method (and all the other
											lifecycle methods).
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Car extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {
												  brand: "Ford",
												  model: "Mustang",
												  color: "red",
												  year: 1964
												};
											  }
											  changeColor = () => {
												this.setState({color: "blue"});
											  }
											  render() {
												return (
												  <div>
													<h1>My {this.state.brand}</h1>
													<p>
													  It is a {this.state.color}
													  {this.state.model}
													  from {this.state.year}.
													</p>
													<button
													  type="button"
													  onClick={this.changeColor}
													>Change color</button>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Car />);
											
		Lifecycle of Components--ReactJS Class Component:
		
			Mounting:

											- Mounting means putting elements into the DOM.
											- The render() method is required and will always be called, the others are optional and will be called if you define them.
											
				constructor:
				
											- The constructor() method is called before anything else, when the component is initiated, and it is the natural place to set up the initial state and other initial values.
											- The constructor() method is called with the props, as arguments, and you should always start by calling the super(props) before anything else, this will initiate the
											parent's constructor method and allows the component to inherit methods from its parent (React.Component).
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  render() {
												return (
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
				getDerivedStateFromProps:
				
											- The getDerivedStateFromProps() method is called right before rendering the element(s) in the DOM.
											- This is the natural place to set the state object based on the initial props.
											- It takes state as an argument, and returns an object with changes to the state.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  static getDerivedStateFromProps(props, state) {
												return {favoritecolor: props.favcol };
											  }
											  render() {
												return (
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header favcol="yellow"/>);
											
				render:
				
											- The render() method is required, and is the method that actually outputs the HTML to the DOM.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';=
											class Header extends React.Component {
											  render() {
												return (
												  <h1>This is the content of the Header component</h1>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
				componentDidMount:
				
											- The componentDidMount() method is called after the component is rendered.
											- This is where you run statements that requires that the component is already placed in the DOM.
											- Được gọi sau khi component đã được mount (hoặc render) lần đầu tiên trong cây DOM. Điều này có nghĩa là componentDidMount sẽ chạy sau khi component được hiển thị lần đầu tiên
											trên trình duyệt. componentDidMount chỉ được gọi một lần duy nhất, sau lần render đầu tiên.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  componentDidMount() {
												setTimeout(() => {
												  this.setState({favoritecolor: "yellow"})
												}, 1000)
											  }
											  render() {
												return (
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
			Updating:
			
											- The next phase in the lifecycle is when a component is updated.
											- A component is updated whenever there is a change in the component's state or props.
											- The render() method is required and will always be called, the others are optional and will be called if you define them.
											
				getDerivedStateFromProps:
				
											- Also at updates the getDerivedStateFromProps method is called. This is the first method that is called when a component gets updated.
											- This is still the natural place to set the state object based on the initial props.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  static getDerivedStateFromProps(props, state) {
												return {favoritecolor: props.favcol };
											  }
											  changeColor = () => {
												this.setState({favoritecolor: "blue"});
											  }
											  render() {
												return (
												  <div>
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												  <button type="button" onClick={this.changeColor}>Change color</button>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header favcol="yellow" />);
											/*
											This example has a button that changes the favorite color to blue,
											but since the getDerivedStateFromProps() method is called,
											the favorite color is still rendered as yellow
											(because the method updates the state
											with the color from the favcol attribute).
											*/
											
				shouldComponentUpdate:
				
											- In the shouldComponentUpdate() method you can return a Boolean value that specifies whether React should continue with the rendering or not.
											- The default value is true.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  shouldComponentUpdate() {
												return false;
											  }
											  changeColor = () => {
												this.setState({favoritecolor: "blue"});
											  }
											  render() {
												return (
												  <div>
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												  <button type="button" onClick={this.changeColor}>Change color</button>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
				render:
				
											- The render() method is of course called when a component gets updated, it has to re-render the HTML to the DOM, with the new changes.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  changeColor = () => {
												this.setState({favoritecolor: "blue"});
											  }
											  render() {
												return (
												  <div>
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												  <button type="button" onClick={this.changeColor}>Change color</button>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
				getSnapshotBeforeUpdate:
				
											- In the getSnapshotBeforeUpdate() method you have access to the props and state before the update, meaning that even after the update, you can check what the values were before
											the update.
											- If the getSnapshotBeforeUpdate() method is present, you should also include the componentDidUpdate() method, otherwise you will get an error.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  componentDidMount() {
												setTimeout(() => {
												  this.setState({favoritecolor: "yellow"})
												}, 1000)
											  }
											  getSnapshotBeforeUpdate(prevProps, prevState) {
												document.getElementById("div1").innerHTML =
												"Before the update, the favorite was " + prevState.favoritecolor;
											  }
											  componentDidUpdate() {
												document.getElementById("div2").innerHTML =
												"The updated favorite is " + this.state.favoritecolor;
											  }
											  render() {
												return (
												  <div>
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												  <div id="div1"></div>
												  <div id="div2"></div>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
				componentDidUpdate:
				
											The componentDidUpdate method is called after the component is updated in the DOM.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Header extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {favoritecolor: "red"};
											  }
											  componentDidMount() {
												setTimeout(() => {
												  this.setState({favoritecolor: "yellow"})
												}, 1000)
											  }
											  componentDidUpdate() {
												document.getElementById("mydiv").innerHTML =
												"The updated favorite is " + this.state.favoritecolor;
											  }
											  render() {
												return (
												  <div>
												  <h1>My Favorite Color is {this.state.favoritecolor}</h1>
												  <div id="mydiv"></div>
												  </div>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Header />);
											
			Unmounting:
			
											The next phase in the lifecycle is when a component is removed from the DOM, or unmounting as React likes to call it.
											
				componentWillUnmount:
				
											The componentWillUnmount method is called when the component is about to be removed from the DOM.
											
											import React from 'react';
											import ReactDOM from 'react-dom/client';
											class Container extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {show: true};
											  }
											  delHeader = () => {
												this.setState({show: false});
											  }
											  render() {
												let myheader;
												if (this.state.show) {
												  myheader = <Child />;
												};
												return (
												  <div>
												  {myheader}
												  <button type="button" onClick={this.delHeader}>Delete Header</button>
												  </div>
												);
											  }
											}
											class Child extends React.Component {
											  componentWillUnmount() {
												alert("The component named Header is about to be unmounted.");
											  }
											  render() {
												return (
												  <h1>Hello World!</h1>
												);
											  }
											}
											const root = ReactDOM.createRoot(document.getElementById('root'));
											root.render(<Container />);

React Router---:
											- React Router là một thư viện định tuyến dựa trên thành phần, máy khách và phía máy chủ khai báo cho React.
	BrowserRouter--React Router:
											- BrowserRouter giúp tích hợp URL với trạng thái ứng dụng React. Các route có thể được liên kết với các thành phần (component) React cụ thể và hiển thị nội dung tương ứng dựa trên
											đường dẫn URL.
											- Về cơ bản, BrowserRouter sử dụng cả thư viện lịch sử cũng như React Context. Thư viện lịch sử giúp React Router theo dõi lịch sử duyệt của ứng dụng bằng cách sử dụng ngăn xếp lịch
											sử có sẵn của trình duyệt và React Context giúp cung cấp lịch sử ở bất cứ nơi nào React Router cần.
											- BrowserRouter là một thành phần trong React Router, một thư viện được sử dụng để quản lý định hướng (routing) trong ứng dụng React. BrowserRouter được sử dụng để bọc toàn bộ ứng
											dụng và cung cấp các tính năng của HTML5 History API để duyệt qua các trang mà không cần tải lại toàn bộ trang.
											- BrowserRouter trong React Router giúp giải quyết vấn đề của việc quản lý định hướng (routing) trong ứng dụng React. Dưới đây là một số vấn đề cụ thể mà BrowserRouter giúp đỡ:
														
														Duyệt Trang Mà Không Tải Lại Toàn Bộ Trang:
																
																- Một ứng dụng React Router thường xuyên là một ứng dụng đơn trang (SPA), nơi người dùng có thể điều hướng giữa các "trang" mà không cần tải lại toàn bộ trang.
																- BrowserRouter sử dụng HTML5 History API để thực hiện điều này mà không cần tải lại trang.
														
														Tích Hợp URL và Trạng Thái Ứng Dụng
														
														Xác Định Các Route và Liên Kết:
																
																BrowserRouter cung cấp các thành phần như Route và Link giúp xác định cách các đường dẫn URL sẽ được điều hướng và làm thế nào các liên kết sẽ được tạo ra.
														
														Lắng Nghe Sự Kiện Thay Đổi URL:
																
																BrowserRouter lắng nghe sự kiện thay đổi URL, giúp ứng dụng React phản ánh các thay đổi trong URL và điều hướng đến các component React tương ứng.
																
											- Không có nhiều thứ đối với BrowserRouter, bạn chỉ cần đảm bảo rằng nếu đang sử dụng React Router trên web, bạn sẽ bọc ứng dụng của mình bên trong thành phần BrowserRouter.
											
											import ReactDOM from <react-dom<
											import * as React from <react<
											import { BrowserRouter } from <react-router-dom<
											import App from <./App`
											ReactDOM.render(
											  <BrowserRouter>
												<App />
											  </BrowserRouter>
											, document.getElementById(<app<))
	Route--React Router:
											Nói một cách đơn giản, Route cho phép bạn ánh xạ vị trí ứng dụng của mình với các thành phần (component) React khác nhau.
											
											<Route path="/dashboard" element={<Dashboard />} />
											
											<Route path="/" element={<Home />} />
											<Route path="/about" element={<About />} />
											<Route path="/settings" element={<Settings />} />
	Routes--React Router:
											- Bạn có thể nghĩ về Routes như là người dẫn đường ẩn dụ cho các tuyến đường của bạn. Bất cứ khi nào bạn có một hoặc nhiều Route, rất có thể bạn sẽ muốn gói chúng trong một Routes.
											- Với React Router v6, <Routes> được sử dụng để thay thế cho <Switch> trong phiên bản v5 và nhóm các <Route> lại với nhau. Nếu bạn không sử dụng <Routes>, bạn có thể thấy mình cần
											phải điều chỉnh cú pháp và cách tổ chức mã nguồn của mình.
											- Để thiết lập một đường dẫn mặc định ban đầu cho React Router, bạn có thể sử dụng một Route không có thuộc tính path. Điều này có nghĩa là nếu không có đường dẫn nào khớp với URL,
											Route sẽ được kích hoạt và hiển thị component được chỉ định.
											
											import { Routes, Route } from "react-router-dom";
											function App() {
											  return (
												<Routes>
												  <Route path="/" element={<Home />} />
												  <Route path="/about" element={<About />} />
												  <Route path="/settings" element={<Settings />} />
												  <Route path="*" element={<NotFound />} />
												</Routes>
											  );
											}
											
											import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
											function App() {
											  return (
												<Router>
												  <Routes>
													<Route path="/" element={<HomePage />} />
													<Route path="/about" element={<AboutPage />} />
													{/* Các Route khác nếu cần */}
													<Route element={<NotFoundPage />} />
												  </Routes>
												</Router>
											  );
											}
	Link--React Router:
											- <Link> là một thành phần của React Router được sử dụng để tạo các liên kết trong ứng dụng React và thường được sử dụng để thay thế cho thẻ <a> khi bạn làm việc với định tuyến trong
											ứng dụng React.
											- Bước tiếp theo là có thể điều hướng giữa chúng. Đây là mục đích của thành phần Link.
											- Để cho Link biết đường dẫn nào sẽ đưa người dùng đến khi được nhấp vào, bạn chuyển nó to để hỗ trợ.
											- Nếu bạn cần kiểm soát nhiều hơn đối với Liên kết, bạn cũng có thể to dưới dạng một đối tượng. Làm như vậy cho phép bạn thêm một chuỗi truy vấn thông qua thuộc tính search hoặc
											chuyển bất kỳ dữ liệu nào đến tuyến đường mới thông qua state.
											- Khi bạn sử dụng <Link>, React Router sẽ chịu trách nhiệm điều hướng (routing) ứng dụng của bạn mà không làm tải lại trang.
											- Khi sử dụng thẻ <a>, trang web sẽ thực hiện một tải lại khi bạn chuyển hướng đến một trang mới, điều này không hiệu quả như việc sử dụng React Router trong ứng dụng React.
											
											<nav>
											  <Link to="/">Home</Link>
											  <Link to="/about">About</Link>
											  <Link to="/settings">Settings</Link>
											</nav>
											
											<nav>
											  <Link to="/">Home</Link>
											  <Link to="/about">About</Link>
											  <Link
												to={{
												  pathname: "/settings",
												  search: "?sort=date",
												  state: { fromHome: true },
												}}
											  >
												Settings
											  </Link>
											</nav>
	useParams--React Router:
											- Giống như các tham số hàm cho phép bạn khai báo trình giữ chỗ khi bạn xác định một hàm, Tham số URL cho phép bạn khai báo trình giữ chỗ cho các phần của URL.
											- Lấy Wikipedia làm ví dụ. Khi bạn truy cập một chủ đề trên Wikipedia, bạn sẽ nhận thấy rằng mẫu URL luôn giống nhau, wikipedia.com/wiki/{topicId}.
											- Thay vì xác định lộ trình cho mọi chủ đề trên trang web, họ có thể khai báo một lộ trình với trình giữ chỗ cho id của chủ đề. Cách bạn nói với React Router rằng một phần nhất định
											của URL là trình giữ chỗ (hoặc Tham số URL), là bằng cách sử dụng: trong phần hỗ trợ đường dẫn của Route
											- Trong React Router, khi bạn định nghĩa một tham số trong đường dẫn sử dụng cú pháp :parameter, giá trị của tham số đó thường được truyền dưới dạng chuỗi (string)
											
											<Route path="/wiki/:topicId" element={<Article />} /> // Giờ đây, bất cứ khi nào bất cứ ai truy cập vào một URL khớp với mẫu / wiki /: topicId (/ wiki / javascript,
																								  // / wiki / Brendan_Eich, / wiki / anything), thành phần Article sẽ được hiển thị.
											import * as React from <react<
											import { useParams } from <react-router-dom<
											import { getArticle } from <../utils<
											function Article () {
											  const [article, setArticle] = React.useState(null)
											  const { topicId } = useParams()
											  React.useEffect(() => {
												getArticle(topicId)
												  .then(setUser)
											  }, [topicId])
											  return (
												...
											  )
											}
											
											<Route path="/item/:id" element={<ItemDetail />} /> // Khi bạn truy cập URL như "/item/123", giá trị của id trong component ItemDetail sẽ là chuỗi "123", không phải số nguyên. Điều
																								// này là do React Router không tự động chuyển đổi tham số thành kiểu dữ liệu khác ngoại trừ chuỗi.
	useLocation--React Router:
											- useLocation sẽ trả về location object hiện tại. Nó sẽ giúp ích trong trường hợp chúng ta muốn lấy thông tin từ URL hiện tại. Ví dụ như, bạn muốn gửi một sự kiện "page view" đến một
											analytics service mỗi khi URL thay đổi.
											- Hook này trả về một đối tượng với các thuộc tính và phương thức sau:
														pathname: 	Một chuỗi đại diện cho phần đường dẫn của URL hiện tại. Trả về phần đường dẫn của URL, bao gồm tất cả các thành phần của đường dẫn trừ chuỗi truy vấn và
																	fragment identifier. Đây thường được sử dụng khi bạn cần lấy thông tin về phần đường dẫn của URL.
														search:		Một chuỗi đại diện cho phần truy vấn của URL hiện tại (bao gồm ký tự ?).
														hash:		Một chuỗi đại diện cho phần mở đầu bằng dấu # của URL hiện tại.
														state:		Một đối tượng đại diện cho trạng thái được chuyển đến từ phương thức history.push() khi di chuyển đến vị trí hiện tại.
											- useLocation cũng cung cấp một phương thức:
														toString(): Trả về một chuỗi đại diện cho toàn bộ URL, bao gồm cả phần đường dẫn, chuỗi truy vấn và fragment identifier.
											
											import { Switch, useLocation } from 'react-router'
											function usePageViews() {
											  let location = useLocation()
											  useEffect(
												() => {
												  ga.send(['pageview', location.pathname])
												},
												[location]
											  )
											}
											function App() {
											  usePageViews()
											  return <Switch>{/* your routes here */}</Switch>
											}
											
											Khi bạn truy cập vào URL "http://localhost:3000/about?id=123#section1"
											import React from 'react';
											import { BrowserRouter as Router, Route, Link, useLocation } from 'react-router-dom';
											function Home() {
											  return <h2>Home</h2>;
											}
											function About() {
											  return <h2>About</h2>;
											}
											function MyComponent() {
											  const location = useLocation();
											  return (
												<div>
												  <h2>Location Info:</h2>
												  <p>Pathname: {location.pathname}</p> // Pathname: /about
												  <p>Search: {location.search}</p> // Search: ?id=123
												  <p>Hash: {location.hash}</p> // Hash: #section1
												</div>
											  );
											}
											function App() {
											  return (
												<Router>
												  <div>
													<nav>
													  <ul>
														<li>
														  <Link to="/">Home</Link>
														</li>
														<li>
														  <Link to="/about">About</Link>
														</li>
													  </ul>
													</nav>
													<Route path="/" exact component={Home} />
													<Route path="/about" component={About} />
													<Route path="/" component={MyComponent} />
												  </div>
												</Router>
											  );
											}
											export default App;
											
											http://example.com/page?query1=value1&query2=value2
											import React from 'react';
											import { useLocation } from 'react-router-dom';
											function MyComponent() {
											  const location = useLocation();
											  return (
												<div>
												  <h2>Location Info:</h2>
												  <p>Pathname: {location.pathname}</p> // /page
												  <p>Search: {location.search}</p> // ?query1=value1&query2=value2
												  <p>Hash: {location.hash}</p>
												</div>
											  );
											}
											export default MyComponent;

											http://example.com/page/subpage?param=value#section
											import React from 'react';
											import { useLocation } from 'react-router-dom';
											function MyComponent() {
											  const location = useLocation();
											  return (
												<div>
												  <h2>Location Info:</h2>
												  <p>Pathname: {location.pathname}</p> // /page/subpage
												  <p>Search: {location.search}</p> // ?param=value
												  <p>Hash: {location.hash}</p> // #section
												  <p>Full URL: {location.toString()}</p> // http://example.com/page/subpage?param=value#section
												</div>
											  );
											}
											export default MyComponent;
	useHistory--React Router:
											- Nếu bạn muốn sử dụng history object cho các tác vụ điều hướng trong trang, bạn có thể sử dụng useHistory.
											- Thuộc tính:
															length:		Số lượng các mục trong lịch sử duyệt.
											- Phương thức:
															push(path, [state]): 		Thêm một mục mới vào lịch sử duyệt, di chuyển đến đường dẫn được chỉ định. Bạn cũng có thể chuyển một trạng thái tùy ý kèm theo đường dẫn.
															replace(path, [state]): 	Thay thế mục hiện tại trong lịch sử duyệt bằng một mục mới, di chuyển đến đường dẫn được chỉ định. Cũng có thể kèm theo trạng thái mới.
															go(n): 						Di chuyển đến một mục trong lịch sử duyệt tương ứng với sự thay đổi của n. Nếu n là số dương, nó sẽ di chuyển về trước. Nếu n là số âm, nó
																						sẽ di chuyển về phía trước. Ví dụ: go(-1) sẽ di chuyển về trang trước đó.
															goBack(): 					Di chuyển về trang trước đó trong lịch sử duyệt, tương đương với go(-1).
															goForward(): 				Di chuyển đến trang tiếp theo trong lịch sử duyệt, tương đương với go(1).
															listen(listener): 			Lắng nghe sự kiện thay đổi trong lịch sử duyệt và gọi hàm listener mỗi khi có thay đổi. Trả về một hàm để hủy lắng nghe sự kiện.
															block(prompt): 				Ngăn chặn chuyển đổi đến một trang mới và yêu cầu người dùng xác nhận. Trả về một hàm để hủy việc block.
											- React Router cung cấp thêm cho chúng ta useNavigate hook, dành riêng cho các tác vụ điều hướng trong trang một cách thuận tiện hơn.
											
											import React from 'react';
											import { useHistory } from 'react-router-dom';
											function MyComponent() {
											  const history = useHistory();
											  const handleClick = () => {
												history.push('/new-page'); // Di chuyển đến trang mới '/new-page'
											  };
											  return (
												<div>
												  <button onClick={handleClick}>Go to New Page</button>
												</div>
											  );
											}
											export default MyComponent;

	Nested Routes--React Router:
											- Các tuyến lồng nhau cho phép Tuyến mẹ hoạt động như một trình bao bọc và kiểm soát việc hiển thị một Tuyến con.
											- Một ví dụ thực tế về giao diện người dùng này có thể trông tương tự như tuyến đường messages / của Twitter. Khi bạn truy cập / messages, bạn sẽ thấy tất cả các cuộc Chat trước đó
											của mình ở bên trái màn hình. Sau đó, khi bạn truy cập / messages /: id, bạn vẫn thấy tất cả các messages của mình, nhưng bạn cũng thấy lịch sử Chat của mình cho: id.
											
											// App.js
											function App() {
											  return (
												<Routes>
												  <Route path="/" element={<Home />} />
												  <Route path="/messages" element={<Messages />} />
												  <Route path="/settings" element={<Settings />} />
												</Routes>
											  );
											}
											
											- Bây giờ, nếu chúng ta muốn Messages kiểm soát việc hiển thị các Tuyến con, thì điều gì ngăn chúng ta chỉ hiển thị một thành phần Định tuyến khác bên trong Messages? Một cái gì đó như
											thế này.
											- Bây giờ khi người dùng điều hướng đến / messages, React Router sẽ hiển thị thành phần Messages. Từ đó, Messages hiển thị tất cả các cuộc Chat của chúng tôi thông qua thành phần Chat
											và sau đó hiển thị các Routes khác có Route ánh xạ / Messages /: id tới thành phần Chat.
											- Lưu ý rằng chúng ta không phải bao gồm đường dẫn đầy đủ / messages /: id trong Route lồng nhau. Điều này là do Routes là thông minh và bằng cách bỏ đi đầu /, nó giả định rằng chúng
											ta muốn đường dẫn này có liên quan đến vị trí của cha , /messages
											
											function Messages() {
											  return (
												<Container>
												  <Conversations />

												  <Routes>
													<Route path=":id" element={<Chat />} />
												  </Routes>
												</Container>
											  );
											}
											
											- Điều gì sẽ xảy ra nếu chúng ta chỉ cập nhật đường dẫn của mình thành / messages / *?
											- Chúng tôi rất vui, điều đó sẽ hoạt động. Bằng cách thêm / * vào cuối đường dẫn / messages, về cơ bản chúng ta đang nói với React Router rằng Messages có thành phần Routes lồng nhau
											và đường dẫn mẹ của chúng ta phải khớp với / messages cũng như bất kỳ vị trí nào khác khớp với / messages / * họa tiết. Chính xác những gì chúng tôi muốn.
											
											// App.js
											function App() {
											  return (
												<Routes>
												  <Route path="/" element={<Home />} />
												  <Route path="/messages/*" element={<Messages />} />
												  <Route path="/settings" element={<Settings />} />
												</Routes>
											  );
											}
											
											- Bởi vì đây là một sở thích phổ biến, React Router cũng hỗ trợ cách này để tạo các tuyến đường lồng nhau. Đây là những gì nó trông như thế nào.
											- Bạn đã khai báo lồng Route con dưới dạng con của Route cha. Giống như trước đây, Route con bây giờ là tương đối với cha, vì vậy bạn không cần phải bao gồm đường dẫn cha (/ messages).
											
											function App() {
											  return (
												<Routes>
												  <Route path="/" element={<Home />} />
												  <Route path="/messages" element={<Messages />}>
													<Route path=":id" element={<Chats />} />
												  </Route>
												  <Route path="/settings" element={<Settings />} />
												</Routes>
											  );
											}
															
											- Bây giờ, điều cuối cùng bạn cần làm là cho React Router biết vị trí trong Tuyến cha (massages) sẽ hiển thị Tuyến con (Chats).
											- Để làm điều này, bạn sử dụng thành phần Outlet của React Router
											- Nếu vị trí của ứng dụng khớp với đường dẫn của Tuyến đường lồng nhau, thành phần Outlet này sẽ hiển thị phần tử của Tuyến đường. Vì vậy, dựa trên Routes của chúng ta ở trên, nếu
											chúng ta đang ở / messages, thành phần Outlet sẽ hiển thị null, nhưng nếu chúng ta ở / messages / 1, nó sẽ hiển thị thành phần <Chats />.
											
											import { Outlet } from "react-router-dom";
											function Messages() {
											  return (
												<Container>
												  <Conversations />
												  <Outlet />
												</Container>
											  );
											}
											
	Pass props to Router Components--React Router:
	
											Với React Router v6, vì bạn chịu trách nhiệm tạo phần tử, nên bạn chỉ cần chuyển một phần tử hỗ trợ cho thành phần như bình thường.
											
											<Route path="/dashboard" element={<Dashboard authed={true} />} />
	Redirect--React Router:
											- Chúng ta có thể chuyển hướng bằng cách sử dụng thành phần <Redirect> bằng cách chỉ cần chuyển tuyến đường mà chúng ta muốn chuyển hướng đến và hiển thị thành phần. Nó đã được tải
											trong thư viện react-router-dom.
											- Cách dễ nhất để sử dụng phương pháp này là duy trì một thuộc tính chuyển hướng bên trong trạng thái của thành phần.
											- Bất cứ khi nào bạn muốn chuyển hướng đến một đường dẫn khác, bạn có thể chỉ cần thay đổi trạng thái để hiển thị lại thành phần, do đó hiển thị thành phần <Redirect>.
											- <Link> được sử dụng để tạo ra các liên kết trong ứng dụng React Router DOM. Nó giúp bạn tạo các liên kết để điều hướng giữa các trang mà không làm tải lại trang hoàn toàn.
											- <Redirect> được sử dụng để chuyển hướng người dùng từ một URL đến một URL khác. Nó thường được sử dụng khi bạn muốn tự động chuyển hướng người dùng sau một số hành động hoặc điều
											kiện nhất định.
											
											state = { redirect: null };
											render() {
											  if (this.state.redirect) {
												return <Redirect to={this.state.redirect} />
											  }
											  return(
											  // Your Code goes here
											  )
											}
											
											import { Redirect } from 'react-router-dom';
											class MyComponent extends React.Component {
											  constructor(props) {
												super(props);
												this.state = {
												  shouldRedirect: false,
												};
											  }
											  handleRedirect = () => {
												this.setState({ shouldRedirect: true });
											  };
											  render() {
												if (this.state.shouldRedirect) {
												  return <Redirect to="/new-page" />;
												}
												return (
												  <div>
													<button onClick={this.handleRedirect}>Go to New Page</button>
												  </div>
												);
											  }
											}
											
	Programmatically Navigate--React Router:
	
											- Để có quyền truy cập vào phương thức điều hướng bắt buộc, bạn sẽ cần sử dụng useNavigate Hook của React Router. Từ đó, bạn có thể chuyển điều hướng đến đường dẫn mới mà bạn muốn
											người dùng được đưa đến khi điều hướng được gọi.
											- Điều hướng hoạt động giống như bất kỳ thành phần React nào khác, tuy nhiên, thay vì hiển thị một số giao diện người dùng, nó điều hướng người dùng đến một vị trí mới.
											- Nó phải nhập nhiều hơn, nhưng tôi tranh luận rằng trạng thái rõ ràng dẫn đến một API khai báo tốt hơn trạng thái ngầm được xử lý bởi một API bắt buộc.
											
											import { useNavigate } from <react-router-dom
											function Register () {
											  const navigate = useNavigate()
											  return (
												<div>
												  <h1>Register</h1>
												  <Form afterSubmit={() => navigate(</dashboard<)} />
												</div>
											  )
											}
											
											function Register() {
											  const [toDashboard, setToDashboard] = React.useState(false);
											  if (toDashboard === true) {
												return <Navigate to="/dashboard" />;
											  }
											  return (
												<div>
												  <h1>Register</h1>
												  <Form afterSubmit={() => toDashboard(true)} />
												</div>
											  );
											}
	Query Strings--React Router:
											- Bạn gần như chắc chắn đã gặp phải các chuỗi truy vấn trước đây. Họ là? và & bạn thấy được nối vào các URL. Chúng là một khía cạnh cơ bản của cách hoạt động của Web vì chúng cho phép
											bạn chuyển trạng thái qua URL.
											- Kể từ phiên bản 6, React Router chủ yếu dựa vào API URLSearchParams để xử lý các chuỗi truy vấn. URLSearchParams được tích hợp vào tất cả các trình duyệt (ngoại trừ IE) và cung cấp
											cho bạn các phương thức tiện ích để xử lý các chuỗi truy vấn. Để thực hiện điều này, React Router đi kèm với một hookSearchParams sử dụng tùy chỉnh, là một trình bao bọc nhỏ
											trên URLSearchParams.
											- useSearchParams trả về một mảng với phần tử đầu tiên là một phiên bản của URLSearchParams và phần tử thứ hai là một cách để cập nhật chuỗi truy vấn.
											- Đây là cách chúng tôi lấy các giá trị từ chuỗi truy vấn của mình bằng cách sử dụng useSearchParams.
											
											import { useSearchParams } from <react-router-dom<
											const Results = () => {
											  const [searchParams, setSearchParams] = useSearchParams();
											  const q = searchParams.get(<q<)
											  const src = searchParams.get(<src<)
											  const f = searchParams.get(<f<)
											  return (
												...
											  )
											}
	Catch all (404) Pages--React Router:
											- Tất cả những gì bạn phải làm là kết xuất một Lộ trình với đường dẫn là * và React Router sẽ đảm bảo chỉ hiển thị phần tử nếu không có Đường dẫn nào khác khớp
											
											<Routes>
											  <Route path="*" element={<NotFound />} />
											  <Route path="/" element={<Home />} />
											  <Route path="/about" element={<About />} />
											  <Route path="/settings" element={<Settings />} />
											</Routes>
	Pass props to Link--React Router:
											- Để chuyển dữ liệu qua một thành phần Liên kết đến một tuyến đường mới, hãy sử dụng bộ phận hỗ trợ trạng thái của Liên kết.
											- Bất cứ khi nào bạn chuyển dữ liệu qua phần hỗ trợ trạng thái, dữ liệu đó sẽ có sẵn trên thuộc tính trạng thái của vị trí, bạn có thể truy cập vào thuộc tính này bằng cách sử dụng
											useLocation Hook tùy chỉnh đi kèm với React Router.
											
											<Link to="/onboarding/profile" state={{ from: "occupation " }}>
											  Next Step
											</Link>									
											import { useLocation } from <react-router-dom<
											function Profile () {
											  const location = useLocation()
											  const { from } = location.state
											  return (
												...
											  )
											}
	Rendering a Sidebar--React Router:
											- Việc hiển thị một thanh bên với React Router không đặc biệt thú vị vì nó chỉ là một tập hợp các Liên kết. Tuy nhiên, điều gì sẽ xảy ra nếu chúng ta muốn thanh bên đó cũng nhận biết
											được vị trí của ứng dụng? Chắc chắn bạn có thể sử dụng useLocation Hook của React Router cho việc này, nhưng React Router đi kèm với một công cụ tốt hơn để ánh xạ vị trí của ứng dụng
											với các thành phần nhất định, cụ thể là Routes và Route.
											- Chìa khóa để hiển thị thanh bên nhận biết vị trí là hiểu rằng với Bộ định tuyến React, bạn có thể hiển thị bao nhiêu Tuyến tùy thích. Có thể bạn đã quen với việc hiển thị các Tuyến
											đường ở cấp cao nhất của ứng dụng, nhưng không có gì ngăn cản bạn hiển thị các Tuyến đường khác ở một nơi khác trong ứng dụng của bạn, chẳng hạn như trong thanh bên.
											
											export default function App() {
											  return (
												<div className="wrapper">
												  <div className="sidebar">
													<ul className="nav">
													  <li>
														<Link to="/">Home</Link>
													  </li>
													  <li>
														<Link to="/p">Profile</Link>
													  </li>
													  <li>
														<Link to="/s">Settings</Link>
													  </li>
													</ul>
													<Routes>
													  <Route path="/" element={<HomeDesc />} />
													  <Route path="/p" element={<ProfileDesc />} />
													  <Route path="/s" element={<SettingsDesc />} />
													</Routes>
												  </div>

												  <Routes>
													<Route path="/" element={<Home />} />
													<Route path="/p" element={<Profile />} />
													<Route path="/s" element={<Settings />} />
												  </Routes>
												</div>
											  );
											}
	Customizing Link--React Router:
											- Một điều tôi thích ở React Router là cách nó có thể kết hợp. Khái niệm này thực sự tỏa sáng khi bạn cần xây dựng thành phần Liên kết tùy chỉnh của riêng mình. Vì React Router có
											API đầu tiên của thành phần, bạn có thể soạn Liên kết giống như bạn soạn bất kỳ thành phần React nào khác.
											- Giả sử chúng tôi muốn tạo một thành phần Liên kết tùy chỉnh “phát sáng” và thêm biểu tượng cảm xúc vào bất kỳ Liên kết nào đang hoạt động. Để làm điều đó, tất cả những gì chúng ta
											phải làm là soạn Liên kết và sau đó useLocation để lấy vị trí hiện tại của ứng dụng.
											
											import { useLocation } from <react-router-dom<
											function GlowLink ({ children, to }) {
											  const location = useLocation()
											  const match = location.pathname === to
											  return (
												<span className={match ? <glow< : <<}>
												  {match ? < < : <<}
												  <Link to={to}>
													{children}
												  </Link>
												</span>
											  )
											}
											...
											<nav>
											  <GlowLink to=</<>Home</GlowLink>
											  <GlowLink to=</about<>About</GlowLink>
											  <GlowLink to=</features<>Features</GlowLink>
											</nav>
	Code Splitting--React Router:
											- Ý tưởng rất đơn giản, đừng tải mã xuống cho đến khi người dùng cần. Người dùng của bạn không cần phải tải xuống toàn bộ ứng dụng của bạn khi tất cả những gì họ cần là một phần của
											nó. Nếu người dùng đang tạo một bài đăng mới, việc họ tải xuống tất cả mã cho tuyến đường / đăng ký là không hợp lý. Nếu người dùng đang đăng ký, họ không cần trình soạn thảo văn bản
											đa dạng thức khổng lồ mà ứng dụng của bạn cần trên lộ trình / settings. Điều đó thật lãng phí và một số người sẽ cho rằng không tôn trọng những người dùng không có đặc quyền về băng
											thông không giới hạn. Code Splitting không chỉ trở nên phổ biến hơn trong những năm gần đây mà còn trở nên dễ dàng hơn theo cấp số nhân.
											- Đây là cách nó hoạt động. Thay vì coi nhập như một từ khóa như bạn thường làm, bạn sử dụng nó giống như một hàm trả về Lời hứa. Lời hứa này sẽ giải quyết với mô-đun sau khi mô-đun
											được tải hoàn toàn.
											- Điều đặc biệt về LazyHomeComponent là React sẽ không tải nó cho đến khi nó cần, khi nó được kết xuất. Điều đó có nghĩa là, nếu chúng ta kết hợp React.lazy với React Router, chúng
											ta có thể tạm dừng việc tải bất kỳ thành phần nào cho đến khi người dùng truy cập vào một đường dẫn nhất định.
											
											if (editingPost === true) {
											  import(<./editpost<)
												.then((module) => module.showEditor())
												.catch((e) => )
											}
											
											if (editingPost === true) {
											  import(<./editpost<)
												.then((module) => module.showEditor())
												.catch((e) => )
											}
											
											import * as React from "react";
											import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
											import Loading from "./Loading";
											const Home = React.lazy(() => import("./Home"));
											const Topics = React.lazy(() => import("./Topics"));
											const Settings = React.lazy(() => import("./Settings"));
											export default function App() {
											  return (
												<Router>
												  <div>
													<ul>
													  <li>
														<Link to="/">Home</Link>
													  </li>
													  <li>
														<Link to="/topics">Topics</Link>
													  </li>
													  <li>
														<Link to="/settings">Settings</Link>
													  </li>
													</ul>
													<hr />
													<React.Suspense fallback={<Loading />}>
													  <Routes>
														<Route path="/" element={<Home />} />
														<Route path="/topics" element={<Topics />} />
														<Route path="/settings" element={<Settings />} />
													  </Routes>
													</React.Suspense>
												  </div>
												</Router>
											  );
											}
	Protected Routes--React Router:
											- Thông thường, khi xây dựng một ứng dụng web, bạn sẽ cần phải bảo vệ các tuyến đường nhất định trong ứng dụng của mình khỏi những người dùng không có xác thực thích hợp.
											- Hãy để tôi đề xuất API cuối cùng có thể trông như thế nào, trước khi chúng ta đi sâu vào triển khai. Điều gì sẽ xảy ra nếu, đối với mọi tuyến đường chúng ta muốn ở chế độ riêng tư,
											thay vì cung cấp cho phần tử Routes của chúng tôi hỗ trợ thành phần mà chúng tôi muốn nó hiển thị trực tiếp, chúng tôi bọc nó bên trong một thành phần mới mà chúng tôi sẽ gọi là
											RequestAuth.
											- Tại thời điểm này, chúng ta biết hai điều chính về RequiAuth. Đầu tiên, nó chỉ có api là một phần tử con. Thứ hai, nếu người dùng được xác thực, nó sẽ hiển thị phần tử con đó, nếu
											không, nó sẽ chuyển hướng người dùng đến một trang mà họ có thể xác thực (trong trường hợp của chúng tôi là / login).
											- Giả sử bạn có thể nhận được trạng thái xác thực của người dùng của mình từ móc useAuth tùy chỉnh, thì RequestAuth trở nên khá đơn giản.
											- Lưu ý vì chúng tôi nhận được vị trí ban đầu mà người dùng đang cố gắng truy cập thông qua hook useLocation và chuyển vị trí đó làm điểm tựa trạng thái khi chúng tôi chuyển hướng họ
											đến / đăng nhập, sau khi họ xác thực, chúng tôi có thể chuyển hướng họ trở lại đường dẫn ban đầu này.
											
											<Routes>
											  <Route path="/" element={<Home />} />
											  <Route path="/pricing" element={<Pricing />} />
											  <Route
												path="/dashboard"
												element={
												  <RequireAuth>
													<Dashboard />
												  </RequireAuth>
												}
											  />
											  <Route
												path="/settings"
												element={
												  <RequireAuth>
													<Settings />
												  </RequireAuth>
												}
											  />
											  <Route path="/login" element={<Login />} />
											</Routes>
											
											function RequireAuth({ children }) {
											  const { authed } = useAuth();
											  const location = useLocation();
											  return authed === true ? (
												children
											  ) : (
												<Navigate to="/login" replace state={{ path: location.pathname }} />
											  );
											}
											
											// In the Login component
											const handleLogin = () => {
											  login().then(() => {
												navigate(state?.path || "/dashboard");
											  });
											};
	Route Config--React Router:
											- React Router v6 đi kèm với useRoutes Hook giúp việc sắp xếp các tuyến của bạn thành một cấu hình tuyến trung tâm không chỉ khả thi mà còn đơn giản với API lớp đầu tiên.
											- Bây giờ với useRoutes, thay vì khai báo các tuyến đường của bạn bằng cách sử dụng các phần tử React (JSX), bạn có thể thực hiện việc đó bằng cách sử dụng các đối tượng JavaScript.
											- useRoutes nhận một mảng các đối tượng JavaScript đại diện cho các tuyến đường trong ứng dụng của bạn. Tương tự như API phần tử React với mỗi tuyến có một đường dẫn, phần tử và
											thuộc tính con tùy chọn.
											- Điều khiến useRoutes trở nên thú vị hơn là cách React Router sử dụng nó trong nội bộ. Trên thực tế, khi bạn sử dụng API phần tử React để tạo các tuyến đường của mình, nó thực sự
											chỉ là một trình bao bọc xung quanh useRoutes.
											
											Thông thường, nếu bạn muốn ánh xạ các đường dẫn đó đến các thành phần React khác nhau, bạn sẽ hiển thị một cái gì đó như thế này.
											return (
											  <Routes>
												<Route path="/" element={<Home />} />
												<Route path="/invoices" element={<Invoices />}>
												  <Route path=":id" element={<Invoice />} />
												  <Route path="pending" element={<Pending />} />
												  <Route path="complete" element={<Complete />} />
												</Route>
												<Route path="/users/*" element={<Users />} />
											  </Routes>
											);
											
											import { useRoutes } from "react-router-dom";
											const routes = useRoutes([
											  { path: "/", element: <Home /> },
											  {
												path: "/invoices",
												element: <Invoices />,
												children: [
												  { path: ":id", element: <Invoice /> },
												  { path: "/pending", element: <Pending /> },
												  { path: "/complete", element: <Complete /> },
												],
											  },
											  {
												path: "/users",
												element: <Users />,
												children: [
												  { path: ":id", element: <Profile /> },
												  { path: "/settings", element: <Settings /> },
												],
											  },
											]);
											export default function App() {
											  return (
												<div>
												  <Navbar />
												  {routes}
												</div>
											  );
											}
	Server Rendering--React Router:
											Nếu kết xuất máy chủ là một khái niệm mới đối với bạn, điều quan trọng là phải nắm được bức tranh toàn cảnh về cách tất cả các phần của kết xuất máy chủ khớp với nhau trước khi đi
											sâu vào chi tiết.
													Người dùng nhập URL của bạn vào trình duyệt web của họ và nhấn enter
													Máy chủ của bạn thấy có một yêu cầu GET
													Máy chủ kết xuất ứng dụng React của bạn thành một chuỗi HTML, bao bọc nó bên trong tài liệu HTML chuẩn (DOCTYPE và tất cả) và gửi lại toàn bộ nội dung dưới dạng phản hồi
											Trình duyệt thấy rằng nó có một tài liệu HTML trở lại từ máy chủ và công cụ kết xuất của nó sẽ hoạt động để hiển thị trang
											Sau khi hoàn tất, trang có thể xem được và trình duyệt bắt đầu tải xuống bất kỳ
											
Redux Toolkit---:

											- Redux là một thư viện quản lý trạng thái (state management) tương thích với các ứng dụng web, phổ biến trong việc phát triển ứng dụng front-end sử dụng JavaScript và ReactJS.
											- Đây là một công cụ hữu ích giúp bạn xây dựng các ứng dụng có tính nhất quán, hoạt động linh hoạt trên nhiều môi trường (client, server và native), và dễ dàng kiểm thử. Sáng tạo từ
											ngôn ngữ Elm và kiến trúc Flux của Facebook, Redux thường được kết hợp sử dụng cùng với React.
											- Redux có nhiệm vụ quản lý trạng thái phức tạp trong ứng dụng web, giúp tách biệt logic và giao diện người dùng. Với tiếp cận dễ hiểu và theo dõi, Redux giúp bạn theo dõi và cập
											nhật trạng thái một cách hiệu quả, đồng thời đảm bảo tính nhất quán cho dữ liệu trong ứng dụng, từ đó dễ dàng debug khi gặp lỗi.
											- Redux Toolkit là thư viện được phát triển bởi ReduxJS, giúp viết mã Redux nhanh chóng, toàn diện và tuân thủ chuẩn mực. Nó giải quyết vấn đề phức tạp của Redux và cung cấp API
											tiện ích để viết mã ngắn gọn, dễ đọc hơn và tuân theo các mẫu thiết kế tốt nhất.
											- Một số lập trình viên cảm thấy Redux hơi dài dòng và khó sử dụng. Tạo một store hoàn chỉnh đòi hỏi nhiều bước và tạo nhiều tệp lặp đi lặp lại. Redux Toolkit được ra đời, nhằm
											tối giản hoá cách setup và sử dụng, giúp lập trình viên có thể tập trung hơn vào việc xử lý logic thay vì mất quá nhiều thời gian ban đầu để set-up.											
	
	Cách cài đặt Redux toolkit--Redux Toolkit:
	
											Sử dụng npm hoặc yarn để cài đặt Redux Toolkit:
											
											npm install @reduxjs/toolkit
											
											yarn add @reduxjs/toolkit
											
	Luồng xử lý của Redux như sau--Redux Toolkit:
	
		Trường hợp không sử dụng Middleware:
		
											-> State được khởi tạo bên trong Store
											-> State được đưa vào Reducer
											-> Reducer khởi tạo giá trị state ban đầu (initialState)
											-> Thực hiện action ở component (dispatch event)
											-> Thay đổi giá trị của state bên trong Reducer thành state mới
											-> Đẩy state mới ra ngoài View (component)
	
		Trường hợp sử dụng Middleware:
		
											-> State được khởi tạo bên trong Store
											-> State được đưa vào Reducer
											-> Reducer khởi tạo giá trị state ban đầu (initialState)
											-> Thực hiện action ở component (dispatch event)
											-> Gọi API ở Middleware
											-> Đưa dữ liệu vừa gọi vào Reducer
											-> Thay đổi giá trị của state bên trong Reducer thành state mới
											-> Đẩy state mới ra ngoài View (component).
	
	Store--Redux Toolkit:
		
					- Các bạn hình dung Redux Store như 1 nơi lưu global state mà tất cả các Component trong phạm vi của Store đều có thể truy xuất để lấy dữ liệu hoặc cập nhật dữ liệu. Giao diện của các
					Component đó cũng sẽ được tự động cập nhật khi state thay đổi.
					- Trong Redux, trạng thái state của application được quản lý bởi một đối tượng gọi là store.
					- Với các dự án lớn thì trong Store có thể chia ra nhiều Slice (nhóm các state theo chức năng)
					- Khai báo phạm vi sử dụng Store, dùng cho toàn bộ website nên sẽ khai báo ở file index.js
					- Store là nơi Redux dùng để lưu toàn bộ state của ứng dụng. Nó giống như một cái nhà kho vậy, khi một component có nhu cầu sử dụng state nào đấy chỉ cần vào trong store để lấy ra.
					
					import React from "react";
					import ReactDOM from "react-dom";
					import { Provider } from "react-redux";
					import { store } from "./store/index";
					import App from "./App";									
					ReactDOM.render(
					  <Provider store={store}>
						<App /> // Bọc App component vào trong Store Provider để App và toàn bộ Component con đều có thể truy xuất đến Store
					  </Provider>,
					  document.getElementById("root")
					);
					
					// store/index.js
					import { configureStore } from "@reduxjs/toolkit";
					import userReducer from "./userSlice";
					export const store = configureStore({
					  reducer: {
						user: userReducer  // Khai báo 1 slice tên là user với giá trị là userReducer được export ở file userSlice
						// Có thể khai báo nhiều slice khác tương tự
					  }
					});
					
					// store/userSlice.js
					import { createSlice } from "@reduxjs/toolkit";										
					const initialState = { // Khởi tạo state cho slice, có thể kèm giá trị mặc định ban đầu
					  username: "Guest"  // State username với giá trị mặc định là "Guest"
					  // Có thể khai báo nhiều state khác nữa
					};										
					export const userSlice = createSlice({ // Cấu hình slice
					  name: "user",  // Tên của slice, mỗi slice đặt 1 tên khác nhau để phân biệt
					  initialState,
					  // Reducers chứa các hàm xử lý cập nhật state
					  reducers: {
						updateUsername: () => {},
					  }
					});										
					export const { updateUsername } = userSlice.actions; // Export action ra để sử dụng cho tiện.
																		 // Action là 1 hàm trả về object dạng {type, payload}, chạy thử console.log(updateUsername()) để xem chi tiết
					
					
					export const selectUsername = state => state.user.username; // Hàm giúp lấy ra state mong muốn.
																				// Hàm này có 1 tham số là root state là toàn bộ state trong store, chạy thử console.log(state) trong nội dung hàm để
																				// xem chi tiết										
					export default userSlice.reducer; // Export reducer để nhúng vào Store
											
	Tương tác với Redux Store--Redux Toolkit:

											- Để cập nhật state trong Store thì chúng ta cần dispatch action tương ứng được khai báo trong phần reducers của slice.
											- Chú ý là khi cập nhật state chúng ta có thể thay đổi trực tiếp state chứ không như khi dùng local state trong Component, đó là do Redux Toolkit sử dụng thêm thư viện immer. Và ở
											trong các reducer này chúng ta chỉ viết code sync chứ không viết code async.
											- Để hiển thị giá trị state ta dùng useSelector
											- Hàm useSelector cần truyền vào 1 hàm callback có tham số là root state và trả về state cần lấy
											- Hook useSelector được sử dụng để trích xuất dữ liệu từ Redux store và hook useDispatch được sử dụng để gửi action đến store.
											
											import React from "react";
											import { Link } from "react-router-dom";
											import { useSelector } from "react-redux";
											import { selectUsername } from "../store/userSlice";
											export default function Dashboard() {										  
											  const username = useSelector(selectUsername); // Lấy ra state username từ store
											  return (
												<>
												  <h1>Dashboard</h2>
												  {/* In biến username ra màn hình */}
												  <h2>Welcome {username}</h2>
												  <Link to="/login">Log out</Link>
												</>
											  );
											}
											
	Reducer trên Redux là gì?--Redux Toolkit
	
											Là các hàm xử lý các hành động cụ thể và thay đổi state của ứng dụng. Reducer nhận vào giá trị của state hiện tại và hành động bạn muốn thực hiện, rồi trả ra state mới dựa trên
											hành động đó.
											
	Action trên Redux là gì?--Redux Toolkit
	
											Là hành động mà bạn muốn thực hiện với state đó. Ví dụ đơn giản nhất là việc thay đổi giá trị của state.
	
	Tại sao lập trình viên nên dùng Redux?--Redux Toolkit
	
											- Khi ứng dụng web Frontend của chúng ta ngày càng lớn, có thêm nhiều component hơn, đồng nghĩa với việc sẽ sinh ra nhiều state. Có những state chúng ta sử dụng trong phạm vi
											component hiện tại, nhưng sẽ có những state ta sẽ sử dụng ở nhiều component khác nhau, và các component mà ta sử dụng nằm rải rác trong source code của chúng ta.
											- Việc truyền state thông qua props theo cách truyền thống từ cha xuống con sẽ không còn hiệu quả nếu như 2 component cần sử dụng chung 1 state nằm quá xa nhau.
	
	Hướng dẫn truy cập state userDetail trên Redux--Redux Toolkit:
	
		Call API ở những nơi cần sử dụng:

											- Cách đầu tiên là làm tương tự như ở file Header.jsx, đấy là component nào cần sử dụng userDetail thì ta call api ở component đấy. Đây là cách nhanh và đơn giản nhất nhưng nó lại có
											vài vấn đề. Đó là nó làm api bị call nhiều lần.
											- Bạn thử tưởng tượng Header nằm trong trang Admin, khi 2 component này được render, nó sẽ call đến api kia một lần, và mỗi khi 1 trong 2 component này re-render, nó sẽ lại call tiếp.
											- Việc này ảnh hưởng rất lớn đến performance của website, khiến website của chúng ta chậm đi đáng kể. Nên đây không phải là cách chúng ta nên làm đúng không?
											
		Lưu dữ liệu call từ api xuống localStorage:
		
											- Cách thứ hai có thể nghĩ đến là lưu dữ liệu call từ api xuống localStorage, component nào cần dùng thì gọi ra để sử dụng là xong.
											- Cách này sẽ giải quyết được vấn đề của cách đầu tiên, là api sẽ không bị gọi đi gọi lại nhiều lần không cần thiết, nhưng nó lại sinh ra 2 vấn đề:
													Một là làm website của chúng ta chậm lại vì việc format dữ liệu từ localStorage, ta phải sử dụng đến hàm stringify và parse để xử lý dữ liệu khi lưu xuống và lấy ra
													từ localStorage.
													Hai là dữ liệu từ localStorage sẽ không tự đồng bộ ở tất cả component khi giá trị của state đó bị thay đổi.
													
		Từ những vấn đề trên mà state management như Redux ra đời, Redux đã khắc phục được toàn bộ nhược điểm bên trên, giúp quản lý state hiệu quả hơn rất nhiều.
		
		Redux hoạt động như thế nào?
		
											- Redux sẽ đưa tất cả các state vào một kho lưu trữ chung gọi là Store, khi component nào đó muốn sử dụng state có trong Store thì sẽ gọi vào Store thông qua Reducer. Và để thực
											hiện hành động đối với các state này thì chúng ta sẽ tạo ra các Action.
	
	Lưu ý khi sử dụng Redux--Redux Toolkit:										
											- Giá trị lưu trong Redux về bản chất vẫn là state nên nó thừa hưởng mọi tính chất của state, chỉ khác ở chỗ nó là global state (state toàn cục) nên khi giá trị lưu trong Redux
											thay đổi thì tất cả component đang sử dụng giá trị đó cũng sẽ thay đổi theo.
											- Chuẩn hoá dữ liệu (Normalized State) trước khi lưu chúng vào Redux để đảm bảo hiệu suất của ứng dụng đạt ở mức cao.
											- Nên thực hiện việc xử lý logic ở các hàm bên ngoài, hạn chế xử lý logic phức tạp bên trong Redux, Redux chỉ nên sử dụng để lưu dữ liệu cuối cùng sau khi đã qua xử lý.
											
	Nên sử dụng Redux trong trường hợp nào?--Redux Toolkit
	
											- Vì việc sử dụng Redux không đúng cách có thể làm ứng dụng của bạn chậm đi đáng kể, ảnh hưởng đến performance. Với những ứng dụng web nhỏ bạn có thể sử dụng state nội bộ hoặc các
											state management gọn nhẹ hơn như ContextAPI, Recoil,...
											- Quản lý nhiều state phức tạp: Khi ứng dụng web của bạn cần quản lý nhiều state phức tạp và chúng cần tương tác với nhau, việc sử dụng Redux sẽ giúp bạn quản lý các state dễ dàng hơn
											- State cần chia sẻ global: Khi nhiều component cần sử dụng chung 1 state, việc sử dụng Redux sẽ giúp các component truy cập dễ dàng hơn so với việc sử dụng props
											- Lưu lại lịch sử của state và actions: Redux cho phép bạn theo dõi lịch sử của các state và actions, điều này rất hữu ích cho việc debug về sau. Redux còn có extension trên Chrome
											tên là Redux DevTools, giúp chúng ta có thể dễ dàng theo dõi lịch sử thay đổi của state và actions ngay trên trình duyệt.
	
	Ví dụ:
	
		Ví dụ 1:
		
						Tạo một dự án ReactJS mới bằng cách sử dụng create-react-app hoặc bất kỳ công cụ khác để tạo dự án.
										
						Tạo một store Redux trong ứng dụng của bạn bằng cách sử dụng configureStore() từ Redux Toolkit:

							import { configureStore } from '@reduxjs/toolkit';
							const store = configureStore({
							  reducer: {
								// Đây là nơi bạn định nghĩa các reducer của bạn.
								// Ví dụ: todoReducer: todoReducer
							  }
							});
											
						Kết nối ứng dụng của bạn với store Redux bằng cách sử dụng provider của React-Redux:

							import <a href="https://nodemy.vn/thu-vien-carousel-duoc-su-dung-de-tao-cac-slideshow-react/">React</a> from 'react';
							import ReactDOM from 'react-dom';
							import { Provider } from 'react-redux';
							import store from './store'; // Import store từ bước 3
							ReactDOM.render(
							  <Provider store={store}>
								<App />
							  </Provider>,
							  document.getElementById('root')
							);
											
						Tạo reducers và actions bằng cách sử dụng các util của Redux Toolkit như createSlice, createAsyncThunk,… Ví dụ:

							import { createSlice } from '@reduxjs/toolkit';
							const todoSlice = createSlice({
							  name: 'todos',
							  initialState: [],
							  reducers: {
								addTodo: (state, action) => {
								  state.push(action.payload);
								},
								removeTodo: (state, action) => {
								  return state.filter((<a href="https://nodemy.vn/tao-ung-dung-todo-voi-usestate-trong-react-hook/">todo</a>) => todo.id !== action.payload);
								},
							  },
							});
							export const { addTodo, removeTodo } = todoSlice.actions;
							export default todoSlice.reducer;
																						
	Phân chia ứng dụng thành nhiều component--ReactJS Class Component:
															ReactJS khuyến khích việc phân chia ứng dụng thành nhiều component nhỏ thay vì viết tất cả mã nguồn trong một file lớn.
		Tính Tái Sử Dụng (Reusability):
															Bằng cách phân chia ứng dụng thành các component nhỏ, bạn có thể tái sử dụng chúng trong nhiều phần của ứng dụng hoặc trong các ứng dụng khác mà không cần phải viết
															lại mã nguồn. Điều này giúp giảm thời gian phát triển và bảo trì mã nguồn.
		Tính Tích Cực (Modularity):
															Phân chia ứng dụng thành các component nhỏ giúp làm cho mã nguồn trở nên dễ đọc và dễ hiểu hơn. Mỗi component chịu trách nhiệm cho một phần nhất định của giao diện
															người dùng, làm cho việc theo dõi và hiểu cấu trúc của ứng dụng dễ dàng hơn.
		Tính Linh Hoạt (Flexibility):
															Sử dụng các component cho phép bạn tạo ra các thành phần có thể tái sử dụng và có thể tái sử dụng mã nguồn dễ dàng. Điều này làm cho việc thay đổi hoặc mở rộng các
															phần của ứng dụng trở nên dễ dàng hơn mà không cần phải ảnh hưởng đến các phần khác.
		Quản lý Trạng Thái (State Management):
															ReactJS sử dụng mô hình stateful components và stateless components để quản lý trạng thái của ứng dụng. Việc phân chia ứng dụng thành các component nhỏ giúp quản lý
															trạng thái trở nên dễ dàng hơn và giảm thiểu các vấn đề liên quan đến quản lý trạng thái.
		Hiệu Năng (Performance):
															Phân chia ứng dụng thành các component nhỏ có thể giúp cải thiện hiệu năng của ứng dụng bằng cách giảm thiểu số lượng các phần tử DOM cần được cập nhật khi trạng thái
															của ứng dụng thay đổi.

MobX---:

						- Mobx là 1 thư viện Javascript dùng để quản lý state của ứng dụng. Mobx có thể sử dụng được với Javascript thuần và với cả các modern framework như Angular, Vue hay React
						- MobX rất đơn giản, có thể mở rộng (scalable) và là một giải pháp để quản lý trạng thái (state management). MobX là một thư viện độc lập, nhưng hầu hết mọi người sử dụng nó với React
											
	Các khái niệm chính--MobX:
	
						- Mobx là mutable, có nghĩa là chúng ta sẽ thay đổi hoàn toàn trực tiếp, thay vì immutable như Redux. Code của Mobx cực ngắn và dễ hiểu.
						- Các event từ UI sẽ gọi đến những actions (@action) trong store của Mobx.
						- Các actions này sẽ thay đổi trực tiếp (mutate) các observable state (@observable) trong store.
						- Những observable state sau khi thay đổi sẽ được truyền đến các cập nhật lại (@computed) những computed value (những giá trị được tính toàn và trả về bởi method getter).
						- Cuối cùng, các side-effect (như render component) sẽ được trigger để render component với state mới.				
											
	Ý tưởng cốt lõi (The core idea)--MobX:

						- Trạng thái (State) là trái tim của mỗi ứng dụng và ở đây không có con đường nào tạo ra nhiều lỗi, không thể quản lý ứng dụng nhanh hơn việc tạo ra một trạng thái không nhất quán (inconsistent state)
						hoặc một state không đồng bộ với các biến cục bộ xung quanh. Do đó có nhiều giải pháp quản lý state bằng cách cố gắng hạn chế các cách mà bạn có thể sửa đổi state, ví dụ như làm state bất biến
						(state immutable). Nhưng các cách này lại phát sinh vấn đề mới, dữ liệu cần được chuẩn hóa, tính toàn vẹn tham chiếu có thể không còn được đảm bảo và nó không thể sử dụng các khái niệm mạnh mẽ
						như prototype.
						- MobX có thể làm state management trở nên đơn giản bởi giải quyết vấn đề cốt lõi: không thể tạo ra trạng thái không nhất quán. Để làm được điều này thật đơn giản: đảm bảo mọi thứ có thể được dẫn xuất
						từ trạng thái ứng dụng một cách tự động.
											
	MobX xử lý ứng dụng của bạn như sau--MobX:

						- Đầu tiên, ở đây là Application State. Nhóm các Objects, array, primitives, tham chiếu tới các model của ứng dụng. Những giá trị này được coi như những "ô dữ liệu" (data cell) của ứng dụng.
						- Kế tiếp là Phái sinh (Derivations). Đơn giản nhất, các giá trị được tính toán tự động từ application state. Những phái sinh (được sinh ra từ cùng một nguyên mẫu). Các bạn có thể hiểu là MobX lưu
						giữ giá trị gốc, và giá trị mình lấy ra hiển thị là giá trị sao chép từ giá trị gốc đó.
						- Phản ứng ( Reactions) cũng tương tự như phái sinh. Điểm khác nhau của những hàm này là chúng không tạo ra giá trị. Thay vào đó, chúng có thể tự động thực thi vài tác vụ. Thường là liên quan tới I/O.
						Chúng đảm bảo DOM luôn được cập nhật hoặc thực hiện các request đúng thời điểm.
						- Cuối cùng là hành động (Actions). Hành động là cách duy nhất để thay đổi state. MobX muốn đảm bảo tất cả sự thay đổi của ứng dụng được gây ra bởi hành động được tự động xử lý bởi Derivations và
						Reactions. Bất đồng bộ và không có vấn đề gì. Ví dụ xây dựng một lớp lưu giữ ghi chú đơn giản. Để rõ ràng hơn về khái niệm cơ bản của MobX ta bắt đầu với một lớp lưu giữ ghi chú cơ bản.
																		
	Quản lý state trong React bằng MobX--MobX:
	
		Observable--Quản lý state MobX:
		
						- Giá trị observable có thể là primitives values (number, string, boolean, null, undefined), reference values (array, objects, function), plain object, class instance, ES6 Map, Set,… Nó là những giá trị
						mà component sẽ quan sát để biết có nên re-render hay không?
						- Đây là một decorator được sử dụng để đánh dấu các thuộc tính của một đối tượng là "observable", có nghĩa là bất kỳ thay đổi nào trong giá trị của thuộc tính này cũng sẽ kích hoạt các cập nhật tương ứng
						trong giao diện người dùng.
						
						// Có hai cách viết như sau
						// Theo dõi 1 mảng
						const list = observable([1,2,3,4])
						list[2] = 5
						// Thay đổi 1 property của object
						class Todo {
						  @observable title = 'Mua banh mi';
						}
						const TODO = new Todo();
						TODO.title = 'Da mua banh mi';
						// Hoặc là
						const person = observable({
							firstName: "Clive Staples",
							lastName: "Lewis",
						})
						person.firstName = "C.S."
						
		Observer--Quản lý state MobX:
		
						- Trong MobX, khi một observable thay đổi, tất cả các components được đánh dấu là @observer mà sử dụng giá trị của observable đó sẽ tự động render lại để phản ánh các thay đổi. Điều này cho phép bạn
						đảm bảo rằng tất cả các thành phần của ứng dụng sẽ được cập nhật một cách đồng bộ khi trạng thái thay đổi.
						- Đây là một decorator được sử dụng để theo dõi các thay đổi trong trạng thái của một component React. Khi một component được đánh dấu bằng @observer, nó sẽ tự động render lại khi các giá trị trạng thái
						được theo dõi thay đổi. Điều này giúp đảm bảo rằng giao diện người dùng sẽ được cập nhật một cách tự động mỗi khi trạng thái thay đổi.
						- Tránh sử dụng quá nhiều observer không cần thiết, và tập trung vào việc chỉ sử dụng observer cho các components cần theo dõi trực tiếp các observable cụ thể.
						
						import { observable } from 'mobx'
						import { Observer, useObserver, observer } from 'mobx-react' // 6.x or mobx-react-lite@1.4.0
						import ReactDOM from 'react-dom'
						// tạo một dữ liệu observable
						const person = observable({
						  name: 'John',
						})						
						const P1 = observer(function P1({ person }) { // observer HOC: Observer cả function component
						  return <h1>{person.name}</h1>
						})				
						const P2 = ({ person }) => ( // observer component: chỉ observer cho component con nằm bên trong
						  <>
							<p>{person.name} dont want to change my name</p> // sẽ không thay đổi vì không được observer
							<Observer>{() => <h1>{person.name} will change to new name</h1>}</Observer> // thay đổi
						  </>
						)					
						const P3 = ({ person }) => {
						  return useObserver(() => <h1>{person.name}</h1>) // useObserver hook - trả về một component mới được observer
						}
						const DetailPerson = () => (
						  <>
							<P1 person={person} />
							<P2 person={person} />
							<P3 person={person} />
						  </>
						)
						// Sau 3 giây chúng ta sẽ thay đổi dữ liệu của person
						setTimeout(() => {
						  person.name = 'Jane'
						}, 1000)
						
		Cấu trúc của mobx nên viết trong react--Quản lý state MobX:
		
						Theo như mobx team khuyên dùng chúng ta nên sử dụng react context để truyền store. Chúng ta nên viết một file riêng chứa toàn bộ dữ liệu observable (mình sẽ gọi là
						store.ts), trong file này mình sẽ định nghĩa một rootStore (sẽ truyền cái này qua component Provider) và một hàm useStore (sẽ trả về store). Component nào cần dùng
						store mình sẽ import useStore vào. Để hiểu chi tiết hơn các bạn xem ví dụ bên dưới

						// store.ts
						import { createContext, useContext } from "react";
						import { observable, action } from 'mobx';
						class Todo {
						  @observable title = 'Mua banh mi';
						  @action // chỉ có action mới có thể modify observable state
						  changeTitle = () => {
							this.title = 'Da mua banh my'
						  }
						  // changeTitle có thể viết lại như sau
						  //  @action.bound
						  //  changeTitle() {
						  //    this.title = 'Da mua banh my'
						  //  }
						}
						export const rootStore = {
						  todoStore: new Todo()
						};
						export type TRootStore = typeof rootStore;
						const RootStoreContext = createContext<null | TRootStore>(null);
						// Tạo ra provider để cung cấp store cho toàn bộ app
						// dung trong file index.tsx
						export const Provider = RootStoreContext.Provider;
						/** tra lai store, chi dung o function component */
						export function useStore() {
						  /** store này sẽ chứa toàn bộ data */
						  const store = useContext(RootStoreContext);
						  if (store === null) {
							throw new Error("Store cannot be null, please add a context provider");
						  }
						  return store;
						}
						// index.tsx
						import * as React from "react";
						import { render } from "react-dom";
						import { Provider, rootStore } from "./store";

						const rootElement = document.getElementById("root");
						/** Truyen store vao thong qua provider */
						render(
						  <Provider value={rootStore}>
							<App />
						  </Provider>,
						  rootElement
						);
						// Todo.tsx
						import { observer } from 'mobx'
						import { Observer, useObserver, observer } from 'mobx-react-lite'
						import ReactDOM from 'react-dom'
						import React from 'react'
						// import store
						import { useStore } from './store';
						export const Todo = observer(() => {
						  const { todoStore } = useStore();
						  return (
							<>
							  <p>title: {todoStore.title}</p>
							  <button onClick={todoStore.changeTitle}>Click to change title</button>
							</>
						  )
						});
															
		computed--Quản lý state MobX:
		
						Giá trị sẽ được tính toán lại mỗi khi observable value thay đổi
		
						import { observable, computed } from "mobx"
						class OrderLine {
							@observable price = 0
							@observable amount = 1
							constructor(price) {
							  this.price = price
							}
							// Giá trị này sẽ được tính toán và trả về mỗi khi 2 giá trị observable ở trên bị thay đổi
							@computed get total() {
							  return this.price * this.amount
							}
						}
						OrderLine.price = 12;
						console.log(OrderLine.total) // 12
						
		toJS--Quản lý state MobX:
		
						- Recursively converts an observable object to a JavaScript object. Supports observable arrays, objects, Maps and primitives.
						- It does NOT recurse into non-observables, these are left as they are, even if they contain observables. Computed and other non-enumerable properties are completely ignored and won't be returned.
						- For more complex (de)serialization scenarios, it is recommended to give classes a (computed) toJSON method, or use a serialization library like serializr.
						- toJS là một hàm được sử dụng để chuyển đổi các đối tượng observable, arrays, và maps sang các đối tượng JavaScript thông thường. Điều này đặc biệt hữu ích khi bạn cần làm việc với các thư viện
						hoặc API bên ngoài không biết cách xử lý các đối tượng observable của MobX.
						
						const obj = mobx.observable({
							x: 1
						})
						const clone = mobx.toJS(obj)
						console.log(mobx.isObservableObject(obj)) // true
						console.log(mobx.isObservableObject(clone)) // false
						
		autorun--Quản lý state MobX:
		
						- Thường dùng cho việc log thông tin
						- Cũng giống như computed cũng sẽ chạy khi observable thay đổi, tuy nhiên autorun không trả về giá trị mới autorun trả về một disposer function, hàm này có vai trò
						huỷ bỏ autorun. Tham số thứ nhất mà autorun trả về một biến dùng để debug
						
						import { observable, computed, autorun } from "mobx"
						class OrderLine {
							@observable price = 0
							@observable amount = 1
							constructor(price) {
								this.price = price;
								autorun((reaction) => {
								  console.log(this.total)
								  if (this.total > 10) {
									reaction.dispose(); // dừng log lại nếu total > 10
								  }
								})
							}
							// Giá trị này sẽ được tính toán và trả về mỗi khi 2 giá trị observable ở trên bị thay đổi
							@computed get total() {
							  return this.price * this.amount
							}
						}
						OrderLine.price = 9; // log ra 9
						OrderLine.price = 11; // log ra 11 sau đó bị huỷ bỏ
						OrderLine.price = 12: // ngưng log vì đã bị huỷ bỏ
															
		when--Quản lý state MobX:
		
						- Xảy ra với điều kiện nào
						- Đôi lúc các bạn sẽ muốn biết khi nào dữ liệu đấy thay đổi và sẽ thay đổi khi nó phù hợp với điều kiện nào
						
						import { observable, computed, when } from "mobx"
						class OrderLine {
							@observable price = 0
							@observable amount = 1
							constructor(price) {
							  this.price = price;
							  // chỉ chạy một lần
							  // Khi this.total lớn hơn 10 thì gán lại this.total = 0
							  when(() => this.total > 10, () => (this.total = 0));
							}
							// Giá trị này sẽ được tính toán và trả về mỗi khi 2 giá trị observable ở trên bị thay đổi
							@computed get total() {
							  return this.price * this.amount
							}
						}
						OrderLine.price = 11;
						console.log(OrderLine.total) // 0
															
		reaction--Quản lý state MobX:
		
						- Một phiên bản nâng cấp so với autorun															
						- function thứ nhất (data function) là function đóng vai trò là dữ liệu được theo dõi, dữ liệu trả lại sẽ là đầu vào cho function thứ hai
						- function thứ hai (effect function) có hai tham số được trả về, tham số thứ nhất là dữ liệu từ function thứ nhất, tham số thứ hai là reaction (vai trò như trong autorun)
						
						import { observable, computed, reaction } from "mobx"
						class Todo {
							@observable todos = [
							  {
								  title: "Make coffee",
								  done: true,
							  },
							  {
								  title: "Find biscuit",
								  done: false,
							  },
							]
							constructor(price) {
							  // reaction 1
							  // Cách sửa dụng reaction sai: nó chỉ theo dõi dộ dài của array todos
							  reaction(
								() => todos.length,
								(length) => console.log("reaction 1:", todos.map((todo) => todo.title).join(", "))
							  )
							  // reaction 2
							  // Cách sửa dụng đúng: nó sẽ theo dõi cả độ dài và khi titles thay đổi
							  reaction(
								() => todos.map((todo) => todo.title),
								(titles) => console.log("reaction 2:", titles.join(", "))
							  )
							}
						}
						Todo.todos.push({ title: "explain reactions", done: false })
						// prints:
						// reaction 1: Make coffee, find biscuit, explain reactions
						// reaction 2: Make coffee, find biscuit, explain reactions
						Todo.todos[0].title = "Make tea"
						// prints:
						// reaction 2: Make tea, find biscuit, explain reactions
															
		useLocalStore - giải pháp thay thế useState hook--Quản lý state MobX:
		
						Chúng ta hãy tưởng tượng có 10 state lại phải có 10 function đóng vai trò setState đi cùng. Thật là nhiều phải không? Tuy nhiên, nếu chúng ta dùng useLocalStore, một
						function built-in nằm trong mobx-react thì không cần như thế nữa. Khi dùng function này chúng ta sẽ có một local store cỡ nhỏ. Việc thay đổi nó sẽ dựa vào việc mutate
						trực tiếp		

						import React from "react";
						import { useLocalStore, observer } from "mobx-react";
						export const CounterWithLocalStore = observer(() => {
						  // Khai báo một store
						  const store = useLocalStore(() => ({
							count: 0,
							increase: () => (store.count += 1), // việc thay đổi sẽ được mutate trực tiếp
							decrease: () => (store.count -= 1),
							reset: () => (store.count = 0)
						  }));
						  const { count, increase, decrease, reset } = store;
						  return (
							<>
							  <p>Count (with local store): {count}</p>
							  <button onClick={increase}>Increase +</button>
							  <button onClick={decrease}>Decrease -</button>
							  <button onClick={reset}>Reset</button>
							</>
						  );
						});
						
		@inject--Quản lý state MobX:
		
						- @inject là một decorator được sử dụng để tiêm các dependencies vào các React components. Nó thường được sử dụng cùng với @observer để tự động cập nhật các components khi dữ liệu được thay đổi.
						
						- Cụ thể, @inject làm những việc sau:
						
							Tiêm Store vào Component:
							
								@inject cho phép bạn tiêm các stores được định nghĩa trong MobX vào một component cụ thể. Điều này giúp component có thể truy cập và sử dụng các dữ liệu và hành vi từ store mà không cần
								phải truyền chúng qua props từ các component cha.
								
							Kết nối Component với Store:
							
								@inject giúp kết nối component với store, cho phép component tự động nhận các thay đổi từ store và cập nhật giao diện người dùng tương ứng.
								
							Tổ chức và Quản lý State:
							
								Sử dụng @inject, bạn có thể tổ chức và quản lý state của ứng dụng một cách rõ ràng và hợp lý hơn bằng cách chia state thành các stores và tiêm chúng vào các components khi cần thiết.
								
						Ví dụ về cách sử dụng @inject trong MobX:
						
							import { observable } from "mobx";
							class UserStore {
							  @observable user = {
								name: "John Doe",
								age: 30
							  };
							}
							const userStore = new UserStore();
							export default userStore;
							
							import React from "react";
							import { inject, observer } from "mobx-react";
							@inject("userStore") // Tiêm userStore vào component này
							@observer // Đánh dấu component này là observer để nó tự động cập nhật khi dữ liệu thay đổi
							class UserProfile extends React.Component {
							  render() {
								const { userStore } = this.props;
								return (
								  <div>
									<h1>{userStore.user.name}</h1>
									<p>Age: {userStore.user.age}</p>
								  </div>
								);
							  }
							}
							export default UserProfile;
							
							- @inject("userStore"): Tiêm userStore vào UserProfile component. Tên của store cần được truyền dưới dạng chuỗi.
							- @observer: Đánh dấu UserProfile là một observer component để nó tự động render lại khi dữ liệu trong userStore thay đổi.
							
							import React from "react";
							import ReactDOM from "react-dom";
							import { Provider } from "mobx-react";
							import userStore from "./stores/UserStore";
							import UserProfile from "./components/UserProfile";
							const stores = {
							  userStore
							};
							ReactDOM.render(
							  <Provider {...stores}>
								<UserProfile />
							  </Provider>,
							  document.getElementById("root")
							);

		extendObservable--Quản lý state MobX:
		
							- extendObservable trong MobX là một hàm được sử dụng để thêm các thuộc tính observable vào một đối tượng hiện có. Điều này hữu ích khi bạn muốn mở rộng một đối tượng với các thuộc tính mới mà cần
							phản ứng lại với sự thay đổi dữ liệu, mà không cần phải định nghĩa lại toàn bộ đối tượng hoặc class từ đầu.
							- extendObservable cho phép bạn thêm các thuộc tính observable vào bất kỳ đối tượng nào một cách linh hoạt. Nó thường được sử dụng khi bạn có một đối tượng ban đầu mà bạn muốn mở rộng với các
							thuộc tính observable mà không thay đổi cấu trúc ban đầu của nó.
							
							import { extendObservable } from "mobx";
							class Person {
							  constructor(name) {
								// Thêm thuộc tính observable ban đầu
								extendObservable(this, {
								  name: name,
								  age: 30
								});
							  }
							}
							// Tạo một đối tượng Person
							const person = new Person("John");
							// Thêm thuộc tính mới một cách linh hoạt
							extendObservable(person, {
							  address: "123 Main St"
							});
							// Sử dụng observable
							console.log(person.name); // "John"
							console.log(person.age); // 30
							console.log(person.address); // "123 Main St"
							

	Ví dụ:
	
		Ví dụ 1:
		
						Trong ví dụ này, @observable được sử dụng để theo dõi trạng thái của thuộc tính todos trong TodoStore, trong khi @observer được sử dụng để theo dõi và tự động render lại component TodoList mỗi khi
						giá trị của todos thay đổi.
		
						import { observable } from "mobx";
						import { observer } from "mobx-react";
						class TodoStore {
						  @observable todos = [];

						  addTodo = (todo) => {
							this.todos.push(todo);
						  };
						}
						const todoStore = new TodoStore();
						@observer
						class TodoList extends React.Component {
						  render() {
							return (
							  <div>
								{todoStore.todos.map((todo, index) => (
								  <div key={index}>{todo}</div>
								))}
							  </div>
							);
						  }
						}
		
		Ví dụ 2:
		
						Trong ví dụ này, todoStore được đánh dấu là observable, cho phép theo dõi và cập nhật các thay đổi trong todos. Hai components TodoList và TodoForm đều được đánh dấu là observer, giúp tự động render
						lại mỗi khi todos thay đổi. TodoForm cho phép người dùng thêm mới các todo vào todoStore bằng cách sử dụng phương thức addTodo từ todoStore.
		
						import React from 'react';
						import { observable } from 'mobx';
						import { observer } from 'mobx-react';
						// Tạo một đối tượng observable
						const todoStore = observable({
						  todos: [],
						  addTodo: function (todo) {
							this.todos.push(todo);
						  },
						});
						// Tạo một component React và sử dụng decorator @observer
						@observer
						class TodoList extends React.Component {
						  render() {
							return (
							  <div>
								<h2>Todo List</h2>
								<ul>
								  {todoStore.todos.map((todo, index) => (
									<li key={index}>{todo}</li>
								  ))}
								</ul>
							  </div>
							);
						  }
						}
						// Component để thêm các todo mới
						@observer
						class TodoForm extends React.Component {
						  handleSubmit = (e) => {
							e.preventDefault();
							const todo = e.target.elements.todo.value;
							todoStore.addTodo(todo);
							e.target.elements.todo.value = '';
						  };
						  render() {
							return (
							  <form onSubmit={this.handleSubmit}>
								<input type="text" name="todo" />
								<button type="submit">Add Todo</button>
							  </form>
							);
						  }
						}
						// Sử dụng TodoList và TodoForm trong một component cha
						class App extends React.Component {
						  render() {
							return (
							  <div>
								<TodoList />
								<TodoForm />
							  </div>
							);
						  }
						}
						export default App;

	Standard--MobX:
	
		Container--Standard MobX:
									/* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/
									import { toJS } from 'mobx';
									import React, { Component } from 'react';
									import { inject, observer } from 'mobx-react';
									import {Checkbox, ContentLayout, dialog, Grid, Header, link, message, Segment} from '@mes/mes-ui-react';
									import { mesAutobind } from '@mes/mes-shared';
									import qs from 'qs';
									import SearchView from '../view/SearchView';
									import ButtonView from '../view/ButtonView';
									import TableView1 from '../view/TableView1';
									import TableView2 from '../view/TableView2';
									import TableView2a2 from '../view/TableView2a2';
									import TableView3 from '../view/TableView3';
									import TableView3a2 from '../view/TableView3a2';
									import { commonUtil } from '../../common/utility';
									@inject('viewRegisterAbnormalMaterialCardStore')
									@mesAutobind
									@observer
									class ViewRegisterAbnormalMaterialCardContainer extends Component {
									  // lifecycle.componentDidMount
									  componentDidMount() {
										this.asyncInit();
									  }
									  // 순차실행
									  async asyncInit() {
										await commonUtil.setCommonSecurity(this.props.viewRegisterAbnormalMaterialCardStore, this.props); // Security 데이터 setting
										await commonUtil.setCommonFacOpCdLov(this.props.viewRegisterAbnormalMaterialCardStore, this.props); // 공장,공정LOV 데이터 setting
										await this.props.viewRegisterAbnormalMaterialCardStore.setParentData(this.props.location ? qs.parse(location.search, { ignoreQueryPrefix: true }) : ''); // 모화면 데이터 setting
										await this.props.viewRegisterAbnormalMaterialCardStore.setInitData(); // 초기데이터 init
										// await this.getCrDefOcrOpCdLov(); //발생공정
										await this.findAllRowData();
										await this.props.viewRegisterAbnormalMaterialCardStore.setMenuItems(); // 연관메뉴 세팅
									  }
									  async getCrDefOcrOpCdLov() {
										const itemList = []; // 요청할 LOV item
										itemList.push({ req: 'item', codeGrp: 'SZ0000', codeId: 'CR_DEF_OCR_OP_CD' });
										const operFlag = this.props.viewRegisterAbnormalMaterialCardStore.securityData.operFlag;
										const facOpCdN = this.props.viewRegisterAbnormalMaterialCardStore.searchParams.selectedOpCdData;
										const opCds = ['153', '1F1', '351', '3F1', '156', '1F2', '157', '1F3', '124'];
										if (operFlag === '5' && opCds.includes(facOpCdN)) {
										  itemList.push({ req: 'item', codeGrp: 'SZ0000', codeId: 'HR_DEF_OCR_OP_CD' });
										}
										await commonUtil.setShowAllLov(this.props.viewRegisterAbnormalMaterialCardStore, this.props, itemList);
									  }
									  // lifecycle.componentWillUnmount
									  componentWillUnmount() {
										// this.props.viewRegisterAbnormalMaterialCardStore.clear(); //TODO
									  }
									  // LOV.공장 onChange
									  onChangeFacLov(e, data) {
										commonUtil.onChangeCommonFacLov(this.props.viewRegisterAbnormalMaterialCardStore, data);
									  }
									  // LOV.공정 onChange
									  onChangeOpCdLov(e, data) {
										commonUtil.onChangeCommonOpCdLov(this.props.viewRegisterAbnormalMaterialCardStore, data, this.props);
									  }
									  // SearchView OnChange 이벤트
									  onChangeSearchData(e, data) {
										let value = data.value;
										if (data.case === 'Upper') {
										  value = value.toUpperCase();
										}
										this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(data.name, value);
										this.onChangeAbnomalCard(e, data);
									  }
									  // onChange input 값
									  onChangeInputData(e, data) {
										let value = data.value;
										if (data.case === 'Upper') {
										  value = value.toUpperCase();
										}
										this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(data.name, value);
									  }
									  // onChange input(number) 값
									  onChangeInputNumberData(e, data) {
										const re = /^[0-9\b]+$/;
										if (e.target.value === '' || re.test(e.target.value)) {
										  console.log(data.name, data.value);
										  this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(data.name, data.value);
										}
									  }
									  // onChange checkbox 값
									  onChangeCheckbox(e, data) {
										console.log(data.name, data.checked);
										this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(data.name, data.checked);
									  }
									  // DatePicker.날짜 onChange
									  onChangeDate = (changedDate, propName) => {
										this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(propName, changedDate);
									  };
									  //onChange 이상재카드 NO
									  async onChangeAbnomalCard(e, data) {
										console.log('onChangeAbnomalCard', data);
										await this.props.viewRegisterAbnormalMaterialCardStore.setSearchParam(data.name, data.value);
										await this.props.viewRegisterAbnormalMaterialCardStore.setCardInfo();
										await this.findAllRowData();
									  }
									  /*
									  * 조회
									  */
									  async findAllRowData() {
										const newFlag = this.props.viewRegisterAbnormalMaterialCardStore.searchParams.newFlag;
										// const cardFind = this.props.viewRegisterAbnormalMaterialCardStore.searchParams.cardFind;

										await this.getCrDefOcrOpCdLov(); //발생공정
										await this.props.viewRegisterAbnormalMaterialCardStore.reqCardNoList();
										if (newFlag) {
										  await this.props.viewRegisterAbnormalMaterialCardStore.processNewFind();
										} else {
										  // pp2.find & pp3.cardFind
										  await this.props.viewRegisterAbnormalMaterialCardStore.processCardFind();
										}
										// await this.props.viewRegisterAbnormalMaterialCardStore.setMenuItems(); // test후 올리기
									  }
									  /*
									  * 이상재카드 등록
									  * 구: reqInsert
									  */
									  async onBtnRegister() {
										const result = await this.props.viewRegisterAbnormalMaterialCardStore.reqRegister();
										if(result) {
										  await this.clearParameters();
										  await this.props.viewRegisterAbnormalMaterialCardStore.processCardFind();
										}
									  }
									  /*
									  * 이상재카드 삭제
									  * 구: reqDelete
									  */
									  async onBtnDelete() {
										const conf = await dialog.confirm(message('N1AJS2141')); // 삭제처리하시겠습니까?
										if (conf) {
										  const result = await this.props.viewRegisterAbnormalMaterialCardStore.reqDelete();
										  if(result) {
											await this.props.viewRegisterAbnormalMaterialCardStore.processDelete();
											await this.clearParameters(); //TODO url 변경
											await this.props.viewRegisterAbnormalMaterialCardStore.processCardFind();

											// await this.props.viewRegisterAbnormalMaterialCardStore.clear();
											// await this.asyncInit();
										  }
										}
									  }
									  /*
									  * url 변경
									  */
									  clearParameters() {
										console.log('[clearParameters]');
										// const getParameters = qs.parse(location.search, { ignoreQueryPrefix: true });
										const securityData = this.props.viewRegisterAbnormalMaterialCardStore.securityData;
										let parameters = '';
										parameters += 'm2n0000046?NS_FKEY=' + securityData.nsFkey;
										parameters += '&NS_RKEY=' + securityData.nsRkey;
										// parameters += '&layout=hidden';
										// parameters += '&selectedFacData=' + getParameters.selectedFacData;
										// parameters += '&selectedOpCdData=' + getParameters.selectedOpCdData;
										// parameters += '&mtlNo=' + getParameters.mtlNo;
										// parameters += '&facOpCdN=' + getParameters.facOpCdN;
										// parameters += '&coilType=' + getParameters.coilType;
										// parameters += '&cardFind=1';
										// link.loadSelf((urlPath.targetLocation === 'PORTAL' ? urlPath.redirectPortalPath : urlPath.redirectLocalPath) + parameters, screenName.m2n0000046);
										if(typeof(history.pushState) !== undefined)
										{
										  let renewURL = '/'+parameters;
										  console.log('renewURL ===>', renewURL);
										  //페이지 갱신 실행!
										  history.pushState(null, null, renewURL);
										}
									  }
									  // lifecycle.render
									  render() {
										/* 변수 */
										const { viewRegisterAbnormalMaterialCardStore } = this.props;
										// console.log('카드 등록전 스토어 데이터 >>', toJS(viewRegisterAbnormalMaterialCardStore));
										return (
										  <ContentLayout>
											{/* 타이틀 */}
											<ContentLayout.Header
											  title="냉연이상재카드조회및등록"
											  menuItems={viewRegisterAbnormalMaterialCardStore.menuItems}
											/>
											{/* 검색 */}
											<SearchView
											  facData={viewRegisterAbnormalMaterialCardStore.facData}
											  reSetOpCdData={viewRegisterAbnormalMaterialCardStore.reSetOpCdData}
											  searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
											  abnlCardNoListResult={viewRegisterAbnormalMaterialCardStore.abnlCardNoListResult}
											  onChangeFacLov={this.onChangeFacLov}
											  onChangeOpCdLov={this.onChangeOpCdLov}
											  findAllRowData={this.findAllRowData}
											  onChangeDate={this.onChangeDate}
											  onChangeAbnomalCard={this.onChangeAbnomalCard}
											  onChangeInputData={this.onChangeInputData}
											  onChangeSearchData={this.onChangeSearchData}
											  cardNoLov={viewRegisterAbnormalMaterialCardStore.cardNoLov}
											  abnomalCardInfo={viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
											/>
											<Segment>
											  {/* 버튼 */}
											  <ButtonView
												onBtnRegister={this.onBtnRegister}
												onBtnDelete={this.onBtnDelete}
												abnomalCardInfo={viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
												searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
												securityData={viewRegisterAbnormalMaterialCardStore.securityData}
												setSearchParam={viewRegisterAbnormalMaterialCardStore.setSearchParam}
												findAllRowData={this.findAllRowData}
												optionsCrEucCngBadF={viewRegisterAbnormalMaterialCardStore.optionsCrEucCngBadF}
											  />
											  <TableView1
												abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
												searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
											  />
											</Segment>
											<Segment>
											  <Header content="발생상황" />
											  {/* 삭제금지 */}
											  {(viewRegisterAbnormalMaterialCardStore.searchParams.preserveFlag || viewRegisterAbnormalMaterialCardStore.searchParams.newFlag) ? (
												<Checkbox
												  label="삭제금지"
												  name="preventDelFlag"
												  checked={viewRegisterAbnormalMaterialCardStore.searchParams.preventDelFlag}
												  onChange={this.onChangeCheckbox}
												/>) : ('')}
											  <Grid>
												<Grid.Row>
												  <Grid.Column width={12}>
													<TableView2
													  abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
													  searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
													  showItemLov={viewRegisterAbnormalMaterialCardStore.showItemLov}
													  onChangeInputData={this.onChangeInputData}
													  onChangeInputNumberData={this.onChangeInputNumberData}
													  chkInsertEmpNo={viewRegisterAbnormalMaterialCardStore.chkInsertEmpNo}
													  optionsCrEucCngBadF={viewRegisterAbnormalMaterialCardStore.optionsCrEucCngBadF}
													/>
												  </Grid.Column>
												  <Grid.Column width={4}>
													<TableView2a2
													  abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
													  searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
													  onChangeInputData={this.onChangeInputData}
													/>
												  </Grid.Column>
												</Grid.Row>
												<Grid.Row>
												  <Grid.Column width={12}>
													<TableView3
													  abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
													  searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
													/>
												  </Grid.Column>
												  <Grid.Column width={4}>
													<TableView3a2
													  abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}
													  searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}
													  onChangeInputData={this.onChangeInputData}
													/>
												  </Grid.Column>
												</Grid.Row>
											  </Grid>
											</Segment>
											{/*<Segment>*/}
											{/*  <TableView3*/}
											{/*    abnomalCardInfo = {viewRegisterAbnormalMaterialCardStore.abnomalCardInfo}*/}
											{/*    searchParams={viewRegisterAbnormalMaterialCardStore.searchParams}*/}
											{/*  />*/}
											{/*</Segment>*/}
										  </ContentLayout>
										);
									  }
									}
									export default ViewRegisterAbnormalMaterialCardContainer;
									
		Model--Standard MobX:
									
									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/
									import { extendObservable } from 'mobx';
									class ViewRegisterAbnormalMaterialCardModel {
									  constructor(item = {}) {
										extendObservable(this, item);
									  }
									  static toSampleModel(item) {
										return new ViewRegisterAbnormalMaterialCardModel(item);
									  }
									  static toSampleModels(items) {

										if (!Array.isArray(items)) {
										  return [];
										}
										return items.map(item => ViewRegisterAbnormalMaterialCardModel.toSampleModel(item));
									  }
									  static toDomainModel(item) {
										return item;
									  }
									  /**
									   * NameValue target
									   *
									   * @param { itemNo, parentNo, shapeType, state, cutDateTime } item
									   */
									  static asNameValues(item) {
										return {
										  nameValues: [
											{ name: 'itemNo',       value: JSON.stringify(item.itemNo) },
											{ name: 'parentNo',     value: JSON.stringify(item.parentNo) },
											{ name: 'shapeType',    value: JSON.stringify(item.shapeType) },
											{ name: 'stage',        value: JSON.stringify(item.stage) },
											{ name: 'cutDateTime',  value: JSON.stringify(item.cutDateTime) },
										  ],
										};
									  }
									  static asIconNameValue(item) {
										return {
										  nameValues: [
											{ name: 'base64Icon', value: item.base64Icon },
										  ],
										};
									  }
									}
									export default ViewRegisterAbnormalMaterialCardModel;
									export {
									  ViewRegisterAbnormalMaterialCardModel,
									};
									
		Render--Standard MobX:
									
									/*===============================================
									*@FileName : 냉연이상재조회 및 등록에서 사용하는 Util class
									*
									*Change history
									*@수정 날짜,SCR_NO,수정자,수정내용
									*@2020-04-28;00000;최솔빛누리;MES3.0 React 최초생성
									*
									================================================*/
									import React from 'react';
									import moment from 'moment';
									/**
									 * JudgeTd
									 * @param abnrMatJdgTp
									 * @param avAcCd
									 * @param incongruentProdCardJdgDt
									 * @param abnrMatJdgManNm
									 * @return
									 */
									export const JudgeTd = (props) => {
									  const abnrMatJdgTp = props.abnrMatJdgTp || '';
									  const avAcCd = props.avAcCd || '';
									  const incongruentProdCardJdgDt = props.incongruentProdCardJdgDt ? moment(props.incongruentProdCardJdgDt).format('YYYY-MM-DD HH:mm') : '';
									  const abnrMatJdgManNm = props.abnrMatJdgManNm || '';
									  return (
										<div>
										  <div align="left">
											{abnrMatJdgTp === '5' ? (
											  <span><b style={{ color: 'red' }}>판정</b> - {avAcCd}</span>) : (
											  abnrMatJdgTp === '1' ? (
												<b style={{ color: 'blue' }}>확인</b>) : (
												'')
											)}
										  </div>
										  <div align="left">{incongruentProdCardJdgDt}</div>
										  <div align="left">{abnrMatJdgManNm}</div>
										</div>
									  );
									};
									export default {
									  JudgeTd,
									};
									
		Repository--Standard MobX:
									
									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/
									import axios from 'axios';
									import { instance } from '@mes/mes-shared';
									class ViewRegisterAbnormalMaterialCardRepository {
									  @instance
									  static instance;
									  // new 200618ver.
									  process(params, process) {
										console.log(process, '==>', params);
										return axios.post(`/m2nz03-operation-common/m2nz03-operation-common/viewRegisterAbnormalMaterialCard/${process}`, params)
										  .then(response => response.data);
									  }
									}
									export default ViewRegisterAbnormalMaterialCardRepository;
									
		Store--Standard MobX:
									
									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/
									import { action, computed, observable, toJS } from 'mobx';
									import { instance, mesAutobind } from '@mes/mes-shared';
									import { notification, dialog, message } from '@mes/mes-ui-react';
									import moment from 'moment';
									import qs from 'qs';
									import ViewRegisterAbnormalMaterialCardRepository from '../repository/ViewRegisterAbnormalMaterialCardRepository';
									import ViewRegisterAbnormalMaterialCardModel from '../model/ViewRegisterAbnormalMaterialCardModel';
									import CommonApi from '../../common/api/commonApi';
									import { urlPath } from '../../common/constant';
									@mesAutobind
									class ViewRegisterAbnormalMaterialCardStore {
									  @instance(ViewRegisterAbnormalMaterialCardRepository.instance)
									  static instance;
									  repository;
									  constructor(repository) {
										this.repository = repository;
									  }
									  @observable
									  _securityData; // security 데이터
									  @computed
									  get securityData() {
										return toJS(this._securityData);
									  }
									  @observable
									  _facData; // 공장LOV 데이터
									  @computed
									  get facData() {
										return toJS(this._facData);
									  }

									  @observable
									  _opCdData; // 공정LOV 데이터

									  @computed
									  get opCdData() {
										return toJS(this._opCdData);
									  }

									  @observable
									  _reSetOpCdData; // 공장값에 의해 재정의된 공정LOV 데이터 P_FacOpCdLOV

									  @computed
									  get reSetOpCdData() {
										return toJS(this._reSetOpCdData);
									  }

									  @observable
									  _cardNoLov = [];  // 이상재카드 NO Lov.

									  @computed
									  get cardNoLov() {
										return toJS(this._cardNoLov);
									  }

									  @observable
									  _abnomalCardInfo; // AbnlMtlCardResult    ABNL_CARD_IMAGE_RESULT

									  @computed
									  get abnomalCardInfo() {
										return toJS(this._abnomalCardInfo);
									  }

									  @observable
									  _inspRemResult;

									  @computed
									  get inspRemResult() { //
										return toJS(this._inspRemResult);
									  }

									  @observable
									  _mtlExamResult;

									  @computed
									  get mtlExamResult() { //
										return toJS(this._mtlExamResult);
									  }

									  @observable
									  _abnlCardNoListResult = [];

									  @computed
									  get abnlCardNoListResult() { // PosGetAbnlMtlCardNoList의 결과값
										return toJS(this._abnlCardNoListResult);
									  }

									  @observable
									  _showItemLov = {
										crDefOcrOpCdLov: [], // 냉연결함발생공정코드
										hrDefOcrOpCdLov: [],
									  };

									  @computed
									  get showItemLov() {
										return toJS(this._showItemLov);
									  }

									  @observable
									  searchParams = { // 검색 파라미터
										newFlag: false,             //newFind = "new" 면 true
										cardFind: '',
										preserveFlag: false,       //P_PreventDelFlag="1"(삭제금지)이면 true

										confirmFlag1: false,
										confirmFlag2: false,
										nextFacOpCdIsPacking: false, //incongruentProdFetchLocTp 항목 구분

										//hidden
										crAbnorOcrDate: '',
										facOpCdN: '',
										mtlNo: '',
										coilType: 'C',

										// [SearchView  values]..
										selectedFacData: '&',   // "1냉연공장"
										selectedOpCdData: '&',  // facOpCdN
										jdgTp: 'ALL',
										selectedDate: '&',      // 발생일  selectedDate = [ P_DateFrom, P_DateTo ]
										pMtlNo4Query: '',
										cardNo: '',             // 이상재카드No

										// [TableView2 values].. 카드작성영역
										crDefCd: '',
										crDefOcrOpCd: '',
										iFacOpCdN: '', // 구: I_FacOpCd //TODO
										crInsporEmpNo: '',
										opSft: '',
										lenDirDefOcrShpTp: '',

										lenDirDefOcrQt: '',
										wDirtDefOcrLocTp: '',
										wDirtDefOcrDetailLoc: '',
										difSurTp: '',
										defOcrPitch: '',
										defOcrNum: '',
										defOcrSize: '',
										defExfoliaF: '',
										defCorF: '',

										defFigF: '',
										shpBadWDirtLocTp: '',
										shpBadWaveMseV: '',
										shpBadWaveHgtMseV: '',
										shpBadSteepMseV: '',
										tscpeMseV: '',
										incongruentProdSdtrmF: '',
										incongruentProdOilF: '',

										shpBadWthMseV: '',
										incongruentProdFetchLocTp2: '',
										incongruentProdFetchLocTp: '',
										crNetTheoWgt: '',

										// [TableView2a2 values]..
										incongruentInsporOpinion: '',

										avAcCd:'',

										crEucCngBadF: '', //냉연공정재변경불가여부
									  };

									  @action
									  setSearchParam(name, value) {
										this.searchParams = new ViewRegisterAbnormalMaterialCardModel({ ...this.searchParams, [name]: value });
									  }

									  @action
									  putAllSearchParams(obj) {
										console.log('putAllSearchParams', obj);
										this.searchParams = new ViewRegisterAbnormalMaterialCardModel(obj);
									  }

									  @action
									  clear() {
										console.log('clear');

										// this._securityData = null;
										this._cardNoLov = [];
										this._crDefOcrOpCdLov = [];
										this._abnomalCardInfo;
										this._inspRemResult;
										this._mtlExamResult;
										this._abnlCardNoListResult = [];
										this.searchParams = { // 검색 파라미터
										  newFlag: false,             //newFind = "new" 면 true
										  cardFind: '',
										  preserveFlag: false,       //P_PreventDelFlag="1"(삭제금지)이면 true

										  confirmFlag1: false,
										  confirmFlag2: false,
										  nextFacOpCdIsPacking: false, //incongruentProdFetchLocTp 항목 구분

										  //hidden
										  crAbnorOcrDate: '',
										  facOpCdN: '',
										  mtlNo: '',
										  coilType: 'C',

										  // [SearchView  values]..
										  selectedFacData: '&',   // "1냉연공장"
										  selectedOpCdData: '&',  // facOpCdN
										  jdgTp: 'ALL',
										  selectedDate: '&',      // 발생일  selectedDate = [ P_DateFrom, P_DateTo ]
										  pMtlNo4Query: '',
										  cardNo: '',             // 이상재카드No

										  // [TableView2 values].. 카드작성영역
										  crDefCd: '',
										  crDefOcrOpCd: '',
										  iFacOpCdN: '', // 구: I_FacOpCd //TODO
										  crInsporEmpNo: '',
										  opSft: '',
										  lenDirDefOcrShpTp: '',

										  lenDirDefOcrQt: '',
										  wDirtDefOcrLocTp: '',
										  wDirtDefOcrDetailLoc: '',
										  difSurTp: '',
										  defOcrPitch: '',
										  defOcrNum: '',
										  defOcrSize: '',
										  defExfoliaF: '',
										  defCorF: '',

										  defFigF: '',
										  shpBadWDirtLocTp: '',
										  shpBadWaveMseV: '',
										  shpBadWaveHgtMseV: '',
										  shpBadSteepMseV: '',
										  tscpeMseV: '',
										  incongruentProdSdtrmF: '',
										  incongruentProdOilF: '',

										  shpBadWthMseV: '',
										  incongruentProdFetchLocTp2: '',
										  incongruentProdFetchLocTp: '',
										  crNetTheoWgt: '',

										  // [TableView2a2 values]..
										  incongruentInsporOpinion: '',

										  //
										  crEucCngBadF: '', //냉연공정재변경불가여부
										};
									  }

									  @observable
									  menuItems = [
										{ text: '이상재 List 조회', link: '/m2n0000161', target: '_self' },
										{ text: '반제품실적처리', link: '/m2n0000044', target: '_parent' },
									  ];

									  //냉연공정재변경불가여부 값 리스트
									  @observable
									  optionsCrEucCngBadF = [
										{ value: '', text: '　' },
										{ value: 'Y', text: 'Y' },
										{ value: 'N', text: 'N' },
									  ];

									  @action
									  setMenuItems() {
										const currentGetParameters = qs.parse(location.search, { ignoreQueryPrefix: true });
										console.log('연관메뉴 세팅 >>>', currentGetParameters);
										const tempMenuItems =  this.menuItems.map((menu) => {
										  const abnomalCardInfo = this._abnomalCardInfo || {};

										  const operFlag = this.securityData.operFlag;
										  const facOpCdN = this.searchParams.selectedOpCdData;
										  const mtlNo = abnomalCardInfo !== {} ? abnomalCardInfo.mtlNo || '' : '';

										  const screenName = menu.text;
										  let screenId = menu.link.substring(1);
										  const authority = this.securityData.authority;

										  let getParameters = '';
										  getParameters += '?NS_FKEY=' + screenId + '_' + authority;
										  getParameters += '&NS_RKEY=' + currentGetParameters.NS_RKEY;

										  switch (screenName) {
											case '반제품실적처리':
											  //광양산세
											  // const kwPicklingFacList = ['1F1', '3F1', '1F2', '1F3', '124', '153', '32B', '156', '157' ];
											  // if (operFlag === '5' && kwPicklingFacList.includes(facOpCdN)) {
											  const selectedFacData = this.searchParams.selectedFacData; // 현업요청 2020.07.02
											  if (operFlag === '5' && selectedFacData === '산세공장') {
												screenId = 'm2nd010045';
												getParameters += '&mtlNo=' + mtlNo;
											  }
											  //포)1CGL
											  else if (operFlag === 'L' && facOpCdN === '2A1') {
												screenId = 'm2n0000044';
												getParameters += '&mtlNo=' + mtlNo;
											  }
											  //기타
											  else {
												screenId = 'm2n0000044';
												getParameters += '&mtlNo=' + mtlNo;
											  }
											  break;
											case '이상재 List 조회':

											  // const listCardExist = currentGetParameters.List_cardExist;
											  const listHistory = currentGetParameters.List_AbnlConfirm;
											  console.log('listHistory >>>', listHistory);

											  if(listHistory !== undefined) {
												// 1. list 화면에서 넘어온 경우(currentGetParameters 존재)
												let listFindParam = '';
												if (listHistory === 'History') { listFindParam = 'historyFind'; } //이력조회
												else if (listHistory === 'Y') { listFindParam = 'cardFind'; } //판정후
												else if (listHistory === 'N') { listFindParam = 'mlnFind'; } //판정전
												else { listFindParam = ''; }
												getParameters += '&selectedFacData=' + currentGetParameters.selectedFacData;
												getParameters += '&selectedOpCdData=' + currentGetParameters.selectedOpCdData; // P_FacOpCdLOV
												getParameters += '&pParentMtlNo=' + currentGetParameters.pParentMtlNo;
												getParameters += '&pDateFrom=' + currentGetParameters.List_DateFrom;
												getParameters += '&pDateTo=' + currentGetParameters.List_DateTo;
												// getParameters += '&mtlNo=' + mtlNo;
												getParameters += '&pFacOpCdN=' + currentGetParameters.List_FacOpCdN;
												getParameters += '&cardExist=' + currentGetParameters.List_cardExist;
												getParameters += '&pAbnlConfirm=' + currentGetParameters.List_AbnlConfirm;
												getParameters += '&pRsitDateFrom=' + currentGetParameters.List_RsitDateFrom;
												getParameters += '&pRsitDateTo=' + currentGetParameters.List_RsitDateTo;
												getParameters += '&pRsitDateChk=' + currentGetParameters.List_RsitDateChk;
												getParameters += '&' + listFindParam + '=1';

											  } else {
												// 2. 바로 등록화면으로 들어온 경우
												getParameters += '&selectedFacData=' + this.searchParams.selectedFacData;
												getParameters += '&selectedOpCdData=' + this.searchParams.selectedOpCdData; // P_FacOpCdLOV
											  }
											  getParameters += '&layout=hidden';
											  break;
											default:
											  break;
										  }

										  const url = (urlPath.targetLocation === 'PORTAL' ? urlPath.redirectPortalPath : urlPath.redirectLocalPath) + screenId + getParameters;
										  return { ...menu, link: url };
										});
										this.menuItems = tempMenuItems;
									  }

									  @action
									  setInitData() { // 초기 데이터 setting
										console.log('[setInitData]');

										//worksCode
										const worksCode = this._securityData.plantFlag;
										const crInsporEmpNo = this._securityData.employeeNumber;
										this.searchParams = { ...this.searchParams, worksCode };

										if (this.searchParams.selectedDate === '&') {
										  const today = moment().format('YYYY-MM-DD');
										  const sevenDaysAgo = moment().subtract(7, 'days').format('YYYY-MM-DD');

										  const selectedDate = [sevenDaysAgo, today];
										  this.setSearchParam('selectedDate', selectedDate);

										} else {

										  const today = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[0] : '';
										  const oneMonthsAgo = moment(today).subtract(1, 'M').format('YYYY-MM-DD');

										  const selectedDate = [oneMonthsAgo, today];
										  this.setSearchParam('selectedDate', selectedDate);
										}

										//facOpCds - for searchView의 cardNoList
										const reSetOpCdData = this._reSetOpCdData || [];
										const facOpCdNs = [];
										reSetOpCdData.map((data, i) => {
										  const value = data.value;
										  if (value !== 'ALL') {
											facOpCdNs.push(value);
										  }
										});
										this.setSearchParam('facOpCdNs', facOpCdNs);
										this.setSearchParam('crInsporEmpNo', crInsporEmpNo);

									  }

									  @action
									  setParentData(requestParams) {
										console.log('카드등록 [setParentData] requestParams', requestParams);
										// default 파라미터: selectedFacData, selectedOpCdData, mtlNo
										// // for 이상재List setting위한 값
										// List_FacOpCdN
										// List_DateFrom
										// List_DateTo
										// List_AbnlConfirm
										// List_cardExist

										// [1 카드가 이미 작성된 경우]
										// selectedDate
										// jdgTp
										// cardFind=1

										//[2 카드작성 X]
										// newFind=new

										const newFlag = requestParams.newFind === 'new'? true:'';
										const cardFind = requestParams.cardFind || '';
										const preserveFlag = requestParams.preventDelFlag === '1';

										console.log('[setParentData]', 'newFlag: ', newFlag, ', preserveFlag: ', preserveFlag);

										this.searchParams = { ...this.searchParams,
										  newFlag,
										  cardFind,
										  preserveFlag,
										};

										if(requestParams.selectedFacData) {
										  this.searchParams = { ...this.searchParams, selectedFacData: requestParams.selectedFacData };
										}
										if(requestParams.mtlNo) {
										  this.setSearchParam('mtlNo', requestParams.mtlNo);
										}
										if(requestParams.facOpCdN) {
										  this.searchParams = { ...this.searchParams, selectedOpCdData: requestParams.facOpCdN };
										  this.searchParams = { ...this.searchParams, iFacOpCdN: requestParams.facOpCdN };
										  if(requestParams.facOpCdN !== requestParams.selectedOpCdData){//다른공정의 소재 일시
											this.reSetFacData(requestParams.facOpCdN);
										  }
										}
										if(requestParams.pMtlNo4Query) {
										  this.searchParams = { ...this.searchParams, pMtlNo4Query: requestParams.pMtlNo4Query };
										}
										if(requestParams.coilType) {
										  this.searchParams = { ...this.searchParams, coilType: requestParams.coilType };
										}
										if(requestParams.jdgTp) {
										  this.searchParams = { ...this.searchParams, jdgTp: requestParams.jdgTp };
										}
										if (requestParams.mtlNo !== undefined && !newFlag) {
										  this.searchParams = { ...this.searchParams, pMtlNo4Query: requestParams.mtlNo };
										}

										//crAbnorOcrDate
										if(requestParams.selectedDate) {
										  this.setSearchParam('crAbnorOcrDate', requestParams.selectedDate);
										}

										const selectedDateSubstr = requestParams.selectedDate ? requestParams.selectedDate.substring(0, 10) : ''; // [1 카드가 이미 작성된 경우]
										if (selectedDateSubstr !== '') {
										  const selectedDateArr = [];
										  selectedDateArr.push(selectedDateSubstr);
										  selectedDateArr.push(selectedDateSubstr);
										  this.setSearchParam('selectedDate', selectedDateArr);
										}
									  }

									  @action
									  async reSetFacData(facOpCdN){ //다른공정의 소재 일시
										console.log("reSetFacData start");
										const plantFlag = this._securityData.plantFlag;
										const id = this._securityData.screenId;
										console.log("reSetFacData facOpCdN : ", facOpCdN);
										const facOpCdData = await CommonApi.getFacOpLov(plantFlag, facOpCdN, id);
										let facData = [];
										let opCdData = [];
										let opCdCnt = 0;
										let opCdDataFac = ''; // 공장
										facOpCdData.facList.map((facTarget, i) => {
										  facData = facData.concat({ key: i, text: facTarget, value: facTarget});
										  facOpCdData.opCdList.map((opCdTarget, j) => {
											if(opCdTarget[facTarget] != undefined) {
											  opCdTarget[facTarget].map((singleOpCdTarget, k) => {
												opCdData = opCdData.concat({ key: opCdCnt, text: singleOpCdTarget.facOpName, value: singleOpCdTarget.facOpCdN, fac: facTarget, url: singleOpCdTarget.viewCode });
												opCdCnt++;
											  })
											}
										  });
										});
										console.log("reSetFacData opCdData", opCdData);
										this._facData = facData;
										this._opCdData = opCdData;
										Object.keys(opCdData).forEach(key => {
										  if (opCdData[key].value === facOpCdN) {
											opCdDataFac = opCdData[key].fac;
										  }
										});
										let tempReSetOpCdData = await this._opCdData.filter(target => target.fac === opCdDataFac); //새공장에 따른 공정lov
										this._reSetOpCdData = tempReSetOpCdData;
										console.log("reSetFacData tempReSetOpCdData", tempReSetOpCdData);
										this.setSearchParam('selectedFacData', opCdDataFac);
										this.setSearchParam('selectedOpCdData', facOpCdN);
										console.log("reSetFacData end");
									  }

									  @action
									  processNewFind() { //pp1
										console.log('[pp1.processNewFind]');
										const operFlag = this._securityData.operFlag;
										const facOpCdN = this.searchParams.selectedOpCdData;

										const dateFrom = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[0] : '';
										const dateTo = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[1] : '';
										const crAbnorOcrDate = this.searchParams.crAbnorOcrDate === '' ? '' : this.searchParams.crAbnorOcrDate.replace(/\s/g, '').replace(/-/gi, '').replace(/:/gi, '').substring(0, 14);

										const securityData = this._securityData;

										const params = { ...this.searchParams,
										  securityData,
										  operFlag, facOpCdN, crAbnorOcrDate, dateFrom, dateTo };

										if (this.searchParams.preventDelFlag !== true) { // 삭제금지 check안된 경우만
										  this.setSearchParam('crDefOcrOpCd', ''); // 새로 조회한 경우 발생공정 선택해둔거 닦기
										}

										return this.repository.process(params, 'newFind')
										  .then((data) => {
											console.log('@@test newFind 조회후', data);
											const errorMessage = data.errorMessage || '';
											if (errorMessage !== '') {
											  console.log('@@ERROR :: ', errorMessage);
											  dialog.alert(message('M2NJS1275')); // 에러발생 //임의작성
											} else {
											  //성공
											  const abnlMtlCardResult = data.abnlMtlCardResult;
											  const inspRemResult = data.inspRemResult;
											  const mtlExamResult = data.mtlExamResult;

											  this._abnomalCardInfo = abnlMtlCardResult;
											  this._inspRemResult = inspRemResult;
											  this._mtlExamResult = mtlExamResult;
											}
										  }).then(() => this.setAfterFind());


									  }

									  @action
									  processCardFind() { //pp2,3
										console.log('[pp23.processCardFind]');

										const operFlag = this._securityData.operFlag;
										const facOpCdN = this.searchParams.selectedOpCdData;

										const dateFrom = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[0] : '';
										const dateTo = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[1] : '';
										console.log('dateFrom : ', dateFrom);
										console.log('selectDate : ', this.searchParams.selectedDate);
										const crAbnorOcrDate = this.searchParams.crAbnorOcrDate === '' ? '' : this.searchParams.crAbnorOcrDate.replace(/\s/g, '').replace(/-/gi, '').replace(/:/gi, '').substring(0, 14);
										console.log('processCardFind crAbnorOcrDate', crAbnorOcrDate);
										const securityData = this._securityData;

										let params = { ...this.searchParams,
										  securityData,
										  operFlag, facOpCdN, crAbnorOcrDate, dateFrom, dateTo };

										return this.repository.process(params, 'cardFind')
										  .then((data) => {
											if (data !== undefined) {
											  console.log('@@ 조회response', data);
											  const errorMessage = data.errorMessage || '';
											  if (errorMessage !== '') {
												console.log('@@ERROR :: ', errorMessage);
												dialog.alert(message('M2NJS1275')); // 에러발생 //임의작성
											  } else {
												//성공AbnormalMaterialStore
												const abnlMtlCardResult = data.abnlMtlCardResult;
												const inspRemResult = data.inspRemResult;
												const mtlExamResult = data.mtlExamResult;
												if (abnlMtlCardResult !== undefined) {
												  console.log('@@test abnlMtlCardResult', abnlMtlCardResult);
												  this._abnomalCardInfo = abnlMtlCardResult;
												  this._abnomalCardInfo.opDnDt = abnlMtlCardResult ? abnlMtlCardResult.crAbnorOcrDate : moment().format('YYYY-MM-DD'); // newFlag아닐때 발생일로 치환
												  this._inspRemResult = inspRemResult;
												  this._mtlExamResult = mtlExamResult;
												  let abnlCardNoListResult = [];
												  if (data.abnlCardNoListResult !== undefined && data.abnlCardNoListResult !== null) {
													console.log("======20201210 가동계 판단 abnlCardNoListResult::",data.abnlCardNoListResult);
													abnlCardNoListResult = data.abnlCardNoListResult;
													if (abnlCardNoListResult !== undefined && Array.isArray(abnlCardNoListResult) && abnlCardNoListResult.length > 0) {
													  // const cardNo = abnlCardNoListResult[0].cardNo;  // 20201023 현재 조회된 카드NO로 우선 요청
													  const cardNo = data.cardNo !== undefined? data.cardNo : abnlCardNoListResult[0].cardNo;
													  this.setSearchParam('cardNo', cardNo);
													}
												  }
												  this._abnlCardNoListResult = abnlCardNoListResult;
												  this._cardNoLov = abnlCardNoListResult;
												  console.log("======20201222 가동계 판단2 this._abnlCardNoListResult::",this._abnlCardNoListResult,"||",this._cardNoLov);
												}
											  }
											}
										  }).then(() => this.setAfterFind());
									  }

									  @action
									  processSave() { //pp4
										console.log('[pp4.processSave]');

										const securityData = this._securityData;
										const abnomalCardInfo = this._abnomalCardInfo;

										const operFlag = this._securityData.operFlag;
										const facOpCdN = abnomalCardInfo.facOpCdN;

										const dateFrom = abnomalCardInfo.crAbnorOcrDate ? moment(abnomalCardInfo.crAbnorOcrDate).format('YYYY-MM-DD') : '';
										const dateTo = abnomalCardInfo.crAbnorOcrDate ? moment(abnomalCardInfo.crAbnorOcrDate).format('YYYY-MM-DD') : '';
										const crAbnorOcrDate = this.searchParams.crAbnorOcrDate === '' || this.searchParams.crAbnorOcrDate === undefined ? '' : this.searchParams.crAbnorOcrDate.replace(/\s/g, '').replace(/-/gi, '').replace(/:/gi, '').substring(0, 14);

										// 20201007 sleeve 항목 카드등록시에 추가
										this.setSearchParam("crSleeveUseF",abnomalCardInfo.sleeveInsertFlag);

										const params = {
										  ...this.searchParams,
										  securityData,
										  operFlag,
										  facOpCdN,
										  dateFrom,
										  dateTo,
										  crAbnorOcrDate,
										  abnlMtlCardResult: abnomalCardInfo,

										};

										return this.repository.process(params, 'save')
										  .then((data) => {
											console.log('@@test save 조회후', data);
											const errorMessage = data.errorMessage || '';
											if (errorMessage !== '') {
											  console.log('@@ERROR :: ', errorMessage);
											  dialog.alert(message('M2NJS1275')); // 에러발생 //임의작성
											} else {
											  //성공
											  const abnlMtlCardResult = data.abnlMtlCardResult;
											  this._abnomalCardInfo = abnlMtlCardResult;

											  const mtlExamResult = data.mtlExamResult;
											  this._mtlExamResult = mtlExamResult;

											  const abnlCardNoListResult = data.abnlCardNoListResult || [];
											  if (Array.isArray(abnlCardNoListResult) && abnlCardNoListResult.length > 0) {
												let cardNo = '';
												if(data.cardNo) {
												  cardNo = data.cardNo;
												} else {
												  cardNo = abnlCardNoListResult[0].cardNo;
												}
												this.setSearchParam('cardNo', cardNo);
											  }
											  this._abnlCardNoListResult = abnlCardNoListResult;
											  this._cardNoLov = abnlCardNoListResult;

											  //save 성공시
											  // 발생일 기간을 당일로 변경
											  const crAbnorOcrDate = this.searchParams.crAbnorOcrDate || '';
											  if(crAbnorOcrDate !== '') {
												const ocrDate = crAbnorOcrDate.split(' ')[0];

												const selectedDate = [ocrDate, ocrDate];
												this.setSearchParam('selectedDate', selectedDate);
											  }

											  this.setSearchParam('newFlag', false);
											  notification(message('M00999110')); // 정상처리되었습니다.

											}
										  }).then(() => this.setAfterFind());

									  }

									  @action
									  processDelete() { //pp5
										console.log('[pp5.processDelete]');

										const securityData = this._securityData;
										const abnomalCardInfo = this._abnomalCardInfo;

										const operFlag = this._securityData.operFlag;
										const facOpCdN = abnomalCardInfo.facOpCdN;

										const dateFrom = abnomalCardInfo.crAbnorOcrDate ? moment(abnomalCardInfo.crAbnorOcrDate).format('YYYY-MM-DD') : '';
										const dateTo = abnomalCardInfo.crAbnorOcrDate ? moment(abnomalCardInfo.crAbnorOcrDate).format('YYYY-MM-DD') : '';
										// const crAbnorOcrDate = this.searchParams.crAbnorOcrDate === '' ? '' : this.searchParams.crAbnorOcrDate.replace(/\s/g, '').replace(/-/gi, '').replace(/:/gi, '').substring(0, 14);

										const params = {
										  ...this.searchParams,
										  securityData,
										  operFlag,
										  facOpCdN,
										  dateFrom,
										  dateTo,
										  // crAbnorOcrDate,
										  abnlMtlCardResult: abnomalCardInfo,

										};

										return this.repository.process(params, 'delete')

										  .then((data) => {
											console.log('@@test delete 조회후',data);
											const errorMessage = data.errorMessage || '';
											if (errorMessage !== '') {
											  console.log('@@ERROR :: ', errorMessage);
											  dialog.alert(message('M2NJS1275')); // 에러발생 //임의작성
											} else {
											  //성공
											  const abnlCardNoListResult = data.abnlCardNoListResult || [];
											  if(Array.isArray(abnlCardNoListResult) && abnlCardNoListResult.length > 0) {
												const cardNo = abnlCardNoListResult[0].cardNo;
												this.searchParams = {...this.searchParams, cardNo};
											  }
											  this._abnlCardNoListResult = abnlCardNoListResult;
											  this._cardNoLov = abnlCardNoListResult;
											  notification(message('M00999110')); // 정상처리되었습니다.
											  // this._abnomalCardInfo = undefined;
											  // this._inspRemResult = undefined;
											  // this._mtlExamResult = undefined;
											  // this.searchParams = {...this.searchParams, examResult: ''};
											}
										  });

									  }

									  /*
									  @action
									  findRowData() {
										console.log('[findRowData]');
										const operFlag = this._securityData.operFlag;
										const facOpCdN = this.searchParams.selectedOpCdData;
										const mtlNo = this.searchParams.mtlNo;

										const dateFrom = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[0] : '';
										const dateTo = this.searchParams.selectedDate !== '&' ? this.searchParams.selectedDate[1] : '';
										const crAbnorOcrDate = this.searchParams.crAbnorOcrDate === '' ? '' : this.searchParams.crAbnorOcrDate.replace(/\s/g, '').replace(/-/gi, '').replace(/:/gi, '').substring(0, 14);

										const coilType = this.searchParams.coilType;
										const jdgTp = this.searchParams.jdgTp;

										const newFlag = this.searchParams.newFlag;
										const params = { operFlag, facOpCdN, mtlNo, crAbnorOcrDate, jdgTp, dateFrom, dateTo, coilType };

										return this.repository.findRowData(params, newFlag)
										  .then((data) => {
											console.log('@@test 조회후',data);
											if(newFlag) { // new
											  const abnomalCardInfo = data.abnlMtlCardResult;
											  const mtlExamResult = data.mtlExamResult;
											  const inspRemResult = data.inspRemResult;

											  this._abnomalCardInfo = abnomalCardInfo;
											  this._mtlExamResult = mtlExamResult;
											  this._inspRemResult = inspRemResult;

											  if (abnomalCardInfo) {
												this.searchParams = {
												  ...this.searchParams,
												  mtlNo: abnomalCardInfo.mtlNo || '',
												  crClMatThk: abnomalCardInfo.crClMatThk || '',
												  crClMatW: abnomalCardInfo.crClMatW || '',
												  crClMatLen: abnomalCardInfo.crClMatLen || '',
												  crMatPrcQt: abnomalCardInfo.crMatPrcQt || '',
												  crNetActualWgt: abnomalCardInfo.crNetActualWgt || '',
												  opDnDt: abnomalCardInfo.opDnDt || '',
												  avOcrCauCd: abnomalCardInfo.avOcrCauCd || '',
												  avAcUqrCd: abnomalCardInfo.avAcUqrCd || '',
												  remFacOpCdN: abnomalCardInfo.remFacOpCdN || '',
												  trackingCode: abnomalCardInfo.trackingCode || '',
												  streLocCd: abnomalCardInfo.streLocCd || '',
												  planPassFacOpCdN: abnomalCardInfo.planPassFacOpCdN || '',
												  orderHeadLineNo: abnomalCardInfo.orderHeadLineNo || '',
												  orderThick: abnomalCardInfo.orderThick || '',
												  orderWidth: abnomalCardInfo.orderWidth || '',
												  orderInnerDiameter: abnomalCardInfo.orderInnerDiameter || '',
												  poscoProdGrd: abnomalCardInfo.poscoProdGrd || '',
												  surfaceFinishCd: abnomalCardInfo.surfaceFinishCd || '',
												  tempGrade: abnomalCardInfo.tempGrade || '',
												  orderUsageCdN: abnomalCardInfo.orderUsageCdN || '',
												  productNameCode: abnomalCardInfo.productNameCode || '',
												  postTreatmentMethodCd: abnomalCardInfo.postTreatmentMethodCd || '',
												  oilingMethodCd: abnomalCardInfo.oilingMethodCd || '',
												  sleeveInsertFlag: abnomalCardInfo.sleeveInsertFlag || '',
												  crIndiDesignEdge: abnomalCardInfo.crIndiDesignEdge || '',
												  surfaceGrd: abnomalCardInfo.surfaceGrd || '',
												  shapeGrd: abnomalCardInfo.shapeGrd || '',
												  passFacOpCdN: abnomalCardInfo.passFacOpCdN || '',
												  slabNo: abnomalCardInfo.slabNo || '',
												  crThk: abnomalCardInfo.crThk || '',
												  crWth: abnomalCardInfo.crWth || '',
												  prodStdPackTol: abnomalCardInfo.prodStdPackTol || '',
												  packingType: abnomalCardInfo.packingType || '',
												  hotCoilNo: abnomalCardInfo.hotCoilNo || '',
												  hrRollDate: abnomalCardInfo.hrRollDate || '',
												  hrClWgt: abnomalCardInfo.hrClWgt || '',
												  smSteelGrd: abnomalCardInfo.smSteelGrd || '',
												  stsSurAvp: abnomalCardInfo.stsSurAvp || '',
												  stsFlatdSvyV: abnomalCardInfo.stsFlatdSvyV || '',
												  stsGuaranteeSurfaceFlag: abnomalCardInfo.stsGuaranteeSurfaceFlag || '',
												  crAbnorOcrDate: abnomalCardInfo.crAbnorOcrDate || '',
												  endUserNumber: abnomalCardInfo.endUserNumber || '',
												  otOrdPrdRsitDt: abnomalCardInfo.otOrdPrdRsitDt || '',
												  orderTypeGroupCode: abnomalCardInfo.orderTypeGroupCode || '',
												  ordPdtItdsCdN: abnomalCardInfo.ordPdtItdsCdN || '',
												  prodStdPackTolMin: abnomalCardInfo.prodStdPackTolMin || '',
												  prodStdPackTolMax: abnomalCardInfo.prodStdPackTolMax || '',
												  steelGroup: abnomalCardInfo.steelGroup || '',
												  endUserName: abnomalCardInfo.endUserName || '',
												  crAbnrMatOcrTp: abnomalCardInfo.crAbnrMatOcrTp || '',
												  crOpSft: abnomalCardInfo.crOpSft || '',
												  orderProductNameCode: abnomalCardInfo.orderProductNameCode || '',
												  ordPdtItpCdN: abnomalCardInfo.ordPdtItpCdN || '',
												};
											  }
											} else { //cardInfo

											}

										  })
										  .then(() => this.setAfterFind());
									  }
									  */

									  @action
									  async setAfterFind() {
										console.log('setAfterFind');
										// row데이터 검색후 data setting하기
										const abnlMtlCardResult = this._abnomalCardInfo;
										const inspRemResult = this._inspRemResult;
										const mtlExamResult = this._mtlExamResult;
										const newFlag = this.searchParams.newFlag;

										if (abnlMtlCardResult) {
										  const mtlNo = abnlMtlCardResult ? abnlMtlCardResult.mtlNo || '' : '';
										  const facOpCdN = abnlMtlCardResult ? abnlMtlCardResult.facOpCdN || '' : '';

										  //고강도강 2차소둔일때 lov공장체크변환변수 추가
										  let sSFacOpCd = facOpCdN;
										  if (sSFacOpCd === '2Q1') {
											sSFacOpCd = '2P1';
										  } else if (sSFacOpCd === '4Q2') {
											sSFacOpCd = '4P2';
										  }

										  let confirmFlag1 = false;
										  let confirmFlag2 = false;
										  const reSetOpCdData = this._reSetOpCdData;
										  const nsFkey = this._securityData.nsFkey;

										  // 품질담당 - 해당공장 판정가능
										  if (mtlNo !== '' && reSetOpCdData.filter(info => info.value === sSFacOpCd)[0] !== undefined && nsFkey === 'm2n0000046_f003')
										  {
											confirmFlag1 = true;
										  }
										  //주임, 파트장 - 해당공정만 판정가능 => 해당공장 판정가능 수정 (2004.11.23)
										  else if (mtlNo !== '' && reSetOpCdData.filter(info => info.value === sSFacOpCd)[0] !== undefined && nsFkey === 'm2n0000046_f002')
										  {
											confirmFlag2 = true;
										  }
										  //임가공 이상재판정 추가 (2018.10.11)
										  else if (facOpCdN.substring(1) === '2A' || facOpCdN.substring(1) === '2B')
										  {
											confirmFlag1 = true;
										  }
										  // MCL 이상재판정 추가 (2020.09.21)
										  else if (facOpCdN === '2S5')
										  {
											confirmFlag1 = true;
											this.setSearchParam('selectedOpCdData', '223');
										  }

										  //판정 확인 여부
										  // const tmpAvAcCd = abnlMtlCardResult ? abnlMtlCardResult.tmpAvAcCd || '' : '';
										  const tmpAbnrMatJdgTp3 = abnlMtlCardResult ? abnlMtlCardResult.abnrMatJdgTp3 || '' : '';
										  const tmpAbnrMatJdgTp2 = abnlMtlCardResult ? abnlMtlCardResult.abnrMatJdgTp2 || '' : '';
										  const tmpAbnrMatJdgTp1 = abnlMtlCardResult ? abnlMtlCardResult.abnrMatJdgTp || '' : '';
										  if (tmpAbnrMatJdgTp1 !== '' && tmpAbnrMatJdgTp2 !== '' && tmpAbnrMatJdgTp3 !== '') {
											confirmFlag1 = false;
											confirmFlag2 = false;
										  }
										  console.log('@@[setInitData]', ', confirmFlag1:', confirmFlag1, ', confirmFlag2: ', confirmFlag2);

										  this.setSearchParam('confirmFlag1', confirmFlag1);
										  this.setSearchParam('confirmFlag2', confirmFlag2);

										  const avAcCd = abnlMtlCardResult ? abnlMtlCardResult.avAcCd || '' : '';
										  this.setSearchParam('avAcCd', avAcCd);

										  const wDirtDefOcrLocTp2 = abnlMtlCardResult ? abnlMtlCardResult.wDirtDefOcrLocTp2 || '' : '';
										  this.searchParams = { ...this.searchParams, wDirtDefOcrLocTp2 };

										  // 결함코드 TableView2
										  //sAvOcrCauCd, coilType
										  if (abnlMtlCardResult !== undefined) {
											let sAvOcrCauCd = '';
											const coilType = abnlMtlCardResult.coilType || 'C';
											if (newFlag) {
											  sAvOcrCauCd = abnlMtlCardResult.avOcrCauCd || '';
											} else {
											  sAvOcrCauCd = abnlMtlCardResult.crDefCd || '';
											}
											console.log('[setAfterFind]', 'crDefCd: ', sAvOcrCauCd, ', coilType: ', coilType);
											this.searchParams = { ...this.searchParams,
											  wDirtDefOcrLocTp2,
											  crDefCd: sAvOcrCauCd,
											  coilType };
										  } // abnlMtlCardResult is not undefined

										  // default 근조Setting
										  let opSft = '';
										  const workDate = moment().format('YYYYMMDDHHmmss');
										  if (newFlag) {
											const opSftParams = {
											  workDate,
											  worksCode: this._securityData.plantFlag,
											  operFlag: this._securityData.operFlag,
											  facOpCd: this.searchParams.selectedOpCdData,
											};
											opSft = await CommonApi.getOpshift('SHIFTOPER', opSftParams).then((data) => data.workShift);
										  }  else if (abnlMtlCardResult !== undefined) {
											opSft = abnlMtlCardResult.opSft;
										  } else {
											opSft = '&nbsp;';
										  }
										  this.setSearchParam('opSft', opSft);

										  // 검사자의견 setting
										  let incongruentInsporOpinion = '';
										  if (newFlag) {
											if (abnlMtlCardResult !== undefined) {
											  const prdDate = moment(abnlMtlCardResult.productDueDate).format('YYYY-MM-DD');
											  incongruentInsporOpinion += `생산기한일: ${prdDate}\n`;
											}
											if (inspRemResult !== undefined) {
											  inspRemResult.map(insp => incongruentInsporOpinion += `${insp.facOpCdN}: ${insp.esdOtTp}: ${insp.inspRem}\n`);
											}
											this.searchParams = { ...this.searchParams, incongruentInsporOpinion };
										  }

										  // 검사자의견2 ExamResult
										  let examResult = '';
										  if (mtlExamResult !== undefined) {
											examResult += `${mtlExamResult.exAMastGdCauOpTp || ' '}`;
											examResult += `${mtlExamResult.extTotJdgGd || ' '}`;
											examResult += `${mtlExamResult.extTotGdCauCd || ' '}`;
											examResult += `${mtlExamResult.extSurJdgGd || ' '}`;
											examResult += `${mtlExamResult.extShpJdgGd || ' '}`;
											examResult += `${mtlExamResult.extSizeJdgGd || ' '}`;
											examResult += `${mtlExamResult.extUtWgtJdgGd || ' '}`;
											examResult += `  / `;
											examResult += `${mtlExamResult.ordSurPrdFlag || '  '}`;
											examResult += `${mtlExamResult.sprdCauCd || '  '}`;
											examResult += ` \n`;
											if (mtlExamResult.crDefOcrOpCd !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd || ' '}`;
											  examResult += `${mtlExamResult.crDefCd || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc || '    '}`;
											}
											examResult += `  / `;
											if (mtlExamResult.crDefOcrOpCd2 !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd2 || ' '}`;
											  examResult += `${mtlExamResult.crDefCd2 || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp2 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt2 || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp2 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc2 || '    '}`;
											}
											examResult += `   \n`;
											if (mtlExamResult.crDefOcrOpCd3 !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd3 || ' '}`;
											  examResult += `${mtlExamResult.crDefCd3 || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp3 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt3 || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp3 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc3 || '    '}`;
											}
											examResult += `  / `;
											if (mtlExamResult.crDefOcrOpCd4 !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd4 || ' '}`;
											  examResult += `${mtlExamResult.crDefCd4 || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp4 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt4 || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp4 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc4 || '    '}`;
											}
											examResult += `   \n`;
											if (mtlExamResult.crDefOcrOpCd5 !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd5 || ' '}`;
											  examResult += `${mtlExamResult.crDefCd5 || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp5 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt5 || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp5 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc5 || '    '}`;
											}
											examResult += `  / `;
											if (mtlExamResult.crDefOcrOpCd6 !== null) {
											  examResult += `${mtlExamResult.crDefOcrOpCd6 || ' '}`;
											  examResult += `${mtlExamResult.crDefCd6 || '  '}`;
											  examResult += `${mtlExamResult.crDefAvp6 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrOccupaRt6 || '    '}`;
											  examResult += `${mtlExamResult.crDefOcrFcTp6 || ' '}`;
											  examResult += `${mtlExamResult.crDefOcrSatLoc6 || '    '}`;
											}
											this.searchParams = { ...this.searchParams, examResult };
										  }

										  // 포장공정체크(2.0: 5,6,7,8,9 => 3.0: '5')
										  const nextFacOpCdN = abnlMtlCardResult ? abnlMtlCardResult.nextFacOpCdN : '';
										  const nextFacOpCd = (nextFacOpCdN !== '' && nextFacOpCdN !== undefined) ? nextFacOpCdN.substring(1, 2) : '';
										  let nextFacOpCdIsPacking = false;
										  if (nextFacOpCd === '5') {
											nextFacOpCdIsPacking = true;
										  }
										  this.searchParams = { ...this.searchParams, nextFacOpCdIsPacking };

										  // abnlCardNoListResult 조회후로 옮겼.. 테스트필fi요
										  // searchView
										  // cardNo   _cardNoLov
										  // const abnlCardNoListResult = this._abnlCardNoListResult;
										  // if (abnlCardNoListResult && abnlCardNoListResult.length > 0) {
										  //
										  const crAbnorOcrDate = abnlMtlCardResult ? abnlMtlCardResult.crAbnorOcrDate : '';
										  this.setSearchParam('crAbnorOcrDate', crAbnorOcrDate);
										  console.log('@@crAbnorOcrDate : ', crAbnorOcrDate);
										  //   const cardNo = facOpCdN
										  //     + moment(crAbnorOcrDate).format('YYMMDDHHmm')
										  //     + mtlNo;
										  //   this.searchParams = { ...this.searchParams, cardNo };
										  //
										  //   let dataList = [];
										  //   dataList = dataList.concat({ key: 0, text: cardNo, value: cardNo });
										  //
										  //   console.log('[setAfterFind] 카드 NO LIst : ', dataList);
										  //   this._cardNoLov = dataList;
										  // }
										}


									  }

									  /*
									  * 이상재카드 등록
									  * 구: reqInsert
									  */
									  @action
									  async reqRegister() {
										console.log('reqRegister');
										if (!this.searchParams.newFlag) {
										  await dialog.alert(message('M2NJS1306')); //카드작성 후 다시 시도하세요.
										  return false;
										}

										if (this.searchParams.crDefCd === '') {
										  await dialog.alert(message('M2NJS1046')); //결함코드를 입력하세요.
										  // document.body.querySelector('input[name=crDefCd]').focus();
										  return false;
										}

										if (this.searchParams.crDefOcrOpCd === '') {
										  await dialog.alert(message('M2NJS1094')); //발생공정을 선택하세요.
										  // document.body.querySelector('select[name=crDefOcrOpCd]').focus(); // select focus 안됨 TODO
										  return false;
										}

										if (this.searchParams.crInsporEmpNo === ''
										// && this._securityData.operFlag === 'L'
										) {
										  await dialog.alert(message('M2NJS1034')); // 검사자직번을 6자리로 입력하세요.
										  // document.body.querySelector('input[name=crInsporEmpNo]').focus();
										  return false;
										}

										if (this.searchParams.opSft === '') {
										  await dialog.alert(message('M2NJS1548')); // 근조값이 올바르지 않습니다.M27	JS1548
										  // document.body.querySelector('input[name=opSft]').focus();
										  return false;
										}

										//검사Line 에러체크
										if (this.checkValidFacOpCd() === false) {
										  return false;
										}

										if (!this.checkMyLength()) {
										  return false;
										}

										let matPrgTp = this._abnomalCardInfo.trackingCode;
										console.log("카드 정보::",this._abnomalCardInfo);
										if (matPrgTp !== undefined && matPrgTp.length > 4) {
										  matPrgTp = matPrgTp.substring(4, 5);
										}

										console.log('matPrgTp : ', matPrgTp);
										console.log('crAbnrMatOcrTp : ', this.searchParams.crAbnrMatOcrTp);
										console.log('avOcrCauCd : ', this.searchParams.avOcrCauCd);

										//matPrgTp == "K" 냉연 보류재, matPrgTp == "" 열연/STS재 보류재
										if ((matPrgTp === 'K' || matPrgTp === '') && this.searchParams.crAbnrMatOcrTp !== 'J' && this.searchParams.avOcrCauCd === '') {
										  // const exeFlag = confirm('이상발생원인코드가 없어서 판정이 불가능합니다. \n 정보전달용으로 카드만 작성하시겠습니까?'); /*** m_mark */
										  const exeFlag = await dialog.confirm(message("M2NJS1550"));
										  if (exeFlag === false) {
											return false;
										  }
										}

										//정보전달용일 경우 이상발생일시 Set
										const today = moment().format('YYYY-MM-DD HH:mm:ss');
										const crAbnorOcrDate = this._abnomalCardInfo.crAbnorOcrDate;

										this.searchParams = { ...this.searchParams,
										  crAbnorOcrDate,
										  otOrdPrdRsitDt: this._abnomalCardInfo.otOrdPrdRsitDt !== null? this._abnomalCardInfo.otOrdPrdRsitDt : today }; // null인 경우 임시 현재 날짜

										//이상재카드 NO List 재조회를 위해
										// this.searchParams = {
										//   ...this.searchParams,
										//   dateFrom: this._abnomalCardInfo.crAbnorOcrDate.substring(0,10),
										//   dateTo: this._abnomalCardInfo.crAbnorOcrDate.substring(0,10),
										//   pMtlNo4Query: '',
										//   jdgTp: '0',
										//   facOpCdN: this.searchParams.iFacOpCdN,
										//   crAbnorOcrDate: this._abnomalCardInfo.crAbnorOcrDate.substring(0,19),
										// };

										// this.setSearchParam('newFlag', false);
										// const params = this.searchParams;
										// return this.repository.process(params, 'save')

										return this.processSave()
										  .then(() => true);
									  }


									  /*
									  * 이상재카드 삭제
									  * 구: reqDelete
									  */
									  @action
									  reqDelete() {
										console.log('reqDelete');
										if (this.searchParams.newFlag) {
										  dialog.alert(message('M2NJS1106')); //새로작성 중인 카드입니다. 삭제하실 수 없습니다.
										  return false;
										}

										if (this.searchParams.cardNo === '') {
										  dialog.alert(message('M2NJS1305')); //카드를 먼저 조회하세요.
										  return false;
										}

										this.setCardInfo();

										//이상재카드 NO List 재조회를 위해
										this.reqCardNoList();

										const params = { ...this.searchParams, facOpCdN: this.searchParams.iFacOpCdN };
										console.log(params);
										// return this.repository.processAbnormalMaterialCard('delete', params);
										return true;
									  }

									  @action
									  reqCardNoList() {
										console.log('reqCardNoList');

										// 발생일
										const selectedDate = this.searchParams.selectedDate;
										console.log('[reqCardNoList]  selectedDate:', selectedDate);
										if (selectedDate !== '&' && (selectedDate[0].length !== 10 || selectedDate[1].length !== 10)) {
										  dialog.alert(message('M2NJS1095')); // 발생일을 [YYYY-MM-DD] 형식으로 입력하세요.
										  return false;
										}
										return true;
									  }

									  /* cardLov의 값으로 cardNo, crAbnorOcrDate, mtlNo setting한다. */
									  @action
									  setCardInfo() {
										console.log('[setCardInfo');
										// cardLov의 값으로 cardNo, P_CrAbnorOcrDate,P_MtlNo setting한다.
										const cardNoObj = this.searchParams.cardNo;

										const facOpCdN = cardNoObj.substring(0, 3);
										const mtlNo = cardNoObj.substring(13);
										// console.log('[setCardInfo] ==> facOpCdN', facOpCdN, ',mtlNo :', mtlNo );
										this.setSearchParam('facOpCdN', facOpCdN);
										this.setSearchParam('mtlNo', mtlNo);

										let crAbnorOcrDate = '';
										const abnlCardNoListResult = this._abnlCardNoListResult || [];
										// console.log('@@test==> abnlCardNoListResult:', abnlCardNoListResult);
										console.log('@@20201222==> abnlCardNoListResult:', abnlCardNoListResult);
										if (abnlCardNoListResult !== undefined) {
										  if (abnlCardNoListResult.length > 0) {
											const cardNoInfo = abnlCardNoListResult.filter((rowValue) => rowValue.cardNo === cardNoObj)[0];
											console.log('cardNoInfo :', cardNoInfo);
											crAbnorOcrDate = cardNoInfo.crAbnorOcrDate;
											this.setSearchParam('crAbnorOcrDate', crAbnorOcrDate);
										  } else {
											// crAbnorOcrDate = cardNoObj;
											// this.searchParams = { ...this.searchParams, crAbnorOcrDate };
										  }
										}
									  }

									  @action
									  checkMyLength() {
										const incongruentInsporOpinion = this.searchParams.incongruentInsporOpinion;
										const nStrSize = incongruentInsporOpinion !== undefined? incongruentInsporOpinion.length : 0;
										const nMax = 400;

										if (nStrSize > nMax) {
										  dialog.alert(message('M2NJS1547'),[nMax, nStrSize]); //검사자의견: {0}자 이하로 입력해 주십시요.현재 입력된 길이 : {1}자 입니다.
										  return false;
										}
										return true;
									  }

									  @action
									  checkValidFacOpCd() {
										const iFacOpCdN = this.searchParams.iFacOpCdN;  //구: I_FacOpCd
										// console.log("iFacOpCdN",iFacOpCdN);
										if (iFacOpCdN === '' || iFacOpCdN.length !== 3) {
										  dialog.alert(message('M2NJS1040')); //검사Line을 2자리로 입력하세요. [예) 1A,1C,1F]
										  // document.body.querySelector('input[name=iFacOpCdN]').focus();
										  return false;
										}

										let validFacOpCd = false;
										const reSetOpCdData = this._reSetOpCdData ? this._reSetOpCdData : [];
										reSetOpCdData.map(opCd => {
										  const value = opCd.value;
										  if (value === 'ALL') {
											//skip
											//TODO ALL의 value값 체크
										  } else if (value === iFacOpCdN || ['2Q1', '4Q2', '2S5', 'A24'].includes(iFacOpCdN)) {  //검사LINE 고강도강 공정추가 20201019 경남스틸 추가
											validFacOpCd = true;
										  }
										});

										if (validFacOpCd === false) {
										  dialog.alert(message('M2NJS1549')); //검사LINE에 유효하지 않은 공장공정코드가 입력되었습니다.
										  return false;
										}

										if (iFacOpCdN.substring(1, 2) === '5') { // 포장
										  dialog.alert(message('M2NJS1039')); //검사Line에 포장Line은 입력할 수 없습니다.
										  // document.body.querySelector('input[name=iFacOpCdN]').focus();
										  return false;
										}

										return true;
									  }

									  /* 직번유효성체크무시
									   입력된 직번과 로그인 직번 체크
									  */
									  @action
									  chkInsertEmpNo() {

										const crInsporEmpNo = this.searchParams.crInsporEmpNo;
										const loginEmpNo = this._securityData ? this._securityData.userEmpNo.substring(2) : '';

										if (crInsporEmpNo === '' || crInsporEmpNo === undefined) { return false; }

										if (crInsporEmpNo.length < 6) {
										  dialog.alert(message('M2NJS1034')); // 검사자직번을 6자리로 입력하세요.
										  this.searchParams = { ...this.searchParams, crInsporEmpNo: '' };
										  document.body.querySelector('input[name=crInsporEmpNo]').focus();
										  return false;
										}

										if (crInsporEmpNo !== loginEmpNo) {
										  dialog.alert(message('M2NJS1616'));
										  this.searchParams = { ...this.searchParams, crInsporEmpNo: loginEmpNo };
										  document.body.querySelector('input[name=crInsporEmpNo]').focus();
										  return false;
										}
										return true;
									  }


									  /* 이상재카드번호 LOV를 조회
									  *  구:[custom].PosGetAbnlMtlCardNoList
									  */
									  // @action
									  // getAbnlMtlCardNoList() {
									  //   console.log('getAbnlMtlCardNoList');
									  //
									  //   const selectedDate = this.searchParams.selectedDate;
									  //   const params = {
									  //     operFlag: this._securityData.operFlag,
									  //     facOpCdN: this.searchParams.selectedOpCdData,
									  //     mtlNo: this.searchParams.pMtlNo4Query,
									  //     jdgTp: this.searchParams.jdgTp,
									  //     dateFrom: selectedDate !== '&' ? this.searchParams.selectedDate[0] : '',
									  //     dateTo: selectedDate !== '&' ? this.searchParams.selectedDate[1] : '',
									  //   };
									  //
									  //   return this.repository.getAbnlMtlCardNoList(params)
									  //     .then((abnlCardNoListResult) => {
									  //       this._abnlCardNoListResult = abnlCardNoListResult;
									  //
									  //       let cardNoList = [];
									  //       abnlCardNoListResult.map((data, i) => {
									  //         cardNoList = cardNoList.concat({ key: i, text: data.cardNo, value: data.cardNo });
									  //       });
									  //       this._cardNoLov = cardNoList;
									  //
									  //       if (abnlCardNoListResult.length > 0) {
									  //         //cardNo setting
									  //         this.searchParams = { ...this.searchParams, cardNo: abnlCardNoListResult[0].cardNo };
									  //
									  //         if (this.searchParams.mtlNo !== '') {
									  //           console.log('Card NO LOV 조회일경우');
									  //           this.searchParams = {
									  //             ...this.searchParams,
									  //             mtlNo: abnlCardNoListResult[0].mtlNo,
									  //             facOpCdN: abnlCardNoListResult[0].facOpCdN,
									  //             crAbnorOcrDate: abnlCardNoListResult[0].crAbnorOcrDate,
									  //           };
									  //         }
									  //       }
									  //     });
									  // }
									}

									export default ViewRegisterAbnormalMaterialCardStore;
									
		View--Standard MobX:
									
									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { Button, ControlLine } from '@mes/mes-ui-react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';
									import ButtonM2n0009016 from '../../common/render/ButtonM2n0009016';
									import ButtonM2n0009058 from '../../common/render/ButtonM2n0009058';
									import ButtonM2n0009057 from '../../common/render/ButtonM2n0009057';

									@mesAutobind
									@observer
									class ButtonView extends Component {
									  render() {

										/* 함수 */
										const { onBtnRegister, onBtnDelete, setSearchParam, findAllRowData, optionsCrEucCngBadF } = this.props; //new
										const { searchParams, abnomalCardInfo, securityData } = this.props;

										const nsFkey = securityData ? securityData.nsFkey : '';
										const newFlag = searchParams.newFlag;
										const confirmFlag1 = searchParams.confirmFlag1;
										const confirmFlag2 = searchParams.confirmFlag2;
										const steelGroup = abnomalCardInfo ? abnomalCardInfo.steelGroup : '';
										const avAcCd = searchParams.avAcCd;

										// 이상재 판정
										const selectedRows = [];
										if(abnomalCardInfo) {
										  selectedRows.push(abnomalCardInfo);
										}

										return (
										  <ControlLine
											leftItems={[
											  <ButtonM2n0009016
												//카드작성
												searchParams={searchParams}
												securityData={securityData}
												setViewRegisterCardSearchParam={setSearchParam}
												findAllRowData={findAllRowData}
											  />,
											  newFlag && (
												<Button
												  content="등록"
												  onClick={onBtnRegister}
												/>
											  ),
											  (!newFlag && nsFkey === 'm2n0000046_f002'? // 20201019 판정전일때만 삭제 가능
												<Button
												  content="삭제"
												  onClick={onBtnDelete}
												/>: ""
											  ),
											  // <Button content="SDD 실적" />,
											  // <Button content="기술해석Data" />,
											  (!newFlag && (confirmFlag1 || confirmFlag2)) && (
												(steelGroup === 'S') ? (
												  // 이상재판정
												  // openJdgPopup
												  <ButtonM2n0009058 //STS강
													// mtlNo={searchParams.mtlNo}
													// crAbnorOcrDate={searchParams.crAbnorOcrDate}
													facOpCdN={searchParams.selectedOpCdData}
													operFlag={securityData.operFlag}
													// orderHeadLineNo={searchParams.orderHeadLineNo}
													findAllRowData={findAllRowData}
													securityData={securityData}
													selectedRows={selectedRows}
													selectedFacData={searchParams.selectedFacData}
													optionsCrEucCngBadF={optionsCrEucCngBadF}
												  />) : (
													<ButtonM2n0009057 //탄소강
													  operFlag={securityData.operFlag}
													  facOpCdN={searchParams.selectedOpCdData}
													  selectedFacData={searchParams.selectedFacData}
													  securityData={securityData}
													  selectedRows={selectedRows}
													  findAllRowData={findAllRowData}
													  optionsCrEucCngBadF={optionsCrEucCngBadF}
													  // mtlNo={searchParams.mtlNo}
													  // crAbnorOcrDate={searchParams.crAbnorOcrDate}
													  // orderHeadLineNo={searchParams.orderHeadLineNo}
													/>)
											  ),
											]}
											rightItems={[
											  // <Button content="엑셀 다운로드" />,
											]}
										  />
										);
									  }
									}

									export default ButtonView;



									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { toJS } from 'mobx';
									import { DatePicker, Input, Label, SearchBox, Select } from '@mes/mes-ui-react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';

									@mesAutobind
									@observer
									class SearchView extends Component {
									  static defaultProps = {
										jdgTpSelectOptions: [
										  { value: 'ALL', text: '전체' },
										  { value: 'N', text: '판정전' },
										  { value: 'Y', text: '판정후' },
										  { value: 'I', text: '전달용' },
										],
									  };

									  render() {
										/* 변수 */
										const {
										  facData, reSetOpCdData, searchParams, cardNoLov,
										  abnlCardNoListResult,
										} = this.props;

										/* 함수 */
										const {
										  onChangeFacLov, onChangeOpCdLov, findAllRowData, onChangeDate,
										  onChangeInputData, onChangeAbnomalCard, onChangeSearchData,
										} = this.props;

										return (
										  <SearchBox onSearch={findAllRowData}>
											<SearchBox.Fields>
											  <SearchBox.Field>
												<Label content="공장" />
												<Select
												  options={facData}
												  value={searchParams.selectedFacData}
												  onChange={onChangeFacLov}
												  placeholder="선택하세요"
												/>
											  </SearchBox.Field>
											  <SearchBox.Field>
												<Label content="공정" />
												<Select
												  options={reSetOpCdData}
												  value={searchParams.selectedOpCdData}
												  onChange={onChangeOpCdLov}
												  placeholder="선택하세요"
												/>
											  </SearchBox.Field>
											  <SearchBox.Field>
												<Label content="판정" />
												<Select
												  name="jdgTp"
												  options={this.props.jdgTpSelectOptions}
												  value={searchParams.jdgTp}
												  onChange={onChangeSearchData}
												/>
											  </SearchBox.Field>
											  <SearchBox.Field className={searchParams.jdgTp === 'N' ? 'hide' : ''}>
												<Label content="발생일" />
												<DatePicker
												  period
												  value={toJS(searchParams.selectedDate)}
												  onChange={date => onChangeDate(date, 'selectedDate')}
												>
												  <Input
													icon="calendar alternate outline"
													className="datepicker input-period"
													placeholder="YYYY.MM.DD ~ YYYY.MM.DD"
												  />
												</DatePicker>
											  </SearchBox.Field>
											  <SearchBox.Field>
												<Label content="재료번호" />
												<Input
												  name="pMtlNo4Query"
												  onChange={onChangeSearchData}
												  value={searchParams.pMtlNo4Query}
												  case="Upper"
												  // size="14"
												  maxLength="13"
												/>
											  </SearchBox.Field>
											  <SearchBox.Field>
												<Label content="이상재카드 NO" />
												{abnlCardNoListResult ? (
												  <Select
													name="cardNo"
													width={170}
													value={searchParams.cardNo}
													options={cardNoLov}
													onChange={onChangeAbnomalCard}
												  />
												) : (
												  <Select
													name="cardNo"
													width={170}
													options={cardNoLov}
												  />
												)}
											  </SearchBox.Field>
											</SearchBox.Fields>
										  </SearchBox>
										);
									  }
									}

									export default SearchView;




									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { observer } from 'mobx-react';
									import { Popup } from '@mes/mes-ui-react';
									import { mesAutobind } from '@mes/mes-shared';
									import moment from 'moment';
									import ALink from '../../common/render/ALink';

									@mesAutobind
									@observer
									class TableView extends Component {
									  render() {
										const { abnomalCardInfo, searchParams } = this.props;

										// 코일이력조회 화면
										let screenId = 'm2n0000087';
										let screenTitle = '냉연 코일이력정보조회';
										const opCds = ['153', '1F1', '351', '3F1', '156', '1F2', '157', '1F3', '124'];
										if (searchParams.worksCode === 'K' && opCds.includes(searchParams.iFacOpCdN)) { // 산세 공장인경우
										  screenId = 'm2nd010092';
										  screenTitle = '산세 코일이력정보조회';
										}

										return (
										  <div className="table-row fixed">
											<table className="ui table center">
											  <colgroup>
												<col style={{ width: '7.5%' }} />
												<col />
												<col />
												<col style={{ width: '6.5%' }} />
												<col />
												<col />
												<col />
												<col />
												<col />
												<col />
												<col />
												<col style={{ width: '7%' }} />
												<col />
												<col />
												<col />
												<col />
											  </colgroup>
											  {

											  }
											  <tbody>
												<tr>
												  <th>재료번호</th>
												  <th>소재두께</th>
												  <th>소재폭</th>
												  <th>소재길이</th>
												  <th>처리량</th>
												  <th>제품두께</th>
												  <th>제품폭</th>
												  <th>생산량</th>
												  <th>작업일시</th>
												  <th>근무조</th>
												  <th>이상원인</th>
												  <th>조치코드</th>
												  <th>차공정</th>
												  <th>Tracking Code</th>
												  <th>저장위치</th>
												  <th>계획공정</th>
												</tr>
												<tr>
												  <td>{ALink({
													value: abnomalCardInfo ? abnomalCardInfo.mtlNo || '' : '',
													screenId: screenId, // 코일이력정보조회 화면 ID (냉연/산세)
													screenTitle: screenTitle,
													parameters: '&mtlNo=' + (abnomalCardInfo ? abnomalCardInfo.mtlNo || '' : ''),
												  })}
												  </td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crClMatThk ? abnomalCardInfo.crClMatThk.toFixed(3) :'' : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crClMatW ? abnomalCardInfo.crClMatW.toFixed(1) : '' : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crClMatLen : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crMatPrcQt : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crThk ? abnomalCardInfo.crThk.toFixed(3): '' : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crWth ? abnomalCardInfo.crWth.toFixed(1): '' : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crNetActualWgt : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.opDnDt !== undefined? moment(abnomalCardInfo.opDnDt).format('YYMMDD HH:mm') :  moment(abnomalCardInfo.crAbnorOcrDate).format('YYMMDD HH:mm'): "" }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.opSft : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.avOcrCauCd : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.avAcCd : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.nextFacOpCdN : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.trackingCode : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.streLocCd : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.planPassFacOpCdN : ''}</td>
												</tr>
												<tr>
												  <th>Orderline No</th>
												  <th>주문두께</th>
												  <th>주문폭</th>
												  <th>내경</th>
												  <th>재질기호</th>
												  <th>표면사상</th>
												  <th>조질도</th>
												  <th>포장범위</th>
												  <th>용도</th>
												  <th>후처리</th>
												  <th>도유</th>
												  <th>SLEEVE</th>
												  <th>EDGE</th>
												  <th>표면등급</th>
												  <th>형상등급</th>
												  <th>통과공정</th>
												</tr>
												<tr>
												  <td>{abnomalCardInfo ? abnomalCardInfo.orderHeadLineNo : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.orderThick ? abnomalCardInfo.orderThick.toFixed(3) : '' : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.orderWidth ? abnomalCardInfo.orderWidth.toFixed(1) : '' : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.orderInnerDiameter : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.poscoProdGrdN : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.surfaceFinishCd : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.tempGrade : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.prodStdPackTol : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.orderUsageCdN : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.postTreatmentMethodCdN : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.oilingMethodCd : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.sleeveInsertFlag : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.crIndiDesignEdge : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.surfaceGrd : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.shapeGrd : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.passFacOpCdN : ''}</td>
												</tr>
												<tr>
												  <th>SLAB NO</th>
												  <th>품명</th>
												  <th>포장방법</th>
												  <th>Hot Coil No</th>
												  <th>열연일자</th>
												  <th>열연중량</th>
												  <th>출강목표</th>
												  <th>STS평점</th>
												  <th>평탄</th>
												  <th>보증</th>
												  <th>전략제품</th>
												  <th>이상발생 일시</th>
												  <th>고객사</th>
												  <th>잔여공정</th>
												  <th>소둔차수</th>
												  <th>등록횟수</th>
												</tr>
												<tr>
												  <td>{abnomalCardInfo ? abnomalCardInfo.slabNo : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.productNameCode : ''}</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.packingType : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.hotCoilNo : '' }</td>
												  <td>{abnomalCardInfo ? moment(abnomalCardInfo.hrRollDate).format('YYMMDD') : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.hrClWgt : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.smSteelGrdN : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.stsSurAvp : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.stsFlatdSvyV : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.stsGuaranteeSurfaceFlag : '' }</td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.strProductClsCd : '' }</td>
												  <td>{abnomalCardInfo ? moment(abnomalCardInfo.crAbnorOcrDate).format('YYMMDD HH:mm') : '' }</td>
												  <td>
													<Popup
													  trigger={<span className="tooltipTxt">{abnomalCardInfo ? abnomalCardInfo.customerNumber : '' }</span>}
													  hoverable
													  content={abnomalCardInfo ? abnomalCardInfo.endUserName : '' }
													/>
												  </td>
												  <td>{abnomalCardInfo ? abnomalCardInfo.remFacOpCdN : '' }</td>
												  <td />
												  <td />
												</tr>
											  </tbody>
											</table>
										  </div>
										);
									  }
									}

									export default TableView;



									/* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { Input, Select } from '@mes/mes-ui-react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';
									import moment from 'moment';

									@mesAutobind
									@observer
									class TableView extends Component {
									  static defaultProps = {
										selectOptionsExist: [
										  { value: '', text: '　' },
										  { value: 'Y', text: '있음' },
										  { value: 'N', text: '없음' },
										],
										optionsLenDirDefOcrShpTp: [
										  { value: '', text: '　' },
										  { value: 'T', text: 'TOP' },
										  { value: 'M', text: 'MIDDLE' },
										  { value: 'B', text: 'BOTTOM' },
										  { value: 'A', text: '전장' },
										  { value: 'R', text: '산발적' },
										],
										optionsWDirtDefOcrLocTp: [
										  { value: '', text: '　' },
										  { value: 'W', text: 'W/S' },
										  { value: 'C', text: 'CENTER' },
										  { value: 'D', text: 'D/S' },
										  { value: 'A', text: '판전면적' },
										],
										optionsDifSurTp: [
										  { value: '', text: '　' },
										  { value: 'F', text: '전면' },
										  { value: 'B', text: '이면' },
										  { value: 'A', text: '전,이면 모두' },
										  { value: 'S', text: '측면' },
										],
										optionsDefCorF: [
										  { value: '', text: '　' },
										  { value: 'A', text: '흑색' },
										  { value: 'B', text: '갈색' },
										  { value: 'C', text: '청색' },
										  { value: 'D', text: '황색' },
										  { value: 'E', text: '백색' },
										  { value: 'F', text: '적색' },
										  { value: 'G', text: '유백색' },
										  { value: 'H', text: '기타' },
										],
										optionsDefFigF: [
										  { value: '', text: '　' },
										  { value: '5', text: '극심' },
										  { value: '4', text: '심함' },
										  { value: '3', text: '약함' },
										  { value: '2', text: '흔적' },
										  { value: '1', text: '촉감없음' },
										],
										optionsShpBadWDirtLocTp: [
										  { value: '', text: '　' },
										  { value: 'W', text: 'W/S' },
										  { value: 'C', text: 'CENTER' },
										  { value: 'D', text: 'D/S' },
										  { value: 'Q', text: 'Q/B' },
										],
										optionsIncongruentProdFetchLocTp: [
										  { value: '', text: '　' },
										  { value: 'E', text: '입측' },
										  { value: 'D', text: '출측' },
										],
										optionsIncongruentProdFetchLocTp2: [
										  { value: '', text: '　' },
										  { value: 'E', text: '입측' },
										  { value: 'D', text: '출측' },
										  { value: 'X', text: '미포장' },
										  { value: 'Y', text: '포장완료' },
										],
									  };

									  render() {
										const { abnomalCardInfo, searchParams, showItemLov, optionsCrEucCngBadF } = this.props; // 변수
										const { onChangeInputData, onChangeInputNumberData, chkInsertEmpNo } = this.props; // 함수
										const preserveFlag = searchParams.preserveFlag;
										const newFlag = searchParams.newFlag;

										// 발생공정 getCrDefOcrOpCdLov
										let defOcrOpCdLov = [];
										const opCds = ['153', '1F1', '351', '3F1', '156', '1F2', '157', '1F3', '124'];
										// console.log("발생공정세팅 전 공장구분::",searchParams);
										if (searchParams.worksCode === 'K' && opCds.includes(searchParams.iFacOpCdN)) {
										  defOcrOpCdLov = showItemLov.hrDefOcrOpCdLov;
										} else {
										  defOcrOpCdLov = showItemLov.crDefOcrOpCdLov;
										}

										let crEucCngBadFShowFlag = false;
										// 조회할 재료의 공장공정코드가 2P1,2V1,2V2,221 일때 냉연공정재변경불가여부를 표출
										if (abnomalCardInfo && ["2P1","2V1","2V2","221"].includes(abnomalCardInfo.facOpCdN)) {
										  crEucCngBadFShowFlag = true;
										}
										return (
										  <div className="table-row fixed">
											<table className="ui table center">
											  <tbody>
												<tr>
												  <th className="red">결함코드</th>
												  <th className="red" title="이상재발생 원인재공 공정을 의미">발생공정</th>
												  <th className="red" title="이상재카드 카드작성 공정을 의미">검사LINE</th>
												  <th className="red">검사자직번</th>
												  <th>작성일시</th>
												  <th className="red">근무조</th>
												  <th>조치코드</th>
												  <th />
												</tr>
												{(preserveFlag || newFlag) ? (
												  <tr>
													<td>
													  {/* 결함코드 */}
													  <Input
														type="text"
														name="crDefCd"
														case="Upper"
														value={searchParams.crDefCd ? searchParams.crDefCd : '' }
														// size="8"
														maxLength="2"
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  {/* 발생공정 */}
													  <Select
														placeholder="select"
														name="crDefOcrOpCd"
														onChange={onChangeInputData}
														options={defOcrOpCdLov}
														value={searchParams.crDefOcrOpCd ? searchParams.crDefOcrOpCd : '' }
													  />
													</td>
													<td>
													  <Input
														type="text"
														name="iFacOpCdN"
														case="Upper"
														value={searchParams.iFacOpCdN ? searchParams.iFacOpCdN : ''}
														onChange={onChangeInputData}
														  // size="8"
														maxLength="3"
													  />
													</td>
													<td>
													  <Input
														type="text"
														name="crInsporEmpNo"
														case="Upper"
														value={searchParams.crInsporEmpNo ? searchParams.crInsporEmpNo : ''}
														onChange={onChangeInputData}
														onBlur={chkInsertEmpNo}
														  // size="8"
														maxLength="6"
													  />
													</td>
													<td>
													  {moment().format('YYYY-MM-DD HH:mm:ss')}
													</td>
													<td>
													  <Input
														type="text"
														name="opSft"
														case="Upper"
														value={searchParams.opSft ? searchParams.opSft : ''}
														onChange={onChangeInputData}
														// size="6"
														maxLength="2"
													  />
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.avAcCd : ''}
													</td>
													<td />
												  </tr>) : (
													<tr>
													  <td>
														{searchParams.crDefCd}
													  </td>
													  <td>
														{/* 발생공정 */}
														{abnomalCardInfo ? abnomalCardInfo.crDefOcrOpCd : ''}
													  </td>
													  <td>
														{/*//TODO check*/}
														{abnomalCardInfo ? abnomalCardInfo.facOpCdN : ''}
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.crInsporEmpNo : ''}
													  </td>
													  <td>
														{abnomalCardInfo ? moment(abnomalCardInfo.otOrdPrdRsitDt).format('YYYY-MM-DD HH:mm:ss') : ' '}
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.opSft : ''}
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.avAcCd : ''}
													  </td>
													  <td />
													</tr>
												)}


												<tr>
												  <th>발생정도</th>
												  <th>발생위치</th>
												  <th>발생부위</th>
												  <th>PITCH</th>
												  <th>발생개소</th>
												  <th>크기</th>
												  <th>박리</th>
												  <th>색상</th>
												</tr>
												{(preserveFlag || newFlag) ? (
												  <tr>
													<td>
													  <Select
														placeholder="select"
														name="lenDirDefOcrShpTp"
														value={searchParams.lenDirDefOcrShpTp}
														options={this.props.optionsLenDirDefOcrShpTp}
														onChange={onChangeInputData}
														width="60%"
													  />
													  <Input
														type="text"
														name="lenDirDefOcrQt"
														value={searchParams.lenDirDefOcrQt ? searchParams.lenDirDefOcrQt : ''}
														onChange={onChangeInputNumberData}
														// size="1"
														maxLength="2"
														width="20%"
													  />
													  Ton
													</td>
													<td>
													  <Select
														placeholder="select"
														name="wDirtDefOcrLocTp"
														value={searchParams.wDirtDefOcrLocTp}
														options={this.props.optionsWDirtDefOcrLocTp}
														onChange={onChangeInputData}
														width="60%"
													  />
													  <Input
														type="text"
														name="wDirtDefOcrDetailLoc"
														value={searchParams.wDirtDefOcrDetailLoc ? searchParams.wDirtDefOcrDetailLoc : ''}
														onChange={onChangeInputNumberData}
														// size="5"
														maxLength="5"
														width="20%"
													  />
													  ㎜
													</td>
													<td>
													  <Select
														placeholder="select"
														name="difSurTp"
														value={searchParams.difSurTp}
														options={this.props.optionsDifSurTp}
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  <Input
														type="text"
														name="defOcrPitch"
														value={searchParams.defOcrPitch}
														onChange={onChangeInputNumberData}
													  />
													</td>
													<td>
													  1M:
													  <Input
														type="text"
														className="pxw-50"
														name="defOcrNum"
														value={searchParams.defOcrNum}
														onChange={onChangeInputNumberData}
													  />
													  개소
													</td>
													<td>
													  직경:
													  <Input
														type="text"
														className="pxw-50"
														name="defOcrSize"
														value={searchParams.defOcrSize}
														onChange={onChangeInputNumberData}
													  />
													  ㎜
													</td>
													<td>
													  <Select
														placeholder="select"
														name="defExfoliaF"
														value={searchParams.defExfoliaF}
														options={this.props.selectOptionsExist}
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  <Select
														placeholder="select"
														name="defCorF"
														value={searchParams.defCorF}
														options={this.props.optionsDefCorF}
														onChange={onChangeInputData}
													  />
													</td>
												  </tr>) : (
													<tr>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.lenDirDefOcrShpTp : ''}
														{abnomalCardInfo ? abnomalCardInfo.lenDirDefOcrQt : '' }
													  Ton
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.lenDirDefOcrShpTp : ''}
														{abnomalCardInfo ? abnomalCardInfo.wDirtDefOcrDetailLoc : ''}
													  ㎜
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.difSurTp : ''}
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.defOcrPitch : ''}
													  </td>
													  <td>
													  1M:
														{abnomalCardInfo ? abnomalCardInfo.defOcrNum : ''}
													  개소
													  </td>
													  <td>
													  직경:
														{abnomalCardInfo ? abnomalCardInfo.defOcrSize : ''}
													  ㎜
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.defExfoliaF : ''}
													  </td>
													  <td>
														{abnomalCardInfo ? abnomalCardInfo.defCorF : ''}
													  </td>
													</tr>
												)}
												<tr>
												  <th>촉감</th>
												  <th>형상</th>
												  <th colSpan="4">형상정도</th>
												  <th>Trimming 유무</th>
												  <th>도유</th>
												</tr>
												{(preserveFlag || newFlag) ? (
												  <tr>
													<td>
													  <Select
														placeholder="select"
														name="defFigF"
														value={searchParams.defFigF}
														options={this.props.optionsDefFigF}
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  <Select
														placeholder="select"
														name="shpBadWDirtLocTp"
														value={searchParams.shpBadWDirtLocTp}
														options={this.props.optionsShpBadWDirtLocTp}
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  Pitch :
													  <Input
														type="text"
														className="pxw-50"
														name="shpBadWaveMseV"
														value={searchParams.shpBadWaveMseV}
														onChange={onChangeInputNumberData}
														// size="5"
														maxLength="5"
													  />
													  ㎜
													</td>
													<td>
													  Height :
													  <Input
														type="text"
														name="shpBadWaveHgtMseV"
														value={searchParams.shpBadWaveHgtMseV}
														onChange={onChangeInputNumberData}
														className="pxw-50"
														// size="5"
														maxLength="5"
													  />
													  ㎜
													</td>
													<td>
													  급준도 :
													  <Input
														type="text"
														className="pxw-50"
														name="shpBadSteepMseV"
														value={searchParams.shpBadSteepMseV}
														onChange={onChangeInputData}
														// size="5"
														maxLength="5"
													  />
													  %
													</td>
													<td>
													  Telescope :
													  <Input
														type="text"
														className="pxw-50"
														name="tscpeMseV"
														value={searchParams.tscpeMseV}
														onChange={onChangeInputNumberData}
														// size="5"
														maxLength="5"
													  />
													  ㎜
													</td>
													<td>
													  <Select
														placeholder="select"
														name="incongruentProdSdtrmF"
														value={searchParams.incongruentProdSdtrmF}
														options={this.props.selectOptionsExist}
														onChange={onChangeInputData}
													  />
													</td>
													<td>
													  <Select
														placeholder="select"
														name="incongruentProdOilF"
														value={searchParams.incongruentProdOilF}
														options={this.props.selectOptionsExist}
														onChange={onChangeInputData}
													  />
													</td>
												  </tr>
												) : (
												  <tr>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.defFigF : ''}
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.shpBadWDirtLocTp : ''}
													</td>
													<td>
													  Pitch :
													  {abnomalCardInfo ? abnomalCardInfo.shpBadWaveMseV : ''}
													  ㎜
													</td>
													<td>
													  Height :
													  {abnomalCardInfo ? abnomalCardInfo.shpBadWaveHgtMseV : ''}
													  ㎜
													</td>
													<td>
													  급준도 :
													  {abnomalCardInfo ? abnomalCardInfo.shpBadSteepMseV : ''}
													  %
													</td>
													<td>
													  Telescope :
													  {abnomalCardInfo ? abnomalCardInfo.tscpeMseV : ''}
													  ㎜
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.incongruentProdSdtrmF : ''}
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.incongruentProdOilF : ''}
													</td>
												  </tr>
												)}

												<tr>
												  {crEucCngBadFShowFlag ? (
													<th>공정변경불가</th>
													) : ( 
													  <th />
													)
												  }
												  <th />
												  <th />
												  <th />
												  <th />
												  <th>불량폭측정</th>
												  <th>인출위치</th>
												  <th>실제중량</th>
												</tr>
												{(preserveFlag || newFlag) ? (
												  <tr>
													<td>
													  {(crEucCngBadFShowFlag && abnomalCardInfo) ? abnomalCardInfo.crEucCngBadF : ''}
													</td>
													<td />
													<td />
													<td />
													<td />
													<td>
													  <Input
														type="text"
														name="shpBadWthMseV"
														value={searchParams.shpBadWthMseV}
														onChange={onChangeInputData}
														// size="6"
														maxLength={5}
													  />
													</td>
													<td>
													  {searchParams.nextFacOpCdIsPacking === true ? (
														<Select
														  placeholder="select"
														  name="incongruentProdFetchLocTp2"
														  value={searchParams.incongruentProdFetchLocTp2}
														  options={this.props.optionsIncongruentProdFetchLocTp2}
														  onChange={onChangeInputData}
														/>
													  ) : (
														<Select
														  placeholder="select"
														  name="incongruentProdFetchLocTp"
														  value={searchParams.incongruentProdFetchLocTp}
														  options={this.props.optionsIncongruentProdFetchLocTp}
														  onChange={onChangeInputData}
														/>
													  )
													  }
													</td>
													<td>
													  <Input
														type="text"
														name="crNetTheoWgt"
														value={searchParams.crNetTheoWgt}
														onChange={onChangeInputNumberData}
														// size="6"
														maxLength="5"
													  />
													</td>
												  </tr>
												) : (
												  <tr>
													<td>
													  {(crEucCngBadFShowFlag && abnomalCardInfo) ? abnomalCardInfo.crEucCngBadF : ''}
													</td>
													<td />
													<td />
													<td />
													<td />
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.shpBadWthMseV : ''}
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.incongruentProdFetchLocTp : ''}
													</td>
													<td>
													  {abnomalCardInfo ? abnomalCardInfo.crNetTheoWgt : ''}
													</td>
												  </tr>
												)}
											  </tbody>
											</table>
										  </div>
										);
									  }
									}

									export default TableView;



									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { TextArea } from '@mes/mes-ui-react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';

									@mesAutobind
									@observer
									class TableView extends Component {
									  render() {

										const { searchParams, abnomalCardInfo } = this.props;
										const { onChangeInputData } = this.props;

										return (
										  <div className="table-row fixed">
											<table className="ui table center">
											  <thead>
												<tr>
												  <th>검사자의견</th>
												</tr>
											  </thead>
											  <tbody>
												<tr>
												  <td>
													<TextArea.Count limit={400} limitDisabled={false}>
													  {(searchParams.newFlag) ? (
														<TextArea
														  rows={5}
														  style={{ height: '169px' }}
														  name="incongruentInsporOpinion"
														  value={searchParams.incongruentInsporOpinion}
														  onChange={onChangeInputData}
														/>
													  ) : (
														<TextArea
														  rows={5}
														  style={{ height: '169px' }}
														  name="incongruentInsporOpinion"
														  value={abnomalCardInfo ? abnomalCardInfo.incongruentInsporOpinion : ''}
														  disabled
														/>
													  )}
													</TextArea.Count>
												  </td>
												</tr>
												{/*<tr>*/}
												{/*  <td>*/}
												{/*    <TextArea*/}
												{/*      rows={5}*/}
												{/*      style={{ height: '167px' }}*/}
												{/*      value={searchParams.examResult ? searchParams.examResult : ''}*/}
												{/*      disabled*/}
												{/*    />*/}
												{/*  </td>*/}
												{/*</tr>*/}
											  </tbody>
											</table>
										  </div>
										);
									  }
									}

									export default TableView;




									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';
									import { TextArea } from '@mes/mes-ui-react';
									import { JudgeTd } from '../render/m2n000046Utils';

									@mesAutobind
									@observer
									class TableView extends Component {

									  render() {
										const { abnomalCardInfo } = this.props;

										return (
										  <div className="table-row fixed">
											<table className="ui table center">
											  <colgroup>
												<col style={{ width: '200px' }} />
												<col />
												<col />
											  </colgroup>
											  <tbody>
											  <tr>
												<th colSpan="3">판정 및 지시</th>
											  </tr>
											  <tr>
												<th>품질담당</th>
												<td>
												  <JudgeTd
													avAcCd={abnomalCardInfo ? abnomalCardInfo.avAcCd : ''}
													abnrMatJdgTp={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgTp3 : ''}
													incongruentProdCardJdgDt={abnomalCardInfo ? abnomalCardInfo.incongruentProdCardJdgDt3 : ''}
													abnrMatJdgManNm={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgManNm3 : ''}
												  />
												</td>
												<td>
												  <TextArea
													rows={3}
													// cols={64}
													name="incongruentInsporOpinion"
													value={abnomalCardInfo ? (abnomalCardInfo.incongruentOpinionInstruc3 === undefined ? '' : abnomalCardInfo.incongruentOpinionInstruc3) : ''}
													readOnly
												  />
												</td>
											  </tr>
											  <tr>
												<th>파트장</th>
												<td>
												  <JudgeTd
													avAcCd={abnomalCardInfo ? abnomalCardInfo.avAcCd : ''}
													abnrMatJdgTp={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgTp2 : ''}
													incongruentProdCardJdgDt={abnomalCardInfo ? abnomalCardInfo.incongruentProdCardJdgDt2 : ''}
													abnrMatJdgManNm={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgManNm2 : ''}
												  />
												</td>
												<td>
												  <TextArea
													rows={3}
													// cols={64}
													name="incongruentInsporOpinion"
													value={abnomalCardInfo ? (abnomalCardInfo.incongruentOpinionInstruc2 === undefined ? '' : abnomalCardInfo.incongruentOpinionInstruc2) : ''}
													readOnly
												  />
												</td>
											  </tr>
											  <tr>
												<th>주임</th>
												<td>
												  <JudgeTd
													avAcCd={abnomalCardInfo ? abnomalCardInfo.avAcCd : ''}
													abnrMatJdgTp={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgTp : ''}
													incongruentProdCardJdgDt={abnomalCardInfo ? abnomalCardInfo.incongruentProdCardJdgDt : ''}
													abnrMatJdgManNm={abnomalCardInfo ? abnomalCardInfo.abnrMatJdgManNm : ''}
												  />
												</td>
												<td>
												  <TextArea
													rows={3}
													// cols={64}
													name="incongruentInsporOpinion"
													value={abnomalCardInfo ? (abnomalCardInfo.incongruentOpinionInstruc === undefined ? '' : abnomalCardInfo.incongruentOpinionInstruc) : ''}
													readOnly
												  />
												</td>
											  </tr>
											  </tbody>
											</table>
										  </div>
										);
									  }
									}

									export default TableView;




									/*================================================================================
									* @화면ID(명): m2n0000046(냉연 이상재카드 조회 및 등록)
									* Change history
									* @수정 날짜;SR_NO;수정자;수정내용
									* @2005-01-26;12970;;source code comment수정
									* @2005-09-02;23261;;검사Line에러체크
									* @2006-03-21;30509;;loadApplet사용
									* @2006-09-06;33474;;if (checkRetry()) { 추가
									* @2007-02-09;47695;;화면Message Master적용
									* @2007-07-18;SCR0013512;;결함6 추가
									* @2008-07-16;WO0271626;;주문의 전략제품 부분 추가.
									* @2009-04-10;WO0534096;;3전기강판 추가 (반제품실적처리)
									* @2010-08-26;WO1817303;;전사제품품종관리체계관리개선 관련 수정
									* @2011-04-12;WO;;광양4POL설비신설전산화 관련 수정
									* @2012-02-19;WO2383128;;포CGL설비신설전산화개발관련 수정 url추가 goSMGPage()
									* @2012-05-04;WO2454043;;윈도우7적용관련 화면수정
									* @2012-09-04;WO2567101;;결함발생공장공정 OperFlag체크
									* @2016-04-26;WO3477753;로그인직번 CHECK
									* @2016-06-28;포항CGL전장보증프로젝트;;PO판정을 위해 외관판정pop 호출시 주문번호 Param 추가
									* @2016-04-26;;;검사LINE 고강도강 공정추가
									* @2018-10-11;SR20180901842;;임가공사(한양철강,대림철강)단미제품 이상재 관리
									* @2019-02-21;SR20190100671;;Win10 업그레이드 MES 화면 수정
									* @2019-06-17;00000;류재욱;MES3.0 React 최초생성
									==================================================================================*/

									import React, { Component } from 'react';
									import { TextArea } from '@mes/mes-ui-react';
									import { observer } from 'mobx-react';
									import { mesAutobind } from '@mes/mes-shared';

									@mesAutobind
									@observer
									class TableView extends Component {
									  render() {

										const { searchParams, abnomalCardInfo } = this.props;
										const { onChangeInputData } = this.props;

										return (
										  <div className="table-row fixed">
											<table className="ui table center">
											  {/*<thead>*/}
											  {/*  <tr>*/}
											  {/*    <th>검사자의견</th>*/}
											  {/*  </tr>*/}
											  {/*</thead>*/}
											  <tbody>
												{/*<tr>*/}
												{/*  <td>*/}
												{/*    <TextArea.Count limit={400} limitDisabled={false}>*/}
												{/*      {(searchParams.newFlag) ? (*/}
												{/*        <TextArea*/}
												{/*          rows={5}*/}
												{/*          style={{ height: '167px' }}*/}
												{/*          name="incongruentInsporOpinion"*/}
												{/*          value={searchParams.incongruentInsporOpinion}*/}
												{/*          onChange={onChangeInputData}*/}
												{/*        />*/}
												{/*      ) : (*/}
												{/*        <TextArea*/}
												{/*          rows={5}*/}
												{/*          style={{ height: '167px' }}*/}
												{/*          name="incongruentInsporOpinion"*/}
												{/*          value={abnomalCardInfo ? abnomalCardInfo.incongruentInsporOpinion : ''}*/}
												{/*          disabled*/}
												{/*        />*/}
												{/*      )}*/}
												{/*    </TextArea.Count>*/}
												{/*  </td>*/}
												{/*</tr>*/}
												<tr>
												  <td>
													<TextArea
													  rows={5}
													  style={{ height: '200px' }}
													  value={searchParams.examResult ? searchParams.examResult : ''}
													  disabled
													/>
												  </td>
												</tr>
											  </tbody>
											</table>
										  </div>
										);
									  }
									}

									export default TableView;

Typescript---:

									- TypeScript is transpiled into JavaScript using a compiler.
									- TypeScript is JavaScript with added syntax for types.
									- JavaScript is a loosely typed language. It can be difficult to understand what types of data are being passed around in JavaScript.
									- In JavaScript, function parameters and variables don't have any information! So developers need to look at documentation, or guess based on the implementation.
									- TypeScript allows specifying the types of data being passed around within the code, and has the ability to report errors when the types don't match.
									- For example, TypeScript will report an error when passing a string into a function that expects a number. JavaScript will not.

	Installing the Compiler:
							
									npm install typescript --save-dev

	Arrays--Typescript:
	
									const names: string[] = [];
									names.push("Dylan"); // no error
									names.push(3); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.
									console.log(names);

		Readonly:
		
									The readonly keyword can prevent arrays from being changed.
									
									const names: readonly string[] = ["Dylan"];
									names.push("Jack"); // Error: Property 'push' does not exist on type 'readonly string[]'.
									// try removing the readonly modifier and see if it works?
									console.log(names);
									
		Type Inference:
		
									TypeScript can infer the type of an array if it has values.
									
									const numbers = [1, 2, 3]; // inferred to type number[]
									numbers.push(4); // no error
									// comment line below out to see the successful assignment 
									numbers.push("2"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
									console.log(numbers);
									let head: number = numbers[0]; // no error
									console.log(head);
									
	Basic Generics--Typescript:
	
									- Generics allow creating 'type variables' which can be used to create classes, functions & type aliases that don't need to explicitly define the types that they use.
									- Generics makes it easier to write reusable code.
									
		Functions:
		
									- Generics with functions help make more generalized methods which more accurately represent the types used and returned.
									- TypeScript can also infer the type of the generic parameter from the function parameters.
									
									function createPair<S, T>(v1: S, v2: T): [S, T] {
									  return [v1, v2];
									}
									console.log(createPair<string, number>('hello', 42)); // ['hello', 42]
									
		Classes:
		
									- Generics can be used to create generalized classes, like Map.
									- TypeScript can also infer the type of the generic parameter if it's used in a constructor parameter.
									
									class NamedValue<T> {
									  private _value: T | undefined;
									  constructor(private name: string) {}
									  public setValue(value: T) {
										this._value = value;
									  }
									  public getValue(): T | undefined {
										return this._value;
									  }
									  public toString(): string {
										return `${this.name}: ${this._value}`;
									  }
									}									 
									const value = new NamedValue<number>('myNumber');
									value.setValue(10);
									console.log(value.toString()); // myNumber: 10
									
		Type Aliases:
		
									- Generics in type aliases allow creating types that are more reusable.
									
									type Wrapped<T> = { value: T };
									const wrappedValue: Wrapped<number> = { value: 10 };
									
		Default Value:
		
									Generics can be assigned default values which apply if no other value is specified or inferred.
									
									class NamedValue<T = string> {
									  private _value: T | undefined;
									  constructor(private name: string) {}
									  public setValue(value: T) {
										this._value = value;
									  }
									  public getValue(): T | undefined {
										return this._value;
									  }
									  public toString(): string {
										return `${this.name}: ${this._value}`;
									  }
									}
									let value = new NamedValue('myNumber');
									value.setValue('myValue');
									console.log(value.toString()); // myNumber: myValue
									
		Extends:
		
									- Constraints can be added to generics to limit what's allowed. The constraints make it possible to rely on a more specific type when using the generic type.
									- This can be combined with a default value.
									
									function createLoggedPair<S extends string | number, T extends string | number>(v1: S, v2: T): [S, T] {
									  console.log(`creating pair: v1='${v1}', v2='${v2}'`);
									  return [v1, v2];
									}
									
	Casting--Typescript:
	
									- There are times when working with types where it's necessary to override the type of a variable, such as when incorrect types are provided by a library.
									- Casting is the process of overriding a type.
									
		Casting with as:
		
			A straightforward way to cast a variable is using the as keyword, which will directly change the type of the given variable.
			
									let x: unknown = 'hello';
									console.log((x as string).length); // 5
									
			Casting doesn't actually change the type of the data within the variable, for example the following code will not work as expected since the variable x is still holds a number.
			
									let x: unknown = 4;
									console.log((x as string).length); // prints undefined since numbers don't have a length
				
			TypeScript will still attempt to typecheck casts to prevent casts that don't seem correct, for example the following will throw a type error since TypeScript knows casting a string to a number doesn't makes
			sense without converting the data:
			
									console.log((4 as string).length); // Error: Conversion of type 'number' to type 'string' may be a mistake because neither type sufficiently overlaps with the other.
																	   // If this was intentional, convert the expression to 'unknown' first.
																	   
		Casting with <>:
		
									- Using <> works the same as casting with as.
									- This type of casting will not work with TSX, such as when working on React files.
									
									let x: unknown = 'hello';
									console.log((<string>x).length); // 5
									
		Force casting:
		
									To override type errors that TypeScript may throw when casting, first cast to unknown, then to the target type.
									
									let x = 'hello';
									console.log(((x as unknown) as number).length); // x is not actually a number so this will return undefined
									
									let x = '123';
									console.log(((x as unknown) as string).length); // x is not actually a number so this will return undefined
									
	Classes--Typescript:
	
									TypeScript adds types and visibility modifiers to JavaScript classes.
									
		Members: Types--Classes Typescript:
		
									The members of a class (properties & methods) are typed using type annotations, similar to variables.
									
									class Person {
									  name: string;
									}								  
									const person = new Person();
									person.name = "Jane";
									console.log(person);
									
		Members: Visibility--Classes Typescript:
		
									- Class members also be given special modifiers which affect visibility.
									- The this keyword in a class usually refers to the instance of the class.
									- There are three main visibility modifiers in TypeScript.
											public - (default) allows access to the class member from anywhere
											private - only allows access to the class member from within the class
											protected - allows access to the class member from itself and any classes that inherit it, which is covered in the inheritance section below
											
									class Person {
									  private name: string;
									  public constructor(name: string) {
										this.name = name;
									  }
									  public getName(): string {
										return this.name;
									  }
									}									 
									const person = new Person("Jane");
									console.log(person.getName()); // person.name isn't accessible from outside the class since it's private
									
		Parameter Properties--Classes Typescript:
		
									TypeScript provides a convenient way to define class members in the constructor, by adding a visibility modifiers to the parameter.
									
									class Person {
									  // name is a private member variable
									  public constructor(private name: string) {}
									  public getName(): string {
										return this.name;
									  }
									}									  
									const person = new Person("Jane");
									console.log(person.getName()); // Jane
									
		Readonly--Classes Typescript:
		
									Similar to arrays, the readonly keyword can prevent class members from being changed.
									
									class Person {
									  private readonly name: string;
									  public constructor(name: string) {
										// name cannot be changed after this initial definition, which has to be either at it's declaration or in the constructor.
										this.name = name;
									  }
									  public getName(): string {
										return this.name;
									  }
									}									  
									const person = new Person("Jane");
									console.log(person.getName()); // Jane
									
		Inheritance: Implements--Classes Typescript:
		
									- Interfaces can be used to define the type a class must follow through the implements keyword.
									- A class can implement multiple interfaces by listing each one after implements, separated by a comma like so: class Rectangle implements Shape, Colored {}
									
									interface Shape {
									  getArea: () => number;
									}
									class Rectangle implements Shape {
									  public constructor(protected readonly width: number, protected readonly height: number) {}
									  public getArea(): number {
										return this.width * this.height;
									  }
									}
									const myRect = new Rectangle(10,20);
									console.log(myRect.getArea());
									
		Inheritance: Extends--Classes Typescript:
		
									Classes can extend each other through the extends keyword. A class can only extends one other class.
									
									interface Shape {
									  getArea: () => number;
									}									  
									class Rectangle implements Shape {
									  public constructor(protected readonly width: number, protected readonly height: number) {}
									  public getArea(): number {
										return this.width * this.height;
									  }
									}									  
									class Square extends Rectangle {
									  public constructor(width: number) {
										super(width, width);
									  }
									  // getArea gets inherited from Rectangle
									}
									const mySq = new Square(20);
									console.log(mySq.getArea()); // 400
									
		Override--Classes Typescript:
		
									- When a class extends another class, it can replace the members of the parent class with the same name. Newer versions of TypeScript allow explicitly marking this with the override keyword.
									- By default the override keyword is optional when overriding a method, and only helps to prevent accidentally overriding a method that does not exist. Use the setting noImplicitOverride
									to force it to be used when overriding.
									
									interface Shape {
									  getArea: () => number;
									}
									class Rectangle implements Shape {
									  // using protected for these members allows access from classes that extend from this class, such as Square
									  public constructor(protected readonly width: number, protected readonly height: number) {}
									  public getArea(): number {
										return this.width * this.height;
									  }
									  public toString(): string {
										return `Rectangle[width=${this.width}, height=${this.height}]`;
									  }
									}
									class Square extends Rectangle {
									  public constructor(width: number) {
										super(width, width);
									  }
									  // this toString replaces the toString from Rectangle
									  public override toString(): string {
										return `Square[width=${this.width}]`;
									  }
									}
									const mySq = new Square(20);
									console.log(mySq.toString()); // Square[width=20]
									
		Abstract Classes--Classes Typescript:

									- Classes can be written in a way that allows them to be used as a base class for other classes without having to implement all the members. This is done by using the abstract keyword.
									Members that are left unimplemented also use the abstract keyword.
									- Abstract classes cannot be directly instantiated, as they do not have all their members implemented.
									
									abstract class Polygon {
									  public abstract getArea(): number;
									  public toString(): string {
										return `Polygon[area=${this.getArea()}]`;
									  }
									}
									class Rectangle extends Polygon {
									  public constructor(protected readonly width: number, protected readonly height: number) {
										super();
									  }
									  public getArea(): number {
										return this.width * this.height;
									  }
									}
									const myRect = new Rectangle(10,20);
									console.log(myRect.getArea()); // 200
									
	Enums--Typescript:
	
									- An enum is a special "class" that represents a group of constants (unchangeable variables).
									- Enums come in two flavors string and numeric.
									
		Numeric Enums - Default--Enums Typescript:
		
									By default, enums will initialize the first value to 0 and add 1 to each additional value:
									
									enum CardinalDirections {
									  North,
									  East,
									  South,
									  West
									};												
									let currentDirection = CardinalDirections.North;
									// North is the first value so it logs '0'
									console.log(currentDirection); // 0
									// throws error when commented in as 'North' is not a valid enum
									// currentDirection = 'North'; 
									// Error: "North" is not assignable to type 'CardinalDirections'.
									
		Numeric Enums - Initialized--Enums Typescript:
		
									You can set the value of the first numeric enum and have it auto increment from that:
									
									enum CardinalDirections {
									  North = 1,
									  East,
									  South,
									  West
									};
									// logs 1 since we initialized the first value to something other than '0'
									console.log(CardinalDirections.North); // 1
									// logs 4 as it continued on from the initial '1' value
									console.log(CardinalDirections.West); // 4
									
		Numeric Enums - Fully Initialized--Enums Typescript:
		
									enum StatusCodes {
									  NotFound = 404,
									  Success = 200,
									  Accepted = 202,
									  BadRequest = 400,
									  Demo
									};
									console.log(StatusCodes.NotFound); // 404
									console.log(StatusCodes.Success); // 200
									console.log(StatusCodes.Demo); // 401
									
		String Enums--Enums Typescript:
		
									Enums can also contain strings. This is more common than numeric enums, because of their readability and intent.
									
									enum CardinalDirections {
									  North = 'North',
									  East = "East",
									  South = "South",
									  West = "West"
									};
									console.log(CardinalDirections.North); // North
									console.log(CardinalDirections.West); // West
									
	TypeScript Functions--Typescript:

		TypeScript has a specific syntax for typing function parameters and return values.
								
		Return Type--Functions Typescript:
			
			The type of the value returned by the function can be explicitly defined.
				
				// the `: number` here specifies that this function returns a number
				function getTime(): number {
				  return new Date().getTime();
				}
				console.log(getTime());
			
			If no return type is defined, TypeScript will attempt to infer it through the types of the variables or expressions returned.
		
		
		Void Return Type--Functions Typescript:
			
			The type void can be used to indicate a function doesn't return any value.
				
				function printHello(): void {
				  console.log('Hello!');
				}
				printHello();
		
		Parameters--Functions Typescript:
			
			Function parameters are typed with a similar syntax as variable declarations.
				
				function multiply(a: number, b: number) {
				  return a * b;
				}
				console.log(multiply(2,5))
				
			If no parameter type is defined, TypeScript will default to using any, unless additional type information is available as shown in the Default Parameters and Type Alias sections below.
		
		Optional Parameters--Functions Typescript:
			
			By default TypeScript will assume all parameters are required, but they can be explicitly marked as optional.
				
				// the `?` operator here marks parameter `c` as optional
				function add(a: number, b: number, c?: number) {
				  return a + b + (c || 0);
				}
				console.log(add(2,5))
		
		Default Parameters--Functions Typescript:
			
			For parameters with default values, the default value goes after the type annotation:
				
				function pow(value: number, exponent: number = 10) {
				  return value ** exponent;
				}
				console.log(pow(10));
			
			TypeScript can also infer the type from the default value.
		
		Named Parameters--Functions Typescript:
			
			Typing named parameters follows the same pattern as typing normal parameters.
				function divide({ dividend, divisor }: { dividend: number, divisor: number }) {
				  return dividend / divisor;
				}
				console.log(divide({dividend: 10, divisor: 2}));
				
				function divide({ dividend, divisor }: { dividend: number, divisor: number }) {
				  return dividend / divisor;
				}
				console.log(divide({10, 2}));
		
		Rest Parameters--Functions Typescript:
			
			Rest parameters can be typed like normal parameters, but the type must be an array as rest parameters are always arrays.
				
				function add(a: number, b: number, ...rest: number[]) {
				  return a + b + rest.reduce((p, c) => p + c, 0);
				}
				console.log(add(10,10,10,10,10));
		
		Type Alias--Functions Typescript:
			
			Function types can be specified separately from functions with type aliases.
			These types are written similarly to arrow functions.
				
				type Negate = (value: number) => number;
				// in this function, the parameter `value` automatically gets assigned the type `number` from the type `Negate`
				const negateFunction: Negate = (value) => value * -1;
				console.log(negateFunction(10));
								
	TypeScript Introduction--Typescript:

			TypeScript is JavaScript with added syntax for types.
			
		What is TypeScript?
			
			- TypeScript is a syntactic superset of JavaScript which adds static typing.
			- This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.
			- TypeScript being a "Syntactic Superset" means that it shares the same base syntax as JavaScript, but adds something to it.
		
		Why should I use TypeScript?
			
			- JavaScript is a loosely typed language. It can be difficult to understand what types of data are being passed around in JavaScript.
			- In JavaScript, function parameters and variables don't have any information! So developers need to look at documentation, or guess based on the implementation.
			- TypeScript allows specifying the types of data being passed around within the code, and has the ability to report errors when the types don't match.
			- For example, TypeScript will report an error when passing a string into a function that expects a number. JavaScript will not.
			- TypeScript uses compile time type checking. Which means it checks if the specified types match before running the code, not while running the code.
		
		How do I use TypeScript?
			
			- A common way to use TypeScript is to use the official TypeScript compiler, which transpiles TypeScript code into JavaScript.
			- The next section shows how to get the compiler setup for a local project.
			- Some popular code editors, such as Visual Studio Code, have built-in TypeScript support and can show errors as you write code!			
									
	TypeScript Keyof--Typescript:

			keyof is a keyword in TypeScript which is used to extract the key type from an object type.
			
		keyof with explicit keys--Keyof Typescript:
		
			When used on an object type with explicit keys, keyof creates a union type with those keys.
					interface Person {
			  name: string;
			  age: number;
			}
			// `keyof Person` here creates a union type of "name" and "age", other strings will not be allowed
			function printPersonProperty(person: Person, property: keyof Person) {
			  console.log(`Printing person property ${property}: "${person[property]}"`);
			}
			let person = {
			  name: "Max",
			  age: 27
			};
			printPersonProperty(person, "name"); // Printing person property name: "Max"s
		
		keyof with index signatures--Keyof Typescript:
		
			keyof can also be used with index signatures to extract the index type.
			
			type StringMap = { [key: string]: unknown };
			// `keyof StringMap` resolves to `string` here
			function createStringPair(property: keyof StringMap, value: string): StringMap {
			  return { [property]: value };
			}
									
	TypeScript Null & Undefined--Typescript:

			- TypeScript has a powerful system to deal with null or undefined values.
			- By default null and undefined handling is disabled, and can be enabled by setting strictNullChecks to true.
			- The rest of this page applies for when strictNullChecks is enabled.
									
		Types--Null & Undefined Typescript:
		
			null and undefined are primitive types and can be used like other types, such as string.
				
				let value: string | undefined | null = null;
				console.log(typeof value);
				value = 'hello';
				console.log(typeof value);
				value = undefined;
				console.log(typeof value);
			
			When strictNullChecks is enabled, TypeScript requires values to be set unless undefined is explicitly added to the type.
		
		Optional Chaining--Null & Undefined Typescript:
			
			Optional Chaining is a JavaScript feature that works well with TypeScript's null handling. It allows accessing properties on an object, that may or may not exist, with a compact syntax. It can be used with
			the ?. operator when accessing properties.
				
				interface House {
				  sqft: number;
				  yard?: {
					sqft: number;
				  };
				}
							
				function printYardSize(house: House) {
				  const yardSize = house.yard?.sqft;

				  if (yardSize === undefined) {
					console.log('No yard');
				  } else {
					console.log(`Yard is ${yardSize} sqft`);
				  }
				}
							
				let home: House = {
				  sqft: 500
				};
							
				printYardSize(home); // Prints 'No yard'
		
		Nullish Coalescence--Null & Undefined Typescript:
		
			Nullish Coalescence is another JavaScript feature that also works well with TypeScript's null handling. It allows writing expressions that have a fallback specifically when dealing with null or undefined. This is
			useful when other falsy values can occur in the expression but are still valid. It can be used with the ?? operator in an expression, similar to using the && operator.
				
				function printMileage(mileage: number | null | undefined) {
				  console.log(`Mileage: ${mileage ?? 'Not Available'}`);
				}						
				printMileage(null); // Prints 'Mileage: Not Available'
				printMileage(0); // Prints 'Mileage: 0'
				
		Null Assertion--Null & Undefined Typescript:
		
			TypeScript's inference system isn't perfect, there are times when it makes sense to ignore a value's possibility of being null or undefined. An easy way to do this is to use casting, but TypeScript also provides the ! operator as a convenient shortcut.
				
				function getValue(): string | undefined {
				  return 'hello';
				}
							
				let value = getValue();
				console.log('value length: ' + value!.length);
			
			Just like casting, this can be unsafe and should be used with care.
		
		Array bounds handling--Null & Undefined Typescript:
		
			- Even with strictNullChecks enabled, by default TypeScript will assume array access will never return undefined (unless undefined is part of the array type).
			- The config noUncheckedIndexedAccess can be used to change this behavior.
				
				let array: number[] = [1, 2, 3];
				let value = array[0]; // with `noUncheckedIndexedAccess` this has the type `number | undefined`									
									
	Object Types--Typescript:

		TypeScript has a specific syntax for typing objects--Object Types Typescript:
		
			// Try playing around with modifying properties and adding ones to see what happens
			const car: { type: string, model: string, year: number } = {
			  type: "Toyota",
			  model: "Corolla",
			  year: 2009
			};
			console.log(car);
			
			Object types like this can also be written separately, and even be reused.
		
		Type Inference--Object Types Typescript:
		
			TypeScript can infer the types of properties based on their values.
				
				const car = {
				  type: "Toyota",
				};
				car.type = "Ford"; // no error
				car.type = 2; // Error: Type 'number' is not assignable to type 'string'.
				console.log(car);
		
		Optional Properties--Object Types Typescript:
		
			Optional properties are properties that don't have to be defined in the object definition.
			
			Example without an optional property
				
				const car: { type: string, mileage: number } = { // Error: Property 'mileage' is missing in type '{ type: string; }' but required in type '{ type: string; mileage: number; }'.
				  type: "Toyota",
				};
				car.mileage = 2000;
					Example with an optional property
						// no error on optional property, remove it and see what happens
				const car: { type: string, mileage?: number } = {
				  type: "Toyota"
				};
				car.mileage = 2000;
				console.log(car);		
									
	Simple Types--Typescript:

		TypeScript supports some simple types (primitives) you may know.
		
		There are three main primitives in JavaScript and TypeScript.
		
			boolean - true or false values
			number - whole numbers and floating point values
			string - text values like "TypeScript Rocks"
			
		Type Assignment--Simple Types Typescript:
		
			When creating a variable, there are two main ways TypeScript assigns a type:		
				Explicit
				Implicit
				
			In both examples below firstName is of type string
		
		Explicit Type--Simple Types Typescript:
		
			Explicit - writing out the type:
			
				let firstName: string = "Dylan"; // type string
				console.log(typeof firstName);
				
		Implicit Type--Simple Types Typescript:
			
			Implicit - TypeScript will "guess" the type, based on the assigned value:
				
				let firstName = "Dylan";
				console.log(typeof firstName);
				
			Note: Having TypeScript "guess" the type of a value is called infer.
			
			Implicit assignment forces TypeScript to infer the value.

			Implicit type assignment are shorter, faster to type, and often used when developing and testing.
			
		Error In Type Assignment--Simple Types Typescript:
			
			TypeScript will throw an error if data types do not match.
				
				let firstName: string = "Dylan"; // type string
				firstName = 33; // attempts to re-assign the value to a different type
				console.log(firstName);
				
			Implicit type assignment would have made firstName less noticeable as a string, but both will throw an error:
				
				let firstName = "Dylan"; // inferred to type string
				firstName = 33; // attempts to re-assign the value to a different type
				console.log(firstName);
				
			JavaScript will not throw an error for mismatched types.
			
		Unable to Infer--Simple Types Typescript:
		
			TypeScript may not always properly infer what the type of a variable may be. In such cases, it will set the type to any which disables type checking.
				
				// Implicit any as JSON.parse doesn't know what type of data it returns so it can be "any" thing... 
				const json = JSON.parse("55");
				// Most expect json to be an object, but it can be a string or a number like this example
				console.log(typeof json);
				
			This behavior can be disabled by enabling noImplicitAny as an option in a TypeScript's project tsconfig.json. That is a JSON config file for customizing how some of TypeScript behaves.
			
			Note: you may see primitive types capitalized like Boolean.

		boolean !== Boolean
		For this tutorial just know to use the lower-cased values, the upper-case ones are for very specific circumstances.		
									
	Special Types--TypeScript:

		TypeScript has special types that may not refer to any specific type of data.
		
		Type: any--Special Types Typescript:
		
			any is a type that disables type checking and effectively allows all types to be used.

			The example below does not use any and will throw an error:
			
				let u = true;
				u = "string"; // Error: Type 'string' is not assignable to type 'boolean'
				u.runANonExistentMethod(); // Error: Property 'runANonExistentMethod' does not exist on type 'boolean'.
				console.log(Math.round(u)); // Error: Argument of type 'boolean' is not assignable to parameter of type 'number'.
			
			Setting any to the special type any disables type checking:
				
				let v: any = true;
				v = "string"; // no error as it can be "any" type
				// v.runANonExistentMethod(); 
				// no type error in the editor, but will still throw an error if commented in
				console.log(Math.round(u)); // no error as it can be "any" type
				
			any can be a useful way to get past errors since it disables type checking, but TypeScript will not be able provide type safety, and tools which rely on type data, such as auto completion, will not
			work. Remember, it should be avoided at "any" cost...
			
		Type: unknown--Special Types Typescript:
		
			TypeScript will prevent unknown types from being used, as shown in the below example:
				
				let w: unknown = 1; 
				w = "string"; // no error
				w = { 
				  runANonExistentMethod: () => {
					console.log("I think therefore I am");
				  } 
				} as { runANonExistentMethod: () => void }
				// How can we avoid the error for the code commented out below when we don't know the type? 
				// w.runANonExistentMethod(); // Error: Object is of type 'unknown'. 
				if(typeof w === 'object' && w !== null) {
				  (w as { runANonExistentMethod: Function }).runANonExistentMethod(); 
				} 
				// Although we have to cast multiple times we can do a check in the if to secure our type and have a safer casting
			
			Compare the example above to the previous example, with any.
			unknown is best used when you don't know the type of data being typed. To add a type later, you'll need to cast it.
			Casting is when we use the "as" keyword to say property or variable is of the casted type.
		
		Type: never--Special Types Typescript:
		
			never effectively throws an error whenever it is defined.
				let x: never = true; // Error: Type 'boolean' is not assignable to type 'never'.
				
			never is rarely used, especially by itself, its primary use is in advanced generics.
		
		Type: undefined & null--Special Types Typescript:
		
			undefined and null are types that refer to the JavaScript primitives undefined and null respectively.
			
				let y: undefined = undefined;
				console.log(typeof y);
				let z: null = null;
				console.log(typeof z);
			
			These types don't have much use unless strictNullChecks is enabled in the tsconfig.json file.		
									
	TypeScript Tuples--TypeScript:

		Typed Arrays--Tuples Typescript:
		
			A tuple is a typed array with a pre-defined length and types for each index.

			Tuples are great because they allow each element in the array to be a known type of value.
			
			To define a tuple, specify the type of each element in the array:
				
				// define our tuple
				let ourTuple: [number, boolean, string];
				// initialize correctly
				ourTuple = [5, false, 'Coding God was here'];
				console.log(ourTuple);
			
			As you can see we have a number, boolean and a string. But what happens if we try to set them in the wrong order:
				
				// define our tuple
				let ourTuple: [number, boolean, string];
				// initialize incorrectly throws an error
				ourTuple = [false, 'Coding God was mistaken', 5];
				console.log(ourTuple);
			
			Even though we have a boolean, string, and number the order matters in our tuple and will throw an error.
		
		Readonly Tuple--Tuples Typescript:
		
			A good practice is to make your tuple readonly.

		Tuples only have strongly defined types for the initial values:
				
				// define our tuple
				let ourTuple: [number, boolean, string];
				// initialize correctly
				ourTuple = [5, false, 'Coding God was here'];
				// We have no type safety in our tuple for indexes 3+
				ourTuple.push('Something new and wrong');
				console.log(ourTuple);
			
			You see the new valueTuples only have strongly defined types for the initial values:
				
				// define our tuple
				let ourTuple: [number, boolean, string];
				// initialize correctly
				ourTuple = [5, false, 'Coding God was here'];
				// We have no type safety in our tuple for indexes 3+
				ourTuple.push('Something new and wrong');
				// instead use our readonly tuple
				const ourReadonlyTuple: readonly [number, boolean, string] = [5, true, 'The Real Coding God'];
				// throws error as it is readonly.
				ourReadonlyTuple.push('Coding God took a day off');
			
			If you have ever used React before you have worked with tuples more than likely.

			useState returns a tuple of the value and a setter function.

			const [firstName, setFirstName] = useState('Dylan') is a common example.

			Because of the structure we know our first value in our list will be a certain value type in this case a string and the second value a function.
		
		Named Tuples--Tuples Typescript:
		
			Named tuples allow us to provide context for our values at each index.
				
				const graph: [x: number, y: number] = [55.2, 41.3];
			
			Named tuples provide more context for what our index values represent.
		
		Destructuring Tuples--Tuples Typescript:
		
			Since tuples are arrays we can also destructure them.
				
				const graph: [number, number] = [55.2, 41.3];
				const [x, y] = graph;		
									
	Type Aliases and Interfaces--TypeScript:

		TypeScript allows types to be defined separately from the variables that use them.

		Aliases and Interfaces allows types to be easily shared between different variables/objects.
		
		Type Aliases--Type Aliases and Interfaces Typescript:
		
			Type Aliases allow defining types with a custom name (an Alias).

			Type Aliases can be used for primitives like string or more complex types such as objects and arrays:
				
				// Try creating a new Car using the alias provided
				type CarYear = number;
				type CarType = string;
				type CarModel = string;
				type Car = {
				  year: CarYear,
				  type: CarType,
				  model: CarModel
				};
				const carYear: CarYear = 2001
				const carType: CarType = "Toyota"
				const carModel: CarModel = "Corolla"
				const car: Car = {
				  year: carYear,
				  type: carType,
				  model: carModel
				};
				console.log(car);
				
		Interfaces--Type Aliases and Interfaces Typescript:
		
			Interfaces are similar to type aliases, except they only apply to object types.
				
				// Try creating a new interface using it below
				interface Rectangle {
				  height: number,
				  width: number
				};
				const rectangle: Rectangle = {
				  height: 20,
				  width: 10
				};
				console.log(rectangle);
		
		Extending Interfaces--Type Aliases and Interfaces Typescript:
		
			Interfaces can extend each other's definition.
			Extending an interface means you are creating a new interface with the same properties as the original, plus something new.
				
				// Try creating a new interface and extending it like below
				interface Rectangle {
				  height: number,
				  width: number
				}
				interface ColoredRectangle extends Rectangle {
				  color: string
				}
				const coloredRectangle: ColoredRectangle = {
				  height: 20,
				  width: 10,
				  color: "red"
				};
				console.log(coloredRectangle);		
									
	Union Types--TypeScript:

		Union types are used when a value can be more than a single type.

		Such as when a property would be string or number.
		
		Union | (OR)--Union Types Typescript:
		
			Using the | we are saying our parameter is a string or number:
				
				function printStatusCode(code: string | number) {
				  console.log(`My status code is ${code}.`)
				}
				printStatusCode(404);
				printStatusCode('404');
		
		Union Type Errors--Union Types Typescript:
		
			Note: you need to know what your type is when union types are being used to avoid type errors:
				
				function printStatusCode(code: string | number) {
				  console.log(`My status code is ${code.toUpperCase()}.`) // error: Property 'toUpperCase' does not exist on type 'string | number'. Property 'toUpperCase' does not exist on type 'number'
				}
			
			In our example we are having an issue invoking toUpperCase() as its a string method and number doesn't have access to it.		
									
	Utility Types--TypeScript:

		TypeScript comes with a large number of types that can help with some common type manipulation, usually referred to as utility types.

		This chapter covers the most popular utility types.
		
		Partial--Utility Types Typescript:
		
			Partial changes all the properties in an object to be optional.
				
				interface Point {
				  x: number;
				  y: number;
				}					
				let pointPart: Partial<Point> = {}; // `Partial` allows x and y to be optional
				pointPart.x = 10;
				console.log(pointPart);
				
				interface Point {
				  x: number;
				  y: number;
				}						
				let pointPart: Partial<Point> = {}; // `Partial` allows x and y to be optional
				pointPart.x = 10;
				pointPart.y = 10;
				console.log(pointPart);
				
		Required--Utility Types Typescript:
		
			Required changes all the properties in an object to be required.
				
				interface Car {
				  make: string;
				  model: string;
				  mileage?: number;
				}			
				let myCar: Required<Car> = {
				  make: 'Ford',
				  model: 'Focus',
				  mileage: 12000 // `Required` forces mileage to be defined
				};
				console.log(myCar);
				
				interface Car {
				  make: string;
				  model: string;
				  mileage?: number;
				}						
				let myCar: Required<Car> = {
				  make: 'Ford',
				  model: 'Focus'
				//  mileage: 12000 // `Required` forces mileage to be defined
				};
				console.log(myCar)
				
		Record--Utility Types Typescript:
		
			Record is a shortcut to defining an object type with a specific key type and value type.
				
				const nameAgeMap: Record<string, number> = {
				  'Alice': 21,
				  'Bob': 25
				};
				console.log(nameAgeMap);
				
			Record<string, number> is equivalent to { [key: string]: number }
			
		
		Omit--Utility Types Typescript:
		
			Omit removes keys from an object type.
				
				interface Person {
				  name: string;
				  age: number;
				  location?: string;
				}
				const bob: Omit<Person, 'age' | 'location'> = {
				  name: 'Bob'
				  // `Omit` has removed age and location from the type and they can't be defined here
				};
				console.log(bob);
				
		Pick--Utility Types Typescript:
		
			Pick removes all but the specified keys from an object type.
				
				interface Person {
				  name: string;
				  age: number;
				  location?: string;
				}						
				const bob: Pick<Person, 'name'> = {
				  name: 'Bob'
				  // `Pick` has only kept name, so age and location were removed from the type and they can't be defined here
				};
				console.log(bob);
				
		Exclude--Utility Types Typescript:
		
			Exclude removes types from a union.
				type Primitive = string | number | boolean;
				const value: Exclude<Primitive, string> = true;
				// a string cannot be used here since Exclude removed it from the type.
				console.log(typeof value);
				
		ReturnType--Utility Types Typescript:
		
			ReturnType extracts the return type of a function type.
				
				// Không hiển thị kết quả nào cả
				type PointGenerator = () => { x: number; y: number; };
				const point: ReturnType<PointGenerator> = {
				  x: 10,
				  y: 20
				};
					
		Parameters--Utility Types Typescript:
		
			Parameters extracts the parameter types of a function type as an array.
				
				// Không hiển thị kết quả nào cả
				type PointPrinter = (p: { x: number; y: number; }) => void;
				const point: Parameters<PointPrinter>[0] = {
				  x: 10,
				  y: 20
				};

	Getting Started--TypeScript:
	
		TypeScript Compiler--Getting Started TypeScript:
			
			TypeScript is transpiled into JavaScript using a compiler.
			
			TypeScript being converted into JavaScript means it runs anywhere that JavaScript runs!
		
		Installing the Compiler--Getting Started TypeScript:
		
			TypeScript has an official compiler which can be installed through npm.
			
			Within your npm project, run the following command to install the compiler:
				
				npm install typescript --save-dev
			
			Which should give you an output similar to:
				
				added 1 package, and audited 2 packages in 2s
				found 0 vulnerabilities
				
			The compiler is installed in the node_modules directory and can be run with: npx tsc.
				
				npx tsc
			
			Which should give you an output similar to:
				
				Version 4.5.5
				tsc: The TypeScript Compiler - Version 4.5.5
			
			Followed by a list of all the Commmon Commands.
		
		Configuring the compiler--Getting Started TypeScript:
		
			By default the TypeScript compiler will print a help message when run in an empty project.

			The compiler can be configured using a tsconfig.json file.
			
			You can have TypeScript create tsconfig.json with the recommended settings with:
				
				npx tsc --init
			
			Which should give you an output similar to:
				
				Created a new tsconfig.json with:
				
				TS
				  target: es2016
				  module: commonjs
				  strict: true
				  esModuleInterop: true
				  skipLibCheck: true
				  forceConsistentCasingInFileNames: true

				You can learn more at https://aka.ms/tsconfig.json
			
			Here is an example of more things you could add to the tsconfig.json file:
				
				{
				  "include": ["src"],
				  "compilerOptions": {
					"outDir": "./build"
				  }
				}
			
			You can open the file in an editor to add those options. This will configure the TypeScript compiler to transpile TypeScript files located in the src/ directory of your project, into JavaScript files in
			the build/ directory.
			This is one way to quickly get started with TypeScript, there are many other options available such as a create-react-app template, a node starter project, and a webpack plugin.		

Kafka---:

	Khái niệm về Apache Kafka--Kafka:

		- Để rõ hơn về lợi ích của kafka, hãy tưởng tượng một hệ thống thương mại điện tử có nhiều máy chủ thực hiện các công việc khác nhau, tất cả các máy chủ này đều muốn giao tiếp với database server, vì vậy chúng ta
		sẽ có nhiều data pipeline kết nối các server khác đến database server này
		- Nhưng trong thực tế, hệ thống thương mại điện tử sẽ còn phải kết nối đến một vài server khác nữa
		- Data pipeline đang trở nên phức tạp theo sự gia tăng của số lượng hệ thống. Để giải quyết vấn đề này thì kafka ra đời. Kafka tách rời các data pipeline giữa các hệ thống để làm cho việc communicate giữa các hệ thống
		trở nên đơn giản hơn và dễ quản lý hơn.

		Kafka là gì?--Khái niệm về Apache Kafka:
			- Real-time data có giá trị đặc biệt quan trọng đối với các doanh nghiệp. Các doanh nghiệp sử dụng real-time data để cải thiện dịch vụ khách hàng, quản lý sản phẩm và tối ưu hóa vận hành. Ngoài ra, real-time data
			còn để giúp theo dõi và duy trì cơ sở hạ tầng CNTT. Nhận biết được những lợi ích trên, nhu cầu thu thập real-time data ngày càng tăng cao ở khắp các doanh nghiệp toàn thế giới.
			- Chính vì thế, những công cụ có khả năng thu thập và lưu trữ dữ liệu thời gian thực ngày càng trở nên được “săn đón”, Kafka chính là một trong những công cụ đó.
			- Apache Kafka là một nền tảng phát trực tuyến sự kiện phân tán mã nguồn mở. Apache Kafka được xây dựng nhằm mục đích xử lý dữ liệu streaming real-time (theo thời gian thực). Nói một cách đơn giản - Apache
			Kafka được phát triển để lưu trữ các streams of records (luồng ghi dữ liệu).
			- Ngày nay, hàng tỷ nguồn dữ liệu liên tục tạo ra các luồng data record, bao gồm các luồng sự kiện. Một sự kiện là một bản ghi kỹ thuật số về một hành động đã xảy ra và thời gian nó xảy ra. Thông thường, một sự kiện
			là một hành động thúc đẩy một hành động khác như một phần của quy trình. Một khách hàng đặt hàng, chọn chỗ ngồi trên chuyến bay, hoặc gửi đơn đăng ký đều là những ví dụ về các sự kiện. Một sự kiện không nhất thiết
			phải liên quan đến một người — ví dụ: báo cáo của máy điều nhiệt được kết nối về nhiệt độ tại một thời điểm nhất định cũng là một sự kiện.
			- Các luồng này tạo cơ hội cho các ứng dụng phản hồi dữ liệu hoặc sự kiện trong thời gian thực. Nền tảng stream dữ liệu cho phép các nhà phát triển xây dựng các ứng dụng liên tục sử dụng và xử lý các luồng này ở
			tốc độ cực cao, với mức độ trung thực và chính xác cao dựa trên thứ tự xuất hiện chính xác của chúng.
			- LinkedIn đã phát triển Kafka vào năm 2011 như một message broker thông lượng cao để sử dụng cho chính nó, sau đó Kafka có nguồn mở và được donate cho Software Foundation. Kafka sử dụng ngôn ngữ chính là Java
			hoặc Scala.
			- Ngày nay, Kafka đã phát triển thành nền tảng stream dữ liệu phân tán được sử dụng rộng rãi nhất, có khả năng nhập và xử lý hàng nghìn tỷ bản ghi mỗi ngày mà không có bất kỳ độ trễ hiệu suất có thể nhận thấy
			nào theo quy mô khối lượng. Các tổ chức trong danh sách Fortune 500 như Target, Microsoft, AirBnB và Netflix dựa vào Kafka để cung cấp trải nghiệm theo thời gian thực, theo hướng dữ liệu cho khách hàng của họ.
		
		Kafka được sử dụng để làm gì?--Khái niệm về Apache Kafka:
		
			Kafka là kho dữ liệu phân tán được sử dụng để xử lý dữ liệu theo thời gian thực. Nếu là nền tảng streaming trực tuyến thì sẽ cần xử lý dữ liệu một cách liên tục theo thứ tự tăng dần. Dưới đây là 3 chức năng
			chính của Kafka:
			
				Publish và subscribe các stream of record
				Lưu trữ các stream of record theo thứ tự
				Hỗ trợ xử lý stream of record theo thời gian thực
				
		Ưu, nhược điểm nổi bật của Kafka--Khái niệm về Apache Kafka:
		
			- Ưu điểm của Kafka
			
				Open-source
				High-throughput: Có khả năng xử lý một lượng lớn thông tin một cách liên tục, gần như không có thời gian chờ
				High-frequency: Có thể xử lý cùng lúc nhiều message và nhiều thể loại topic
				Scalability: Dễ dàng mở rộng khi có nhu cầu
				Tự động lưu trữ message, dễ dàng kiểm tra lại
				Cộng đồng người dùng đông đảo, được hỗ trợ nhanh chóng khi cần
			
			- Nhược điểm của Kafka
			
				Chưa có bộ công cụ giám sát hoàn chỉnh: Có nhiều tool khác nhau nhưng mỗi tool chỉ đáp ứng một tính năng quản lý nhất định, chẳng hạn như: Kafka tool (offset manager) GUI tool - quản lý topic và consumer, Lense - hỗ trợ query message, Akhq - toolbox quản lý Kafka và view data bên trong Kafka
				Không chọn được topic theo wildcard: Người dùng sẽ cần phải sử dụng chính xác tên topic để xử lý message
				Giảm hiệu suất: Kích thước message tăng khiến cho consumer và producer phải compress và decompress message, từ đó làm bộ nhớ bị chậm đi, ảnh hưởng đến throughput và hiệu suất.
				Xử lý chậm: Đôi khi số lượng queues trong Kafka cluster tăng đột biến khiến Kafka xử lý chậm hơn.
				
		Lý do nên sử dụng Kafka--Khái niệm về Apache Kafka:
		
			- Kafka được đóng gói hoàn chỉnh, hiệu năng cao, dễ dàng mở rộng mà không làm gián đoạn hệ thống. Nếu bạn đang xây dựng phần mềm hoặc website hiển thị thông tin theo thời gian thực, thì đây chính là một lựa chọn lý
			tưởng. Bên cạnh đó, Kafka cũng có khả năng nhập và lưu trữ dữ liệu trong quá trình phát trực tiếp; hoặc sử dụng như một phần mềm message broker để các ứng dụng/nền tảng giao tiếp với nhau.
			
			- Một số lợi ích nổi bật của Kafka bao gồm:
				Khả năng mở rộng cao: Mô hình phân vùng nhật ký của Kafka cho phép dữ liệu có thể được phân phối trên nhiều máy chủ và mở rộng máy chủ khi có nhu cầu.
				Tốc độ nhanh chóng: Việc xử lý thông qua tách các luồng dữ liệu giúp cho tốc độ trở nên nhanh hơn.
				Khả năng chịu lỗi và độ bền: Do các gói dữ liệu được sao chép và phân phối trên nhiều máy chủ khác nhau, nên khi có sự cố thì dữ liệu sẽ ít gặp lỗi và an toàn hơn.
		
		Cơ chế hoạt động của Kafka--Khái niệm về Apache Kafka:
		
			Apache Kafka hoạt động giống như một message queue (hàng đợi message) pub-sub truyền thống (chẳng hạn như RabbitMQ) ở chỗ nó cho phép bạn publish và subscribe các luồng message. Tuy nhiên Apache Kafka khác
			với message queue truyền thống ở 3 điểm chính:
				
				Kafka hoạt động như một hệ thống phân tán hiện đại chạy dưới dạng một cụm và có thể mở rộng quy mô để xử lý bất kỳ số lượng ứng dụng nào.
				Kafka được thiết kế để phục vụ như một hệ thống lưu trữ và có thể lưu trữ dữ liệu trong thời gian cần thiết; hầu hết các message queue sẽ xóa message ngay sau khi consumer xác nhận đã nhận.
				Kafka xử lý stream processing, tính toán các luồng dẫn xuất và các dataset một cách linh hoạt, thay vì chỉ chuyển các dãy thông báo.
		
		Quy trình làm việc của Pub-Sub Messaging--Khái niệm về Apache Kafka:
		
			Sau đây là quy trình từng bước của Pub-Sub Messaging:
			
				- Các producer gửi message đến một topic theo định kỳ.
				- Kafka broker lưu trữ tất cả các message trong các partition được định cấu hình cho topic cụ thể đó. Nó đảm bảo các message được chia đều giữa các partition. Nếu producer gửi hai message và có hai
				partition, Kafka sẽ lưu trữ một message trong partition đầu tiên và message thứ hai trong partition thứ hai.
				- Consumer sẽ subscribe một topic cụ thể.
				- Sau khi consumer đã subscribe một topic, Kafka sẽ cung cấp offset hiện tại của topic cho consumer và cũng lưu offset trong nhóm Zookeeper.
				- Consumer sẽ yêu cầu Kafka trong một khoảng thời gian đều đặn (ví dụ 100 Ms) cho các message mới.
				- Khi Kafka nhận được message từ producer, nó sẽ chuyển tiếp những message này đến consumer.
				- Consumer sẽ nhận được message và xử lý nó.
				- Sau khi message được xử lý, consumer sẽ gửi xác nhận đến Kafka broker.
				- Khi Kafka nhận được xác nhận, nó sẽ thay đổi offset thành giá trị mới và cập nhật nó trong Zookeeper. Vì các offset được duy trì trong Zookeeper nên consumer có thể đọc message tiếp theo một cách chính
				xác ngay cả khi máy chủ gặp sự cố.
				- Luồng trên sẽ lặp lại cho đến khi consumer dừng yêu cầu.
				- Consumer có tùy chọn tua lại/bỏ qua offset mong muốn của một topic bất kỳ lúc nào và đọc tất cả các message tiếp theo.
		
		Một số khái niệm cơ bản trong Kafka--Khái niệm về Apache Kafka:
		
			Producer:
			
				Producer là những application produce data và gửi data tới Kafka Server. Data này sẽ là những message có định dạng, được gửi dưới dạng mảng byte tới Kafka server. Ví dụ như các bạn có một tập tin .txt chứa
				text bên trong, chúng ta có thể dùng Producer để đọc từng dòng trong tập tin này rồi gửi tới Kafka server.
			
			Consumer:
				
				- Kafka sử dụng consumer để subscribe vào topic, các consumer được định danh bằng các group name. Nhiều consumer có thể cùng đọc một topic. Sau khi nhận được data, Consumer có thể thêm code để xử lý data theo
				nhu cầu của mình.
				- Consumer là những ai có thể subscribe vào một hoặc nhiều topic cụ thể và nhận message thuộc topic đó từ hệ thống.
			
			Cluster:
				
				- Kafka cluster là một set các server, mỗi một set này được gọi là 1 broker.
				- Nhiều broker cùng làm việc với nhau, tránh single point failure (để toàn bộ broker trên cùng một server sau đó sever đó có vấn đề thì sẽ gặp ảnh hưởng toàn bộ).
			
			Broker:
				
				Broker là Kafka server, là cầu nối giữa Message Publisher và Message Consumer, giúp chúng có thể trao đổi message với nhau.
			
			Topic:
				
				- Dữ liệu truyền trong Kafka theo topic, khi cần truyền dữ liệu cho các ứng dụng khác nhau thì sẽ tạo ra các topic khác nhau.
				- Tên đại diện của một kênh cho phép các hệ thống nói chuyện với nhau. Bạn cũng có thể hiểu Topic là tổng hợp của một dãy event tương tự với nhau, gần như một bảng SQL vậy.
			
			Partitions:
				
				- Kafka là một distributed messaging system và chúng ta có thể setup Kafka server với cluster. Trong trường hợp một topic nhận quá nhiều message tại cùng một thời điểm, chúng ta có thể chia topic này thành
				những partitions được share giữa các Kafka server với nhau trong một cluster được handle các message này.
				- Một partition sẽ small và independent với các partitions khác. Số lượng partition cho mỗi topic thì tuỳ theo nhu cầu của ứng dụng mà chúng ta có thể quyết định.
				- Message đưa ra sẽ được Kafka chỉ định hoặc chủ động chỉ định partition để biết message đó “đi đâu về đâu”. Một topic có thể có một hoặc nhiều partition.
			
			Consumer Group:
				
				Consumer group là một group các Consumer consume message từ Kafka server. Mỗi một Consumer Group sẽ share với nhau việc handle message.
			
			ZOOKEEPER:
				
				Dùng để quản lý và bố trí các broker.
			
			Connector:
				
				Kết nối Kafka với các hệ thống cơ sở dữ liệu khác.
			
			Event Distributed System:
				
				Nền tảng phân phối message rộng rãi, ngắt hệ thống ra nhiều server, nhiều cluster khác nhau.
			
			Event:
				
				Một sự kiện, hành động được diễn ra.
			
			Stream:
				
				Chuyển hóa luồng topic đầu vào thành topic đầu ra.
				
		Tìm hiểu về ứng dụng của Kafka--Khái niệm về Apache Kafka:
		
			- Nhờ khả năng xử lý hiệu quả và lưu trữ dữ liệu lớn theo thời gian thực, Kafka được các doanh nghiệp thuộc nhiều lĩnh vực khác nhau tin tưởng để sử dụng cho hệ thống của họ.
			- Đóng vai trò như message broker
				Người dùng có thể sử dụng Kafka để thay thế cho các Message broker, ví dụ như ActiveMQ hoặc RabbitMQ.
			- Quản lý hoạt động website
				Đây là cách thức truyền thống để sử dụng Kafka, được dùng để xây dựng website và đăng tải nội dung theo thời gian thực. Các dữ liệu như lượt xem trang, hoạt động tìm kiếm… đều được tạo thành các topic. Việc
				quản lý hoạt động này giúp bạn phân tích hành vi của người dùng trên trang tốt hơn, từ đó thu hút được nhiều người đọc hơn.
			- Đo lường
				Kafka cũng có thể được dùng để xây dựng dữ liệu giám sát các hoạt động. Điều này đồng nghĩa với việc tập hợp số liệu thống kê từ nhiều nguồn phân tán trên trang để tạo ra một nguồn dữ liệu tổng hợp.
			- Tạo log
				Kafka hỗ trợ tổng hợp log hoặc nhật ký hoạt động, tóm tắt các chi tiết và cung cấp bản ghi cụ thể về dữ liệu sự kiện nhằm phục vụ cho việc xử lý trong tương lai.
			- Stream processing
				Steam processing là cách sử dụng phổ biến hiện nay của Kafka, hệ thống được phát triển để xử lý dữ liệu theo thời gian thực. Mỗi khi dữ liệu mới được thêm vào topic, thì sẽ được ghi vào hệ thống ngay lập tức
				và truyền đến bên nhận dữ liệu. Hơn nữa, thư viện Kafka Streams được tích hợp từ phiên bản 0.10.0.0 có tính năng xử lý stream nhẹ nhưng rất mạnh mẽ.
		
		Kết luận--Khái niệm về Apache Kafka:
		
			Trong quá trình phát triển website, ứng dụng rất dễ xảy ra trường hợp lượng message cần xử lý tăng lên quá nhiều dẫn đến các data pipeline trở nên vô cùng phức tạp, khiến việc quản lý và vận hành rất khó
			khăn. Kafka với năng lực phân phối tuyệt vời là giải pháp hoàn hảo để xử lý cho bài toán này. Tuy nhiên, để triển khai 1 hệ thống như vậy sẽ cần rất nhiều thời gian, nguồn lực, tài nguyên và chi phí.

		
		Ví dụ--Khái niệm về Apache Kafka: 
				
			package com.poscodx.odc.ampro015.config.kafka.listeners;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
			import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
			import org.apache.commons.lang3.time.DateUtils;
			import org.apache.kafka.clients.consumer.ConsumerRecord;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.kafka.annotation.KafkaHandler;
			import org.springframework.kafka.annotation.KafkaListener;
			import org.springframework.stereotype.Component;
			import java.util.Date;
			import java.util.concurrent.TimeoutException;
			@Component
			@KafkaListener(id = "multiGroup1", topics = "amface", groupId = "deep-fake", autoStartup = "false")
			public class MultiTypeKafkaListener {
				@Autowired
				ServiceLifecycle serviceLifecycle;
				@KafkaHandler
				public void handleUserFaceRequest(DeepFaceInfoRequest userFaceRequest) throws TimeoutException {
					try {
						System.out.println("User face received UserFaceRequest 1 (user-face): " + userFaceRequest);
					} catch (Exception e) {
						System.out.println("Handle kafka's message error: " + e.getMessage());
					}
				}
				@KafkaHandler
				public void handleUserFaceRequest2(String userFaceRequest) throws TimeoutException {
					try {
						System.out.println("User face received String 2 (user-face): " + userFaceRequest);
						DeepFaceInfoRequest receiver = DeepFaceInfoRequest.fromJson(userFaceRequest);
			//            String dateInString = receiver.getAccessTime().replace("T", " ");
			//            Date checkTime = DateUtils.parseDate(dateInString, new String[] { "yyyy-MM-dd HH:mm:ss", "dd/MM-yyyy" });
			//            receiver.setAccessTimeToDate(checkTime);
						System.out.println("User face received String 2 (Oject): " + receiver);
						serviceLifecycle.requestLevel2WorkingTimeService().createOrUpdateWorkingTime(serviceLifecycle, receiver.getId(), receiver.getAccessTime());
						serviceLifecycle.requestLevel2Service().sendCheckFaceTimeNotification(receiver, "/topic/check-face-time");
					} catch (Exception e) {
						System.out.println("Handle kafka's message error: " + e.getMessage());
					}
				}
				@KafkaHandler
				public void unknown(ConsumerRecord<String, Object> record) throws TimeoutException {
					try {
						System.out.println("User face received Object 2 (user-face): " + record.value());
					} catch (Exception e) {
						System.out.println("Handle kafka's message error: " + e.getMessage());
					}
				}
			}

			package com.poscodx.odc.ampro015.config.kafka.producers;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
			import lombok.NoArgsConstructor;
			import lombok.extern.slf4j.Slf4j;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.kafka.core.KafkaTemplate;
			import org.springframework.stereotype.Component;
			@Slf4j
			@NoArgsConstructor
			@Component
			public class ProductProducer {
				final String topic = "deepfake";
				@Autowired
				private KafkaTemplate<String, DeepFaceInfoRequest> kafkaTemplate;
				@Autowired
				private KafkaTemplate<String, String> kafkaTemplate2;
			//    @Autowired
			//    private KafkaTemplate<String, Object> multiTypeKafkaTemplate;
				public void sendMessage(String message) {
					kafkaTemplate2.send(topic, message);
					log.info("Send message String: {}", message);
				}
				public void sendMessage(DeepFaceInfoRequest message) {
					kafkaTemplate.send(topic, message);
					log.info("Send message UserFaceRequest: {}", message);
				}
			}

			package com.poscodx.odc.ampro015.config.kafka;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
			import lombok.extern.slf4j.Slf4j;
			import org.apache.kafka.clients.consumer.ConsumerConfig;
			import org.apache.kafka.common.serialization.StringDeserializer;
			import org.springframework.beans.factory.annotation.Value;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
			import org.springframework.kafka.core.ConsumerFactory;
			import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
			import org.springframework.kafka.support.serializer.JsonDeserializer;
			import java.util.HashMap;
			import java.util.Map;
			@Slf4j
			@Configuration
			public class KafkaConsumerConfig {
				@Value(value = "${spring.kafka.bootstrap-servers}")
				private String bootstrapAddress;
				public ConsumerFactory<String, String> consumerFactory(String groupId) {
					Map<String, Object> props = new HashMap<>();
					props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
					props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
					props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
					props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
					props.put(ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG, "20971520");
					props.put(ConsumerConfig.FETCH_MAX_BYTES_CONFIG, "20971520");
					return new DefaultKafkaConsumerFactory<>(props);
				}
				public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory(String groupId) {
					ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
					factory.setConsumerFactory(consumerFactory(groupId));
					return factory;
				}
				@Bean
				public ConcurrentKafkaListenerContainerFactory<String, String> deepFakeKafkaListenerContainerFactory() {
					return kafkaListenerContainerFactory("deep-fake");
				}
				public ConsumerFactory<String, DeepFaceInfoRequest> consumerFactory2(String groupId) {
					Map<String, Object> props = new HashMap<>();
					props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
					props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);
					return new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(), new JsonDeserializer<>(DeepFaceInfoRequest.class));
				}
				@Bean
				public ConcurrentKafkaListenerContainerFactory<String, DeepFaceInfoRequest> deepFakeeKafkaListenerContainerFactory2() {
					ConcurrentKafkaListenerContainerFactory<String, DeepFaceInfoRequest> factory = new ConcurrentKafkaListenerContainerFactory<>();
					factory.setConsumerFactory(consumerFactory2("deep-fake"));
					return factory;
				}
			}

			package com.poscodx.odc.ampro015.config.kafka;
			import lombok.extern.slf4j.Slf4j;
			import org.apache.kafka.clients.admin.AdminClient;
			import org.apache.kafka.clients.admin.ListTopicsOptions;
			import org.springframework.beans.factory.annotation.Autowired;
			import org.springframework.boot.actuate.health.Health;
			import org.springframework.boot.actuate.health.HealthIndicator;
			import org.springframework.kafka.core.KafkaAdmin;
			import org.springframework.stereotype.Component;
			import java.util.concurrent.TimeUnit;
			@Component("kafka_indicator")
			@Slf4j
			public class KafkaHealthIndicator implements HealthIndicator {
				@Autowired
				private KafkaAdmin kafkaAdmin;
				@Override
				public Health health() {
					try (AdminClient client = AdminClient.create(kafkaAdmin.getConfig())) {
						client.listTopics(new ListTopicsOptions().timeoutMs(1000)).listings().get(10, TimeUnit.SECONDS);
						return Health.up().build();
					} catch (Exception e) {
						return Health.down().withException(e).build();
					}
				}
			}

			package com.poscodx.odc.ampro015.config.kafka;
			import com.poscdx.odc.ampro015.domain.entity.payload.request.DeepFaceInfoRequest;
			import org.apache.kafka.clients.producer.ProducerConfig;
			import org.apache.kafka.common.serialization.StringSerializer;
			import org.springframework.beans.factory.annotation.Value;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.kafka.core.DefaultKafkaProducerFactory;
			import org.springframework.kafka.core.KafkaTemplate;
			import org.springframework.kafka.core.ProducerFactory;
			import org.springframework.kafka.support.serializer.JsonSerializer;
			import java.util.HashMap;
			import java.util.Map;
			@Configuration
			public class
			KafkaProducerConfig {
				@Value(value = "${spring.kafka.bootstrap-servers}")
				private String bootstrapAddress;
				@Bean
				public ProducerFactory<String, String> producerFactory() {
					Map<String, Object> configProps = new HashMap<>();
					configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
					configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
					configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
					configProps.put(ProducerConfig.MAX_REQUEST_SIZE_CONFIG, "20971520");
			//        configProps.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG,4000);
			//        configProps.put(ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG,6000);

					return new DefaultKafkaProducerFactory<>(configProps);
				}
				@Bean
				public KafkaTemplate<String, String> kafkaTemplate() {
					return new KafkaTemplate<>(producerFactory());
				}
				@Bean
				public ProducerFactory<String, DeepFaceInfoRequest> userFaceProducerFactory() {
					Map<String, Object> configProps = new HashMap<>();
					configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
					configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
					configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
					return new DefaultKafkaProducerFactory<>(configProps);
				}
				@Bean
				public KafkaTemplate<String, DeepFaceInfoRequest> userFaceKafkaTemplate() {
					return new KafkaTemplate<>(userFaceProducerFactory());
				}
			}

			package com.poscodx.odc.ampro015.config.kafka;
			import org.apache.kafka.clients.admin.AdminClientConfig;
			import org.apache.kafka.clients.admin.NewTopic;
			import org.springframework.beans.factory.annotation.Value;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.kafka.core.KafkaAdmin;
			import java.util.HashMap;
			import java.util.Map;
			@Configuration
			public class KafkaTopicConfig {
				@Value(value = "${spring.kafka.bootstrap-servers}")
				private String bootstrapAddress;
				@Bean
				public KafkaAdmin kafkaAdmin() {
					Map<String, Object> configs = new HashMap<>();
					configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress);
					return new KafkaAdmin(configs);
				}
			}									
	
MICROSERVICE---:

	Microservices là gì?--MICROSERVICE:
	
		Vậy Microservices là gì nhỉ?--Microservices là gì:
				
				Thực tế có nhiều định nghĩa khác nhau đối với Microservices nhưng hiểu theo cách đơn giản thì, microservice là một kiếu kiến trúc phần mềm. Các module trong phần mềm này được chia thành các service rất
				nhỏ (microservice). Mỗi service sẽ được đặt trên một server riêng -> dễ dàng để nâng cấp và scale ứng dụng.
		
		Monolith Application là gì?--Microservices là gì:
		
				Bạn đã bao giờ từng làm việc trong những dự án có đặc điểm như sau chưa?
					
					Release vài tháng 1 lần
					Có các đặc điểm và chức năng bao phủ phạm vi rộng
					Team size lớn
					Việc debug trở thành thử thách lớn
					Khó khăn để ứng dụng các công nghệ mới
					
					Đó chính là những đặc điểm của Monolith Application
				
				Các ứng dụng Monolith thường rất lớn - thường sẽ có size hơn 100.000 dòng code. Trong một số trường hợp thậm chí có hơn một triệu dòng code.
				
				Khi xây dựng phần mềm theo kiến trúc monolith (một khối). Toàn bộ các module (view, business, database, report) đều được gom chung vào một project lớn. Khi deploy, chúng ta sẽ quăng khối code này lên server
				và config để nó chạy.
				
				Kiến trúc này hoạt động khá ngon vì nó đơn giản, dễ code. Tuy nhiên, khi phần mềm trở nên lớn và phức tạp thì nó lại dần bộc lộ nhược điểm. Do các module đóng với nhau thành một bánh, khi muốn nâng cấp
				một module, ta phải deploy lại toàn bộ code (người dùng cuối sẽ không sử dụng được toàn bộ các chức năng của hệ thống khi deploy); khi muốn phục vụ nhiều người dùng, ta phải nâng cấp server...
				
				Các thử thách đối với Monolith Application
					
					Scalability
					Ứng dụng các công nghệ mới
					Ứng dụng automation test
					Áp dụng quy trình làm việc - Agile?
					Thích ứng với thực tiễn phát triển hiện đại
					
					...
				Một dịch vụ gọi taxi qua di động, với business logic được thể hiện bởi các khối dịch vụ, đối tượng cho từng vùng nghiệp vụ (domain objects) và các sự kiện (events: khách đặt xe, khách hủy xe, xe nhận
				khách...)Xung quanh lõi là bộ chuyển đổi (adapter) ví dụ như kết nối vào cơ sở dữ liệu, gửi nhận thông điệp (messaging), web service hoặc giao diện web front end.
				
				Trong nhiều trường hợp, người ta có thể xây dựng các services độc lập nhưng chúng lại được triển khai chung. Mặc dù có cấu trúc module hóa hợp lý, nhưng ứng dụng kiểu này sẽ đóng gói và cài đặt thành một
				khối (monolithic). Mã chạy cụ thể tùy thuộc vào ngôn ngữ lập trình hay thư viện framework.
				
				Tương tự như ứng dụng monolithic, những services này to và phức tạp lên theo thời gian vì thường xuyên thêm các tính năng. Và thế là những ứng dụng này lại trở thành một mớ các services monolithic, cũng
				không còn khác mấy so với kiến trúc một khối thông thường. Hình trên thể hiện một ứng dụng gồm nhiều services. Những services này được triển khai cùng một lúc vào 1 ứng dụng lớn. Dù bên trong có gồm các
				services thì đây là một ứng dụng monolithic. Một số tính chất của kiến trúc một khối:
				
					Được thiết kế, phát triển và triển khai theo một khối duy nhất
					Ứng dụng monolithic phức tạp và to gây khó khăn cho việc bảo trì, nâng cấp và thêm tính năng mới
					Khó áp dụng phát triển kiểu agile
					Phải triển khai lại toàn bộ hệ thống dù chỉ cập nhật hay nâng cấp một phần
					Mở rộng: phải mở rộng cả khối ứng dụng, gặp khó khăn nếu có các yêu cầu về tài nguyên khác nhau (ví dụ một service yêu cầu thêm CPU, service khác lại yêu cầu nhiều memory)
					Độ tin cậy: một service không ổn định có thể sập cả hệ thống
					Khó đổi mới: ứng dụng monolithic phải sử dụng chung công nghệ nên khó thay đổi hay áp dụng công nghệ mới.
		
		Kiến trúc dịch vụ nhỏ (Microservices Architecture)--Microservices là gì:
		
				Khác biệt với kiến trúc Monolith, thay vì gom tất cả module thành một khối (monolith), ta tách các module thành những service siêu nhỏ. Mỗi service sẽ được đặt trên một server riêng (Có thể dùng server cloud
				như AWS hoặc Azure), giao tiếp với nhau thông qua mạng (Gửi nhận message qua giao thức HTTP hoặc sử dụng MessageQueue)...
				
				Nền tảng cả kiến trúc microservices là xây dựng một ứng dụng mà ứng dụng này là tổng hợp của nhiều services nhỏ và độc lập có thể chạy riêng biệt, phát triển và triển khai độc lập.
				
				Ta có thể giải quyết các vấn đề của ứng dụng một khối bằng kiến trúc microservices (nhiều dịch vụ nhỏ). Ý tưởng là chia nhỏ ứng dụng lớn ra thành các dịch vụ nhỏ kết nối với nhau.
				
				Mỗi dịch vụ nhỏ thực hiện một tập các chức năng chuyên biệt như quản lý đơn hàng, quản lý khách hàng. Mỗi dịch vụ là một ứng dụng nhỏ có kiến trúc đa diện lõi là business logic kết nối ra các adapter khác
				nhau. Một số dịch vụ nhỏ lộ ra giao tiếp lập trình API cho dịch vụ nhỏ khác hay ứng dụng client gọi tới. Khi vận hành, mỗi dịch vụ nhỏ được chạy trong một máy ảo hoặc Docker container.
				
				Mỗi vùng chức năng giờ được thực thi bởi một dịch vụ nhỏ. Ứng dụng web cũng có thể chia nhỏ hơn chuyên cho từng đối tượng người dùng (hành khách/tài xế). Thiết kế giao diện cho từng đối tượng người dùng
				giúp tối ưu trải nghiệm tốt hơn, tốc độ nhanh hơn, dễ tương thích hơn trong khi chức năng tối giản hơn.
				
				Một số khái niệm về microservices nói về quá trình chia tách ứng dụng monolithic thành nhóm các services độc lập. Tuy nhiên, theo quan điểm của tôi, microservices không chỉ về chia tách các servcies sẵn có
				trong monolithic.
				
				Điều quan trọng chính là nhìn vào các tính năng trong một ứng dụng monolithic, ta có thể nhận biết, xác định các yêu cầu và khả năng cần thiết để đáp ứng một nghiệp vụ. Sau đó từng nghiệp vụ này sẽ được xây
				dựng thành những service nhỏ, độc lập. Những services này có thể sử dụng các nền tảng công nghệ khác nhau và phục vụ một mục đích cụ thể và có giới hạn.
		
		Và một phần mềm xây dựng theo kiến trúc Microservices trông sẽ như nào?--Microservices là gì:
		
				Hình dưới đây sẽ minh họa cho việc phần mềm được xây dựng theo kiến trúc Monolith, một ứng dụng sẽ chứa tất cả các thành phần
				Còn hình dưới sẽ minh họa việc ứng dụng ở trên khi được xây dựng theo kiến trúc Microservices
				Kiến trúc Microservice bao gồm một số thành phần nhỏ, được thiết kế tốt và tương tác qua các message.
		
		Các ưu điểm của Kiến trúc Microservices--Microservices là gì:
		
				Hiện nay, các ứng dụng thường rất lớn và liên tục được update ví dụ như facebook, linkin,... . Với kiến trúc monolith, việc gom toàn bộ ứng dụng vào một khối làm việc nâng cấp trở nên khó khăn và mất thời
				gian. Để giải quyết vấn đề đó, các ứng dụng lớn cần thiết được tách ra thành các service nhỏ. Mỗi service quản lý một cơ sở dữ liệu riêng, nằm trên một server riêng, tách biệt hoàn toàn với nhau. Các ưu
				điểm như sau:
				
					- Điều quan trọng nhất là rất dễ nâng cấp và scale up, scale down. Giả sử bạn làm một trang web liên quan tới vận tải, kho bãi. Khi số lượng xe hay hàng hóa tăng lên, chỉ việc nâng cấp server cho service
					liên quan đến nghiệp vụ kho vận(ngược lại, có thể giảm server nếu cần thiết). Với cloud computing, việc nâng cấp server vô cùng dễ dàng chỉ với vài cú click chuột. Điều này rất khó thực hiện với monolith.
					- Do tách biệt nên nếu một service bị lỗi, toàn bộ hệ thống vẫn hoạt động bình thường. Với monolith, một module bị lỗi có thể sẽ kéo sập toàn bộ hệ thống.
					- Các service nằm tách biệt nhau, chúng có thể được sử dụng các ngôn ngữ lập trình riêng, database riêng. VD service xử lý ảnh có thể viết bằng C++, service tổng hợp data có thể viết bằng Python.
					- Có thể áp dụng được các quy trình tự động hóa, như build, deploy, monitoring,...
					- Khi chia nhỏ các service, team size sẽ giảm và mọi người sẽ làm việc hiệu quả hơn
					- Cho phép dễ dàng continuous delivery và deployment các ứng dựng lớn, phức tạp:
					-  Cải thiện khả năng bảo trì - mỗi service tương đối nhỏ do đó dễ hiểu và thay đổi hơn
					- Khả năng testing dễ dàng hơn - các services nhỏ hơn và nhanh hơn để test
					...
		Tuy nhiên không phải là không có nhược điểm--Microservices là gì:
		
				- Các module giao tiếp qua mạng nên có thể tốc độ không cao bằng monolith. Ngoài ra, mỗi module phải tự giải quyết các vấn đề về bảo mật, transaction, lỗi kết nối, quản lý log files.
				- Việc đảm bảo tính đồng nhất trong dữ liệu sẽ trở nên phức tạp hơn
				- Sử dụng nhiều service nên việc theo dõi, quản lý các service này sẽ phức tạp hơn
				- Cần một đội ngũ thật ngon để thiết kế và triển khai bao gồm software architect xịn
				- Các nhà phát triển phải đối phó với sự phức tạp của việc tạo ra một hệ thống phân tán
				- Cần implement việc communication giữa các inter-services
				- Handle partial failure là rất phức tạp vì một luồng xử lý cần đi qua nhiều services
				- Việc thực hiện các requests trải rộng trên nhiều services khó khăn hơn, điều này cũng đòi hỏi sự phối hợp cẩn thận giữa các teams
				- Khó khăn trong việc đảm bảo toàn vẹn CSDL nếu triển khai theo kiến trúc cơ sở dữ liệu phân vùng
				- Triển khai và quản lý microservices nếu làm thủ công theo cách đã làm với ứng dụng một khối phức tạp hơn rất nhiều
				- Phải xử lý sự cố khi kết nối chậm, lỗi khi thông điệp không gửi được hoặc thông điệp gửi đến nhiều đích đến vào các thời điểm khác nhau
		
		Một số điều cần lưu ý khi thiết kế Microservices--Microservices là gì:
		
				Một số cách hiểu sai về Microservices
					
					- Số dòng code/ kích cỡ của một đội lập trình là chỉ số tồi: có vài cuộc bàn luận về kích thước của một service dựa vào số lượng dòng code hay kích thước của đội phát triển service đó (ví dụ two-pizza
					team).Tuy nhiên, những cách đo đếm này không thực tiễn và không chính xác, vì ta có thể phát triển services với ít dòng code hoặc với một đội nhỏ nhưng hoàn toàn vi phạm các nguyên tắc trong kiến trúc
					microservices.
					- "Micro" là một từ khóa dễ gây nhầm lẫn. Nếu bạn nghĩ rằng nên tạo ra services nhỏ hết mức thì đó là một cách hiểu sai.
					- Trong SOA, services thường trở thành các cục monolithic với nhiều hàm, chức năng khác hỗ trợ. Vì vậy, chỉ phát triển services kiểu SOA rồi dán nhãn microservices hoàn toàn lạc hướng và không mang lại bất
					kì lợi ích nào của kiến trúc microservices.
				
				Vậy cần tuân thủ điều gì?
					
					- Single Responsibility Principle (SRP): một service với phạm vi và chức năng giới hạn, tập trung vào một nhiệm vụ giúp quá trình phát triển và triển khai dịch vụ trở nên nhanh chóng hơn.
					- Trong quá trình thiết kế, ta nên xác định và giới hạn các services theo chức năng nghiệp vụ thực tế
					- Đảm bảo microservices có thể phát triển và triển khai độc lập
					- Mục tiêu của thiết kế là phạm vi của microservices phục vụ một nghiệp vụ chứ không chỉ đơn giản làm các dịch vụ nhỏ hơn. Kích thước hợp lý của một service là kích thước đủ để đáp ứng yêu cầu của một
					chức năng trong hệ thống.
					- Khác với services trong SOA, một microservice không nên có quá nhiều hàm hay chức năng hỗ trợ xung quanh và định dạng thông báo/ gửi tin (messaging) đơn giản.
		
		Làm thế nào để duy trì tính nhất quán dữ liệu?--Microservices là gì:
		
				- Thông thường, để đảm bảo tính độc lập mỗi service sẽ có một cơ sở dữ liệu riêng. Duy trì tính nhất quán dữ liệu giữa các services là một thách thức nên 2 phase-commit/distributed transactions không phải là
				một lựa chọn tối ưu. Thay vào đó, một ứng dụng nên sử dụng Saga partten.
				- Một service publishes một event khi dữ liệu của nó thay đổi. Các services khác consume event đó và cập nhật dữ liệu của chúng. Nếu một transaction thất bại, thì saga sẽ thực hiện một loạt các transactions
				để hoàn tác các transactions trước đó. Có một số cách đáng tin cậy để updating data và publishing các events là Event Sourcing và Transaction Log Tailing.
		
		Khi nào nên sử dụng kiến trúc Microservices?--Microservices là gì:
		
				- Việc xây dựng phần mềm theo kiến trúc nào hoàn toàn phụ thuộc vào phạm vi bài toán mà ứng dụng đó đặt ra, hiện tại thì theo đánh giá của mình Monolith phù hợp với các ứng dụng cỡ vừa và nhỏ,
				còn Microservices sẽ phù hợp với những ứng dụng lớn => chúng ta cần cân nhắc cẩn thận khi sử dụng để tránh trường hợp mang dao mổ trâu đi thịt gà
				- Khi phát triển phiên bản đầu tiên của ứng dụng, bạn thường không gặp phải các vấn đề mà Microservices giải quyết. Hơn nữa, sử dụng một kiến trúc phân tán, phức tạp sẽ làm chậm quá trình phát triển. Đây là
				một vấn đề rất lớn đối với các start-up vì họ cần phát triển nhanh mô hình kinh doanh cùng ứng dụng đi kèm. Vì vậy, theo tôi, trừ khi bạn có một hệ thống quá phức tạp để quản lý bằng Monolithic Architecture,
				hoặc bạn xác định tương lai của ứng dụng sẽ trở nên như vậy. Thì kiến trúc Monolithic vẫn đủ tốt đối với bạn.
		
		Thiết kế phần mềm theo kiến trúc Microservice--Microservices là gì:
		
				Mỗi microservice nên có một database riêng biệt
					
					- Việc này đảm bảo cho microservice có tính đóng gói cao. Tuy vậy việc phân tách nơi chứa dữ liệu cho mỗi microservice không hề đơn giản, nó là phần khó nhất trong việc thiết kế ứng dụng phần mềm theo kiến
					trúc microservice. Do đó, rất nhiều người chọn lựa thiết kế sử dụng chung database cho nhiều microservice.
					- Cách này tồn tại một hạn chế là khi database schema cần thay đổi cho microservice1 thì nó sẽ làm ảnh hưởng và gây lỗi cho các microservice khác sử dụng chung database này. Để sửa lỗi, ta cần sửa đổi,
					cập nhật toàn bộ microservice còn lại để chúng có thể hoạt động với schema mới.
					- Có một cách tiếp cận khác, giúp tránh được hạn chế trên.
					- Sơ đồ trên, microservice2 không truy cập trực tiếp vào database, thay vào đó nó truy cập database thông qua microservice1. Do đó việc thay đổi schema của database sẽ không ảnh hưởng tới
					microservice2. Tuy nhiên với cách tiếp cận này thì microservice2 phụ thuộc vào microservice1, khi microservice1 có lỗi thì microservice2 cũng bị lỗi theo.
					- Việc chọn cách tiếp cận nào phụ thuộc rất nhiều vào tình hình thực tế của dự án. Cần cân nhắc thiệt hơn của mỗi phương án để đưa ra lựa chọn cuối cùng.
				
				Giữ source code của microservice ở mức hợp lý
					
					Như đã đề cập ở phần ưu và nhược điểm của microservice. Kích thước source code của một microservice không nên quá nhỏ hoặc quá lớn. Tuy nhiên cái khó ở đây là không có một con số định lượng cho kích
					thước của một microservice, nên thông thường việc quyết định kích thước của một microservice là do kinh nghiệm, cảm tính.
				
				Tạo build script cho mỗi microservice
					
					Build script có thể là một file bash hoặc Dockerfile để đóng gói microservice vào bên trong một docker image.
				
				Triển khai mỗi microservice bên trong một app (docker container)
				
					Việc triển khai mỗi microservice trong một docker container đem lại rất nhiều lợi ích cho việc triển khai và mở rộng ứng dụng cũng như việc phân chia tài nguyên phần cứng cho mỗi microservice. Hiện
					nay có rất nhiều công cụ hỗ trợ cho việc liên tục tích hợp, liên tục triển khai hệ thống microservice. Các công cụ này giúp tăng hiệu quả làm việc cho các lập trình viên, giảm thời gian phôi phối sản
					phẩm phần mềm, và các công cụ này đòi hỏi mỗi microservice được đóng gói trong một docker image và triển khai trên app.
				
				Stateless server
				
					- Khi một yêu cầu được gửi đến server thì một phiên làm việc (session) được mở ra, kèm theo đó là các thông tin của phiên. Stateless server là server không lưu thông tin của phiên. Mà thông tin về phiên
					được lưu ở một nơi khác, như caching server chẳng hạn.
					- Việc này rất quan trọng, bởi vì mỗi microservice thường được đóng gói thành một docker image. Khi muốn cập nhật một microservice, ta cập nhật docker image của nó, và khi chạy docker image
					mới (xóa bỏ container cũ và tạo container mới dựa trên image mới) thì toàn bộ thông tin của các phiên hoạt động trên container cũ sẽ bị mất, thông tin phiên thường bao gồm thông tin mà client gửi
					tới server, mất thông tin này là một lỗi vô cùng nghiêm trọng. Nếu container là stateless thì nó không lưu thông tin của các phiên nên không có gì để mất cả.		

AJAX---:

	AJAX Introduction--AJAX:
	
		AJAX is a developer's dream, because you can:
						
						Read data from a web server - after the page has loaded
						Update a web page without reloading the page
						Send data to a web server - in the background
						
						<!DOCTYPE html>
						<html>
						<body>
						<div id="demo">
						<h2>The XMLHttpRequest Object</h2>
						<button type="button" onclick="loadDoc()">Change Content</button>
						</div>
						<script>
						function loadDoc() {
						const xhttp = new XMLHttpRequest();
						xhttp.onload = function() {
							document.getElementById("demo").innerHTML =
							this.responseText;
						}
						xhttp.open("GET", "ajax_info.txt");
						xhttp.send();
						}
						</script>
						</body>
						</html>
					
		What is AJAX?
						
						AJAX = Asynchronous JavaScript And XML.
						
						AJAX is not a programming language.
						
						AJAX just uses a combination of:
							A browser built-in XMLHttpRequest object (to request data from a web server)
							JavaScript and HTML DOM (to display or use the data)
						
						AJAX is a misleading name. AJAX applications might use XML to transport data, but it is equally common to transport data as plain text or JSON text.
						
						AJAX allows web pages to be updated asynchronously by exchanging data with a web server behind the scenes. This means that it is possible to update parts of a web page, without reloading the whole page.
		
		How AJAX Works
						
						1. An event occurs in a web page (the page is loaded, a button is clicked)
						2. An XMLHttpRequest object is created by JavaScript
						3. The XMLHttpRequest object sends a request to a web server
						4. The server processes the request
						5. The server sends a response back to the web page
						6. The response is read by JavaScript
						7. Proper action (like page update) is performed by JavaScript
					
		Modern Browsers (Fetch API)
		
						Modern Browsers can use Fetch API instead of the XMLHttpRequest Object.
						The Fetch API interface allows web browser to make HTTP requests to web servers.
						If you use the XMLHttpRequest Object, Fetch can do the same in a simpler way.		

Jquery---:

				- jQuery was created in 2006 by John Resig. It was designed to handle Browser Incompatibilities and to simplify HTML DOM Manipulation, Event Handling, Animations, and Ajax.
				- For more than 10 years, jQuery has been the most popular JavaScript library in the world.
				- However, after JavaScript Version 5 (2009), most of the jQuery utilities can be solved with a few lines of standard JavaScript

	Selector - Chọn phần tử trong jQuery--Jquery:
	
		Selector - Chọn phần tử trong jQuery
		
				Selector chọn phần tử là chức năng quan trong của jQuery, như bạn thấy Selector bắt đầu bằng ký tự $. Selector cho phép bạn chọn phần tử HTML và tương tác với phần tử, Selector tìm kiếm và lựa chọn
				phần tử dựa trên id, class, thẻ, thuộc tính phần tử, giá trị phần tử và cả nội dung trong phần tử.
			
			Lựa chọn theo tên thẻ phần tử
				
				Các phần tử HTML như đã biết thuộc một trong các thẻ như : <p> <h1> <span> ..., các tên thẻ này được jQuery dùng để lựa chọn phần tử.

				Giả sử chọn tất cả các phần tử thẻ <p> trên trang thì viết như sau:
			
					$("p")
					
				Ví dụ: khi bấm vào một nút <button> tất cả các phần tử thẻ <p> bị ẩn đi
						
						$(document).ready(
							function () {

								//Chọn các phần tử button và gán sự kiện click cho nó
								$("button").click(function () {

									//Chọn các phần tử p và thi hành ẩn các phần tử đó
									$("p").hide();

								});
							}
						);
						
			Lựa chọn theo id phần tử
			
					Một phần tử HTML có id thì có thể chọn bằng bằng ký hiệu #id trong Selector. Ví dụ phần tử có id là 'test' thì chọn nó như sau
						
						$("#test")
					
					Ví dụ: khi bấm vào một nút <button> phần tử có id là test bị ẩn đi bị ẩn đi
						
						$(document).ready(
							function () {

								//Chọn các phần tử button và gán sự kiện click cho nó
								$("button").click(function () {

									//Chọn phần tử có id là test và thi hành ẩn các phần tử đó
									$("#test").hide();

								});
							}
						);
						
			Lựa chọn theo class
			
					Tương tự như chọn theo id, một phần tử có class là test thì chọn nó như sau
						
						$(".test")
			
			Bạn nhận thấy, cách chọn phần tử trong jQuery giống với cách chọn phần tử của CSS		

		Các Selector hữu ích hay dùng trong jQuery
			
			Cơ bản thì Selector jQuery giống với Selector CSS, bảng dưới đây là các trường hợp có thể bạn dùng tới
			
			Selector cơ bản
			
			*							$("*")							Chọn tất cả các phần tử
			#id							$("#lastname")					Chọn phần tử có id="lastname"
			.class						$(".intro")						Chọn phần tử có class="intro"
			.class,.class				$(".intro,.demo")				Chọn phần tử có class là "intro" hoặc "demo"
			element						$("p")							Chọn các phần tử thẻ <p>
			el1,el2,el3					$("h1,div,p")					Chọn tất cả các phần tử thẻ <h1> <div> và <p>			
			
			Selector nâng cao
			:first						$("p:first")					Chọn phần tử <p> đầu tiên trong luồng HTML
			:last						$("p:last")						Chọn phần tử <p> cuối cùng
			:even						$("tr:even")					Chọn các phần tử <tr> ở vị trí chẵn
			:odd						$("tr:odd")						Chọn các phần tử <tr> ở vị trí lẻ			
			:first-child				$("p:first-child")				Chọn tất cả phần tử <p> với điều kiện nó là phần tử con đầu tiên trong phần tử cha chứa nó
			:first-of-type				$("p:first-of-type")			Chọn các phần tử <p> với điều kiện nó là phần tử <p> đầu tiên gặp trong các phần tử con mà phần tử cha chứa
			:last-child					$("p:last-child")				Chọn các phần tử <p> với điều kiện nó là phần tử cuối cùng trong phần tử cha chứa nó.
			:last-of-type				$("p:last-of-type")				Chọn các phần tử <p> với điều kiện nó là phần tử <p> sau cùng thấy trong phần tử cha
			:nth-child(n)				$("p:nth-child(2)")				Tất cả các phần tử <p> là phần tử con thứ 2
			:nth-last-child(n)			$("p:nth-last-child(2)")		Tất cả phần tử <p> là phần tứ con thứ 2 đếm từ dưới lên.
			:nth-of-type(n)				$("p:nth-of-type(2)")			Tất cả phần <p> là, nó là phần tử thứ 2 dạng <p> trong các phần tử con
			:nth-last-of-type(n)		$("p:nth-last-of-type(2)")		Tất cả các phần tử <p>, nó là phần tử thứ 2 dạng <p> đếm từ dưới lên.
			parent < child				$("div > p")					Tất cả phần tử <p> là phần tử con trực tiếp của phần tử <div>
			parent descendant			$("div p")						Tất cả phần tử <p> là phần tử con, cháu ... của <div>
			element + next				$("div + p")					Chọn phần tử <p> mà nó là phần tử tiếp theo của một phần tử <div>
			element ~ siblings			$("div ~ p")					Các phần tử <p> có cấp ngang hàng với một phần tử <div>			
			
			Selector jQuery chọn phần tử danh sách

			:eq(index)					$("ul li:eq(3)")				Phần tử thứ 4 trong một danh sách
			:gt(no)						$("ul li:gt(3)")				Các phần tử có chỉ số lớn hơn 3
			:lt(no)						$("ul li:lt(3)")				Các phần tử trong danh sách có chỉ số nhỏ hơn 3
			:not(selector)				$("input:not(:empty)")			Các phần tử <input> không rỗng
			
			Selector jQuery theo trạng thái
			
			:header						$(":header")					Tất cả các phần tử <h1>, <h2> ...
			:animated					$(":animated")					Các phần tử động
			:focus						$(":focus")						Phần tử đang giữ focus
			:contains(text)				$(":contains('Hello')")			Các phần tử có chứa chữ "Hello"
			:has(selector)				$("div:has(p)")					Các phần tử <div> trong nó có chứa một phần tử <p>
			:empty						$(":empty")						Tất cả các phần tử rỗng
			:parent						$(":parent")					Các phần tử là cha của một phần tử khác
			:hidden						$("p:hidden")					Tất cả các phần tử <p> đang ẩn
			:visible					$("table:visible")				Tất cả các <table> đang hiện thị			
			
			Selector jQuery theo thuộc tính phần tử
			
			[attribute]					$("[href]")						Các phần tử có thuộc tính href
			[attribute=value]			$("[href='default.htm']")		Các phần tử có thuộc tính href và giá trị thuộc tính là "default.htm"
			[attribute!=value]			$("[href!='default.htm']")		Các phần tử có thuộc tính href nhưng giá trị khác "default.htm"
			[attribute$=value]			$("[href$='.jpg']")				Các phần tử có thuộc tính href và giá trị có phần cuối bằng ".jpg"
			[attribute|=value]			$("[title|='Tomorrow']")		Các phần tử có title bằng 'Tomorrow' hoặc bắt đầu bởi 'Tomorrow'
			[attribute^=value]			$("[title^='Tom']")				Các phần tử có title với giá trị bắt đầu bằng "Tom"
			[attribute~=value]			$("[title~='hello']")			Các phần tử có title, và giá trị có chứa "hello"
			[attribute*=value]			$("[title*='hello']")			Các phần tử có title và giá trị chứa "hello"			
			
			Selector jQuery trong FORM

			:input						$(":input")						Tất cả các phần tử input
			:text						$(":text")						Tất cả các phần tử có type="text"
			:password					$(":password")					Tất cả phần tử có type="password"
			:radio						$(":radio")						Tất cả phần tử có type="radio"
			:checkbox					$(":checkbox")					Tất cả phần tử có type="checkbox"
			:submit						$(":submit")					Tất cả phần tử có type="submit"
			:reset						$(":reset")						Tất cả phần tử cótype="reset"
			:button						$(":button")					Tất cả phần tử có type="button"
			:image						$(":image")						Tất cả phần tử có type="image"
			:file						$(":file")						Tất cả phần tử có type="file"
			:enabled					$(":enabled")					Tất cả các phần tử input là enable
			:disabled					$(":disabled")					Các phần tử input bị vô hiệu
			:selected					$(":selected")					Các phần tử input là selected
			:checked					$(":checked")					Các phần tử input là checked

	Thuộc tính HTML và jQuery--Jquery:
	
		Làm việc với thuộc tính phần tử HTML
			
			Chúng ta có thể tương tác lấy, gán giá trị cho thuộc tính HTML (href, src, id, class, style ... ) rất dễ dàng thông qua jQuery. Phương thức attr() sử dụng để lấy giá trị thuộc tính và gán giá trị thuộc tính.
				
				attr(attr_name) : lấy giá trị của thuộc tính có tên attr_name
				attr(attr_name, attr_val) : gián giá trị attr_val vào thuộc tính attr_name
			
			Lấy thuộc tính
				
				Ví dụ trong HTMl của bạn có phần tử thẻ <a> với id là 'exam', giờ ta dùng attr() để lấy giá trị thuộc tính href
					
					HTML
					
						<a id="exam" href="https://xuanthulab.net/">
						   Bấm vào đây
						</a>
					
					JavaScript
					
						$(function() {
						  var val = $("a#exam").attr("href");
						  alert(val);
						});
					// Hiện thị thông báo : https://xuanthulab.net/
			
			Gán giá trị cho thuộc tính
			
				Trở lại ví dụ trên, giờ viết JavaScript / jQuery để thay đổi thuộc tính href thanh địa chỉ link mới : google.com.vn
				
				JavaScript
				
					$(function() {
						$("a#exam").attr("href", "https://www.google.com.vn/");
					});
					
			Kiểm tra một thuộc tính tồn tại với jQuery
			
				Cách 1
				
					var attr = $("selector").attr('name');
					if (typeof attr !== typeof undefined && attr !== false) {
					  // Có thuộc tính name
					}
					else {
					  // không có thuộc tính name
					}
					
				Cách 2 - Sử dụng hàm JavaScript
					
					if ($("selector")[0].hasAttribute('name')) {
						// có thuộc tính name
					}
					else {
					  // không có thuộc tính name
					}
					
		Loại bỏ thuộc tính HTML
		
			Thuộc tính của phần tử HTML có thể xóa bỏ khỏi phần tử bằng phương thức removeAttr(attr_name)
			
			JavaScript
					
					//xóa bỏ thuộc tính border khỏi phần tử table
					$("table").removeAttr("border");

					//xóa bỏ thuộc tính class khỏi phần tử div
					$("div").removeAttr("class");

					//xóa bỏ thuộc tính title khỏi phần tử a
					$("table").removeAttr("title");		
					
	Nội dung phần tử với jQuery--Jquery
	
		Lấy nội dung phần tử
			
			Có vài phương thức để tương tác với nội dung của các phần tử HTML. Trong đó phương thức html() được dùng để lấy nội dung phần tử được chọn, nó lấy cả nội dung HTML markup. Còn nếu muốn chỉ lấy nội dung text
			không HTML markup thì dùng phương thức text()

			Ví dụ sau bấm vào phần tử p.example1 thì sẽ lấy nội dung HTML Markup và text rồi thông báo
			
				HTML + JavaScript
					
					<p class="example1"><strong>Bấm vào đây</strong> <i>để lấy nội dung</i></p>
					<script>
						//Bắt sự kiện click cho phần tử có class .example1
						$(".example1").click(function () {
							//lấy phần tử bấm chuột - chính là  $(".example1")
							var ele_example1 = $(this);
							//lấy nội dung
							var htmlmarkup =  ele_example1.html();
							var htmlcontent = ele_example1.text();
							alert("HTML Markup:\n" + htmlmarkup);
							alert("HTML Content:\n" + htmlcontent);
						});
					</script>

		Gán nội dung cho phần tử
		
			Phương thức html(), text() như trên không có tham số thì là đọc và trả về nội dung phần tử, còn nếu nó có tham số thì trở thành thiết lập gán giá trị tham số cho phần tử.
				
				<div class="card p-4 m-4">
					<p class="example2"><strong>Bấm vào đây</strong> <i>để thay đổi</i></p>
				</div>
				<script>
					$(".example2").click(function () {
						var ele_example2 = $(this);
						 var htmlmarkup =  ele_example2.html();
						 ele_example2.html(htmlmarkup + htmlmarkup);
					});
				</script>

		Đọc và gán giá trị phần tử val()
		
			Để đọc hoặc gán giá trị cho các phần tử trong <form> sử dụng phương thức val(), khi phương thức không có tham số là đọc, khi có tham số thì là gán giá trị tham số vào giá trị phần tử.
			
			Ví dụ dọc giá trị của phần tử select
				
				<select id="single">
					<option>Chọn 1</option>
					<option>Chọn 2</option>
				</select>
				<br>
				<select id="multiple" multiple="multiple">
					<option selected="selected">Chọn 3</option>
					<option>Chọn 4</option>
					<option selected="selected">Chọn 5</option>
				</select>
				<br>
				<input type="text" value="giá trị text">
				<br>
				<p id="info1">Nơi hiện thị thông tin</p>
				<script>
					//Hàm đọc và hiện thị thông tin
					function displayVals() {
						var singleValues =   $( "#single" ).val();
						var multipleValues = $( "#multiple" ).val() || [];
						$( "p#info1" ).html( "<b>Single:</b> " + singleValues +
							" <b>Multiple:</b> " + multipleValues.join( ", " ) );
					}
					
					
					//Bắt sự kiện thi thay đổi giá trị
					$( "#single, #multiple" ).change( displayVals );
					displayVals();
				</script>

			Ví dụ đọc giá trị của input kiểu text
				
				<input id="inputtext" type="text" value="Nhập giá trị">
				<p id="giatriinputtext"></p>
				<script>
					//Hàm đọc giá trị và hiện thị thông tin
					function textthaydoi() {
						var value = $( this ).val();
						$( "p#giatriinputtext" ).text( value );
					}
					//Bắt sự kiện keyup của textbox
					$( "#inputtext" ).keyup(textthaydoi);
					//Cho #inputext phát sinh một sự kiện keyup ban đầu
					$( "#inputtext" ).keyup();
				</script>
				
	Chèn thêm nội dung vào HTML với jQuery--Jquery:
	
		Thêm nội dùng vào trang HTML
		
			Ở phần trước chúng ta đã dử dụng các phương thức html(), text() để lấy cũng như thiết lập giá trị/nội dung trong phần tử. Tuy nhiên khi sử dụng các phương thức này thì nội dung cũ của phần tử sẽ bị ghi đè, mất đi. Do vậy jQuery còn cung cấp thêm các phương thức linh hoạt hơn là:
				
				append() chèn nội dùng vào cuối trong các phần tử chọn
				prepend() chèn nội dùng vào phần đầu trong phần tử chọn
				after() chèn nội dùng vào phía sau phần tử chọn
				before() chèn nội dùng vào phía trước phần tử chọn
				
			Nội dung chèn có thể là HTML Markup, Text hoặc tạo ra một phần tử DOM mới bằng jQuery, ví dụ tạo phần tử <p> mới sau đó thiết lập nội dung text cho nó là 'Hello World'
				
				var newelement = $("<p></p>").text("Hello World");
		
		Ví dụ sử dụng append(), prepend(), after(), before() trong jQuery
			
			Ở ví dụ dưới đây, dùng jQuery chọn phần tử div có nền màu đen, sau đó chèn nội dung vào bên trong nó (chèn ở đầu (prepend, ở cuối append) và phía trước (before) phía sau (after)
				
				<style>
					#containerexample {
						background: #9c27b0;
						padding: 20px;
						color: white;
						font-weight: bold;
					}
					#phantudiv {
						background: #1d1e1f;
						padding: 30px;
					}
					#containerexample p {
						border: 1px dashed gray;
						padding: 5px;
						animation-name: keyframes1;
						animation-duration: 2s;
					}
					#phantudiv>p.phantup {
						color: yellow;
					}
					@keyframes keyframes1 {
						0%  {opacity: 0;}
						100% {opacity: 1;}
					}
				</style>
				<div id="containerexample">
					<div id="phantudiv">
						<p class="phantup">Nội dung ban đầu trong phần tử</p>
					</div>
					<br>
					<button onclick="append_jquery()">append()</button>
					<button onclick="prepend_jquery()">prepend()</button>
					<button onclick="after_jquery()">after()</button>
					<button onclick="before_jquery()">before()</button>
				</div>
				<script>
					var phantuchon = $("#phantudiv");
					function append_jquery() {
						phantuchon.append("<p>Chèn thêm bằng append()</p>");
					}
					function prepend_jquery() {
						phantuchon.prepend("<p>Chèn thêm bằng prepend()</p>");
					}
					function after_jquery() {
						phantuchon.after("<p>Chèn thêm bằng after()</p>");
					}
					function before_jquery() {
						phantuchon.before("<p>Chèn thêm bằng before()</p>");
					}
				</script>

	Hiệu ứng động với animate() trong jQuery--Jquery
	
		Phương thức animate() giúp bạn tạo ra các hiệu ứng động bằng cách thay đổi các thuộc tính của phần tử từ giá trị ban đầu đến giá trị mong muốn. Các thuộc tính muốn biến đổi và giá trị của nó viết theo cặp theo nguyên
		tắc JSON rồi truyền vào tham số thứ nhất của phương thức. Tham số thứ hai của phương thức là khoảng thời gian (mili giây) diễn ra hiệu ứng. Củ pháp của cơ bản như sau:
			
			.animate({property1: value1, property2: value2, ... }, speed);
		
		Có thể thêm tham số thứ 3 chức năng easing 'swing' 'linear', tham số thứ 4 là một hàm callback, được gọi sau khi hiệu ứng động hoàn thành.
		
		Ví dụ sau, hiệu ứng diễn ra trong 2s bằng cách thay đổi chiều rộng, cao của phần tử.
			
			<div id="example1"></div>
			<button id="button1">Hiệu ứng animate()</button>
			<script>
				$("#button1").click(function () {
					$("#example1").css({"width": "10px",
						"height": "10px",
						"background":"orangered"});
					$("#example1").animate(
						{"width": "100%", "height": "100px"}, 2000);
				});
			</script>
			
			Check trường hợp tại https://xuanthulab.net/hieu-ung-dong-voi-animate-trong-jquery.html
		
		Bạn cũng có thể thiết lập hiệu ứng thay đổi từ giá trị hiện tại tới giá trị cộng thêm bằng cách dùng += hoặc -=
		
		Dừng lập tức hiệu ứng động
			
			Hiệu ứng đang chạy với .animate() có thể bắt dừng ngay lập tức bằng phương thức .stop()
				
				<div id="example2"><strong>****</strong></div>
				<button id="button2">Chạy animate()</button>
				<button id="button3">Dừng animate()</button>
				<script>
					function animate_examp() {
						var mr = $("#example2").css("margin-left");
						if (mr == '0px')
							$("#example2").animate({"margin-left": "320px"}, 2000, "linear", function () {
								animate_examp();
							});
						else
							$("#example2").animate({"margin-left": "0px"}, 2000, "linear", function () {
								animate_examp();
							});
					  }
					$("#button2").click(function () {
						animate_examp();
						$(this).hide();
					});
					$("#button3").click(function () {

						$("#example2").stop();
						$("#button2").show();
					});
				</script>
				
	Hiệu ứng ẩn hiện phần tử HTML DOM với jQuery--Jquery
	
		Hiệu ứng Hide/Show
		
			jQuery có một số hiệu ứng động rất dễ để sử dụng. Trong đó, phương thức hide() và show() đùng để ẩn đi hay hiện thị các phần tử chọn, tương tự toggle() sẽ tương đương với show() nếu phần tử đang ẩn, và tương đương với hide() nếu phần tử đang hiện thị.
				
				<button id="vidu1">Bấm vào đây
					<strong id="pvidu1">Sử dụng toggle()</strong>
				</button>
				<script>
					$("#vidu1").click(function() {
					   $("#pvidu1").toggle();
					});
				</script>
				
			Phương thức show(), hide(), toggle() có thể chứa tham số thứ nhất để chỉ ra thời gian hoàn thành hiệu ứng (tính bằng mili giây).
			
			Ví dụ hiệu ứng xảy ra trong 1s
				
				<button id="vidu2">Bấm vào đây
					<strong id="pvidu2">Sử dụng toggle(1000)</strong>
				</button>
				<script>
					$("#vidu2").click(function() {
						$("#pvidu2").toggle(1000);
					});
				</script>
				
			Phương thức show(), hide(), toggle() còn có thể chứa hàm callback, là hàm sẽ thi hành sau khi hiệu ứng hoàn thành.
			
			Ví dụ sau sẽ gọi một hàm callback sau khi hiệu ứng hoàn thành.
				
				<button id="vidu3">Bấm vào đây
					<strong id="pvidu3">Sử dụng toggle(1000)</strong>
				</button>
				<script>
					$("#vidu3").click(function() {
						$("#pvidu3").toggle(500, function() {
							$("#pvidu3").toggle(500);
						});
					});
				</script>
				
		Hiệu ứng mờ dần
		
			Tương tự như ba hàm show(), hide(), toggle() cũng có ba hàm với chức năng tương tự nhưng đi kèm hiệu ứng phai dần đó là fadeIn(), fadeOut() và fadeToggle()

			Tương tự nó cũng có thể có hai tham số tốc độ và ham callback, ví dụ:
				
				<button id="vidu4">Bấm vào đây
					<strong id="pvidu4">Sử dụng fadeToggle(1000)</strong>
				</button>
				<script>
					$("#vidu4").click(function() {
						$("#pvidu4").fadeToggle(1000, function() {
							$("#pvidu4").fadeToggle(1000);
						});
					});
				</script>
				
			Ngoài ra còn có phương thức fadeTo(speed, opacity) để chạy hiệu ứng thiết lập opacity về giá trị chỉ ra. Ví dụ:
				
				$("div").fadeTo(1500, 0.7);
				
		Hiệu ứng trượt phần tử
		
			Hiệu ứng xuất ẩn phần tử slideUp, xuất hiện phần tử slideDown là hiệu ứng giống với hide(), show() nhưng kèm thêm trượt phần tử. Tương tự có slideToggle() để chuyển trạng thái qua lại giữa hai phương thức này
				
				<button id="vidu5">Bấm vào đây
					<strong id="pvidu5">Sử dụng slideUp(1000)</strong>
				</button>
				<script>
					$("#vidu5").click(function() {
						$("#pvidu5").slideToggle(1000, function() {
							//... code in callback
						});
					});
				</script>
				
	Bắt các sự kiện DOM trong jQuery--Jquery
	
		Bắt các sự kiện với jQuery
		
			jQuery cung cấp một công cụ mạnh mẽ để bắt các sự kiện trong JavaScript. Các sự kiện được phát sinh khi người dùng thực hiện các hành động trên trang, ví dụ bấm vào một phần tử, di chuyển chuột, gửi form ...

		Xét một ví dụ: khi người dùng bấm vào một phần tử có id là "demo" thì hiện thị ngày tháng hiện tại. Nếu chỉ dùng JavaScript thì bạn đã biết (Sự kiện với JavaScript) có thể thực hiện như sau:
				
				<button id="demo">Ngày hiện tại</button>
				<script>
					var x = document.getElementById("demo");
					x.onclick = function () {
						alert(Date());
					}
				</script>
			
		Còn thực hiện với jQuery như sau:
		
				$("#demo").click(function() {
					alert(Date());
				});
				
				Như bạn thấy tên sự kiện trong JavaScript là onclick thì với thư viện jQuery nó bỏ đi on thành click
		
		Danh sách các sự kiện hay dùng
			
			Sự kiện với chuột
				
				click xảy ra khi click chuột trên phần tử.
				dblclick nháy kép chuột.
				mouseenter chuột đi vào phần tử.
				mouseleave chuột ra khỏi phần tử.
				mouseover chuột trên phần tử.
				
			Sự kiện với bàn phím
			
				keydown phím ấn xuống
				keyup phím nhả ra
				
			Sự kiện trên form
				
				submit gửi form
				change giá trị phần tử trong form thay đổi
				focus nhận focus
				blur mất focus
				
			Sự kiện trên Document
			
				ready khi DOM đã tải xong hoàn toàn (trang được load và dựng đầy đủ)
				resize khi cửa sổ Browser thay đổi kích thước
				scroll khi người dùng cuộn trang, phần tử
				
		Ví dụ bắt dự kiện mouseover, mouseleave
			
			<style>
				#ele1 {
					background-color: #ff5329;
					padding: 25px;
					color: white;
					cursor: pointer;
				}
			</style>
			<div id="ele1">PHẦN TỬ KIỂM TRA</div>
			<script>
				$("#ele1").mouseover(function () {
					$(this).html("Chuột trên phần tử : " + Date());
				});
				$("#ele1").mouseleave(function () {
					$(this).html("Ra khỏi phần tử: " + Date());
				});
			</script>
			
		Bắt các sự kiện với on
		
			Đây là một cách khác, các sự kiện bắt bằng phương thức .on('eventname', handler) với tên sự kiện.
			
			Ví dụ bắt sự kiện click
				
				$( "p" ).on( "click", function() {
				  alert("clicked");
				});
			Cách này có cái hay là có thể bắt một lúc nhiều sự kiện, ví dụ: .on("click, dbclcik", handler)
		
		Tắt sự kiện với off
			
			Sự kiện thực hiện trên jQuery có thể được loại bỏ bằng phương thức .off()

			Ví dụ: nếu sự kiện click trên thẻ div được gán, có thể loại bỏ nó bằng cách:
				
				$("div").off("click");
				
		Đối tượng Event
		
			Các handler hàm xử lý sự kiện bắt được, đều có thể nhận được một đối tượng mang thông tin sự kiện nó nhận được (các ví dụ trên chúng ta chưa viết để nhận đối tượng này), như các thuộc tính, phương thức liên
			quan đến sự kiện.

			Để nhận được đối tượng này, các hàm Handler ở trên chỉ cần cho thêm tên một tham số khi khai báo, tên này chính là đối tượng Event.
			
			Ví dụ:
				
				//sự kiện với phần tử a
				$( "a" ).click(function(event) {
				  alert(event.pageX);
				  event.preventDefault();
				});
				//sự kiện với phần tử p
				$( "p" ).on( "click", function(doituongsukien) {
					  alert(doituongsukien.pageX);
				});
				
			Đối tượng Event có một số thuộc tính, phương thức hay dùng như:
			
				pageX, pageY vị trí chuột khi sự kiện xảy ra
				type kiểu sự kiện, ví dụ "click"
				which nút, phím được bấm
				data dữ liệu được chuyển theo sự kiện
				target phần tử DOM phát sinh sự kiện
				preventDefault() phương thức chặn lại ứng sử mặc định của sự kiện (ví dụ bấm vào link sẽ chuyển trang, thì hàm này sẽ hủy hành động này)
				stopPropagation() ngăn tiếp tục gửi sự kiện (nếu gọi thì sự kiên không còn được gửi tiếp trong hệ thống các đối tượng nhận sự kiện)
		
		Phát sinh sự kiện
			
			Như trên đã biết một sự kiện như click, keyup, focus ... phát sinh bởi hoạt động của người dùng trên trang. Nhưng bạn cũng có thể tự phát sinh sự kiện này, ví dụ bấm chuột vào một liên kết ...Thật đơn giản, chỉ
			cần gọi phương thức .trigger("eventname");
			
			Ví dụ gửi form
				
				$("form").trigger("submit");
		
		Ví dụ tổng hợp, viết các việc cần làm:
		
			<style>
				.rem {
					margin-left: 5px;
					background-color: white;
					color: red;
					border: none;
					cursor: pointer;
				}
			</style>
			<input type="text" placeholder="New item" />
			<button id="add">Thêm việc</button>
			<ol id="mylist"></ol>
			<script>
				$(function() {
					$("#add").on("click", function() {
						var val = $("input").val();
						if(val !== '') {
							var elem = $("<li></li>").text(val);
							$(elem).append("<button class='rem'>X</button>");
							$("#mylist").append(elem);
							$("input").val("");
							$(".rem").on("click", function() {
								$(this).parent().remove();
							});
						}
					});
				});
			</script>		
			
	Xóa phần tử khỏi DOM HTML với jQuery--Jquery
	
		Loại bỏ phần tử với jQuery
		
			Trong jQuery có vài phương thức để loại bỏ phần tử trong DOM như: .empty(), .remove(), .detach()
			
				.empty() : phương thức này loại bỏ tất cả các phần tử con của phần tử chọn được.
				.remove() : loại bỏ các phần tử chọn được.
				.detach() : tương tự như .remove() nhưng toàn bộ dữ liệu jQuery liên kết vẫn được giữ nguyên. Điều này có ích nếu muốn sử dụng lại phần tử đó như sẽ chèn vào vị trí khác.
		
		Ví dụ .detach()
			  .appendTo() : chèn phần tử đang chọn vào một phần tử khác chỉ ra trong tham số
		
			<style>
				#container1 p{
					background-color: #b92c28;
					color: white;
					padding: 10px;
					animation-duration: 3s;
					-webkit-animation-name: keyframes1;
					-moz-animation-name: keyframes1;
					-o-animation-name: keyframes1;
					animation-name: keyframes1;
				}
				@keyframes keyframes1 {
					0%  {opacity: 0;}
					100% {opacity: 1;}
				}
			</style>
			<div id="container1">
				<p><strong>Phần tử P</strong> được append và detach</p>
			</div>
			<button id="button1">appendTo / detach</button>
			<script>
				var pvidu1;
				$("#button1").click(function () {
					if ( pvidu1 ) {
						pvidu1.appendTo( "#container1" );
						pvidu1 = null;
					} else {
						pvidu1 = $( "#container1 p" ).detach();
					}
				});
			</script>
			
		Ví dụ .empty(), .remove
		
			Ví dụ sau loại bỏ toàn phần các phần tử con của <p> trong trang:
			
			<button onclick="emptyp()">Loại bỏ phần tử con của &lt;p&gt;</button>
			<button onclick="removep()">Loại bỏ các phần tử &lt;p&gt;</button>
			<script>
				function emptyp() {
					$( "p,pre" ).empty();
				}
				function removep() {
					$( "p,pre" ).remove();
				}
			</script>		
			
	jQuery và thuộc tính CSS--Jquery
	
		jQuery và thuộc tính CSS
		
			Trong jQuery có phương thức .css() được dùng để lấy giá trị hoặc thiết lập giá trị cho một thuộc tính CSS vào phần tử. (color, background-color, width ...)
			
			Lấy thuộc tính CSS của phần tử
				
				.css("attr");
				
			Ví dụ
			
				<style>
					#vidu1 {
						background-color: green;
						color: white;
						padding: 30px;
						cursor: pointer;
					}
				</style>
				<p id="vidu1">Ví dụ về CSS (click here)</p>
				<script>
					$('#vidu1').click(function () {
						alert($(this).css("background-color"));
						$(this).css("background-color", "#FF5722");

					});
				</script>

		Thiết lập nhiều thuộc tính css()
			Các thuộc tính cần thiết lập cho phần tử có thể gộp lại vào một JSON (JavaScript Object Notation), mỗi thuộc tính biểu diễn bằng một cặp "property":"value", các cặp cách nhau bởi dấu phẩy và toàn bộ bao
			bọc trong {}
				
				.css({"property1":"value1", "property2":"value2" ...});
			
			<style>
				#vidu2 {
					background-color: green;
					color: white;
					padding: 30px;
					cursor: pointer;
				}
			</style>
			<p id="vidu2">Ví dụ về CSS nhiều thuộc tính (click here)</p>
			<script>
				$('#vidu2').click(function () {
					$(this).css({
						"background-color" :"#FF5722",
						"font-size": "200%",
						"color": "whitesmoke"
						});

				});
			</script>

		Kích thước phần tử với jQuery
		
			Có các hàm lấy kích thước và thiết lập kích thước cho phần tử: width(), height(), innerWidth(), innerHeight(), outerWidth(), outerHeight()

			<style>
				#vidu3 {
					width: 300px;
					height: 100px;
					padding: 10px;
					margin: 20px;
					border: 3px solid blue;
					background-color: red;
					color: white;
				}
			</style>
			<div id="vidu3"></div>
			<script>
				$(function() {
					var txt = "";
					txt += "width: " + $("#vidu3").width() + " ";
					txt += "height: " + $("#vidu3").height() + "<br/>";
					txt += "innerWidth: " + $("#vidu3").innerWidth() + " ";
					txt += "innerHeight: " + $("#vidu3").innerHeight() + "<br/>";
					txt += "outerWidth: " + $("#vidu3").outerWidth() + " ";
					txt += "outerHeight: " + $("#vidu3").outerHeight();
					$("#vidu3").html(txt);
				});
			</script>		
			
	JavaScript / jQuery DOM Selectors--Jquery
	
		Finding HTML Element by Id
			
			Return the element with id="id01":
				
				jQuery
					
					<!DOCTYPE html>
					<html>
					<head>
					<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
					</head>
					<body>
					<h2>Finding HTML Elements by Id</h2>
					<p id="id01">Hello World!</p>
					<p id="id02">Hello Sweden!</p>
					<p id="id03">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					$(document).ready(function() {
					  var myElements = $("#id01");
					  $("#demo").text("The text from the id01 paragraph is: " + myElements[0].innerHTML);
					});
					</script>
					</body>
					</html>
					
				JavaScript
				
					<!DOCTYPE html>
					<html>
					<body>
					<h2>Finding HTML Elements by Id</h2>
					<p id="id01">Hello World!</p>
					<p id="id02">Hello Sweden!</p>
					<p id="id03">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					const myElement = document.getElementById("id01");
					document.getElementById("demo").innerHTML = "The text from the id01 paragraph is: " + myElement.innerHTML;
					</script>
					</body>
					
		Finding HTML Elements by Tag Name
						
			Return all <p> elements:
							
				jQuery
					
					<!DOCTYPE html>
					<html>
					<head>
					<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
					</head>
					<body>
					<h2>Finding HTML Elements by Tag Name</h2>
					<p>Hello World!</p>
					<p>Hello Sweden!</p>
					<p>Hello Japan!</p>
					<p id="demo"></p>
					<script>
					$(document).ready(function() {
					  var myElements = $("p");
					  $("#demo").text("The text in the first paragraph is: " + myElements[0].innerHTML);
					});
					</script>
					</body>
					</html>
		
				JavaScript
					<!DOCTYPE html>
					<html>
					<body>
					<h2>Finding HTML Elements by Tag Name</h2>
					<p>Hello World!</p>
					<p>Hello Sweden!</p>
					<p>Hello Japan!</p>
					<p id="demo"></p>
					<script>
					const myElements = document.getElementsByTagName("p");
					document.getElementById("demo").innerHTML = "The text in the first paragraph is: " + myElements[0].innerHTML;
					</script>
					</body>
					</html>
		
		Finding HTML Elements by Class Name
			
			Return all elements with class="intro".
				
				jQuery
					
					<!DOCTYPE html>
					<html>
					<head>
					<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
					</head>
					<body>
					<h2>Finding HTML Elements by Class Name</h2>
					<p class="intro">Hello World!</p>
					<p class="intro">Hello Sweden!</p>
					<p class="intro">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					$(document).ready(function() {
					  var myElements = $(".intro");
					  $("#demo").text("The first paragraph with class='intro' is: " + myElements[0].innerHTML);
					});
					</script>
					</body>
					</html>
					
				JavaScript
					
					<!DOCTYPE html>
					<html>
					<body>
					<h2>Finding HTML Elements by Class Name</h2>
					<p class="intro">Hello World!</p>
					<p class="intro">Hello Sweden!</p>
					<p class="intro">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					const myElements = document.getElementsByClassName("intro");
					document.getElementById("demo").innerHTML = "The first paragraph with class='intro' is: " + myElements[0].innerHTML;
					</script>
					</body>
					</html>

		Finding HTML Elements by CSS Selectors
			
			Return a list of all <p> elements with class="intro".
				
				jQuery
					
					<!DOCTYPE html>
					<html>
					<head>
					<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
					</head>
					<body>
					<h2>Finding HTML Elements by Query Selector</h2>
					<p class="intro">Hello World!</p>
					<p class="intro">Hello Sweden!</p>
					<p class="intro">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					$(document).ready(function() {
					  var myElements = $("p.intro");
					  $("#demo").text("The first paragraph with class='intro' is: " + myElements[0].innerHTML);
					});
					</script>
					</body>
					</html>
					
				JavaScript
					
					<!DOCTYPE html>
					<html>
					<body>
					<h2>Finding HTML Elements by Query Selector</h2>
					<p class="intro">Hello World!</p>
					<p class="intro">Hello Sweden!</p>
					<p class="intro">Hello Japan!</p>
					<p id="demo"></p>
					<script>
					const myElements = document.querySelectorAll("p.intro");
					document.getElementById("demo").innerHTML = 
					"The first paragraph with class='intro' is: " + myElements[0].innerHTML;
					</script>
					</body>
					</html>

	jQuery.each() Function--Jquery:

		jQuery .each() là gì?
		
			- jQuery each function được sử dụng để lặp qua từng phần tử của jQuery object.
			- jQuery object là 1 object chứa 1 hoặc nhiều phần tử DOM và dùng để giao tiếp với tất cả jQuery functions. Nó rất có ích cho thao tác với nhiều phần tử DOM, lặp qua nhiều array và thuộc tính của object. Thêm
			vào đó, jQuery cung cấp 1 helper function có cùng tên và dùng để gọi mà không cần phải chọn hay tạo phần tử DOM trước đó.
		
		jQuery .each() cú pháp
		
			Ví dụ dưới đây chọn tất cả thẻ div trên trang web và in ra số thứ tự và id của chúng. Kết quả in ra có thể là: “div0:header”, “div1:body”, “div2:footer”. Ví dụ này sử dụng jQuery each() function như 1 function tiện ích.
				
				// DOM ELEMENTS
				$('div').each(function (index, value) {
				  console.log('div' + index + ':' + $(this).attr('id'));
				});
			
			Ví dụ tiếp theo sẽ cho ta thấy cách sử dụng của function tiệc ích này. Trong trường hợp object lặp được truyền vào như tham số thứ nhất. Trong ví dụ 1 cho ta thấy cách lặp qua 1 mảng:
				
				// ARRAYS
				var arr = [
				   'one',
				   'two',
				   'three',
				   'four',
				   'five'
				];
				$.each(arr, function (index, value) {
				  console.log(value);

				  // Will stop running after "three"
				  return (value !== 'three');
				});
				// Outputs: one two three
				
			Trong ví dụ cuối này sẽ cho ta thấy cách lặp qua thuộc tính của 1 object:
				
				// OBJECTS
				var obj = {
				   one: 1,
				   two: 2,
				   three: 3,
				   four: 4,
				   five: 5
				};
				$.each(obj, function (index, value) {
				  console.log(value);
				});
				// Outputs: 1 2 3 4 5
				
		Basic jQuery.each() function example
		
			Hãy xem each() giúp chúng ta thế nào khi kết hợp với 1 jQuery object. Ví dụ đầu tiên chọn tất cả thẻ a trên trang và in ra thuộc tính href của chúng.
				
				// DOM ELEMENTS
				$('a').each(function (index, value){
				  console.log($(this).attr('href'));
				});
					Ví dụ thứ 2 in tất cả giá trị href trên trang web (giả sử chỉ giao thức HTTP)
						$('a').each(function (index, value){
				  var link = $(this).attr('href');

				  if (link.indexOf('http://') === 0) {
					console.log(link);
				  }
				});
				
				<a href="http://www.jquery4u.com">JQUERY4U</a>
				<a href="http://www.phpscripts4u.com">PHP4U</a>
				<a href="http://www.blogoola.com">BLOGOOLA</a>
					
				http://jquery4u.com
				http://www.phpscripts4u.com
				http://www.blogoola.com
				
			Chúng ta cần để ý là các phần tử DOM từ 1 jQuery object cần phải được bọc lại khi sử dụng bên trong jQuery each(). Lí do là jQuery thực tế là 1 vỏ bọc xung quanh 1 array của các phần tử DOM. Khi sử dụng
			jQuery each() mảng này sẽ được lặp qua giống như cách lặp qua 1 array truyền thống. Vì điều này, chúng ta không lấy các phần tử đã được bọc ở bên ngoài.
		
		jQuery.each() Array Example
		
			Hãy xem 1 array truyền thống có thể được xử lý.
				
				var numbers = [1, 2, 3, 4, 5, 6];
				$.each(numbers , function (index, value){
				  console.log(index + ':' + value);
				});
				
			Ví dụ trên sẽ in ra: 0:1, 1:2, 2:3, 3:4, 4:5, and 5:6.Ví dụ trên sẽ in ra: 0:1, 1:2, 2:3, 3:4, 4:5, and 5:6.
			Không có gì đặc biệt ở đây. Thuộc tính số thứ tự của array, chúng ta có các số từ 0 đến N - 1, N là số các phần tử trong array.
		
		jQuery.each() JSON Example
		
			Chúng ta có thể có cấu trúc dữ liệu phức tạp hơn, như là arrays trong arrays, objects trong objects, arrays trong objects, hoặc objects trong arrays. Hãy xem làm thế nào each() có thể giúp chúng ta trong những trường hợp này.
				
				var json = [
				 { 'red': '#f00' },
				 { 'green': '#0f0' },
				 { 'blue': '#00f' }
				];

				$.each(json, function () {
				   $.each(this, function (name, value) {
					  console.log(name + '=' + value);
				   });
				});

			Ví dụ này in ra: red=#f00, green=#0f0, blue=#00f.
			
			Chúng ta xử lý dữ liệu lồng nhau với cách gọi each() lồng nhau. Vòng gọi ở ngoài xử lý array ở biến JSON, vòng gọi ở trong xử lý objects. Trong ví dụ này mỗi object có 1 key, mặc dù vậy, có thể gán bao
			nhiều key tùy ý.
		
		jQuery.each() Class Example
		
			Ví dụ này cho thấy làm thế nào để lặp qua mỗi phần tử có class là productDescription như HTML bên dưới.
				
				<div class="productDescription">Red</div>
				<div>Pink</div>
				<div class="productDescription">Orange</div>
				<div class="generalDescription">Teal</div>
				<div class="productDescription">Green</div>
				
			Chúng ta sử dụng each() helper thay cho each() method của selector $('.productDescription').
			
				$.each($('.productDescription'), function (index, value) {
				  console.log(index + ':' + $(value).text());
				});
				
			Trong trường hợp này kết quả in ra là: 0:Red, 1:Orange, 2:Green.
			Chúng ta không cần phải kèm theo index và value. Có 1 vài tham số trên phần tử DOM mà chúng ta đang lặp qua có thể giúp tìm ra. Xa hơn, trong ví dụ này chúng ta cũng có thể sử dụng nhiều method tiện ích
			hơn. Chúng ta có thể viết như thế này:
				
				$('.productDescription').each(function () {
				  console.log($(this).text());
				});
				
				Red
				Orange
				Green
				
				1 lần nữa, chúng ta cần bọc phần tử DOM trong 1 jQuery instance. Chúng ta sử dụng text() method để lấy text của phần tử ra.
		
		jQuery .each() Delay Example
		
			Trong ví dụ tiếp theo, khi user click vào phần tử có ID là 5demo tất cả các item sẽ được gán thành orange ngay lập tức. Sau 1 khoảng thời gian phụ thuộc vào index (0, 200, 400, … milliseconds) chúng ta sẽ fade out phần tử.
				
				$('#5demo').bind('click', function (e) {
				  $('li').each(function (index) {
					$(this).css('background-color', 'orange')
						  .delay(index * 200)
						  .fadeOut(1500);
				  });
				  e.preventDefault();
				});
				
	.addClass()--Jquery:
	
		.addClass(): thêm class cho thành phần.
		
		Cấu trúc
			
			.addClass(tênclass)
			
				$('div').addClass('test');
				
				Html viết:
				
					<!DOCTYPE HTML>
					<html>
					<head>
					<meta charset="utf-8">
					<title>Tiêu đề</title>
					<script src="https://code.jquery.com/jquery-latest.js"></script>
					<style>
					.test {
						background-color: blue;
					}
					</style>
					<script>
					$(function(){
						$('div').addClass('test');
					});
					</script>
					</head>

					<body>
					<div>Thành phần div</div>
					</body>
					</html>
					Thành phần div đã được thêm class="test".
				
				So sánh code HTML trước và sau khi có jQuery:
					
					Trước khi có jQuery
						
						<div>Thành phần div</div>
					
					Sau khi có jQuery
						
						<div class="test">Thành phần div</div>
			
			.addClass(tênclass01 tênclass02)
				
				$('div').addClass('test01 test02');
				
				Html viết:
					
					<!DOCTYPE HTML>
					<html>
					<head>
					<meta charset="utf-8">
					<title>Tiêu đề</title>
					<script src="https://code.jquery.com/jquery-latest.js"></script>
					<style>
					.test {
						background-color: blue;
					}
					.bdrDiv {
						border: 3px solid yellow;
					}
					</style>
					<script>
					$(function(){
						$('div').addClass('test bdrDiv');
					});
					</script>
					</head>
					<body>
					<div>Thành phần div</div>
					</body>
					</html>
					
					Thành phần div đã được thêm class="test bdrDiv".

				So sánh code HTML trước và sau khi có jQuery:
				
					Trước khi có jQuery
						
						<div>Thành phần div</div>
					
					Sau khi có jQuery
					
						<div class="test bdrDiv">Thành phần div</div>
						
			.addClass(function(index){...})
				
				$('ul li').addClass(function(index){
					return "list-" + index;
				});
				
				Html viết:
					
					<!DOCTYPE HTML>
					<html>
					<head>
					<meta charset="utf-8">
					<title>Tiêu đề</title>
					<script src="https://code.jquery.com/jquery-latest.js"></script>
					<style>
					.list-2 {
						background-color: blue;
					}
					</style>
					<script>
					$(function(){
						$('ul li').addClass(function(index){
							return "list-" + index;
						});
					});
					</script>
					</head>
					<body>
					<ul>
					<li>Thành phần li 0</li>
					<li>Thành phần li 1</li>
					<li>Thành phần li 2</li>
					<li>Thành phần li 3</li>
					<li>Thành phần li 4</li>
					</ul>
					</body>
					</html>
					
					Tất cả các thành phần li đã thêm class theo thứ tự

				So sánh code HTML trước và sau khi có jQuery:
					
					Trước khi có jQuery
						
						<ul>
						  <li>Thành phần li 0</li>
						  <li>Thành phần li 1</li>
						  <li>Thành phần li 2</li>
						  <li>Thành phần li 3</li>
						  <li>Thành phần li 4</li>
						</ul>
					
					Sau khi có jQuery
						
						<ul>
						  <li class="list-0">Thành phần li 0</li>
						  <li class="list-1">Thành phần li 1</li>
						  <li class="list-2">Thành phần li 2</li>
						  <li class="list-3">Thành phần li 3</li>
						  <li class="list-4">Thành phần li 4</li>
						</ul>
			
			.addClass(function(index, class_đã_có){...})
				
				$('ul li').addClass(function(index, current){
					var newClass;
					if(current == "blue") {
						newClass = "red";
					}
					return newClass;
				});
				
				Html viết:
					
					<!DOCTYPE HTML>
					<html>
					<head>
					<meta charset="utf-8">
					<title>Tiêu đề</title>
					<script src="https://code.jquery.com/jquery-latest.js"></script>
					<style>
					li {
						background-color: blue;
					}
					li.bdrRed {
						border: 3px dashed red;
					}
					</style>
					<script>
					$(function(){
						$('ul li').addClass(function(index, current){
							var newClass;
							if(current == "blue") {
								newClass = "bdrRed";
							}
							return newClass;
						});
					});
					</script>
					</head>
					<body>
					<ul>
					<li>Thành phần li 0</li>
					<li>Thành phần li 1</li>
					<li>Thành phần li 2</li>
					<li class="blue">Thành phần li 3</li>
					<li>Thành phần li 4</li>
					</ul>
					</body>
					</html>
					
					Thành phần li có class="blue" đã được thêm class bdrRed.

				So sánh code HTML trước và sau khi có jQuery:
					
					Trước khi có jQuery
						
						<ul>
						  <li>Thành phần li 0</li>
						  <li>Thành phần li 1</li>
						  <li>Thành phần li 2</li>
						  <li class="blue">Thành phần li 3</li>
						  <li>Thành phần li 4</li>
						</ul>
					
					Sau khi có jQuery
						
						<ul>
						  <li>Thành phần li 0</li>
						  <li>Thành phần li 1</li>
						  <li>Thành phần li 2</li>
						  <li class="blue bdrRed">Thành phần li 3</li>
						  <li>Thành phần li 4</li>
						</ul>
						
	Sử dụng Jquery Ajax--Jquery:
	
		Ajax là gì
		
			Kỹ thuật Ajax được dùng trong lập trình web với mục đích là lấy dữ liệu hoặc xử lý dữ liệu từ server. Sau đó hiển thị nó lên trang web NHƯNG KHÔNG RELOAD lại trang web.
			
			Anh lấy ví dụ như anh có một table chứa danh sách người dùng sau trên hệ thống chăm sóc khách hàng của anh.
			
			Bây giờ anh muốn xoá một dòng (khách hàng) thì anh click vào dấu ba chấm bên tay phải sau đó chọn nút “Xóa khỏi tài khoản”.
				
				Trường hợp 1 : nếu như anh không dùng AJAX thì khi hành động xoá tài khoản thành công thì trang web sẽ reload lại nguyên cả trang. Nó sẽ vẽ lại (load lại) phần header, phần footer và các menu của trang web.
				
				Trường hợp 2 : nếu anh sử dụng AJAX thì khi hành động xoá tài khoản thành công. Trang web sẽ không reload lại toàn bộ cả trang, mà nó chỉ vẽ lại chỗ table với 1 dòng bị xoá đi. Như vậy nó chỉ ảnh
				hưởng một phần chỗ table được vẽ lại thôi còn nguyên trang web vẫn không thay đổi
			
			Như vậy các em có thể thấy Ajax được sử dụng để vẽ lại giao diện cho phần mà ta muốn thay đổi chứ không reload lại toàn trang web. Như các em biết khi reload toàn trang web thì lúc này trình duyệt sẽ vẽ lại tất
			cả các phần tử trên web và sẽ mất rất nhiều thời gian để vẽ toàn bộ các phần tử. Dẫn đến việc là người dùng sẽ chờ đợi rất lâu mới thấy được trang web.
			
			Nhờ có Ajax mà chúng ta có thể tăng Performance (hiệu năng) của website lên rất nhiều. Trước khi có công nghệ VueJS, Angular hay ReactJS thì Jquery Ajax được sử dụng hầu hết trong tất cả dự án web.
			
			Ngoài việc tăng hiệu năng vì không reload lại nguyên trang web. Ajax còn hoạt động theo cơ chế bất đồng bộ có nghĩa là khi anh bấm vào nút “Xóa khỏi tài khoản” thì nó sẽ thực hiện việc gọi lên server. Trong
			lúc đó anh có thể tiếp tục thực hiện các nhiệm vụ hay tác vụ khác trên website mà không cần phải chờ cho việc xoá tài khoản thành công rồi anh mới được phép thực hiện các nhiệm vụ khác.
		
		Sử dụng phương thức ajax
		
			Trong tất cả dự án anh làm thì anh thường dùng Jquery Ajax dưới đây để code.
				
				var search = {}
				search["username"] = $("#username").val(); // lấy dữ liệu trong ô username và truyền lên cho server.
				$.ajax({
						type: "POST",
						contentType: "application/json",
						url: "/api/search",
						data: JSON.stringify(search),
						dataType: 'json',
						cache: false,
						timeout: 600000,
						success: function (data) {
							var json = "<h4>Ajax Response</h4><pre>"
								+ JSON.stringify(data, null, 4) + "</pre>";
							$('#feedback').html(json);

							console.log("SUCCESS : ", data);
							$("#btn-search").prop("disabled", false);
						},
						error: function (e) {
							var json = "<h4>Ajax Response</h4><pre>"
								+ e.responseText + "</pre>";
							$('#feedback').html(json);
							console.log("ERROR : ", e);
							$("#btn-search").prop("disabled", false);
						}
					});
					
			Bước 1 : Khai báo sử dụng jquery ajax.
				
				$.ajax
				
			Bước 2 : Khai báo kiểu yêu cầu là POST hoặc GET và tham số truyền vào cho request.
				
				type: “POST” : khai báo phương thức là POST hoặc GET.
				
				url: “/api/search” : đường link của server.
				
				data: JSON.stringify(search) : dùng thư viện JSON để chuyển đổi dữ liệu thành định dạng JSON và truyền lên cho server.
				
				dataType: ‘json’ : kiểu định dạng dữ liệu cho server.
			Bước 3 : Khi server xử lý thành công.
				success: function (data) : khi server xử lý thành công thì kết quả sẽ được lưu trong biến data. Sau đó chúng ta sẽ xử lý data bằng việc dùng Jquery tìm các phần tử cần thay đổi sau đó gán dữ
				liệu vào $(‘#feedback’).html(json). Các em thấy chúng ta chỉ thay đổi 1 phần trên website chứ không reload nguyên cả trang như anh nói ở phần mở bài. Chính vì vậy mà hiệu suất website rất nhanh. Các em
				có thay đổi gì thì thay đổi và xử lý web trong method success này.
			
			Bước 4 : khi server xử lý thất bại.
				
				Chúng ta sử dụng method error: function (e) để xử lý trường hợp server không trả về được kết quả như mình mong muốn.
		
		Ajax Load
			
			Để lấy dữ liệu từ server trả về client thì Jquery cung cấp cho chúng ta phương thức load(). Cú pháp như sau
				
				$(selector).load(URL,data,callback);
					
					selector : thành phần HTML được chọn để thực hiện thao tác load
					
					load(URL,data,callback) : trong đó URL chính là đường dẫn đến server (ví dụ https://server.com),
					
					data chính là dữ liệu mà ta muốn truyền lên cho server
					
					callback : phương thức sẽ thực thi các dòng lệnh sau khi phương thức load hoàn thành
			
			Anh có ví dụ dưới đây khi click vô button “Load Content” nó sẽ gọi lên server lúc này server sẽ trả về file là test.html. Giả sử anh có file test.html với nội dung như sau
				
				<h1>Simple Ajax Demo</h1>
				<p id="hint">This is a simple example of Ajax loading.</p>
				<p><img src="sky.jpg" alt="Cloudy Sky"></p>
			
			Như vậy khi anh click vào button “Load Content” trong trường hợp gọi lên server thành công thì anh sẽ hiển thị alert thành công, còn nếu thất bại thì anh hiển thị alert thất bại
				
				<!DOCTYPE html>
				<html lang="en">
				<head>
				<meta charset="utf-8">
				<title>Showing Ajax Load Request Status in jQuery</title>
				<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
				<script>
				$(document).ready(function(){
					$("button").click(function(){
						$("#box").load("/examples/html/test.html", function(responseTxt, statusTxt, jqXHR){
							if(statusTxt == "success"){
								alert("New content loaded successfully!");
							}
							if(statusTxt == "error"){
								alert("Error: " + jqXHR.status + " " + jqXHR.statusText);
							}
						});
					});
				});
				</script>
				</head>
				<body>
					<div id="box">
						<h2>Click button to load new content inside DIV box</h2>
					</div>
					<button type="button">Load Content</button>
				</body>
				</html>
				
					$(“button”).click : mình đăng ký sự kiện click cho nút button
					
					load(“/examples/html/test.html”) : mình nhận vào đường link trên server lên server để lấy kết quả
					
					responseTxt : đây là kết quả trả về từ server. Trong trường hợp này là file test.html của mình. Sau khi có kết quả thì mình sẽ xử lý như thế nào là tùy thuộc vào bài toán của mình.
					
					statusTxt : status của request từ client lên server nếu server trả về thành công thì mình nhận HTTP status là 200 hoặc status text là success từ server trả về.
		
		Ajax Get Post
			
			Ngoài Ajax load chúng ta có thêm 2 phương thức là GET và POST để lấy dữ liệu và cập nhật dữ liệu giữa client và server. Cái này thì các anh dùng nhiều trong lập trình web. Trong đó phương thức GET dùng để lấy
			dữ liệu còn POST dùng để truyền dữ liệu từ client lên server để server cập nhập thông tin.
			
			Get
				
				Cú pháp GET như sau
					
					$.get(URL,callback);
						
						ULR : là đường link của server
						
						callback : phương thức sẽ xử lý sau khi server trả về kết quả
				
				Ví dụ khi anh click vào button “send and HTTP GET” lúc này mình sẽ gửi 1 yêu cầu lên server để server trả về dữ liệu mà mình yêu cầu.
					
					<!DOCTYPE html>
					<html>
					<head>
					<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
					<script>
					$(document).ready(function(){
					  $("button").click(function(){
						$.get("demo_test.asp", function(data, status){
						  alert("Data: " + data + "\nStatus: " + status);
						});
					  });
					});
					</script>
					</head>
					<body>
					<button>Send an HTTP GET request to a page and get the result back</button>
					</body>
					</html>
					
						$.get : mình khai báo jquery get
						
						demo_test.asp : đường link của server. Nó có thể là https://levunguyen/update hay bất kỳ một đường dẫn nào của server.
						
						data : dữ liệu trả về từ server
						
						status : tình trạng server trả về thành công hoặc có lỗi.
			
			Post
				
				Cú pháp POST như sau
					
					$.post(URL,data,callback);
						
						URL : là đường link của server
						
						data : các tham số ta muốn gửi theo request cho server
						
						callback : phương thức sẽ xử lý khi server trả về kết quả
					
					$("button").click(function(){
					  $.post("demo_test_post.asp",
					  {
						name: "le vu nguyen",
						city: "da nang"
					  },
					  function(data, status){
						alert("Data: " + data + "\nStatus: " + status);
					  });
					});
					
						Chúng ta sử dụng $.post để thực hiện method post
						
						demo_test_post.asp : đường link của server
						
						name: “le vu nguyen”, city: “da nang” là 2 tham số mà ta gửi lên server
						
						function(data,status) : trong đó data là cái mình nhận được từ server và status là thông báo server xử lý thành công hay thất bại.

CSS---:

	Selector chọn phần tử trong CSS--CSS
	
		Pesudo CSS Selector
		
			Code HTML:
			
				<div class="container">
				  <div class="paragraph-container">
					<p id="hola-id" class="hola-class">Hola world</p>
					<p class="hello-class">Hello world</p>
					<p class="hello-class again-class">Hello again world</p>
				  </div>

				  <p class="outside-class">I'm outside</p>

				  <ul id="list-id" class="list-class">
					<li class="list-item-class">First</li>
					<li class="list-item-class">Second</li>
					<li class="list-item-class">Third</li>
					<li class="list-item-class">Fourth</li>
					<li class="list-item-class">Fifth</li>
				  </ul>

				  <div class="single-paragraph-container">
					<p>I'm the only child of this span</p>
				  </div>
				</div>
				
			Chọn phần tử đầu tiên: A:first-child. Nó chọn đến phần tử con đầu tiên. (A phải có cha mẹ).
			
				li:first-child {
				  color: blue;
				}
				
			Bạn đoán thử xem. Nhắm mục tiêu ul:first-child có thành công không?
			
				ul:first-child {
				  color: red;
				}
				
				Chẳng có gì xảy ra.
				Điều này là do mặc dù ul có cha mẹ (div với class .container), nhưng ul không phải là con đầu tiên (nó là con thứ 3).
			
			CSS dưới đây sẽ hoạt động vì .paragraph-container là con đầu tiên của .container.
				
				.paragraph-container:first-child {
				  color: red;
				}
				
			Chọn phần tử con cuối cùng: A:last-child. Hoạt động như A:first-child, ngoại trừ thay vì chọn phần tử con đầu tiên, nó chọn phần tử con cuối cùng.
				
				li:last-child {
				  color: purple;
				}
				
			Chỉ chọn phần tử con: A:only-child. Chọn tất cả A là con duy nhất của cha mẹ nó. Tương tự như bộ chọn phần tử con đầu tiên (A:first-child) và phần tử con cuối cùng (A:last-child). Ngoại trừ mục tiêu không được có anh chị em nào.
				
				p:only-child {
				  color: red;
				}
				
			Lưu ý mặc dù chúng ta có một số phần tử p, chỉ phần tử cuối cùng được áp dụng vì các phần tử p khác không phải là phần tử con duy nhất của cha mẹ chúng.
			
			Nói cách khác, phần tử con có anh chị em thì không được áp dụng.
			
			Bộ chọn phần tử con thứ N: A:nth-child(n). Nó chọn từng mục tiêu là con thứ n của cha mẹ nó.
				
				li:nth-child(2) {
				  color: red;
				}
				
			Hãy thử với phần tử p:
				
				p:nth-child(2) {
				  color: red;
				}
				
				Bạn có thể thấy tại sao hai phần tử p thay đổi màu sắc?
			
			Bộ chọn con thứ N cuối cùng: A:nth-last-child(n). Nó tương tự như bộ chọn con thứ N, ngoại trừ nó được tính từ cuối cùng.
				
				li:nth-last-child(2) {
				  color: red;
				}
				
			Không chọn: A:not(B). Chọn tất cả các phần tử A mà không phải B.
				
				p:not(.outside-class) {
				  color: blue;
				}
				
			Bộ chọn loại đầu tiên: A:first-of-type. Nó chọn phần tử đầu tiên thuộc loại này trong số các phần tử anh chị em của nó.
				
				Nghe có vẻ tương tự :first-child nhỉ?
				Nhưng không phải.
				Để cảm nhận sự khác biệt của nó, hãy thử nghịch nó xem sao:
					
					li:first-of-type {
					  color: blue;
					}
					
				Ok, đó không phải là một ví dụ hay vì nó cho thấy kết quả tương tự như li:first-child .
				
				Hãy làm một ví dụ khác:
					
					p:first-of-type {
					  color: red;
					}
					
					So sánh với p:first-child. Bạn sẽ nhận thấy rằng p ở giữa chuyển sang màu đỏ khi sử dụng :first-of-type.

					Điều này là do p ở giữa là loại phần tử p đầu tiên trong số các anh chị em của nó.
			
			Bộ chọn loại cuối cùng: A:last-of-type. Giống như trên, nhưng ngược lại.
			
				li:last-of-type {
				  color: blue;
				}
				
			Bộ chọn loại thứ N: A:nth-of-type(n). Cũng giống như hai bộ chọn trên, nhưng nó chọn phần tử thứ N.
				
				li:nth-of-type(2) {
				  color: blue;
				}
				
			Hãy thử với phần tử khác.
				
				p:nth-of-type(2) {
				  color: blue;
				}
				
			Nếu chúng ta thay đổi nó thành p:nth-of-type(1), thì nó hoạt động giống như first-of-type.
			
			Ngoài ra nếu chúng ta thay đổi nó thành p:nth-of-type(4), không có thay đổi gì. Đây là do không có phần tử p thứ 4 trong số các anh chị em.
			
			Bộ chọn Only type: A:only-of-type. Chọn phần tử chỉ có loại đó, không có Anh / Chị / Em.
				
				p:only-of-type {
				  color: purple;
				}
				
				Chú ý, chúng ta có hai phần tử p đổi màu.

				Điều này là do có hai phần tử p này không có Anh / Chị / Em cùng loại.
		
		Pesudo-Selector (links và input)
			Dưới đây là danh sách các pesudo selector khác. Chúng thường được liên kết với các liên kết (a) (mặc dù chúng có thể hoạt động với các phần tử không liên kết non-link).
			
			Code HTML:
			
				<div id="app">
				  <a class="cheesyLink" href="#">I like cheese</a>
				  <a class="sweetLink" href="#">I like donut</a>
				  <div class="burger">I like cheezburger</div>
				  <div class="container">
					<form onsubmit="event.preventDefault()">
					  <input class="myinput"type="text" />
					  <input class="mysubmit" type="submit" />
					</form>
				  </div>
				</div>
				
			Hover Selector: A:hover. Chọn phần tử được hover. Thường được sử dụng để làm nổi bật các liên kết.
				
				a:hover {
				  color: red;
				}
				
			Không chỉ hoạt động với thẻ a. Bộ chọn này hoạt động với mọi thứ.
				
				.burger:hover {
				  color: red;
				}
				
			Focus Selector: A:focus. Chọn phần tử bạn đang tập trung vào nó. Thường được sử dụng với input.
				
				input:focus {
				  background: red;
				}
				
			Active Selector: A:active. Chọn phần tử đang có trạng thái active.
				
				.cheesyLink:active {
				  background: red;
				}
				
			Lưu ý khi bạn click vào nó, nền (background) sẽ thay đổi.
			
			Link Selector: A:link. Nó chọn tất cả các link chưa được click.
				
				a:link {
				  background: blue;
				}
				
		Attribute CSS Selector
			
			Bộ chọn thuộc tính CSS (Attribute CSS Selector) sử dụng để chọn thuộc tính HTML (HTML Attributes).
				
				Code HTML:
				
					<div for="chocolate">Chocolate</div>
					<div for="peanut">Peanut</div>
					<div for="butter">Butter</div>
					<div>Jelly</div>
					 
			Bộ chọn thuộc tính cơ bản: A[B]. Chọn tất cả các phần tử A có thuộc tính B.
				
				div[for] {
				  color: red;
				}
			Bộ chọn thuộc tính cụ thể: A[B="C"]. Chọn các phần tử A có thuộc tính B với giá trị là C.
				
				div[for="chocolate"]{
				  color: blue;
				}
				
			Bộ chọn thuộc tính cụ thể (Bắt đầu với ...): A[B^="C"]. Chọn tất cả các phần tử A có thuộc tính B với giá trị bắt đầu là C. Ký tự ^ là ký tự thể hiện chuỗi bắt đầu (trong Biểu thức chính quy (Regex)).
				
				div[for^="cho"] {
				  color: magenta;
				}
				
			Bộ chọn thuộc tính cụ thể (Kết thúc với ...): A[B$="C"]. Chọn tất cả các phần tử A có thuộc tính B với giá trị kết thúc là C. Ký tự $ là ký tự thể hiện chuỗi kết thúc trong (Biểu thức chính quy (Regex)).
				
				div[for$="er"] {
				  color: yellow;
				}
				
			Bộ chọn thuộc tính cụ thể (Chứ ký tự ...): A[B*="C"]. Chọn tất cả phần tử A với thuộc tính B chứa giá trị C.
				
				div[for*="ut"]{
				  color: cyan;
				}		
		CSS Selectors
		
			.class								.intro						Selects all elements with class="intro"
			.class1.class2						.name1.name2				Selects all elements with both name1 and name2 set within its class attribute
			.class1 .class2						.name1 .name2				Selects all elements with name2 that is a descendant of an element with name1
			#id									#firstname					Selects the element with id="firstname"
			*									*							Selects all elements
			element								p							Selects all <p> elements
			element.class						p.intro						Selects all <p> elements with class="intro"
			element,element						div, p						Selects all <div> elements and all <p> elements
			element element						div p						Selects all <p> elements inside <div> elements
			element>element						div > p						Selects all <p> elements where the parent is a <div> element
			element+element						div + p						Selects the first <p> element that is placed immediately after <div> elements
			element1~element2					p ~ ul						Selects every <ul> element that is preceded by a <p> element
			[attribute]							[target]					Selects all elements with a target attribute
			[attribute=value]					[target="_blank"]			Selects all elements with target="_blank"
			[attribute~=value]					[title~="flower"]			Selects all elements with a title attribute containing the word "flower"
			[attribute|=value]					[lang|="en"]				Selects all elements with a lang attribute value equal to "en" or starting with "en-"
			[attribute^=value]					a[href^="https"]			Selects every <a> element whose href attribute value begins with "https"
			[attribute$=value]					a[href$=".pdf"]				Selects every <a> element whose href attribute value ends with ".pdf"
			[attribute*=value]					a[href*="w3schools"]		Selects every <a> element whose href attribute value contains the substring "w3schools"
			:active								a:active					Selects the active link
			::after								p::after					Insert something after the content of each <p> element
			::before							p::before					Insert something before the content of each <p> element
			:checked							input:checked				Selects every checked <input> element
			:default							input:default				Selects the default <input> element
			:disabled							input:disabled				Selects every disabled <input> element
			:empty								p:empty	Selects 			every <p> element that has no children (including text nodes)
			:enabled							input:enabled				Selects every enabled <input> element
			:first-child						p:first-child				Selects every <p> element that is the first child of its parent
			::first-letter						p::first-letter				Selects the first letter of every <p> element
			::first-line						p::first-line				Selects the first line of every <p> element
			:first-of-type						p:first-of-type				Selects every <p> element that is the first <p> element of its parent
			:focus								input:focus					Selects the input element which has focus
			:fullscreen							:fullscreen					Selects the element that is in full-screen mode
			:hover								a:hover						Selects links on mouse over
			:in-range							input:in-range				Selects input elements with a value within a specified range
			:indeterminate						input:indeterminate			Selects input elements that are in an indeterminate state
			:invalid							input:invalid				Selects all input elements with an invalid value
			:lang(language)						p:lang(it)					Selects every <p> element with a lang attribute equal to "it" (Italian)
			:last-child							p:last-child				Selects every <p> element that is the last child of its parent
			:last-of-type						p:last-of-type				Selects every <p> element that is the last <p> element of its parent
			:link								a:link						Selects all unvisited links
			::marker							::marker					Selects the markers of list items
			:not(selector)						:not(p)						Selects every element that is not a <p> element
			:nth-child(n)						p:nth-child(2)				Selects every <p> element that is the second child of its parent
			:nth-last-child(n)					p:nth-last-child(2)			Selects every <p> element that is the second child of its parent, counting from the last child
			:nth-last-of-type(n)				p:nth-last-of-type(2)		Selects every <p> element that is the second <p> element of its parent, counting from the last child
			:nth-of-type(n)						p:nth-of-type(2)			Selects every <p> element that is the second <p> element of its parent
			:only-of-type						p:only-of-type				Selects every <p> element that is the only <p> element of its parent
			:only-child							p:only-child				Selects every <p> element that is the only child of its parent
			:optional							input:optional				Selects input elements with no "required" attribute
			:out-of-range						input:out-of-range			Selects input elements with a value outside a specified range
			::placeholder						input::placeholder			Selects input elements with the "placeholder" attribute specified
			:read-only							input:read-only				Selects input elements with the "readonly" attribute specified
			:read-write							input:read-write			Selects input elements with the "readonly" attribute NOT specified
			:required							input:required				Selects input elements with the "required" attribute specified
			:root								:root						Selects the document's root element
			::selection							::selection					Selects the portion of an element that is selected by a user
			:target								#news:target				Selects the current active #news element (clicked on a URL containing that anchor name)
			:valid								input:valid					Selects all input elements with a valid value
			:visited							a:visited					Selects all visited links
			
	Thứ tự ưu tiên CSS--CSS
	
		Selector
		
			CSS có thể phân làm 6 loại
			
				element (Vd: div, span,...)
				pseudo-element (Vd: :before, :after)
				class (Vd: .class-1, .class-2,...)
				pseudo-class (vd: :last-child, :first-child,...)
				attibute (vd: [href], [src])
				id (vd: #pages, #pagination,...)
				inline style
				universal selector (*, +, >, ~)
				
		Thứ tự ưu tiên
		
			Dù là mới nghịch css thì chắc các bạn cũng nhận ra những thứ cơ bản như thằng dưới đè thằng trên, thằng id thì lớn hơn class, và thằng inline thì "dưới một người trên vạn người", hay selector càng chi tiết thì
			ưu tiên càng cao,... Nhưng như vậy thì chẳng lẽ mỗi element lại phải có 1 id, hay file css lại toàn những đoạn selector dài đến đau mắt? Không đâu, CSS quy định cho id, class,.. nhưng giá trị khác nhau, dựa vào
			đó, chúng ta có thể tối ưu được selector hợp lý.
			
			Bắt đầu với universal selector
			
				Point: 0 - 0 - 0
				
				Hiệu ứng: Là một selector có tác dụng bổ trợ (ngoại trừ *), một khi xuất hiện, nhưng selector gần nó sẽ đc liên kết tuỳ theo universal selector được "triệu hồi". Nó hoàn toàn không có giá trị khi tính thứ tự
				ưu tiên.
				
				VD:
				
					* = 0-0-0
					* > * = 0-0-0
					* + * + * = 0-0-0
					
			Element và pseudo-element
			
				Point: 0 - 0 - X
				
				Hiệu ứng: Với mỗi element hoặc pseudo-element xuất hiện trong selector, X sẽ được tăng thêm 1 điểm.
				
				VD:
					
					div = 0-0-1
					div div = 0-0-2
					10 element = 0-0-10
					
			Class, pseudo-class và attribute
			
				Point: 0 - X - 0
				
				Hiệu ứng: Với mỗi class, pseudo-class, hoặc attibute xuất hiện trong selector, X sẽ được tăng thêm 1 điểm.
				
				VD:
				
					.list = *:first-child = [type="text"] = 0-1-0
					div.list = li:first-child = input[type="text"] = 0-1-1
					div input[type="text"] = 0-1-2
					.list .items = .list.items = .item:first-child = 0-2-0
					input[type="text"]:not(.class) = 0-2-1
					10 class + 11 element = 0-10-11
					
				Chú ý: độ ưu tiên áp dụng với cả pseudo-class :not(x), nhưng nó có hơi đặc thù khi mà selector x được chọn sẽ không thay đổi giá trị nhưng những selector khác x sẽ được tăng độ ưu tiên
			
			ID
			
				Point: X - 0 - 0
				
				Hiệu ứng: Với mỗi ID xuất hiện trong selector, X sẽ được tăng thêm 1 điểm.
				
			Inline style
			
				Point: 1 - 0 - 0 - 0
				
				Hiệu ứng: là dạng chỉ mặt, đặt tay rồi, thuộc hàng COCC, dưới một người trên vạn người, là một sự phiền phức, rắc rồi, nhưng đôi khi vẫn phải dùng đến
				
			!important
			
				Point: 1 - 0 - 0 - 0 - 0
				
				Hiệu ứng: Dù chỉ là giá trị thêm trong thuộc tính của css, nhưng nó lại thuộc hàng máu mặt nhất, đứng đầu thiên hạ, hiệu triệu quần hùng, một khi anh xuất hiện thì toàn dân dẹp đường cho anh thả ga chạy, một sự cucsuc không hề nhẹ
		
		Với Cascading Style Sheets – CSS giúp chúng ta có thể định kiểu cho bất kỳ phần tử HTML nào trên trang web. Một phần tử trên trang có thể sử dụng các bộ chọn khác nhau như bộ chọn class, bộ chọn id hoặc bộ chọn
		thẻ. Cũng có nhiều cách nhúng CSS:
		
			Inline (nhúng trực tiếp vào phần tử HTML bằng việc sử dụng thuộc tính style của phần tử
			Internal (tạo các bộ chọn trực tiếp trên trang bằng cách đặt trong thẻ <style></style>
			External (tạo file css nằm riêng và nhúng vào trang sử dụng thẻ <link> để nhúng vào trang
		
		Vấn đề xảy ra khi một phần tử HTML chịu tác động của nhiều bộ chọn với nhiều giá trị giống nhau ví dụ như định kiểu màu sắc cho chữ, thì nó sẽ ưu tiên giá trị nào để thiết lập định kiểu cho thẻ.

		Và với một website làm sao để có thể tối ưu việc thiết kế để có thể tái sử dụng lại CSS, làm cho giữa các trang web được đồng nhất về giao diện và rất nhiều khía cạnh khác như tối ưu tốc độ load trang, bảo hành, bảo
		trì được dễ dàng và hiệu quả.
		
		CHỒNG CHÉO CSS VÀ THỨ TỰ ƯU TIÊN
			
			– Sự chồng chéo xảy ra khi một đối tượng chịu tác động bởi nhiều rule khác nhau.
			– Khi sự chồng chéo xảy ra thì thứ tự ưu tiên sẽ quyết định định dạng của đối tượng.
			
			Dạng chồng chéo 1
				
				Chồng chéo giữa các rule khác loại.
				
				Thứ tự ưu tiên của 4 dạng rule như sau:
				
				Nhận xét: Thứ tự ưu tiên tỉ lệ nghịch với phạm vi tác động. Dạng rule có phạm vi tác động càng cao thì ưu tiên càng thấp, ngược lại dạng rule có phạm vi tác động càng thấp thì ưu tiên càng cao.
				
				Ví dụ 1.1
				
					Đoạn văn “Chào mừng bạn đến với khoá học CSS!” chịu tác động bởi 4 rule thuộc 4 dạng khác nhau (inline, thẻ p, class .p1, id #p2). 4 rule này quy định 4 màu chữ (color) khác nhau.
						<p class="p1" id="p2" style="color:black;">Chào mừng các bạn đến với khoá học CSS!</p>
						p{
						  color:red;
						}
						.p1{
						  color:green;
						}
						#p2{
						  color:blue;
						}
						Kết quả: Theo bảng thứ tự ưu tiên thì màu của chữ “Chào mừng bạn đến với khoá học CSS” sẽ theo màu ưu tiên của rule inline (màu black)
						
				Ví dụ 1.2
				
					Bây giờ nếu ta bỏ đi style=”color:black” (rule dạng inline) thì theo bạn kết quả sẽ như thế nào?
		
					Chạy trực tiếp ví dụ 1.1 bằng cách xoá dòng style=”color:black” rồi kích nút Run để xem kết quả.

					Kết quả dòng chữ “Chào mừng bạn đến với khoá học CSS!” sẽ có màu theo quy định của rule dạng id #p2 (màu blue)
				
				Ví dụ 1.3
					
					Nếu ta tiếp tục bỏ đi thuộc tính id (rule dạng id)

					Kết quả chữ “Chào mừng bạn đến với khoá học CSS!” sẽ có màu theo quy định của rule dạng class .p1 (màu green)
				
				Ví dụ 1.4
					
					Ta có thể sử dụng !important để tăng mức độ ưu tiên.
						
						<p class="p1" id="p2" style="color:black;">Chào mừng các bạn đến với khoá học CSS!</p>
						p{
						  color:red!important;
						}
						.p1{
						  color:green;
						}
						#p2{
						  color:blue;
						}
						
					Với việc thêm !important vào sau giá trị màu red thì rule dạng tag, lúc này css của thẻ này có mức độ ưu tiên cao nhất.
				
				Ví dụ 1.5
					
					<p class="p1" id="p2" style="color:black!important;">Chào mừng các bạn đến với khoá học CSS!</p>
					p{
					  color:red!important;
					}
					.p1{
					  color:green!important;
					}
					#p2{
					  color:blue;
					}
					
					Nhưng nếu các dạng rule đều có !important thì thứ tự ưu tiên lại theo bảng ưu tiên ở trên (inline > id > class > tag)
			
			Dạng chồng chéo 2
				
				<p class="p1">Chào mừng các bạn đến với khoá học CSS!</p>
				.p1{
				  color:green;
				}
				.p1{
				  color:blue;
				  background-color:#FF0;
				}
				
				Trong khai báo trên thì cả 2 rule đều là dạng class và cùng tên p1. Hai rule này có thuộc tính color chồng nhau.
				
				Trình duyệt xử lý mã (html,css,javascript) theo thứ tự từ trái qua phải, từ trên xuống dưới nên trong trường hợp này rule nào nằm sau sẽ ưu tiên hơn rule nằm trước. Do đó, màu sẽ là blue
		
		TỐI ƯU CSS TRONG THIẾT KẾ WEB
			
			Qua các ví dụ phân tích ở trên, để tạo một website chuyên nghiệp như:
				
				Định kiểu đồng nhất trên tất cả các trang
				
				Tối ưu cho việc load trang, cache cho trang web
				
				Tối ưu cho việc bảo trì, tái sử dụng lại CSS, v.v.
			
			Một số khuyến nghị:
				
				Nên sử dụng CSS dạng External
				
				Hạn chế tối đa việc định kiểu CSS dạng Inline
				
				Dựa theo phạm vi hoạt động của CSS dạng thẻ, id, class, inline để thiết lập các CSS cho phù hợp
				
				Khi public website lên Internet, cần sử dụng các công cụ nén CSS để tối ưu việc load trang
	
Note:

	Xử lý null trong store, cần thiết vì nếu null thì retVal.map sẽ báo lỗi:
		    @Override
			public Pme00ProjectInfo retrieve(String cdVId) {
				Optional<Pme00ProjectInfoJpo> retVal = this.repository.findById(cdVId);
				return retVal.map(Pme00ProjectInfoJpo::toDomain).orElse(null);
			}
			
			
	
	BeanUtils:	https://www.baeldung.com/apache-commons-beanutils
	
	StreamSupport.stream(jpos.spliterator(), false).map(Pme00ProjectInfoJpo::toDomain).collect(Collectors.toList());
	
	@IdClass(M00TaskId.class)
	
	Date _fromRegistrationStartDate = (fromRegistrationStartDate != null) ? new SimpleDateFormat("yyyy-MM-dd").parse(fromRegistrationStartDate) : null;
    Date _toRegistrationEndDate = (toRegistrationEndDate != null) ? new SimpleDateFormat("yyyy-MM-dd").parse(toRegistrationEndDate) : null;
    Date _fromRequestStartDate = (fromRequestStartDate != null) ? new SimpleDateFormat("yyyy-MM-dd").parse(fromRequestStartDate) : null;
    Date _toRequestEndDate = (toRequestEndDate != null) ? new SimpleDateFormat("yyyy-MM-dd").parse(toRequestEndDate) : null;
	
	
	const now = moment().format('yyyy-MM-DD');
	
	maria: "AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +: Không hỗ trợ check mảng rỗng với IN
	
	
	
	
	
	
	
	
	
	https://www3.ntu.edu.sg/home/ehchua/programming/sql/SampleDatabases.html
	

	java.time.ZonedDateTime
	java.time.Instant
	java.sql.Date
	java.sql.Time
	Calendar java
	
	Socket
	
	Properties
	
	Session
	
	InternetAddress
	
	object trong java không có dạng key-value
	
	
	
	đoạn code sau có đúng không?
let totalRow;
// console.log()
totalRow["Project Name"] = "Total";
totalRow["Task Count"] = res.data[0]["Total Tasks"];
totalRow["Finished Count"] = res.data[0]["Total Finished Tasks"];
totalRow["Testing Count"] = res.data[0]["Total Testing Tasks"];
totalRow["Remain Count"] = res.data[0]["Total Remain Tasks"];
totalRow["Delayed Count"] = res.data[0]["Total Delayed Tasks"];
Đoạn code của bạn không đúng. Khi bạn viết let totalRow;, bạn chỉ khai báo biến totalRow nhưng chưa khởi tạo nó, do đó nó sẽ có giá trị là undefined. Khi bạn cố gắng gán giá trị cho các thuộc tính của totalRow như
totalRow["Project Name"] = "Total";, bạn sẽ gặp lỗi "TypeError: Cannot set properties of undefined (setting 'Project Name')".
Để sửa lỗi này, bạn cần khởi tạo totalRow là một đối tượng trước khi gán giá trị cho các thuộc tính của nó. Dưới đây là cách sửa đoạn code của bạn:
let totalRow = {};
totalRow["Project Name"] = "Total";
totalRow["Task Count"] = res.data[0]["Total Tasks"];
totalRow["Finished Count"] = res.data[0]["Total Finished Tasks"];
totalRow["Testing Count"] = res.data[0]["Total Testing Tasks"];
totalRow["Remain Count"] = res.data[0]["Total Remain Tasks"];
totalRow["Delayed Count"] = res.data[0]["Total Delayed Tasks"];



  function formatData(data) {
    return data.toFixed(2);
  }
  
  
  
  
  
  
  
  
  
  
  
Trong Java, khi chuyển đổi giữa các kiểu nguyên thủy (primitive) mà không có mất mát dữ liệu hoặc tràn số, không có thông báo lỗi hoặc ngoại lệ được ném ra từ Java Compiler hoặc Java Runtime Environment. Chuyển đổi này được coi là ngầm định và tự động thực hiện theo quy tắc chuyển đổi kiểu dữ liệu.

Ví dụ, khi chuyển đổi một kiểu dữ liệu int sang kiểu long, không có rủi ro mất mát dữ liệu hoặc tràn số. Chuyển đổi này sẽ được thực hiện tự động và không có ngoại lệ ném ra. Tuy nhiên, nếu chuyển đổi từ kiểu long sang kiểu int, có thể xảy ra mất mát dữ liệu nếu giá trị của long vượt quá phạm vi của kiểu int. Trong trường hợp này, chuyển đổi sẽ vẫn diễn ra, nhưng giá trị của int sẽ bị cắt bỏ phần dư.

Tuy nhiên, trong một số trường hợp, nếu chuyển đổi không hợp lệ, ví dụ như chuyển đổi kiểu char sang kiểu boolean, hoặc chuyển đổi giữa các kiểu số nguyên với phạm vi không tương thích, bạn có thể gặp lỗi biên dịch hoặc warning từ Java Compiler.

Do đó, mặc dù không phải tất cả các chuyển đổi giữa các kiểu dữ liệu nguyên thủy đều thông báo lỗi hoặc ngoại lệ, vẫn cần kiểm tra và đảm bảo rằng các chuyển đổi được thực hiện một cách hợp lệ và không gây mất mát dữ liệu hoặc tràn số không mong muốn.

 
 
 BigDecimal and BigInteger in Java
 
 https://rikkei.edu.vn/ep-kieu-trong-java/
 https://ioflood.com/blog/java-casting/#:~:text=Java%20casting%20is%20a%20process,%3D%20(subClass)super%3B%20.
 https://www.geeksforgeeks.org/class-type-casting-in-java/
 
 
 renderValue={(selected) => selected.join(", ")}
 Trong đoạn code này, hàm renderValue nhận một tham số là selected, đại diện cho giá trị đã chọn trong Select component. Hàm này sử dụng phương thức join của mảng selected để kết hợp các phần tử trong mảng thành một chuỗi,
 với dấu phẩy và khoảng trắng làm phân cách giữa các phần tử.
 
 renderValue={(selected) => {
  selected.join(", ");
}}
Trong đoạn code này, hàm renderValue cũng nhận một tham số selected, nhưng trong phần thân của hàm không có giá trị trả về được xác định. Lệnh selected.join(", ") chỉ được gọi, nhưng không có hành động nào được thực hiện với
kết quả trả về của nó.


vì có thể render nhiều lần nên cần check điều kiện của state trước khi thực hiện lệnh

chưa nắm rõ thì cần hạn chế update state nhiều hơn 1 lần trong code

cái gì có khả năng lặp lại cần tách riêng ra để có thể tái sử dụng










server:
  port: 9720

spring:
  h2:
    console:
      enabled: false
      path: /h2-consoles

  websocket:
#    local
    client-server: http://localhost:3000
#    product
#    client-server: http://172.25.219.61:8080/

datasource:
#  url: jdbc:mariadb://172.25.219.61:3306/pme00
#  username: dev
#  password: dbdev
  url: jdbc:mariadb://localhost:3306/viva-odc
  username: root
  password: ngoctuan99
  driver-class-name: org.mariadb.jdbc.Driver

minio:
  url: http://172.25.219.61:6040/
  accessKey: 2046KAWetUZYcG8nubg0
  secretKey: cpxDglli2pZI3KdiIsG1ZdJVi0wgRCFlBwQlK5OJ
  bucketName: ampro

resetPassword:
  frontEndUrl: http://172.25.219.61:8080
  subject: Reset Password








package com.poscodx.odc.ampro015.config.jwt;

import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class AuthTokenFilter extends OncePerRequestFilter {
  @Autowired
  private JwtUtils jwtUtils;

  @Autowired
  private ServiceLifecycle serviceLifecycle;

  @Autowired
  private EmployeeDetailsServiceImpl employeeDetailsService;

//  private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    String jwt = parseJwt(request);
    if(serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwt).isEmpty()){//check token in blacklist
      if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
//          String username = jwtUtils.getUserNameFromJwtToken(jwt);
        String id = jwtUtils.getUserIdFromJwtToken(jwt);

//          UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        UserDetails userDetails = employeeDetailsService.loadUserById(id);
        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

        SecurityContextHolder.getContext().setAuthentication(authentication);
      }
    }

    filterChain.doFilter(request, response);
  }

  private String parseJwt(HttpServletRequest request) {
    String headerAuth = request.getHeader("Authorization");

    if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
      return headerAuth.substring(7);
    }

    return null;
  }
}



package com.poscodx.odc.ampro015.config.jwt;

import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class AuthTokenFilter extends OncePerRequestFilter {
  @Autowired
  private JwtUtils jwtUtils;

  @Autowired
  private ServiceLifecycle serviceLifecycle;

  @Autowired
  private EmployeeDetailsServiceImpl employeeDetailsService;

//  private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    String jwt = parseJwt(request);
    if(serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwt).isEmpty()){//check token in blacklist
      if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
//          String username = jwtUtils.getUserNameFromJwtToken(jwt);
        String id = jwtUtils.getUserIdFromJwtToken(jwt);

//          UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        UserDetails userDetails = employeeDetailsService.loadUserById(id);
        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities());
        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

        SecurityContextHolder.getContext().setAuthentication(authentication);
      }
    }

    filterChain.doFilter(request, response);
  }

  private String parseJwt(HttpServletRequest request) {
    String headerAuth = request.getHeader("Authorization");

    if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
      return headerAuth.substring(7);
    }

    return null;
  }
}








package com.poscodx.odc.ampro015.config.jwt;

import com.poscodx.odc.ampro015.config.services.EmployeeDetailsImpl;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.util.Date;

@Component
public class JwtUtils {

  @Value("${bezkoder.app.jwtSecret}")
  private String jwtSecret;

  @Value("${bezkoder.app.jwtExpirationMs}")
  private int jwtExpirationMs;

  public String generateJwtToken(Authentication authentication) {

    EmployeeDetailsImpl userPrincipal = (EmployeeDetailsImpl) authentication.getPrincipal();

    return Jwts.builder()
//        .setSubject((userPrincipal.getUsername()))
        .setSubject((userPrincipal.getId()))
        .setIssuedAt(new Date())
        .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs))
        .signWith(key(), SignatureAlgorithm.HS256)
        .compact();
  }
  
  private Key key() {
    return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
  }

  public String getUserNameFromJwtToken(String token) {
    return Jwts.parserBuilder().setSigningKey(key()).build()
               .parseClaimsJws(token).getBody().getSubject();
  }

  public String getUserIdFromJwtToken(String token) {
    return Jwts.parserBuilder().setSigningKey(key()).build()
            .parseClaimsJws(token).getBody().getSubject();
  }

  public boolean validateJwtToken(String authToken) {
    try {
      Jwts.parserBuilder().setSigningKey(key()).build().parse(authToken);
      return true;
    } catch (MalformedJwtException e) {
      System.out.println("Invalid JWT token: {}" + e.getMessage());
    } catch (ExpiredJwtException e) {
      System.out.println("JWT token is expired: {}" + e.getMessage());
    } catch (UnsupportedJwtException e) {
      System.out.println("JWT token is unsupported: {}" + e.getMessage());
    } catch (IllegalArgumentException e) {
      System.out.println("JWT claims string is empty: {}" +  e.getMessage());
    }

    return false;
  }
}







package com.poscodx.odc.ampro015.config.provider;

import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class CustomAuthenticationProvider implements AuthenticationProvider {
    private final EmployeeDetailsServiceImpl employeeDetailsService;
    private final PasswordEncoder encoder;
    @Override
    public Authentication authenticate(Authentication authentication)
            throws AuthenticationException {

        String id = authentication.getPrincipal().toString();
        String password = authentication.getCredentials().toString();

        UserDetails currentUser = employeeDetailsService.loadUserById(id);
        if (currentUser == null) {
            throw new UsernameNotFoundException("User not found");
        }
        // Example: validating credentials
        if (!encoder.matches(password, currentUser.getPassword())) {
            throw new UsernameNotFoundException("Invalid credentials");
        }

        // Create a fully authenticated Authentication object
        return new UsernamePasswordAuthenticationToken(currentUser, password, currentUser.getAuthorities());
    }

    @Override
    public boolean supports(Class<?> authentication) {
        return authentication.equals(UsernamePasswordAuthenticationToken.class);
    }
}




package com.poscodx.odc.ampro015.config.services;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.poscdx.odc.ampro015.domain.entity.M00Employee;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.*;

@Data
public class EmployeeDetailsImpl implements UserDetails {

    private static final long serialVersionUID = 1L;

    private String id;

    private String username;

    private String avatar;

    private String email;

    private List<String> role;

    private Map <String, List<String>> permissionMap;

  @JsonIgnore
  private String password;

  private Collection<? extends GrantedAuthority> authorities;

    public EmployeeDetailsImpl(String id, String username, String email, String avatar, String password, List<String> role,
                               Collection<? extends GrantedAuthority> authorities, Map <String, List<String>> permissionMap) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.avatar = avatar;
        this.password = password;
        this.role = role;
        this.authorities = authorities;
        this.permissionMap = permissionMap;
    }

    public static EmployeeDetailsImpl build(M00Employee user, List<String> listRoles, List<Map<String, String>> listPermission) {

        Set<SimpleGrantedAuthority> authorities = new HashSet<>();
        Map <String, List<String>> permissionMap = new HashMap<>();
        List<String> permissionList;
        for (Map<String, String> map : listPermission) {
            Set<String> set = map.keySet();
            for (String key : set) {
                authorities.add(new SimpleGrantedAuthority(map.get(key)));
                permissionList = permissionMap.get(key) == null ? new ArrayList<>() : permissionMap.get(key);
                if (!permissionList.contains(map.get(key))) permissionList.add(map.get(key));
                permissionMap.put(key, permissionList);
            }
        }

        return new EmployeeDetailsImpl(
                user.getEmpId(),
                user.getName(),
                user.getMail(),
                user.getAvatar(),
                user.getPassword(),
                listRoles,
                authorities,
                permissionMap);
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        EmployeeDetailsImpl user = (EmployeeDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
}














package com.poscodx.odc.ampro015.config.services;

import com.netflix.discovery.converters.Auto;
import com.poscdx.odc.ampro015.domain.entity.M00Employee;
import com.poscdx.odc.ampro015.domain.entity.Pme00RoleUser;
import com.poscdx.odc.ampro015.domain.entity.Pme00Setting;
import com.poscdx.odc.ampro015.domain.entity.SettingMedia;
import com.poscdx.odc.ampro015.domain.spec.Pme00SettingService;
import com.poscdx.odc.ampro015.domain.utils.Utils;
import com.poscodx.odc.ampro015.store.Pme00RoleUserJpaStore;
import com.poscodx.odc.ampro015.store.jpo.M00EmployeeJpo;
import com.poscodx.odc.ampro015.store.jpo.Pme00PerRoleJpo;
import com.poscodx.odc.ampro015.store.jpo.Pme00PermissionJpo;
import com.poscodx.odc.ampro015.store.jpo.Pme00SettingJpo;
import com.poscodx.odc.ampro015.store.repository.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class EmployeeDetailsServiceImpl implements UserDetailsService {

    @Autowired
    M00EmployeeRepository employeeRepository;
    @Autowired
    Pme00RoleRepository roleRepository;
    @Autowired
    Pme00PerRoleRepository perRoleRepository;
    @Autowired
    Pme00PermissionRepository permissionRepository;
    @Autowired
    Pme00RoleUserJpaStore pme00RoleUserJpaStore;
    @Autowired
    Pme00SettingService pme00SettingService;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        M00EmployeeJpo user = employeeRepository.findByName(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with UserName: " + username));
        M00Employee employee = user.toDomain();
        SettingMedia settingMedia = pme00SettingService.getMediaSetting();
        if (settingMedia != null) {
            employee.setAvatar(Utils.setFilePath(settingMedia, employee.getAvatar(), Utils.UPLOAD_SERVICE_EMPLOYEE));
        }
        //List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findRoleUserByEmpId(user.getEmpId());
        List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findByEmployeeId(user.getEmpId());
        List<String> listRoles = new ArrayList<>();
        for (Pme00RoleUser roleUser : roles) {
            roleRepository.findById(roleUser.getRoleId()).ifPresent(pme00RoleJpo -> listRoles.add(pme00RoleJpo.getName()));
        }
        String roleName = "ROLE_STAFF";
        if (!roles.isEmpty()) {
            // roleName = role.get().getName().name();
            //roleName = role.get().getName();
        }
        return EmployeeDetailsImpl.build(employee, null, null);
    }

    @Transactional
    public UserDetails loadUserById(String id) throws RuntimeException {
        M00EmployeeJpo user = employeeRepository.findById(id)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with Id: " + id));
        M00Employee employee = user.toDomain();
        SettingMedia settingMedia = pme00SettingService.getMediaSetting();
        if (settingMedia != null) {
            employee.setAvatar(Utils.setFilePath(settingMedia, employee.getAvatar(), Utils.UPLOAD_SERVICE_EMPLOYEE));
        }

        //List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findRoleUserByEmpId(user.getEmpId());
        List<Pme00RoleUser> roles = pme00RoleUserJpaStore.findByEmployeeId(user.getEmpId());
        List<String> listRoles = new ArrayList<>();
        for (Pme00RoleUser roleUser : roles) {
            roleRepository.findById(roleUser.getRoleId()).ifPresent(pme00RoleJpo -> listRoles.add(pme00RoleJpo.getName()));
        }
        // Optional<Pme00RoleJpo> role = roleRepository.findByName(user.getRole());

        if (!roles.isEmpty()) {
            // List<Integer> perIds =
            // perRoleRepository.findByRoleId(user.getRole()).stream().map(Pme00PerRoleJpo::getPermissionId).collect(Collectors.toList());
            // Set<String> perName = perIds.stream().map(i ->
            // Objects.requireNonNull(permissionRepository.findById(i).orElse(null)).getName()).collect(Collectors.toSet());
            // return EmployeeDetailsImpl.build(user, perName);
            List<Map<String, String>> listPermission = new ArrayList<>();
            for (Pme00RoleUser roleUser : roles) {
                List<Integer> perIds = perRoleRepository.findByRoleId(roleUser.getRoleId()).stream()
                        .map(Pme00PerRoleJpo::getPermissionId).collect(Collectors.toList());
                perIds.forEach(permissionId -> {
                    Optional<Pme00PermissionJpo> permission = permissionRepository.findById(permissionId);
                    if (permission.isPresent()) {
                        //perName.add(permission.get().getName());
                        Map<String, String> per = new HashMap<>();
                        per.put(permission.get().getGroup(), permission.get().getName());
                        listPermission.add(per);
                    }
                });
            }
            return EmployeeDetailsImpl.build(employee, listRoles, listPermission);
        }
        return new EmployeeDetailsImpl(user.getEmpId(), user.getName(), user.getMail(), user.getAvatar(), user.getPassword(), listRoles, null, null);
    }
}













package com.poscodx.odc.ampro015.config;

import com.poscodx.odc.ampro015.config.exceptionhandler.AuthEntryPoint;
import com.poscodx.odc.ampro015.config.jwt.AuthTokenFilter;
import com.poscodx.odc.ampro015.config.provider.CustomAuthenticationProvider;
import com.poscodx.odc.ampro015.config.services.EmployeeDetailsServiceImpl;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import org.apache.commons.codec.digest.Md5Crypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.math.BigInteger;

@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
// (securedEnabled = true,
// jsr250Enabled = true,
// prePostEnabled = true) // by default
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private AuthTokenFilter authTokenFilter;
    @Autowired
    private EmployeeDetailsServiceImpl employeeDetailsService;
    @Autowired
    private AuthEntryPoint unauthorizedHandler;
    @Autowired
    private CustomAuthenticationProvider authenticationProvider;

    // Details omitted for brevity
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new PasswordEncoder() {
            @Override
            public String encode(CharSequence rawPassword) {
                try {
                    MessageDigest md = MessageDigest.getInstance("MD5");
                    byte[] messageDigest = md.digest(rawPassword.toString().getBytes());
                    BigInteger number = new BigInteger(1, messageDigest);
                    String hashtext = number.toString(16);
                    while (hashtext.length() < 32) {
                        hashtext = "0" + hashtext;
                    }
                    return hashtext;
                } catch (NoSuchAlgorithmException e) {
                    throw new RuntimeException(e);
                }
            }

            @Override
            public boolean matches(CharSequence rawPassword, String encodedPassword) {
                return encode(rawPassword).equals(encodedPassword);
            }
        };
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth)
            throws Exception {
        auth.authenticationProvider(authenticationProvider)
                .userDetailsService(employeeDetailsService)
                .passwordEncoder(passwordEncoder());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Enable CORS and disable CSRF
        http = http.cors().and().csrf().disable();

        // Set session management to stateless
        http = http
                .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and();

        // Set unauthorized requests exception handler
        http = http
                .exceptionHandling()
                .authenticationEntryPoint(
                        unauthorizedHandler
                )
                .and();

        // Set permissions on endpoints
        http.authorizeRequests()
                // Our public endpoints
                .antMatchers(HttpMethod.POST, "/author/signup").permitAll()
                .antMatchers(HttpMethod.POST, "/author/signin").permitAll()
                .antMatchers(HttpMethod.POST, "/author/logout").permitAll()
//                .antMatchers(HttpMethod.GET, "/images/**").permitAll()
//                .antMatchers(HttpMethod.GET, "/user-management/**").permitAll()
//
//                .antMatchers(HttpMethod.GET, "**/dashboard.do").permitAll()
//                .antMatchers(HttpMethod.POST, "**/dashboard.do").permitAll()
//                .antMatchers(HttpMethod.GET, "**/dashboard.do/**").permitAll()
//                .antMatchers(HttpMethod.POST, "**/dashboard.do/**").permitAll()
//                // .antMatchers(HttpMethod.GET, "**/asset-view.do/**").permitAll()
//                .antMatchers(HttpMethod.GET, "**/asset/view-asset/**").permitAll()
//                .antMatchers(HttpMethod.POST, "**/asset/view-asset/**").permitAll()
//                .antMatchers(HttpMethod.GET, "/level2/**").permitAll()
//                .antMatchers(HttpMethod.POST, "/level2/**").permitAll()
                .anyRequest().permitAll();
//                .anyRequest().authenticated();
        // Add JWT token filter
        http.addFilterBefore(
                authTokenFilter,
                UsernamePasswordAuthenticationFilter.class
        );

    }
}

















package com.poscodx.odc.ampro015.rest;

import com.poscdx.odc.ampro015.domain.entity.LogoutAccessToken;
import com.poscdx.odc.ampro015.domain.entity.M00Employee;
import com.poscdx.odc.ampro015.domain.entity.Pme00PasswordToken;
import com.poscdx.odc.ampro015.domain.entity.SettingEmailSender;
import com.poscdx.odc.ampro015.domain.entity.payload.request.ForgotPasswordRequest;
import com.poscdx.odc.ampro015.domain.entity.payload.request.LoginRequest;
import com.poscdx.odc.ampro015.domain.entity.payload.request.ResetPasswordRequest;
import com.poscdx.odc.ampro015.domain.entity.payload.response.*;
import com.poscdx.odc.ampro015.domain.lifecycle.ServiceLifecycle;
import com.poscdx.odc.ampro015.domain.utils.Utils;
import com.posco.reuse.common.logging.PosLogWriterIF;
import com.posco.reuse.common.logging.PosLogger;
import com.poscodx.odc.ampro015.MailConfig;
import com.poscodx.odc.ampro015.config.jwt.JwtUtils;
import com.poscodx.odc.ampro015.config.services.EmployeeDetailsImpl;
import com.poscoict.base.share.util.json.JsonUtil;
import lombok.RequiredArgsConstructor;
import org.apache.commons.codec.digest.DigestUtils;
import org.jetbrains.annotations.NotNull;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.ResourceUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.validation.Valid;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.stream.Collectors;

//@CrossOrigin(origins = "*", maxAge = 3600)
@CrossOrigin(origins = "*")
//@CrossOrigin(origins = "${cross.origins}")
@RestController
@RequiredArgsConstructor
@RequestMapping("/author")
public class AuthResource {

    private final AuthenticationManager authenticationManager;
    private final ServiceLifecycle serviceLifecycle;
    private final PasswordEncoder encoder;
    private final JwtUtils jwtUtils;
    private final MailConfig mailConfig;

    @PostMapping("/signup")
    public ResponseEntity<?> registerUser(@Valid @RequestBody M00Employee signUpRequest) {
        return (ResponseEntity<?>) ResponseEntity.ok();
    }

    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(loginRequest.getId(), loginRequest.getPassword())); // call load user from db based on CustomAuthenticationProvider implements AuthenticationProvider 

        SecurityContextHolder.getContext().setAuthentication(authentication);
        String jwt = jwtUtils.generateJwtToken(authentication);

        //EmployeeDetailsImpl userDetails1 = (EmployeeDetailsImpl) authentication.getPrincipal();
        EmployeeDetailsImpl userDetails = (EmployeeDetailsImpl) authentication.getPrincipal();

   List<String> permissions1 = userDetails.getAuthorities().stream()
           .map(GrantedAuthority::getAuthority)
           .collect(Collectors.toList());

        LoginUserInfo userInfo = LoginUserInfo.builder()
                .id(userDetails.getId())
                .username(userDetails.getUsername())
                .email(userDetails.getEmail())
                .listRole(userDetails.getRole())
                .avatar(userDetails.getAvatar())
                .build();

        return ResponseEntity.ok(new JwtResponse(jwt,
                userInfo, userDetails.getPermissionMap()));
    }

    @PostMapping("/logout")
    public ResponseEntity<?> logout(HttpServletRequest request) {
        String jwtToken = parseJwt(request);
        System.out.println("jwt token: " + jwtToken);
        if (jwtToken == null || jwtToken.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Not logged in yet!");
        } else {
            if (serviceLifecycle.requestLogoutAccessTokenService().findByToken(jwtToken).isEmpty()) {
                //Save logout access token to blacklist
                LogoutAccessToken token = LogoutAccessToken.builder()
                        .token(jwtToken)
                        .status(1) //blacklist token
                        .build();
                serviceLifecycle.requestLogoutAccessTokenService().register(token);
            }
            return ResponseEntity.ok().body("Logout successfully!");
        }
    }

    @PostMapping("/forgot-password")
    public ResponseEntity<?> ForgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotPasswordRequest) {
        M00Employee employee = serviceLifecycle.requestM00EmployeeService().getEmployeeByEmail(forgotPasswordRequest.getEmail());
        if(employee == null){
            ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
            forgotPasswordResponse.setError(true);
            forgotPasswordResponse.setMessage("Email is not exists on system. Please check again!");
            return ResponseEntity.ok(forgotPasswordResponse);
        }else{

            SettingEmailSender settingEmailSender = serviceLifecycle.requestPme00SettingService().getEmailSenderSetting();
            if(settingEmailSender==null){
                ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
                forgotPasswordResponse.setError(true);
                forgotPasswordResponse.setMessage("Have Error when send email. Please contact with administrator");
                PosLogger.developerLog(PosLogWriterIF.ERROR,"CMS Can not get email sender setting", this);
                return ResponseEntity.ok(forgotPasswordResponse);
            }

            UUID uuid = UUID. randomUUID();
            Pme00PasswordToken pme00PasswordToken = getPme00PasswordToken(employee, uuid);
            String resetHtmlTemplate = LoadTemplate();
            Utils.MAIL_SMTP_SERVER = settingEmailSender.getHost();
            Utils.MAIL_SMTP_SERVER_PORT = settingEmailSender.getPort();
            Utils.MAIL_SMTP_EMAIL_ID = settingEmailSender.getSenderID();
            Utils.MAIL_SMTP_EMAIL_ID_ALIAS = settingEmailSender.getSenderName();
            Utils.MAIL_SMTP_EMAIL_USERNAME = settingEmailSender.getUsername();
            Utils.MAIL_SMTP_EMAIL_PASSWORD = settingEmailSender.getPassword();
            Utils.MAIL_FRONT_END_URL = mailConfig.getFrontEndUrl();

            Map<String, String> map = new HashMap<String, String>();
            map.put("url", mailConfig.getFrontEndUrl());
            map.put("token",uuid.toString());
            for (Map.Entry<String, String> entry : map.entrySet()) {
                resetHtmlTemplate = resetHtmlTemplate.replace("${" + entry.getKey() + "}", entry.getValue());
            }
            if(serviceLifecycle.requestLevel2Service().sendMail(employee.getMail(),mailConfig.getSubject(),resetHtmlTemplate)){
                serviceLifecycle.requestPasswordService().register(pme00PasswordToken);
                ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
                forgotPasswordResponse.setError(false);
                forgotPasswordResponse.setMessage("Please check email to process next step");
                return ResponseEntity.ok(forgotPasswordResponse);
            }else {
                ForgotPasswordResponse forgotPasswordResponse = new ForgotPasswordResponse();
                forgotPasswordResponse.setError(true);
                forgotPasswordResponse.setMessage("Have Error when send email. Please contact with administrator");
                return ResponseEntity.ok(forgotPasswordResponse);
            }
        }
    }
    @CrossOrigin
    @GetMapping("/reset-password/{token}")
    public ResponseEntity<?> ResetPasswordGetToken(@PathVariable("token") String token) {
        //String s = LoadTemplate();

        ResetPasswordResponse resetPasswordResponse = new ResetPasswordResponse();
        Pme00PasswordToken pme00PasswordToken = serviceLifecycle.requestPasswordService().FindPasswordTokenByToken(token);
        if(pme00PasswordToken==null){
            resetPasswordResponse.setError(true);
            resetPasswordResponse.setMessage("Token is not exists on system. Please check again!");
            return ResponseEntity.ok(resetPasswordResponse);
        }else {
            if(pme00PasswordToken.IsExpired()){
                resetPasswordResponse.setError(true);
                resetPasswordResponse.setMessage("Token is expired!");
            }else{
                resetPasswordResponse.setError(false);
                resetPasswordResponse.setMessage("");
                resetPasswordResponse.setEmpId(pme00PasswordToken.getEmpId());
            }
            return ResponseEntity.ok(resetPasswordResponse);
        }
    }
    @PostMapping("/reset-password/{token}")
    public ResponseEntity<?> ResetPassword(@Valid @PathVariable("token") String token,
                                           @Valid @RequestBody ResetPasswordRequest resetPasswordRequest) {
        ResetPasswordResponse resetPasswordResponse = new ResetPasswordResponse();
        Pme00PasswordToken pme00PasswordToken = serviceLifecycle.requestPasswordService().FindPasswordTokenByToken(token);

        M00Employee m00Employee = serviceLifecycle.requestM00EmployeeService().find(pme00PasswordToken.getEmpId());
        if (m00Employee == null) {
            resetPasswordResponse.setError(true);
            resetPasswordResponse.setMessage("Token is not exists on system. Please check again!");
            return ResponseEntity.ok(resetPasswordResponse);
        } else {
            if (pme00PasswordToken.IsExpired()) {
                resetPasswordResponse.setError(true);
                resetPasswordResponse.setMessage("Token is expired!");
            } else {
                if(!resetPasswordRequest.getPassword().equals(resetPasswordRequest.getConfirmPassword())){
                    resetPasswordResponse.setError(true);
                    resetPasswordResponse.setMessage("Password is not match!");
                }else {
                    String passwordToMd5Hex = DigestUtils
                            .md5Hex(resetPasswordRequest.getPassword());
                    m00Employee.setPassword(passwordToMd5Hex);
                    M00Employee updateM00Employee = serviceLifecycle.requestM00EmployeeService().modify(m00Employee);

                    resetPasswordResponse.setError(false);
                    resetPasswordResponse.setMessage("Password is changed! You can login again, now!");
                }
            }
            return ResponseEntity.ok(resetPasswordResponse);
        }

    }

    @NotNull
    private static Pme00PasswordToken getPme00PasswordToken(M00Employee employee, UUID uuid) {
        Pme00PasswordToken pme00PasswordToken=new Pme00PasswordToken();
        pme00PasswordToken.setEmpId(employee.getEmpId());
        pme00PasswordToken.setToken(uuid.toString());
        pme00PasswordToken.setCreateAt(new Date());
        pme00PasswordToken.setCreateBy("0");
        pme00PasswordToken.setUpdateAt(new Date());
        pme00PasswordToken.setUpdateBy("0");
        long currentTimeInMillis = System.currentTimeMillis();
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(currentTimeInMillis);
        calendar.add(Calendar.HOUR, Utils.MAX_EXPIRE_TOKEN);
        pme00PasswordToken.setExpire(calendar.getTimeInMillis());
        return pme00PasswordToken;
    }

    private String LoadTemplate() {
        try {
            return new String(Files.readAllBytes(ResourceUtils.getFile("classpath:password-reset.html").toPath()));
        } catch (IOException e) {
            e.printStackTrace();

        }
        return "";
    }
    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        System.out.println("Authorization: " + headerAuth);

        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }

        return null;
    }
}













package com.poscodx.odc.ampro015.config.exceptionhandler;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {

//  private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
//    logger.error("Unauthorized error: {}", authException.getMessage());

    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

    final Map<String, Object> body = new LinkedHashMap<>();;
    body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
    body.put("error", "Unauthorized");
    body.put("message", authException.getMessage());
    body.put("path", request.getServletPath());

    final ObjectMapper mapper = new ObjectMapper();
    mapper.writeValue(response.getOutputStream(), body);
  }
}












server:
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json # 성능 가이드 - 해당값 지정 [TODO - 중]
    min-response-size: 1024

spring:
  servlet:
    multipart:
      max-file-size: 50MB
      max-request-size: 50MB
  datasource:
    url: ${datasource.url}
    username: ${datasource.username}
    password: ${datasource.password}
    driver-class-name: ${datasource.driver-class-name}
  jpa:
    hibernate:
      ddl-auto: update
#    show-sql: true
    ddl-auto: update
    properties:
      hibernate:
        format_sql: true
  zipkin:
    enabled: false
  sleuth:
    messaging:
      enabled: false
      kafka:
        enabled: false

feign:
  hystrix:
    enabled: false
  client:
    config:
      default:
        connectTimeout: 3000 # TODO[선택] : 업무 요건에 맞게 변경
        readTimeout: 10000 # TODO[선택] : 업무 요건에 맞게 변경
ribbon:
  ReadTimeout: 10000 # TODO[선택] : 업무 요건에 맞게 변경
  ConnectTimeout: 3000 # TODO[선택] : 업무 요건에 맞게 변경

qrcode:
  domain : http://localhost:3000/asert?token=
  fileType : png
  size : 250

bezkoder:
  app:
    jwtSecret: cG9zY29kLXh2aWV0bmFtbnVtYmVyb25laW5teWhlYXJ0XjBedGhlbWt5dHVjaHVjaHVvaWR1ZGFp
    jwtExpirationMs: 36000000

cross:
  origins: "http://localhost:3000"



  minio:
    url: ${minio.url}
    accessKey: ${minio.accessKey}
    secretKey: ${minio.secretKey}
    bucketName: ${minio.bucketName}

resetPassword:
  frontEndUrl: ${resetPassword.frontEndUrl}
  subject: ${resetPassword.subject}
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  JSON.stringify
  
  instance trong JS
  
  Tìm hiểu về kiểu Map, Set, Regular Expressions trong JS
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
