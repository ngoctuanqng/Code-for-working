useReducer--REACTJS:
		
		- Thực tế khi sử dụng useState thì nó sẽ trả về 1 phiên bản đơn giản của useReducer, vậy nên chúng ta có thể coi
		useReducer như một phiên bản nâng cao hơn dùng để thay thế cho việc sử dụng useState.
		
		- Khi gọi dispatch(action), nó sẽ chạy qua reducer và truyền action cùng với trạng thái hiện tại vào hàm
		reducer. Sau đó, hàm reducer sẽ kiểm tra hành động và trả về một phiên bản mới
		của trạng thái dựa trên hành động đó.
		
		- Trong hàm reducer sẽ có biến state và biến action, biến action được lấy từ dispatch.
		
		- The dispatch function only updates the state variable for the next render. If you read the state variable after
		calling the dispatch function, you will still get the old value that was on the screen before your call.
		
		- If the new value you provide is identical to the current state, as determined by an Object.is comparison, React
		will skip re-rendering the component and its children. This is an optimization. React may still need to call your
		component before ignoring the result, but it shouldn’t affect your code.
		
		- React batches state updates. It updates the screen after all the event handlers have run and have called
		their set functions. This prevents multiple re-renders during a single event.
		In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you
		can use flushSync.
		
		- useReducer is a React Hook that lets you add a reducer to your component.

			// Define reducer function
			const reducer = (state, action) => {
			  switch (action.type) {
				case 'INCREMENT':
				  return { count: state.count + 1 };
				case 'DECREMENT':
				  return { count: state.count - 1 };
				case 'RESET':
				  return { count: 0 };
				default:
				  return state;
			  }
			};
			import React, { useReducer } from 'react';
			import reducer from './Reducer';
			// Component
			function Counter() {
			  // Sử dụng useReducer với reducer function và initialState
			  const [state, dispatch] = useReducer(reducer, { count: 0 });
			  // Handlers
			  const increment = () => dispatch({ type: 'INCREMENT' });
			  const decrement = () => dispatch({ type: 'DECREMENT' });
			  const reset = () => dispatch({ type: 'RESET' });
			  return (
				<div>
				  <p>Count: {state.count}</p>
				  <button onClick={increment}>Increment</button>
				  <button onClick={decrement}>Decrement</button>
				  <button onClick={reset}>Reset</button>
				</div>
			  );
			}
			export default Counter;
		
		
		- The dispatch function returned by useReducer lets you update the state to a different value and trigger a
		re-render. You need to pass the action as the only argument to the dispatch function
		
		- dispatch functions do not have a return value.
		
		- The dispatch function only updates the state variable for the next render. If you read the state variable after
		calling the dispatch function, you will still get the old value that was on the screen before your call.
		
		- Chú ý cái này giống như là useState nhưng sẽ xử lý nâng cao hơn, vì thế các chức năng mà useState có thì cái này
		cũng làm được
		
		- Ví dụ đầy đủ về useReducer
		
			import { useReducer } from 'react';
			import AddTask from './AddTask.js';
			import TaskList from './TaskList.js';

			function tasksReducer(tasks, action) {
			  switch (action.type) {
				case 'added': {
				  return [...tasks, {
					id: action.id,
					text: action.text,
					done: false
				  }];
				}
				case 'changed': {
				  return tasks.map(t => {
					if (t.id === action.task.id) {
					  return action.task;
					} else {
					  return t;
					}
				  });
				}
				case 'deleted': {
				  return tasks.filter(t => t.id !== action.id);
				}
				default: {
				  throw Error('Unknown action: ' + action.type);
				}
			  }
			}

			export default function TaskApp() {
			  const [tasks, dispatch] = useReducer(
				tasksReducer,
				initialTasks
			  );

			  function handleAddTask(text) {
				dispatch({
				  type: 'added',
				  id: nextId++,
				  text: text,
				});
			  }

			  function handleChangeTask(task) {
				dispatch({
				  type: 'changed',
				  task: task
				});
			  }

			  function handleDeleteTask(taskId) {
				dispatch({
				  type: 'deleted',
				  id: taskId
				});
			  }

			  return (
				<>
				  <h1>Prague itinerary</h1>
				  <AddTask
					onAddTask={handleAddTask}
				  />
				  <TaskList
					tasks={tasks}
					onChangeTask={handleChangeTask}
					onDeleteTask={handleDeleteTask}
				  />
				</>
			  );
			}

			let nextId = 3;
			const initialTasks = [
			  { id: 0, text: 'Visit Kafka Museum', done: true },
			  { id: 1, text: 'Watch a puppet show', done: false },
			  { id: 2, text: 'Lennon Wall pic', done: false }
			];

		- State is read-only. Don’t modify any objects or arrays in state:
			
			// Don't mutate an object in state like this:
			state.age = state.age + 1;
				
		- Instead, always return new objects from your reducer:
		
			function reducer(state, action) {
			  switch (action.type) {
				case 'incremented_age': {
				  // ✅ Instead, return a new object
				  return {
					...state,
					age: state.age + 1
				  };
				}
	
		- React saves the initial state once and ignores it on the next renders.
		
		- Although the result of createInitialState(username) is only used for the initial render, you’re still calling this
		function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.
		
		- To solve this, you may pass it as an initializer function to useReducer as the third argument instead:
			
			function createInitialState(username) {
				 // ...
			}

			function TodoList({ username }) {
			  const [state, dispatch] = useReducer(reducer, username, createInitialState);
			  // ...