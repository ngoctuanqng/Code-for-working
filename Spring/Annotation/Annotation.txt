Annotation--SPRING:

	lombok--Annotation:
								import lombok.*;
								@Data // Tạo getters, setters, toString(), equals(), hashCode() tự động cho tất cả các trường
								@NoArgsConstructor // Tạo constructor mặc định không tham số
								@AllArgsConstructor // Tạo constructor chứa tất cả các trường
								@Builder // Tạo builder pattern cho lớp
								@ToString // Tạo toString() tự động
								@EqualsAndHashCode // Tạo equals() và hashCode() tự động dựa trên tất cả các trường
								public class User {
									@NonNull // Tạo constructor với tham số bắt buộc và đảm bảo rằng trường không thể null
									private String username;
									@Setter(AccessLevel.PROTECTED) // Tạo setter protected cho trường này
									private String password;
									@Getter(AccessLevel.PACKAGE) // Tạo getter package-private cho trường này
									private int age;
									@ToString.Exclude // Không bao gồm trường này trong toString() tự động
									private String email;										
									@Builder.Default // Giá trị mặc định cho trường này khi sử dụng builder pattern
									private boolean active = true;
								}									
	@Data--Annotation:
								Annotation @Data sẽ tương đương với annotation @Getter + @Setter + @ToString + @NoArgsConstructor + @EqualsAndHashCode 
								
								import lombok.AllArgsConstructor;
								import lombok.Data;
								import lombok.ToString;
								@ToString(exclude = "address")
								@AllArgsConstructor
								@Data
								public class Person {
								  private String name;
								  private String address;
								  public static void main(String[] args) {
									Person person = new Person("kai", "Ha Noi - Viet Nam");
									System.out.println(person);
									System.out.println("Address: " + person.getAddress());
								 }

								}
	@Autowired--Annotation:
						
						- Sẽ không thể @Autowired một lớp nếu lớp đó không sử dụng @Component, @Controller, @Service hoặc @Repository
						- Cơ chế khi Spring bắt đầu chạy nó sẽ quét qua các lớp có sử dụng annotation để tạo Bean.
						- Đồng thời sẽ tìm kiếm xem trong các bean đó có khai báo @Autowire không, nó sẽ tìm kiếm các bean tương ứng để tiêm (Injection) vào bean đó.									
						- Quản lý phụ thuộc (Dependency Management): Sử dụng tiêm bean giúp quản lý phụ thuộc giữa các thành phần của ứng dụng. Thay vì tạo ra các đối tượng một cách cứng nhắc bằng cách sử dụng từ khóa
						new, bạn có thể chỉ định phụ thuộc của một đối tượng thông qua tiêm bean. Điều này giúp giảm sự ràng buộc giữa các lớp và làm cho mã trở nên linh hoạt hơn.
						- Tái sử dụng và linh hoạt: Tiêm bean cho phép bạn tái sử dụng các đối tượng trong ứng dụng của bạn. Thay vì tạo mới một đối tượng mỗi lần cần sử dụng, bạn có thể tiêm một đối tượng đã được
						khởi tạo trước đó vào trong các thành phần khác nhau của ứng dụng.
						- Kiểm soát vòng đời (Lifecycle Management): Spring Framework quản lý vòng đời của các bean, cho phép bạn cấu hình các hành vi khởi tạo, cách hủy và các quy trình khác liên quan đến vòng đời
						của các đối tượng trong ứng dụng.
																   
						@Service
						public class BookServiceImpl implements BookService {
						  @Autowired
						  private BookDao bookDao;
						  @Autowired
						  private CustomerDao customerDao;
						  ...
						}
						
						@Component  
						public class Customer   {  
						  private Person person;  
						  @Autowired  
						  public Customer(Person person)   {   
							this.person=person;  
						  }  
						}	
						
	@Transactional--Annotation:
	
						- Được sử dụng để quản lý giao dịch trong ứng dụng Java. Khi bạn đánh dấu một phương thức hoặc một lớp với @Transactional, Spring sẽ tự động quản lý việc bắt đầu và
						kết thúc các giao dịch.
						- Transaction quản lý những thay đổi mà bạn thực hiện trong một hoặc nhiều hệ thống, nó có thể database, message brokers, hoặc bất kỳ loại hệ thống phần mềm nào khác. Mục tiêu chính của giao
						dịch là cung cấp các đặc điểm ACID để đảm bảo tính nhất quán và hợp lệ của dữ liệu của bạn.
								
		ACID transactions--@Transactional SPRING:
		
								Vốn dĩ một transaction được đặc trưng bởi 4 yếu tố (thường được gọi là ACID)
		
			Atomicity: 
									Quy định rằng tất cả các hoạt động của transaction hoặc là thực thi thành công hết hoặc là không có bất cứ hành động nào được thực thi khi có bất
									kỳ một hoạt động thực thi không thành công.
			
			Consistency: 
									Nghĩa là tất cả các ràng buộc toàn vẹn dữ liệu(constraints, key, data types, Trigger, Check) phải được thực thi thành công cho mọi transaction
									phát sinh xuống database, nhằm đảm bảo tính đúng đắn của dữ liệu.
			
			Isolation: 
			
									Đảm bảo các transaction xảy ra xen kẽ sẽ không làm ảnh hưởng đến tính nhất quán của dữ liệu. Các thay đổi dữ liệu bên trong mỗi transaction sẽ được cô
									lập, các transaction khác sẽ không thể nhìn thấy cho đến khi nó được đồng bộ xuống database.
			
			Durability: 
			
									Đảm bảo một transaction thực thi thành công thì tất cả những thay đổi trong transaction phải được đồng bộ xuống database kể cả khi hệ thống xảy ra
									lỗi hoặc bị mất điện.
												
									@Override
									@Transactional(rollbackFor = Exception.class, // rollback transaction cho tất cả các sub-class của Exception ngoại trừ EntityNotFoundException
													noRollbackFor = EntityNotFoundException.class)
									public void updateAuthorWithRollbackCustom(Long id, String name) {
										Author author = authorRepository.findById(id).orElse(null);
										author.setName(name);
									}
												
									@Transactional(isolation = Isolation.SERIALIZABLE) // Mức độ cô lập SERIALIZABLE là mức độ cô lập cao nhất trong các mức độ cô lập của giao dịch. Nó đảm bảo rằng
																					   // các giao dịch sẽ không gặp phải vấn đề về đọc/xuất cũng như mất dữ liệu, bằng cách chặn các giao dịch cùng truy
																					   // cập đến cùng một dữ liệu cùng một lúc. Điều này có nghĩa là chỉ có một giao dịch có thể thực hiện tác động đến
																					   // dữ liệu vào một thời điểm nhất định, và các giao dịch khác phải chờ đợi cho đến khi giao dịch đó hoàn thành
																					   // trước khi được phép thực hiện.
									
									@Transactional(propagation = Propagation.SUPPORTS, readOnly = true) // Thuộc tính readOnly xác định xem giao dịch có phải là chỉ đọc hay không. Trong trường hợp này,
																										// giá trị true được sử dụng, vì vậy giao dịch sẽ chỉ thực hiện các thao tác đọc trên cơ sở dữ
																										// liệu và không thực hiện bất kỳ thao tác ghi nào. Điều này có thể tối ưu hóa hiệu suất của các
																										// phương thức chỉ đọc, bởi vì nó không cần phải đảm bảo việc commit hoặc rollback các thay đổi.								
									
		Configure Transactions--@Transactional SPRING:
		
									Spring 3.1 introduces the @EnableTransactionManagement annotation that we can use in a @Configuration class to enable transactional support:
										
										@Configuration
										@EnableTransactionManagement
										public class PersistenceJPAConfig{

										   @Bean
										   public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
											   //...
										   }

										   @Bean
										   public PlatformTransactionManager transactionManager() {
											  JpaTransactionManager transactionManager = new JpaTransactionManager();
											  transactionManager.setEntityManagerFactory(entityManagerFactory().getObject());
											  return transactionManager;
										   }
										}
										
									However, if we’re using a Spring Boot project and have a spring-data-* or spring-tx dependencies on the classpath, then transaction management will be enabled by default.
					
		Configure Transactions With XML--@Transactional SPRING:
		
									For versions before 3.1, or if Java is not an option, here is the XML configuration using annotation-driven and namespace support:
										
										<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
										   <property name="entityManagerFactory" ref="myEmf" />
										</bean>
										<tx:annotation-driven transaction-manager="txManager" />
		
		The @Transactional Annotation--@Transactional SPRING:
		
									With transactions configured, we can now annotate a bean with @Transactional either at the class or method level:
										
										@Service
										@Transactional
										public class FooService {
											//...
										}
									
									The annotation supports further configuration as well:
									
										The Propagation Type of the transaction
										The Isolation Level of the transaction
										A Timeout for the operation wrapped by the transaction
										A readOnly flag – a hint for the persistence provider that the transaction should be read only
										The Rollback rules for the transaction
									
									Note that by default, rollback happens for runtime, unchecked exceptions only. The checked exception does not trigger a rollback of the transaction. We can, of course, configure
									this behavior with the rollbackFor and noRollbackFor annotation parameters.
		
		Potential Pitfalls--@Transactional SPRING:
		
			Transactions and Proxies
			
				- At a high level, Spring creates proxies for all the classes annotated with @Transactional, either on the class or on any of the methods. The proxy allows the framework to inject transactional logic
				before and after the running method, mainly for starting and committing the transaction.
				- What’s important to keep in mind is that, if the transactional bean is implementing an interface, by default the proxy will be a Java Dynamic Proxy. This means that only external method calls that come
				in through the proxy will be intercepted. Any self-invocation calls will not start any transaction, even if the method has the @Transactional annotation.
				- Another caveat of using proxies is that only public methods should be annotated with @Transactional. Methods of any other visibilities will simply ignore the annotation silently as these are not proxied.
			
			Changing the Isolation Level
			
				courseDao.createWithRuntimeException(course);
				
				We can also change the transaction isolation level:
					
					@Transactional(isolation = Isolation.SERIALIZABLE)
				
				Note that this has actually been introduced in Spring 4.1; if we run the above example before Spring 4.1, it will result in:
					
					org.springframework.transaction.InvalidIsolationLevelException: Standard JPA does not support custom isolation levels – use a special JpaDialect for your JPA implementation
			
			Read-Only Transactions
				
				The readOnly flag usually generates confusion, especially when working with JPA. From the Javadoc:
					
					This just serves as a hint for the actual transaction subsystem; it will not necessarily cause failure of write access attempts. A transaction manager which cannot interpret the read-only hint will
					not throw an exception when asked for a read-only transaction.
				
				The fact is that we can’t be sure that an insert or update won’t occur when the readOnly flag is set. This behavior is vendor-dependent, whereas JPA is vendor agnostic.
				
				It’s also important to understand that the readOnly flag is only relevant inside a transaction. If an operation occurs outside of a transactional context, the flag is simply ignored. A simple example of
				that would call a method annotated with:
					
					@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
				
				From a non-transactional context, a transaction will not be created and the readOnly flag will be ignored.
			
			Transaction Logging
				
				A helpful method to understand transactional-related issues is fine-tuning logging in the transactional packages. The relevant package in Spring is “org.springframework.transaction”, which should be
				configured with a logging level of TRACE.
			
			Transaction Rollback
				
				The @Transactional annotation is the metadata that specifies the semantics of the transactions on a method. We have two ways to rollback a transaction: declarative and programmatic.
				
				In the declarative approach, we annotate the methods with the @Transactional annotation. The @Transactional annotation makes use of the attributes rollbackFor or rollbackForClassName to rollback the
				transactions, and the attributes noRollbackFor or noRollbackForClassName to avoid rollback on listed exceptions.
				
				The default rollback behavior in the declarative approach will rollback on runtime exceptions.
				
				Let’s see a simple example using the declarative approach to rollback a transaction for runtime exceptions or errors:
					
					@Transactional
					public void createCourseDeclarativeWithRuntimeException(Course course) {
						courseDao.create(course);
						throw new DataIntegrityViolationException("Throwing exception for demoing Rollback!!!");
					}
				
				Next, we’ll use the declarative approach to rollback a transaction for the listed checked exceptions. The rollback in our example is on SQLException:
					
					@Transactional(rollbackFor = { SQLException.class })
					public void createCourseDeclarativeWithCheckedException(Course course) throws SQLException {
						courseDao.create(course);
						throw new SQLException("Throwing exception for demoing rollback");
					}
				
				Let’s see a simple use of attribute noRollbackFor in the declarative approach to prevent rollback of the transaction for the listed exception:
					
					@Transactional(noRollbackFor = { SQLException.class })
					public void createCourseDeclarativeWithNoRollBack(Course course) throws SQLException {
						courseDao.create(course);
						throw new SQLException("Throwing exception for demoing rollback");
					}
				
				In the programmatic approach, we rollback the transactions using TransactionAspectSupport:
					
					public void createCourseDefaultRatingProgramatic(Course course) {
						try {
						   courseDao.create(course);
						} catch (Exception e) {
						   TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
						}
					}
				
				Spring proxy sẽ tự động rollback transaction nếu có một RuntimeException xảy ra. Bạn có thể tùy biến bằng cách sử dụng thuộc tính rollbackFor và noRollbackFor của @Transactional annotation.
				
				Chúng ta có thể phỏng đoán ý nghĩa của chúng từ tên như thuộc tính rollbackFor cho phép bạn cung cấp một mảng các Exception class mà transaction sẽ bị rollback nếu chúng xảy ra. Và noRollbackFor được
				dùng để chỉ định một mảng các Exception class mà transaction sẽ không rollback khi chúng xảy ra.
				
				Trong ví dụ sau, mình muốn rollback transaction cho tất cả các sub-class của Exception ngoại trừ EntityNotFoundException
					
					@Override
					@Transactional
							(rollbackFor = Exception.class,
									noRollbackFor = EntityNotFoundException.class)
					public void updateAuthorWithRollbackCustom(Long id, String name) {
						Author author = authorRepository.findById(id).orElse(null);
						author.setName(name);
					}

	@Query--Annotation:
								Với cách sử dụng @Query, bạn sẽ có thể sử dụng câu truy vấn JPQL (Hibernate) hoặc raw SQL.
								
								public interface UserRepository extends JpaRepository<User, Long> {
									@Query("select u from User u where u.emailAddress = ?1") // Khi được gắn @Query, thì tên của method không còn tác dụng nữa. Đây là JPQL
									User myCustomQuery(String emailAddress);
									@Query(value = "select * from User u where u.email_address = ?1", nativeQuery = true) // Đây là Native SQL
									User myCustomQuery2(String emailAddress);
								}
								
								public interface UserRepository extends JpaRepository<User, Long> {					
									@Query("SELECT u FROM User u WHERE u.status = :status and u.name = :name") // JPQL
									User findUserByNamedParams(@Param("status") Integer status, @Param("name") String name);										
									@Query(value = "SELECT * FROM Users u WHERE u.status = :status and u.name = :name", nativeQuery = true) // Native SQL
									User findUserByNamedParamsNative(@Param("status") Integer status, @Param("name") String name);
								}
		search query:
								@Query(value =
										"SELECT DISTINCT INFO.*\n" +
											", EMP1.NAME AS KOREA_PM_NAME\n" +
											", EMP1.PHOTO AS KOREA_PM_PHOTO\n" +
											", EMP2.NAME AS VIETNAM_PL_NAME\n" +
											", EMP2.PHOTO AS VIETNAM_PL_PHOTO\n" +
										"FROM \n" +
											"TB_PME00_PROJECT_INFO INFO\n" +
											"JOIN TB_M00_EMPLOYEE EMP1\n" +
												"ON EMP1.EMP_ID = INFO.KOREA_PM \n" +
											"JOIN TB_M00_EMPLOYEE EMP2\n" +
												"ON EMP2.EMP_ID = INFO.VIETNAM_PL \n" +
											"JOIN TB_M00_CODES030 CODE030\n" +
												"ON CODE030.CD_V = INFO.CD_V \n" +
											"JOIN TB_PME00_MEMBER MEMBER\n" +
												"ON INFO.CD_V = MEMBER.CD_V_ID \n" +
										"WHERE  1 = 1 \n" +
											"AND (:cdVAll = TRUE OR INFO.CD_V IN (:cdV))\n" +
											"AND (:meaning IS NULL OR (CODE030.CD_V_MEANING LIKE CONCAT('%', :meaning, '%')))\n" +
											"AND (:period IS NULL OR :period = 0 OR (INFO.PERIOD = :period))\n" +
											"AND (:koreaPM IS NULL OR ( INFO.KOREA_PM LIKE CONCAT('%', :koreaPM, '%')))\n" +
											"AND (:vietnamPL IS NULL OR (INFO.VIETNAM_PL LIKE CONCAT('%', :vietnamPL, '%')))\n" +
											"AND (:framework IS NULL OR (INFO.FRAMEWORK LIKE CONCAT('%', :framework, '%')))\n" +
											"AND (:searchAllStatus = TRUE OR INFO.STATUS IN (:searchStatus))\n" +
											"AND ((:fromStartDate IS NULL AND :toStartDate IS NULL) OR (INFO.START_DATE BETWEEN :fromStartDate AND :toStartDate))\n" +
											"AND ((:fromEndDate IS NULL AND :toEndDate IS NULL) OR (INFO.END_DATE BETWEEN :fromEndDate AND :toEndDate))" +
											"AND (:empId IS NULL OR (INFO.KOREA_PM = :empId OR INFO.VIETNAM_PL = :empId OR :empId = MEMBER.EMP_ID OR :empId = CODE030.CREATED_PROGRAM_ID))\n"
										, nativeQuery = true)
								List<Object[]> findProjectInfoWithEmpId(@Param("cdVAll") boolean cdVAll, @Param("cdV") List<String> cdV, @Param("meaning") String meaning, @Param("period") int period,
															   @Param("koreaPM") String koreaPM,  @Param("vietnamPL") String vietnamPL,
															   @Param("framework") String framework, @Param("searchAllStatus") boolean searchAllStatus,
															   @Param("searchStatus") List<String> searchStatus, @Param("fromStartDate") Date fromStartDate,
															   @Param("toStartDate") Date toStartDate, @Param("fromEndDate") Date fromEndDate,
															   @Param("toEndDate") Date toEndDate, @Param("empId") String empId, Pageable pageable);

								@Query(value = "SELECT t.PROJECT_NUMBER \n" +
										",t.TASK_NAME \n" +
										",t.CATEGORY \n" +
										",t.EMP_ID \n" +
										",t.LAST_UPDATE_ID \n" +
										",t.PASSWORD \n" +
										",t.REMARK \n" +
										",t.STATUS \n" +
										",t.TASK_EXPLAIN \n" +
										",t.WRITER \n" +
										",t.PLAN_DATE \n" +
										",t.ACTUAL_END_DATE \n" +
										",t.LAST_UPDATE_TIMESTAMP \n" +
										",t.CREATION_TIMESTAMP \n" +
										",t.START_DATE \n" +
										" FROM tb_m00_task AS t \n" +
										" WHERE 1=1 \n"+
										" AND (:projectNumber IS NULL OR t.PROJECT_NUMBER LIKE :projectNumber)\n" +
										" AND (:taskName IS NULL OR t.TASK_NAME LIKE CONCAT('%',:taskName, '%'))\n" +
										" AND (:planFrom IS NULL OR t.PLAN_DATE >= :planFrom)\n" +
										" AND (:planTo IS NULL OR t.PLAN_DATE <= :planTo)\n" +
										" AND (:actualFrom IS NULL OR t.ACTUAL_END_DATE >= :actualFrom)\n" +
										" AND (:actualTo IS NULL OR t.ACTUAL_END_DATE <= :actualTo)\n" +
										" AND (:startDateFrom IS NULL OR t.START_DATE >= :startDateFrom)\n" +
										" AND (:startDateTo IS NULL OR t.START_DATE <= :startDateTo)\n" +
										" AND (:category IS NULL OR t.CATEGORY = :category)\n" +
										" AND (:empId IS NULL OR t.EMP_ID = :empId)\n" +
										" AND (:status IS NULL OR t.STATUS = :status)\n", nativeQuery = true)
								List<M00TaskJpo> searchTask(@Param("projectNumber") String projectNumber,
															@Param("taskName") String taskName,
															@Param("planFrom") String planFrom,
															@Param("planTo") String planTo,
															@Param("actualFrom") String actualFrom,
															@Param("actualTo") String actualTo,
															@Param("startDateFrom") String startDateFrom,
															@Param("startDateTo") String startDateTo,
															@Param("status") String status,
															@Param("empId") String empId,
															@Param("category") String category);
															
		search task phân biệt giữa ON của JOIN và WHERE:	
		
									    @Query(value = "SELECT DISTINCT t.PROJECT_NUMBER \n" +
										",t.TASK_NAME \n" +
										",t.CATEGORY \n" +
										",t.EMP_ID \n" +
										",t.LAST_UPDATE_ID \n" +
										",t.PASSWORD \n" +
										",t.REMARK \n" +
										",t.STATUS \n" +
										",t.TASK_EXPLAIN \n" +
										",t.WRITER \n" +
										",t.PLAN_DATE \n" +
										",t.ACTUAL_END_DATE \n" +
										",t.LAST_UPDATE_TIMESTAMP \n" +
										",t.CREATION_TIMESTAMP \n" +
										",t.START_DATE \n" +
										",t.STATUS_APPROVE \n" +
										",t.ATTACH_FILE \n" +
										",t.ESTIMATE_DAY \n" +
										" FROM tb_m00_task AS t \n" +
										" LEFT JOIN tb_pme00_employee_task AS emp ON t.PROJECT_NUMBER = emp.PROJECT_NUMBER " + // lấy data tổng quát
										"                                        and t.TASK_NAME = emp.TASK_NAME \n"+
										" WHERE 1=1 \n"+
										" AND (COALESCE(:projectNumber) IS NULL OR t.PROJECT_NUMBER IN (:projectNumber)) \n" +
										" AND (:taskName IS NULL OR t.TASK_NAME LIKE CONCAT('%',:taskName, '%'))\n" +
										" AND (COALESCE(:category) IS NULL OR t.CATEGORY IN (:category)) \n" +
										" AND (:empId IS NULL OR emp.EMP_ID = :empId)\n" + // lấy data chi tiết

										" AND (:planFrom IS NULL OR t.PLAN_DATE >= :planFrom)\n" +
										" AND (:planTo IS NULL OR t.PLAN_DATE <= :planTo)\n" +
										" AND (:actualFrom IS NULL OR t.ACTUAL_END_DATE >= :actualFrom)\n" +
										" AND (:actualTo IS NULL OR t.ACTUAL_END_DATE <= :actualTo)\n" +
										" AND (:startDateFrom IS NULL OR t.START_DATE >= :startDateFrom)\n" +
										" AND (:startDateTo IS NULL OR t.START_DATE <= :startDateTo)\n" +

										" AND (COALESCE(:status) IS NULL OR t.STATUS IN (:status)) \n", nativeQuery = true)
								List<M00TaskJpo> findTaskByMultiConditions(@Param("projectNumber") List<String> projectNumber,
																		   @Param("taskName") String taskName,
																		   @Param("status") List<String> status,
																		   @Param("empId") String empId,
																		   @Param("category") List<String> category,
																		   @Param("planFrom") String planFrom,
																		   @Param("planTo") String planTo,
																		   @Param("actualFrom") String actualFrom,
																		   @Param("actualTo") String actualTo,
																		   @Param("startDateFrom") String startDateFrom,
																		   @Param("startDateTo") String startDateTo);

	@Id--Annotation:
								- @Id trong Spring (cụ thể là trong context của JPA - Java Persistence API) được sử dụng để đánh dấu một trường trong một lớp là khóa chính (primary key) của đối
								tượng khi được ánh xạ vào cơ sở dữ liệu.
								- Khi bạn đánh dấu một trường bằng @Id, bạn đang xác định rằng trường đó sẽ được sử dụng để định danh duy nhất cho mỗi bản ghi trong cơ sở dữ liệu.
								- Trường được đánh dấu bởi @Id là trường quan trọng để xác định mỗi bản ghi và cho phép bạn thực hiện các thao tác như tìm kiếm, cập nhật và xóa dữ liệu một cách
								chính xác.
								
								@Entity
								public class Product {
									@Id
									@GeneratedValue(strategy = GenerationType.IDENTITY)
									private Long id; // @Id được sử dụng để đánh dấu trường id trong lớp Product là khóa chính của đối tượng.
									private String name;
									private double price;
									// Constructors, getters, setters...
								}
	@IdClass--Annotation:
								- @IdClass là một annotation trong Spring được sử dụng để xác định một lớp ID tùy chỉnh cho một entity có khóa chính phức hợp (composite primary key).
								- Khi bạn có một entity với nhiều trường tạo thành khóa chính, bạn sẽ cần sử dụng @IdClass để định nghĩa một lớp ID tùy chỉnh và ánh xạ các trường của
								entity đó với các trường trong lớp ID.
								- Một số trường hợp khác khi sử dụng @IdClass:
									Quan hệ một-nhiều: Khi bạn có một entity cha chứa khóa chính phức hợp và liên kết với nhiều entity con.
									Chuyển đổi dữ liệu: Khi bạn cần chuyển đổi dữ liệu giữa các hệ thống có định nghĩa khóa chính khác nhau.
									Tích hợp dữ liệu: Khi bạn cần tích hợp dữ liệu từ nhiều nguồn có định nghĩa khóa chính khác nhau.
								- Tóm lại, @IdClass là một annotation hữu ích trong Spring khi bạn cần làm việc với các entity có khóa chính phức hợp. Nó giúp bạn định nghĩa và quản lý
								các khóa chính một cách hiệu quả.
								
								@Entity
								@Table(name = "orders")
								@IdClass(OrderId.class)
								public class Order {
									@Id
									private Long customerId;
									@Id
									private Long productId;
									private int quantity;
									// getters, setters, and other methods
								}
								public class OrderId implements Serializable {
									private Long customerId;
									private Long productId;

									// getters, setters, and hashCode/equals methods
								}
								Trong ví dụ này, customerId và productId tạo thành khóa chính phức hợp cho Order entity
								Lớp OrderId phải implement Serializable interface và cung cấp các phương thức getters, setters, hashCode() và equals() cho các trường của khóa chính.
								Sau đó, chúng ta sử dụng @IdClass(OrderId.class) để liên kết Order entity với lớp OrderId.
								Khi sử dụng @IdClass, Spring sẽ biết cách làm việc với khóa chính phức hợp của Order entity, bao gồm các hoạt động như lưu, tìm kiếm, cập nhật và xóa dữ liệu.
								
								public class AccountId implements Serializable {
									private String accountNumber;
									private String accountType;
									public AccountId(String accountNumber, String accountType) {
										this.accountNumber = accountNumber;
										this.accountType = accountType;
									}
								}									
								@Entity
								@IdClass(AccountId.class)
								public class Account {
									@Id
									private String accountNumber;
									@Id
									private String accountType;
									// other fields, getters and setters
								}
	@EmbeddedId--Annotation:
								
								- Trong JPA (Java Persistence API), @EmbeddedId là một annotation được sử dụng để chỉ định rằng một trường trong một entity class là một đối tượng nhúng
								(embedded object) đại diện cho khóa chính của entity.
								- Khi bạn có một entity class có một khóa chính được tạo ra từ một hoặc nhiều trường, và bạn muốn sử dụng một đối tượng đơn lẻ để đại diện cho các trường này,
								bạn có thể sử dụng @EmbeddedId.
								
								@Embeddable
								public class BookId implements Serializable {
									private String title;
									private String language;
									public BookId(String title, String language) {
										this.title = title;
										this.language = language;
									}
									// getters, equals() and hashCode() methods
								}								
								@Entity
								public class Book {
									@EmbeddedId
									private BookId bookId; // @EmbeddedId được sử dụng để chỉ định rằng trường bookId là một đối tượng nhúng đại diện cho khóa chính của entity Book.
									// constructors, other fields, getters and setters
								}
						
	@GeneratedValue--Annotation:
								
								- @GeneratedValue là một annotation trong JPA (Java Persistence API) được sử dụng để chỉ định cách sinh giá trị cho trường khóa chính (primary key)
								của một đối tượng khi nó được thêm vào cơ sở dữ liệu.
								
		GenerationType.IDENTITY
										- Đây là cách thông thường để sinh khóa chính cho các cơ sở dữ liệu hỗ trợ tự động tăng (auto-increment) như MySQL hoặc PostgreSQL.
										- Mỗi khi bạn thêm một bản ghi mới, giá trị của trường khóa chính sẽ tự động tăng.
										
										@Id
										@GeneratedValue(strategy = GenerationType.IDENTITY)
										private Long id;
		GenerationType.SEQUENCE
										- Sử dụng để sinh giá trị khóa chính từ một chuỗi (sequence) được quản lý bởi cơ sở dữ liệu. Một số cơ sở dữ liệu như Oracle hỗ trợ chuỗi.
										
										@Id
										@GeneratedValue(strategy = GenerationType.SEQUENCE)
										private Long id;
		GenerationType.TABLE
										- Sử dụng một bảng đặc biệt để lưu trữ các giá trị của khóa chính đã được sinh ra. Đây là cách chung chung và có thể sử dụng ở các cơ
										sở dữ liệu không hỗ trợ các loại trên.
										
										@Id
										@GeneratedValue(strategy = GenerationType.TABLE)
										private Long id;
		GenerationType.AUTO				
		
										- Cách này để cơ sở dữ liệu tự động chọn phương pháp sinh giá trị cho khóa chính dựa vào đặc điểm của cơ sở dữ liệu.
										- Nó có thể sử dụng IDENTITY, SEQUENCE hoặc bất kỳ cách nào khác được hỗ trợ.
										
										@Id
										@GeneratedValue(strategy = GenerationType.AUTO)
										private Long id;
		GenerationType.NONE				
										- Được sử dụng khi bạn muốn tạo giá trị khóa chính một cách thủ công mà không sử dụng tự động sinh giá trị.
										
										@Id
										@GeneratedValue(strategy = GenerationType.NONE)
										private Long id;
	@Column--Annotation:
								
								- @Column được sử dụng để chỉ định thông tin chi tiết của cột mà một field của entity sẽ được ánh xạ với một column trong database. Bắt buộc phải có trong sql mới có @Column, nếu không
								sẽ sinh ra lỗi.
								- Thuộc tính name được sử dụng để chỉ định tên cột nào trong database map với tên field được chú thích. Nếu không chỉ định, Hibernate sẽ lấy tên field map với
								tên cột trong database (trùng với tên trong file sql).
								- Thuộc tính length cho phép kích thước của cột. @Column không chỉ rõ phần tử length, mặc định nó là 255.
								- Thuộc tính nullable được sử dụng để chỉ định liệu cột có cho phép giá trị null hay không. Giá trị nullable mặc định là true.
								- precision và scale được sử dụng để chỉ định số chữ số toàn phần và số chữ số sau dấu thập phân của các số dấu phẩy động (floating-point).
								
								import javax.persistence.Column;
								import javax.persistence.Entity;
								import javax.persistence.Id;
								import javax.persistence.Table;
								@Entity
								@Table(name = "employees")
								public class Employee {
									@Id
									@Column(name = "employee_id", nullable = false, unique = true)
									private Long id;
									@Column(name = "full_name", length = 100, nullable = false)
									private String fullName;
									@Column(name = "email", length = 100, unique = true)
									private String email;
									@Column(name = "age", nullable = false)
									private int age;
									@Column(name = "salary", precision = 10, scale = 2)
									private double salary;
									// Getters and setters
								}
								
	@Table--Anotation:
	
								- schema trong @Table của JPA chính là tên scheme trong database
								- Trong database thì thứ tự từ lớn đến nhỏ sẽ là Database -> schema -> table -> column
								
								@Entity
								@Table(name = "users", schema = "my_database")
								public class User {
									// ...
								}
								
	@Getter và @Setter--Annotation:
								
								- @Getter và @Setter là các chú thích (annotations) của Project Lombok, một thư viện Java được sử dụng để giảm thiểu mã lặp lại và tự động sinh mã trong các lớp Java.
								- Chú thích này được sử dụng để tự động tạo các phương thức getter và setter cho các thuộc tính (fields) trong lớp, giúp bạn truy cập và thiết lập giá trị của
								thuộc tính một cách dễ dàng và an toàn mà không cần viết các phương thức getter và setter thủ công.
								
								import lombok.Getter;
								import lombok.Setter;
								@Getter
								@Setter
								public class User {
									private String username;
									private String email;
									private int age;
								}
								
								import lombok.Getter;
								import lombok.Setter;
								public class Person {
									@Getter @Setter // Tự động tạo getter và setter cho thuộc tính name
									private String name;
									@Getter @Setter // Tự động tạo getter và setter cho thuộc tính age
									private int age;
									public Person(String name, int age) {
										this.name = name;
										this.age = age;
									}
								}

	@RequestMapping--Annotation:
								
								- @RequestMapping là một annotation tổng quát được sử dụng để ánh xạ một hoặc nhiều loại request HTTP (GET, POST, PUT, DELETE, vv.) đến một phương thức xử lý trong controller.
								- Nó được sử dụng để map các request. Nó có nhiều phần tử tùy chọn như consumes, header, method, name, params, path, produces, và value.
								- Chúng tôi sử dụng nó với lớp cũng như phương thức.
								- Có nhiệm vụ ánh xạ các request (yêu cầu) người dùng vào method tương ứng trong controller.									
								
								@Controller
								public class MyController {										
									@RequestMapping(value = "/hello", method = RequestMethod.GET) // Ánh xạ các request GET đến đường dẫn "/hello"
									@ResponseBody
									public String hello() {
										return "Hello World!";
									}										
									@RequestMapping(value = "/hello", method = RequestMethod.POST) // Ánh xạ các request POST đến đường dẫn "/hello"
									@ResponseBody
									public String helloPost() {
										return "Hello World (POST)!";
									}										
									@RequestMapping(value = "/bye", method = RequestMethod.GET) // Ánh xạ các request GET đến đường dẫn "/bye"
									@ResponseBody
									public String bye() {
										return "Goodbye!";
									}
								}
								
								@RequestMapping(value = "/method2", method = RequestMethod.POST)
								public String method2() {
									return "method2";
								}
								@RequestMapping(value = "/method3", method = {RequestMethod.POST, RequestMethod.GET})
								public String method3() {
									return "method3";
								}
	@GetMapping--Annotation:
								
								- Nó là một biến thể của @RequestMapping với method được thiết lập là GET.
								- Nó dùng để tạo một điểm cuối trong web service, và nó được sử dụng thay cho @RequestMapping(method = RequestMethod.GET).

	
								import org.springframework.web.bind.annotation.GetMapping;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {
									@GetMapping("/hello")
									public String hello() {
										return "Hello, world!";
									}
								}
	@PostMapping--Annotation:
								- Sử dụng khi gửi data tới server để tạo ra tài nguyên mới. Thay cho @RequestMapping(method = RequestMethod.POST).
								
								import org.springframework.web.bind.annotation.PostMapping;
								import org.springframework.web.bind.annotation.RequestBody;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {
									@PostMapping("/submit")
									public String submitForm(@RequestBody String formData) {
										// Xử lý dữ liệu được gửi từ form
										return "Form submitted: " + formData;
									}
								}
	@PutMapping--Annotation:
								
								- Sử dụng để thay đổi thông tin của một tài nguyên đã tồn tại trong hệ thống bằng cách sử dụng nội dung trong body của request.
								- Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.PUT).
								
								import org.springframework.web.bind.annotation.PutMapping;
								import org.springframework.web.bind.annotation.RequestBody;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {										
									@PutMapping("/update") // Sử dụng @PutMapping để xác định phương thức xử lý yêu cầu PUT đến "/update"
									public String updateData(@RequestBody String updatedData) {
										// Xử lý dữ liệu cập nhật được gửi từ yêu cầu PUT
										return "Data updated: " + updatedData;
									}
								}
								
	@DeleteMapping--Annotation:
								
								- Sử dụng để xóa một resource chỉ định. Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.DELETE).
								
								import org.springframework.web.bind.annotation.DeleteMapping;
								import org.springframework.web.bind.annotation.PathVariable;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {										
									@DeleteMapping("/delete/{id}") // Sử dụng @DeleteMapping để xác định phương thức xử lý yêu cầu DELETE đến "/delete/{id}"
									public String deleteItem(@PathVariable int id) {
										// Xử lý yêu cầu xóa với ID được cung cấp
										return "Item with ID " + id + " has been deleted.";
									}
								}
	@RequestParam--Annotation:
									
									- Chúng ta sử dụng @RequestParam để bắt các giá trị tham số mà người dùng truyền vào trên url theo định dạng key và value.
									- Mặc định, các tham số được bắt bởi @RequestParam không bắt buộc phải có giá trị, nếu không có giá trị nào được cung cấp, thì giá trị mặc định sẽ là null.
									- Thường được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP methods như GET và POST.
		
		- Gửi dữ liệu dưới dạng query parameters:	
		
														https://example.com/api/endpoint?param1=value1&param2=value2
		
		- Gửi dữ liệu dưới dạng form data:
		
														POST /api/endpoint HTTP/1.1
														Host: example.com
														Content-Type: application/x-www-form-urlencoded
														param1=value1&param2=value2
		
		Ví dụ:				
		
														const name = formData.get('name');
														const age = formData.get('age');
														axios.post('/api/example', {
															params: {
																name: name,
																age: age
															}
														})
														.then(function(response) {
															console.log(response.data);
														})
														.catch(function(error) {
															console.error(error);
														});
														
														@RestController
														@RequestMapping("/api")
														public class ExampleController {
															@GetMapping("/example")
															public String handleGetRequest(
																@RequestParam String name,
																@RequestParam int age
															) {
																return "GET request: Name=" + name + ", Age=" + age;
															}
															@PostMapping("/example")
															public String handlePostRequest(
																@RequestParam String name,
																@RequestParam int age
															) {
																return "POST request: Name=" + name + ", Age=" + age;
															}
														}
														
														@PostMapping("/search-include-task")
														@PreAuthorize("hasAnyAuthority('GET_PROJECT,GET_PROJECT_OWNER')")
														public Map<String, Object> findProjectListWithTask(@RequestBody ProjectManagementDto dto,
																										   @RequestParam(required = false, defaultValue = "0", name = "pageNo") int pageNo,
																										   @RequestParam(required = false, defaultValue = "20", name = "pageSize") int pageSize) {
															PosLogger.developerLog(PosLogWriterIF.INFO, "Project -> " + dto, this);
															if (Utils.checkPermission("GET_PROJECT_OWNER")) {
																String id = Utils.getLoginUserDetail();
																if (id != null) {
																	return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, id, pageNo, pageSize);
																}
															}
															return this.serviceLifecycle.requestLevel2ProjectService().getProjectListWithTask(serviceLifecycle, dto, null, pageNo, pageSize);
														}
														
														@PostMapping(path = "/upload/{service}")
														public String uploadFile(@PathVariable("service") String serviceName,
																				 @RequestParam ("file") MultipartFile image) {
															return this.serviceLifecycle.requestLevel2Service().uploadFile(Utils.UPLOAD_BUCKET, serviceName, image);
														}
																
			- Gửi URL dưới dạng List<String>				
														
														http://localhost:9720/project/monitoring-view?projectName=ISP&projectName=TL
	
	@RequestBody--Annotation:
	
								- Có thể được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP methods như POST, PUT, PATCH và DELETE.
								- Nó được sử dụng để liên kết yêu cầu HTTP với một đối tượng trong một tham số phương thức. Bên trong nó sử dụng HTTP MessageConverters để chuyển đổi phần thân của
								yêu cầu. Khi chúng tôi chú thích một tham số phương thức với @RequestBody, Spring sẽ liên kết phần body yêu cầu HTTP đến với tham số đó.
								- Được sử dụng để lấy các giá trị mà người dùng gửi lên server mà các giá trị đó được chứa trong phần thân (body) của request.
								
								const user = {
								  name: 'John',
								  age: 30
								};
								axios.post('/example', user)
								  .then(response => {
									console.log(response.data);
								  })
								  .catch(error => {
									console.error(error);
								  });
								
								import org.springframework.web.bind.annotation.PostMapping;
								import org.springframework.web.bind.annotation.RequestBody;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {
									@PostMapping("/example")
									public String exampleEndpoint(@RequestBody User user) {
										return "Received user: " + user.getName();
									}
								}
	
	@PathVariable--Annotation:
	
								- @PathVariable được sử dụng để xử lý những URI động, có một hoặc nhiều parameter trên URI.
								- @PathVariable thường được sử dụng trong các phương thức của các controller được ánh xạ với các HTTP GET, POST, PUT, DELETE và PATCH.
								
								@RequestMapping("/test2/{id}/{name}")
								public String test2(@PathVariable("id") int id, @PathVariable("name") String name, Model model) {
								  model.addAttribute("id", id);
								  model.addAttribute("name", name);
								  return "test2";
								}
								
	@RequestHeader--Annotation:
								
								- @RequestHeader được sử dụng khi ta muốn lấy dữ liệu được truyền bằng Header của một request (yêu cầu từ client)
								
								@GetMapping("/double")
								public ResponseEntity<String> doubleNumber(@RequestHeader("my-number") int myNumber) {
									return new ResponseEntity<String>(String.format("%d * 2 = %d", myNumber, (myNumber * 2)), HttpStatus.OK);
								}
								
	@ResponseHeader--Annotation:
	
								- Chúng ta sử dụng @ResponseHeader khi mình muốn trả về thêm dữ liệu cho client ở phần trên cùng của mỗi response
								
								public String addUser(@Valid User user, BindingResult bindingResult,HttpServletRequest request,HttpServletResponse response)
								{
								  if(bindingResult.hasErrors())
								  {
									bindingResult.getFieldError();
									return"edit";
								  }
								  response.setHeader("Cache-Control","no-cache,no-store,must-revalidate");
								  response.setHeader("Pragma","no-cache"); // ta trả thêm các giá trị ở trên phần header cho client thông qua phương thức response.setHeader
								  response.setDateHeader("Expires", 0);
								  return "redirect:/welcome/profile/"+user.getName();
								}
	@RestController--Annotation:
	
								- @RestController là một composed annotation được kết từ annotation @Controller và @ResponseBody, khi đặt một annotation @RestController trên một class controller
								thì mọi method controller trong class đó sẽ được thừa hưởng annotation @ResponseBody và response data trong controller này sẽ được trả về dưới dạng message.
								
								import org.springframework.web.bind.annotation.GetMapping;
								import org.springframework.web.bind.annotation.RequestAttribute;
								import org.springframework.web.bind.annotation.RestController;
								import javax.servlet.http.HttpServletRequest;
								@RestController
								public class ExampleRestController {
									@GetMapping("/example")
									public String exampleHandler(HttpServletRequest request, @RequestAttribute("userId") Long userId) {											
										String attributeValue = (String) request.getAttribute("exampleAttribute"); // Truy cập thuộc tính của yêu cầu đã được đặt trong phạm vi Servlet											
										return "{\"userId\": " + userId + ", \"exampleAttribute\": \"" + attributeValue + "\"}"; // Trả về dữ liệu dưới dạng chuỗi JSON
									}
								}
	@PreDetroy và @PostConstruct--Annotation:
									
									- Đây là cách dùng khác để quản lý vòng đời của Bean. Ngoài cách sử dụng initMethod và destroyMethod.
									- Ta có thể sử dụng @PreDetroy và @PostConstruct với cùng một mục đích
									
									public class Computer {
										@PostConstruct
										public void turnOn(){
											System.out.println("Load operating system");
										}
										@PreDestroy
										public void turnOff(){
											System.out.println("Close all programs");
										}
									}
									
	@PropertySource và @Value--Annotation:
									
									- Trong Spring chúng ta sử dụng @PropertySource để cho Spring biết tìm các file properties cấu hình cho hệ thống ở đâu đồng thời sử dụng
									- @Value để lấy các giá trị trong file properties
									- @Value là một annotation trong Spring Framework, được sử dụng để tiêm các giá trị cấu hình vào các trường, phương thức hoặc tham số của một bean.
									- Ngoài việc sử dụng với các trường, @Value cũng có thể được sử dụng với các phương thức và tham số của constructor hoặc setter
		
		Ví dụ 1:
		
									import org.springframework.beans.factory.annotation.Value;
									import org.springframework.stereotype.Component;
									@Component
									public class MyService {
										@Value("${app.name}")
										private String appName;
										@Value("${app.version}")
										private String appVersion;

										publi void printAppInfo() {
											System.out.println("Application Name: " + appName);
											System.out.println("Application Version: " + appVersion);
										}
									}										
									@Value("${app.name}") sẽ lấy giá trị của app.name từ các tệp cấu hình (ví dụ: application.properties hoặc application.yml) và gán nó vào trường appName.
									@Value("${app.version}") sẽ lấy giá trị của app.version từ các tệp cấu hình và gán nó vào trường appVersion.
									
									# application.properties
									app.name=My Application
									app.version=1.0.0
									
									# application.yml
									app:
									  name: My Application
									  version: 1.0.0
		
		Ví dụ 2:
		
									import org.springframework.beans.factory.annotation.Value;
									import org.springframework.stereotype.Component;
									@Component
									public class MyService {
										private String appName;
										private String appVersion;
										public MyService(@Value("${app.name}") String appName, @Value("${app.version}") String appVersion) {
											this.appName = appName;
											this.appVersion = appVersion;
										}
										public void printAppInfo() {
											System.out.println("Application Name: " + appName);
											System.out.println("Application Version: " + appVersion);
										}
									}			
		
		Ví dụ 3:
		
									import org.springframework.beans.factory.annotation.Value;
									import org.springframework.stereotype.Component;										
									@Component
									public class AppConfig {
									    @Value("${app.name}")
									    private String appName;
									
									    @Value("${app.version}")
									    private String appVersion;
									
									    public void printAppInfo() {
									        System.out.println("Application Name: " + appName);
									        System.out.println("Application Version: " + appVersion);
									    }
									}
									app.name=MyApp
									app.version=1.0.0
									
									@Configuration
									@ComponentScan(basePackages = { "levunguyen.*" })
									@PropertySource("classpath:config.properties")
									public class AppConfigMongoDB {
										@Value("${mongodb.url}")
										private String mongodbUrl;
										@Value("${mongodb.db}")
										private String defaultDb;
									}
	@Scope--Annotation:
									- Khi bean được tạo ra thì nó có nhiều scope khác nhau. @Scope ở đây là phạm vi bean được sinh và bị phá huỷ dưới sự quản lý của Spring Container.
									- Khi bean được sinh ra nó có 5 scope (phạm vi được sử dụng):
										singleton: Đây là scope mặc định của 1 bean khi được sinh ra. Nếu ta không khai báo scope cụ thể thì bean sẽ lấy singleton scope. Singleton bean có nghĩa là bean
										chỉ tạo ra 1 lần và được sử dụng trong container. Chỉ duy nhất 1 bean tồn tại trong container.
										prototype: Ngược lại với singleton ta muốn có nhiều bean (đối tượng) thì ta sử dụng scope prototype.
										Request: Bean được sinh ra thông qua các request http (yêu cầu) từ người dùng. Chỉ được dùng trong các ứng dụng web.
										Session: Bean được sinh ra thông qua các http session.
										Global-session: Bean được sinh ra thông qua các request http (yêu cầu) từ người dùng. Chỉ được dùng trong các ứng dụng web.
									
									@Component
									@Scope("request")
									public class Contact {
										...
									}
	@Valid--Annotation:
									
									- Dùng để kiểm tra dữ liệu có đúng như mình mong muốn hay không. Ví dụ dưới đây mình mong muốn name là không được rỗng , author không được rỗng.
									- Nếu dữ liệu bị rỗng thì @Validated sẽ bắt lỗi.
									
									public class UserDTO {
										@NotBlank(message = "Username is required")
										private String username;
										@Email(message = "Invalid email")
										private String email;
										// Getters and setters
									}
									
									import org.springframework.validation.annotation.Validated;
									import org.springframework.web.bind.annotation.*;
									import javax.validation.Valid;

									@RestController
									@RequestMapping("/api/users")
									@Validated // @Validated được đặt trên class UserController để kích hoạt validation.
									public class UserController {
										@PostMapping("/register")
										public String registerUser(@Valid @RequestBody UserDTO userDTO) {
											// Xử lý đăng ký người dùng
											return "User registered successfully!";
										}
									}
	@ResponseBody--Annotation:
									
									- Chúng ta sử dụng @ResponseBody để nói cho controller biết rằng ta sẽ trả về một đối tượng Object kiểu Json cho client chứ mình không render ra một trang view.
									
									@RequestMapping(path = "/something", method = RequestMethod.PUT)
									public  @ResponseBody String helloWorld() {
										return "Hello World";
									}
									
	@Qualifier--Annotation:
									- Chú thích này được sử dụng cùng với chú thích @Autowired. Khi bạn cần kiểm soát nhiều hơn quá trình tiêm phụ thuộc, @Qualifier có thể được sử dụng.
									- @Qualifier có thể được chỉ định trên các tham số phương thức hoặc đối số phương thức khởi tạo riêng lẻ.
									- Chú thích này được sử dụng để tránh nhầm lẫn xảy ra khi bạn tạo nhiều bean cùng loại và chỉ muốn nối một trong số chúng với một thuộc tính.
									
									public interface Animal {
										void makeSound();
									}
									import org.springframework.stereotype.Component;
									@Component
									@Qualifier("dog")
									public class Dog implements Animal {
										@Override
										public void makeSound() {
											System.out.println("Woof");
										}
									}
									import org.springframework.stereotype.Component;
									@Component
									@Qualifier("cat")
									public class Cat implements Animal {
										@Override
										public void makeSound() {
											System.out.println("Meow");
										}
									}
									import org.springframework.beans.factory.annotation.Autowired;
									import org.springframework.beans.factory.annotation.Qualifier;
									import org.springframework.stereotype.Service;
									@Service
									public class AnimalService {
										private final Animal animal;
										@Autowired
										public AnimalService(@Qualifier("dog") Animal animal) {
											this.animal = animal;
										}
										public void makeAnimalSound() {
											animal.makeSound();
										}
									}
									import org.springframework.boot.CommandLineRunner;
									import org.springframework.boot.SpringApplication;
									import org.springframework.boot.autoconfigure.SpringBootApplication;
									import org.springframework.context.annotation.Bean;
									@SpringBootApplication
									public class Application {
										public static void main(String[] args) {
											SpringApplication.run(Application.class, args);
										}
										@Bean
										public CommandLineRunner commandLineRunner(AnimalService animalService) {
											return args -> {
												animalService.makeAnimalSound();
											};
										}
									}
									
									@Component
									public class AnimalService {
										private final Animal animal;
										@Autowired
										public AnimalService(@Qualifier("dog") Animal animal) {
											this.animal = animal;
										}
										public void makeSound() {
											animal.makeSound();
										}
									}
									
									@Component
									public class BeanA {
									  @Autowired
									  @Qualifier("BeanB2")
									  private BeanInterface dependency;
									  ...
									}
									
	@Lazy--Annotation:
									
									- Chú thích này được sử dụng trên các lớp thành phần. Theo mặc định, tất cả các phụ thuộc tự động mong muốn được tạo và định cấu hình khi khởi động.
									- Nhưng nếu bạn muốn khởi tạo bean một cách lười biếng, bạn có thể sử dụng chú thích @Lazy trên lớp. Điều này có nghĩa là bean sẽ chỉ được tạo và khởi tạo khi
									nó được yêu cầu lần đầu tiên. Bạn cũng có thể sử dụng chú thích này trên các lớp @Configuration. Điều này chỉ ra rằng tất cả các phương thức @Bean
									trong @Configuration đó phải được khởi tạo một cách lười biếng.
									
									@Component
									@Lazy
									public class HeavyResource {
										public HeavyResource() {
											// Thực hiện việc khởi tạo có thể tốn kém
											System.out.println("HeavyResource initialized.");
										}
										public void doSomething() {
											System.out.println("HeavyResource: Doing something.");
										}
									}
									
	@CookieValue--Annotation:
									
									- Chú thích này được sử dụng ở cấp tham số phương thức. @CookieValue được sử dụng làm đối số của phương thức ánh xạ yêu cầu.
									Cookie HTTP được liên kết với tham số @CookieValue cho một tên cookie nhất định. Chú thích này được sử dụng trong phương thức được chú thích bằng @RequestMapping.
									
									@RequestMapping("/cookieValue")
									public void getCookieValue(@CookieValue "JSESSIONID" String cookie){
										...
									}
	@ConfigurationProperties--Annotation:
	
											- Chỉ định lớp sẽ được map với các properties có prefix, ví dụ @ConfigurationProperties(prefix="app")
											
											app.name=MyApp
											app.description=This is my application
											app.version=1.0
											
											import org.springframework.boot.context.properties.ConfigurationProperties;
											import org.springframework.stereotype.Component;
											@Component
											@ConfigurationProperties("app")
											public class AppProperties {

												private String name;
												private String description;
												private String version;

												// Getters and Setters
											}
									
	@ModelAttribute--Annotation:
	
									- Chúng ta sử dụng ModelAttribute như một cầu nối giữa Controller và View. Từ Controller chúng ta truyền các dữ liệu qua cho View thông qua ModelAttribute.
									- Từ View chúng ta sẽ sử dụng Thymeleaf để đọc các dữ liệu từ model và hiển thị ra cho người dùng
									
									<form:form method="POST" action="/spring-mvc-basics/addEmployee" modelAttribute="employee">
										<form:label path="name">Name</form:label>
										<form:input path="name" />
										<form:label path="id">Id</form:label>
										<form:input path="id" />
										<input type="submit" value="Submit" />
									</form:form>
									
									@RequestMapping(value = "/addEmployee", method = RequestMethod.POST)
									public String submit( @ModelAttribute("employee") Employee employee) {
										model.addAttribute("name", employee.getName());
										model.addAttribute("id", employee.getId());
										employeeMap.put(employee.getId(), employee);
										return "employeeView";
									}
									
	@SessionAttribute--Annotation:
	
									- Chúng ta sử dụng @SessionAttribute để lưu trữ các giá trị trong một phiên làm việc.
									- Giống như mình làm một ứng dụng shopping cart . Khi người dùng chọn 1 sản phẩm thì mình dùng session mình lưu lại.
									- Khi khách hàng thanh toán giỏ hàng thì mình lấy hết tất cả các mặt hàng chứa trong session ra và tính toán
									
									@Controller
									@SessionAttributes("shoppingCart")
									public class AddToCartController {
										@PostMapping("/addToCart")
										public String addToCart(final Model model, @ModelAttribute ShoppingCart shoppingCart, final String productCode) {
											if (shoppingCart != null) {
											 //add product to the shopping cart list
											 shoppingCart.setProduct(productCode);
											 model.addAttribute("cart", shoppingCart);
											} else {
											 ShoppingCart cart = new ShoppingCart();
											 cart.setCustomerName("Super customer");
											 cart.setProduct(productCode);
											 model.addAttribute("cart", cart);
											}
											return "redirect:" + "product-detail-page";
										}
										@ModelAttribute("shoppingCart")
										public ShoppingCart shoppingCart() {
											return new ShoppingCart();
										}
									}									
							
	@Bean--Annotation:
								
								- Tạo bean một phần nữa là muốn tạo 1 đối tượng để sử dụng chung, tạo hay update 1 chỗ thì các chỗ khác cùng bị ảnh hưởng
								- @Bean dùng cho phương thức để hoàn lại đối tượng bean, phạm vi là phương thức
								- Khi bạn nói về "tiêm bean" trong Spring, bạn đang nói về việc cung cấp các đối tượng (beans) cho các thành phần khác của ứng dụng thông qua DI.
								- Nó là một annotation cho method. Nó là sự thay thế của thẻ XML <bean>. Nó cho biết method tạo ra một bean được Spring Container quản lý.
								- Chú thích @Bean hoạt động với @Configuration để tạo Spring bean, @Configuration sẽ có các phương thức để khởi tạo và cấu hình các phần phụ thuộc.
								- Các phương thức như vậy sẽ được chú thích bằng @Bean. Phương thức được chú thích với chú thích này hoạt động như là bean ID và nó tạo và trả về bean thực.
								- Tất cả các Method sử dụng annotation @Bean phải nằm trong class Configuration.
								
								@Configuration
								public class AppConfig{
								  @Bean
								  public Person person(){
									return new Person(address());
								  }
								  @Bean
								  public Address address(){
									return new Address();
								  }
								}
								
	@Configuration--Annotation:
	
								- Được sử dụng để chỉ ra rằng class khai báo sử dụng annotation @Configuration sẽ khai báo một hoặc nhiều @Bean method trong class đó.
								- Những class khai báo với @Configuration sẽ được Spring container quản lý và tạo bean trong lúc chương trình đang chạy.
								- Thông thường các bean cấu hình cho dự án ta để trong này.
								
								@Configuration  
								public class Vehicle   {  
								  @Bean Vehicle engine()  {  
									return new Vehicle();  
								  }  
								}
								
	@Component--Annotation:
	
								- Khi một class được đánh dấu là @Component thì sẽ được tạo thành 1 bean. Khi Spring start thì nó quét qua các annotation có đánh dấu là @Component thì nó sẽ tạo bean cho class đó.
								- Dùng để tạo đối tượng bean phạm vi class
								- Ví dụ ta có class Contact và ta đánh dấu nó là @Component thì Spring khi đọc qua class này nó sẽ tạo 1 bean có tên là contact trong container của nó.
								- Nếu có class nào dùng thì nó sẽ nhúng bean này vào. Dùng @component là để tạo ra một bean
								- Sẽ không thể @Autowired một lớp nếu lớp đó không sử dụng @Component, @Service, @Controller hoặc @Repository  
								
								import org.springframework.stereotype.Component;
								@Component
								public class HelloWorldService {
									public String getGreeting() {
										return "Hello, World!";
									}
								}
								import org.springframework.beans.factory.annotation.Autowired;
								import org.springframework.stereotype.Controller;
								import org.springframework.web.bind.annotation.GetMapping;
								import org.springframework.web.bind.annotation.ResponseBody;
								@Controller
								public class GreetingController {
									private final HelloWorldService helloWorldService;
									@Autowired
									public GreetingController(HelloWorldService helloWorldService) {
										this.helloWorldService = helloWorldService;
									}
									@GetMapping("/greet")
									@ResponseBody
									public String greet() {
										return helloWorldService.getGreeting();
									}
								}

	@Controller--Annotation:
	
								- Là một chuyên môn hóa của @Component.
								- Là một annotation ở class. Nó đánh dấu class là một class để xử lý request web.
								- Nó thường được sử dụng để phục vụ các request từ UI. Mặc định thì nó trả về một chuỗi cho biết route nào cần redirect.
								- Nó chủ yếu được sử dụng với annotation @RequestMapping.
								
								@Controller  
								@RequestMapping("books")  
								public class BooksController   {  
								  @RequestMapping(value = "/{name}", method = RequestMethod.GET)  
								  public Employee getBooksByName()   {  
									return booksTemplate;  
								  }  
								}
								
								@Controller
								public class HomeController {
									@RequestMapping("/")
									public String homePage() {
										return "home";
									}
								}
								
	@Service--Annotation:
	
								- Nếu một class được đánh dấu là @Service thì nó là kiểu đặt biệt của @Component.
								- Nó được dùng để xử lý các nghiệp vụ của ứng dụng.									
								- Thường được sử dụng ở class. Nó cho Spring biết rằng class này chứa business logic.
								- Ví dụ như kế toán thì có nghiệp vụ là kiểm tra chi, quản lý thu.
								
								package com.hdd;  
								@Service  
								public class TestService  {  
								  public void service1()  {  
									  //business code  
								  }  
								}
								
	@Repository--Annotation:
								- Nếu một class được đánh dấu là @Repository thì nó là kiểu đặt biệt của @Component .
								- Nó được sử dụng để nói bean này dùng để truy cập và thao tác xuống cơ sở dữ liệu.
								- Chú thích này có tính năng dịch tự động. Ví dụ: khi một ngoại lệ xảy ra trong @Repository, có một trình xử lý cho ngoại lệ đó và không cần thêm khối try catch.
								
								package com.hdd;  
								@Repository   
								public class TestRepository  {  
								  public void delete()  {     
									//persistence code  
								  }  
								}
	@ComponentScan--Annotation:
	
								- Là annotation khai báo ở cấp độ class, giống như cái tên của nó, annotation @ComponentScan dùng để scan toàn bộ bean trong ứng dụng, mặc định nó sẽ scan tất cả
								bean trong package ở vị trí đặt class chứa hàm main, ngoài ra chúng ta cũng có thể tùy chỉnh package cần scan
								- Chúng ta sử dụng @ComponentScan để thông báo Spring Container biết phải vào package nào trong dự án để quét các Annotation và tạo Bean
								- Khi bạn sử dụng @ComponentScan trong một class, Spring sẽ tự động phát hiện và đăng ký các bean (component) được đánh dấu bằng các annotation như @Component, @Service,
								@Repository, @Controller, và @Configuration.
								- Một số lưu ý về @ComponentScan:
									Phạm vi quét: Bạn có thể chỉ định các package cụ thể cần được quét bằng cách sử dụng basePackages hoặc basePackageClasses.
									Loại trừ một số package: Bạn cũng có thể loại trừ một số package khỏi quá trình quét bằng cách sử dụng excludeFilters.
									Sử dụng với @SpringBootApplication: Trong Spring Boot, @SpringBootApplication đã bao gồm @ComponentScan, vì vậy bạn thường không cần
									phải sử dụng @ComponentScan một cách riêng biệt.
								
								import org.springframework.boot.SpringApplication;
								import org.springframework.boot.autoconfigure.SpringBootApplication;
								import org.springframework.context.annotation.ComponentScan;
								@SpringBootApplication
								@ComponentScan(basePackages = {"com.example.myapp"})
								public class MyAppApplication {
									public static void main(String[] args) {
										SpringApplication.run(MyAppApplication.class, args);
									}
								}
								@SpringBootApplication là một annotation phổ biến trong Spring Boot, được sử dụng để kích hoạt tất cả các tính năng cấu hình và tự động cấu hình.
								@ComponentScan(basePackages = {"com.example.myapp"}) chỉ định rằng Spring nên quét và tìm kiếm các component, service, repository,
								controller, v.v... trong package com.example.myapp và các package con của nó.
								
								@ComponentScan(basePackages = "com.javatpoint")  
								@Configuration
								public class ScanComponent  {  
								  // ...  
								}
								
		Các param trong @ComponentScan:
		
											basePackages:		dùng để chỉ ra những package cần scan, bạn có thể truyền vào một hoặc nhiều package name
											basePackageClasses:	chỉ ra những class cần scan
											excludeFilters:		dùng để filter loại trừ những bean or package không cần scan
											includeFilters: 	dùng dể filter những bean or package cần scan.
											lazyInit: 			dùng để lazy load bean, default = false
											resourcePattern: 	chỉ ra các pattern file để Spring có thể scan, default pattern "**/*.class"
											
	@EnableAutoConfiguration--Annotation:
	
											- Annotation @EnableAutoConfiguration trong Spring Boot là một trong những annotation quan trọng nhất, được sử dụng để kích hoạt tính
											năng auto-configuration của Spring Boot.
											- Khi sử dụng @EnableAutoConfiguration trong một ứng dụng Spring Boot, Spring Boot sẽ tự động cấu hình các bean cần thiết dựa trên các
											dependencies có sẵn trong classpath của ứng dụng. Điều này giúp giảm đáng kể lượng cấu hình mà nhà phát triển phải viết.
											- Ví dụ, nếu trong classpath của ứng dụng có thư viện spring-boot-starter-web, Spring Boot sẽ tự động cấu hình các bean cần thiết như DispatcherServlet,
											HandlerMapping, ViewResolver, v.v. để tạo ra một ứng dụng web hoàn chỉnh.
											- Nó tự động cấu hình bean có trong classpath và cấu hình nó để chạy các phương thức.
											- Việc sử dụng chú thích này bị giảm trong bản phát hành Spring Boot 1.2.0 vì các nhà phát triển đã cung cấp một giải pháp thay thế cho chú thích,
											tức là @SpringBootApplication.
											- Ngoài ra, @EnableAutoConfiguration còn có một số tùy chọn như:
												exclude = {...}: Loại trừ một hoặc nhiều auto-configuration classes.
												excludeName = {...}: Loại trừ các auto-configuration classes dựa trên tên.
											- Annotation @EnableAutoConfiguration là một phần quan trọng của Spring Boot, giúp đơn giản hóa quá trình cấu hình ứng dụng và tập trung vào việc phát triển các
											tính năng chính thay vì việc cài đặt các cấu hình hệ thống.
											
											@SpringBootApplication
											@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
											public class MyApplication {
												// ...
											}
											Trong ví dụ trên, auto-configuration cho DataSource sẽ bị loại trừ, giúp ngăn chặn Spring Boot tự động cấu hình DataSource nếu không mong muốn.
											
											@RestController
											@EnableAutoConfiguration
											public class ExampleController {
												@GetMapping("/")
												String home() {
													return "Hello World!";
												}
												public static void main(String[] args) {
													SpringApplication.run(ExampleController.class, args);
												}
											}
											
	@SpringBootApplication--Annotation:
	
											- Nó là sự kết hợp của ba chú thích @EnableAutoConfiguration, @ComponentScan và @Configuration.
											- Chú thích này được sử dụng trên lớp ứng dụng trong khi thiết lập một dự án Spring Boot. Lớp được chú thích bằng @SpringBootApplication phải được
											giữ trong gói cơ sở.
											- Một thứ mà @SpringBootApplication thực hiện là quét thành phần. Nhưng nó sẽ chỉ quét các gói con của nó. Ví dụ: nếu bạn đặt lớp được chú thích bằng
											@SpringBootApplication trong com.example thì @SpringBootApplication sẽ quét tất cả các gói con của nó, chẳng hạn như com.example.a, com.example.b và
											com.example.a.x.
											
											import org.springframework.boot.SpringApplication;
											import org.springframework.boot.autoconfigure.SpringBootApplication;
											import org.springframework.web.bind.annotation.GetMapping;
											import org.springframework.web.bind.annotation.RestController;
											@SpringBootApplication
											public class ExampleApplication {
												public static void main(String[] args) {
													SpringApplication.run(ExampleApplication.class, args);
												}
											}
											@RestController
											class ExampleController {
												@GetMapping("/")
												String home() {
													return "Hello World!";
												}
											}
											
	@Required--Annotation:  
								
								- Nó áp dụng cho method bean setter. Nó chỉ ra rằng bean được chú thích phải được điền vào thời điểm cấu hình với thuộc tính bắt buộc,
								nếu không nó sẽ ném một ngoại lệ BeanInitizationException.
								- Trong Spring Framework, annotation @Required được sử dụng để đánh dấu một thuộc tính của bean là bắt buộc phải được cấu hình trong tệp cấu hình (configuration file). Khi một bean được
								khởi tạo và nếu một thuộc tính được đánh dấu bằng @Required mà không có giá trị nào được cung cấp cho nó, Spring Container sẽ ném ra một ngoại lệ BeanInitializationException, báo cho
								bạn biết rằng thuộc tính đó là bắt buộc và cần phải được cung cấp.
								- Điều này hữu ích khi bạn muốn đảm bảo rằng một số thuộc tính quan trọng của bean đã được thiết lập trước khi sử dụng nó. Bằng cách này, nó giúp tránh được những lỗi logic hoặc giúp
								phát hiện sớm những thiếu sót trong cấu hình của ứng dụng Spring của bạn.
							
								import org.springframework.beans.factory.annotation.Required;
								public class Person {
									private String name;
									@Required
									public void setName(String name) {
										this.name = name;
									}
									public String getName() {
										return name;
									}
								}
								import org.springframework.context.ApplicationContext;
								import org.springframework.context.support.ClassPathXmlApplicationContext;
								public class Main {
									public static void main(String[] args) {
										ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
										Person person = (Person) context.getBean("person");
										System.out.println("Name: " + person.getName());
									}
								}
								Kết quả là: Name: John Doe		
								
								import org.springframework.beans.factory.annotation.Required;
								public class Employee {
									private String empName;
									@Required
									public void setEmpName(String empName) {
										this.empName = empName;
									}
									public String getEmpName() {
										return empName;
									}
								}
								Trong ví dụ này, thuộc tính empName được đánh dấu bằng @Required, điều này đảm bảo rằng mỗi khi một bean Employee được khởi tạo, phải cung cấp giá trị cho empName. Nếu không, Spring sẽ
								ném ra một ngoại lệ khi khởi tạo bean.
								
								public class Machine   {  
								  private Integer cost;  
								  @Required  
								  public void setCost(Integer cost)   {  
									this.cost = cost;  
								  }  
								  public Integer getCost()   {  
									return cost;  
								  }     
								}
								
	@PatchMapping--Annotation:
								
								Sử dụng để áp dụng sửa đổi 1 phần cho resource. Nó được sử dụng thay vì sử dụng: @RequestMapping (method = RequestMethod.PATCH)
								
								import org.springframework.web.bind.annotation.PatchMapping;
								import org.springframework.web.bind.annotation.RequestBody;
								import org.springframework.web.bind.annotation.RestController;
								@RestController
								public class ExampleController {										
									@PatchMapping("/update") // Sử dụng @PatchMapping để xác định phương thức xử lý yêu cầu PATCH đến "/update"
									public String updateData(@RequestBody String updatedData) {
										// Xử lý dữ liệu cập nhật được gửi từ yêu cầu PATCH
										return "Data updated: " + updatedData;
									}
								}
								
	@RequestAttribute--Annotation:
									
									- Nó liên kết một tham số phương thức với thuộc tính yêu cầu. Nó cung cấp quyền truy cập thuận tiện vào các thuộc tính yêu cầu từ một phương thức bộ điều khiển.
									- Với sự trợ giúp của chú thích @RequestAttribute, chúng tôi có thể truy cập các đối tượng được điền ở phía máy chủ.
								
									import javax.servlet.*;
									import javax.servlet.http.HttpServletRequest;
									import java.io.IOException;
									public class MyFilter implements Filter {
										@Override
										public void init(FilterConfig filterConfig) throws ServletException {
											// initialization code
										}
										@Override
										public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
												throws IOException, ServletException {
											HttpServletRequest httpRequest = (HttpServletRequest) request;
											httpRequest.setAttribute("myAttribute", "Hello from Filter");
											chain.doFilter(request, response);
										}
										@Override
										public void destroy() {
											// cleanup code
										}
									}
									import org.springframework.boot.web.servlet.FilterRegistrationBean;
									import org.springframework.context.annotation.Bean;
									import org.springframework.context.annotation.Configuration;
									@Configuration
									public class WebConfig {
										@Bean
										public FilterRegistrationBean<MyFilter> loggingFilter() {
											FilterRegistrationBean<MyFilter> registrationBean = new FilterRegistrationBean<>();
											registrationBean.setFilter(new MyFilter());
											registrationBean.addUrlPatterns("/greet/*");

											return registrationBean;
										}
									}
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.RequestAttribute;
									import org.springframework.web.bind.annotation.RequestMapping;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									@RequestMapping("/greet")
									public class GreetingController {
										@GetMapping
										public String greet(@RequestAttribute("myAttribute") String myAttribute) {
											return myAttribute;
										}
									}

									import org.springframework.stereotype.Controller;
									import org.springframework.ui.Model;
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.RequestAttribute;
									import javax.servlet.http.HttpServletRequest;
									@Controller
									public class ExampleController {
										@GetMapping("/example")
										public String exampleHandler(HttpServletRequest request, @RequestAttribute("userId") Long userId, Model model) {											
											String attributeValue = (String) request.getAttribute("exampleAttribute"); // Truy cập thuộc tính của yêu cầu đã được đặt trong phạm vi Servlet																				
											model.addAttribute("userId", userId); // Thêm dữ liệu vào model để truyền đến view
											model.addAttribute("exampleAttribute", attributeValue);
											return "exampleView";
										}
									}
									
	@SneakyThrows--Annotation:
	
								- @SneakyThrows là một chú thích (annotation) của Project Lombok, một thư viện Java được sử dụng để giảm thiểu mã lặp lại và tự động sinh mã trong các lớp Java.
								- Chú thích này được sử dụng để giảm thiểu việc phải bắt và xử lý các ngoại lệ (exceptions) kiểu đã khai báo trong phạm vi của phương thức hoặc khối mã.
								- Lưu ý rằng, việc sử dụng @SneakyThrows cần được cân nhắc cẩn thận. Nó thường được sử dụng trong các tình huống đơn giản và không thể tránh được việc ném ra ngoại
								lệ checked. Tuy nhiên, nếu việc xử lý ngoại lệ phức tạp hơn, thì nên xem xét việc sử dụng mã try-catch hoặc khai báo throws rõ ràng hơn để làm mã dễ đọc và hiểu hơn.
								- @SneakyThrows là một annotation Lombok, được sử dụng để tự động thêm throws clause cho các method. Nó sẽ tự động bắt và ném các exception ở bên trong method mà không
								cần bạn phải khai báo throws clause.
								- Sử dụng @SneakyThrows có các lợi ích sau:
									Giảm code boilerplate: Bạn không cần phải khai báo throws clause cho các exception có thể xảy ra trong method.
									Tăng tính linh hoạt: Nếu method cần ném một exception mới, bạn không cần phải sửa lại method signature.
									Đơn giản hóa code: Việc không khai báo throws clause giúp code trông gọn gàng và dễ đọc hơn.
								- Tuy nhiên, việc sử dụng @SneakyThrows cũng có một số rủi ro:
									Nó làm cho code khó debug hơn vì các exception được ném mà không được khai báo.
									Nó vi phạm nguyên tắc "Fail Fast" vì các exception có thể được ném ở bất kỳ đâu trong code.
								- Vì vậy, việc sử dụng @SneakyThrows cần được cân nhắc kỹ lưỡng và chỉ áp dụng khi thực sự cần thiết. Thông thường, việc khai báo throws clause một cách rõ ràng sẽ giúp
								code dễ hiểu và bảo trì hơn.
								
								import lombok.SneakyThrows;
								public class MyClass {
									@SneakyThrows
									public void myMethod() {
										// code that may throw an exception
										throw new Exception("Something went wrong");
									}
								}
								Trong ví dụ trên, myMethod() sẽ tự động ném Exception mà không cần khai báo throws Exception trong method signature.
								
								import lombok.SneakyThrows;
								public class Example {
									@SneakyThrows
									public void doSomething() {										
										throw new Exception("Something went wrong!"); // Throwing a checked exception without a try-catch block or throws declaration
									}
								}
								
	@EnableAsync--Annotation:
								
								- Chúng ta muốn sự kiện được xử lý ở một Thread khác, đây gọi là bất đồng bộ (Asynchronous)
								- Để làm được điều này, chúng ta cần kích hoạt chức năng xử lý bất đồng bộ của Spring Boot, bằng cách bổ sung annotation @EnableAsync.
								- Spring Boot khi thấy Annotation này, sẽ kích hoạt cho phép xử lý sự kiện dưới dạng Async
								- Các Event sẽ được gửi vào một Executor (đơn giản nhất là SimpleAsyncTaskExecutor) và chờ được xử lý.
								
								@Configuration
								@EnableAsync
								public class ListenerConfiguration {
									/**
									 * Tạo ra Executor cho Async
									 * @return
									 */
									@Bean
									TaskExecutor taskExecutor() {
										return new SimpleAsyncTaskExecutor();
									}
								}

	@Async--Annotation:
								
								- Sau khi kích hoạt tính năng Async bằng @EnabelAsync, bất kỳ sự kiện nào bạn muốn nó xử lý Async thì hãy đánh dấu nó bởi @Async.
								- Là một annotation được sử dụng để xác định một phương thức là một phương thức bất đồng bộ (asynchronous). Khi bạn đánh dấu một phương thức với @Async, nó sẽ chạy
								trong một thread riêng biệt và không chặn luồng chính (main thread). Điều này cho phép phương thức thực thi mà không cần đợi cho kết quả và giúp cải thiện hiệu năng
								và thời gian phản hồi của ứng dụng.
								
								@Configuration
								@EnableAsync // Bật tính năng bất đồng bộ cho ứng dụng Spring bằng cách thêm @EnableAsync vào một configuration class hoặc class chứa các cấu hình của ứng dụng.
								public class AppConfig {
									// Các cấu hình khác...
								}
								
								@Service
								public class MyService {									
									@Async // Đánh dấu phương thức bạn muốn thực thi bất đồng bộ với @Async.
									public void asyncMethod() {
										// Các tác vụ bất đồng bộ sẽ được thực hiện ở đây
									}
								}
								
								@Component
								public class MyDog {
									@Async // @Async là cách lắng nghe sự kiện ở một Thread khác, không ảnh hưởng tới luồng chính
									@EventListener // @EventListener sẽ lắng nghe mọi sự kiện xảy ra
												   // Nếu có một sự kiện DoorBellEvent được bắn ra, nó sẽ đón lấy và đưa vào hàm để xử lý
									public void doorBellEventListener(DoorBellEvent doorBellEvent) throws InterruptedException {
										// Giả sử con chó đang ngủ, 1 giây sau mới dậy
										Thread.sleep(1000);
										// Sự kiện DoorBellEvent được lắng nghe và xử lý tại đây
										System.out.println("Chó ngủ dậy!!!");
										System.out.println(String.format("Go go!! Có người tên là %s gõ cửa!!!", doorBellEvent.getGuestName()));
									}
								}


	@PreAuthorize--Annotation:
									
									- @PreAuthorize là một annotation từ Spring Security được sử dụng để thiết lập điều kiện trước khi phương thức được thực thi									
									
									@GetMapping("/admin")
									@PreAuthorize("hasAuthority('ADMIN')") // hasAuthority() kiểm tra xem người dùng hiện tại có quyền (authority) cụ thể hay không. Quyền là một khái niệm tổng quát hơn so với vai trò (role).
									public String showAdmin() {
										return "admin";
									}
									
									import org.springframework.security.access.prepost.PreAuthorize;
									@PreAuthorize("hasAnyAuthority('CREATE_POST', 'EDIT_POST', 'DELETE_POST')") // hasAnyAuthority() kiểm tra xem người dùng hiện tại có ít nhất một trong các quyền được chỉ định hay không.
																												// Nếu người dùng có ít nhất một quyền, biểu thức sẽ trả về true.
									public void createPost(Post post) {
										// Tạo bài viết mới
									}
									
									@PreAuthorize("hasRole('ROLE_VIEWER')") // @PreAuthorize(“hasRole(‘ROLE_VIEWER’)”) has the same meaning as @Secured(“ROLE_VIEWER”)																		
									public String getUsernameInUpperCase() {
										return getUsername().toUpperCase();
									}
									
									@PreAuthorize("hasAnyRole('ROLE_ADMIN', 'ROLE_USER')") // hasAnyRole() kiểm tra xem người dùng hiện tại có ít nhất một trong các vai trò được chỉ định hay không. Nếu người dùng có ít
																						   // nhất một vai trò, biểu thức sẽ trả về true.
									public void deleteProduct(Long productId) {
										// Xóa sản phẩm
									}
									
									@PreAuthorize("hasRole('ROLE_VIEWER') or hasRole('ROLE_EDITOR')") // @Secured({“ROLE_VIEWER”,”ROLE_EDITOR”}) can be replaced with 
																									  // @PreAuthorize(“hasRole(‘ROLE_VIEWER’) or hasRole(‘ROLE_EDITOR’)”):
									public boolean isValidUsername3(String username) {
										//...
									}
									
									@PreAuthorize("#username == authentication.principal.username")
									@PostAuthorize("returnObject.username == authentication.principal.nickName")
									public CustomUser securedLoadUserDetail(String username) {
										return userRoleRepository.loadUserByUserName(username);
									}
									
									@GetMapping("/user/{username}")
									@PreAuthorize("isAuthenticated() and #username == authentication.principal.username") // Yêu cầu đăng nhập isAuthenticated()
																														  // Giá trị biến đường dẫn {username} bằng với tên đăng nhập hiện thời
																														  // #username == authentication.principal.username. Chú ý authentication.principal
																														  // là một biến mặc định mà Spring Security cung cấp để lấy thông tin về người
																														  // dùng đang đăng nhập
									public String getMyRoles(@PathVariable("username") String username) {
											SecurityContext securityContext = SecurityContextHolder.getContext();
											return securityContext.getAuthentication().getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));
									}
									
		Các phương thức chính của @PreAuthorize bao gồm:
		
			hasRole(String role):
			
									Kiểm tra xem người dùng hiện tại có vai trò cụ thể hay không.
									
									@PreAuthorize("hasRole('ROLE_ADMIN')")
									public void deleteProduct(int productId) {
										// Xóa sản phẩm
									}
		
			hasAnyRole(String... roles):
			
									Kiểm tra xem người dùng hiện tại có ít nhất một trong các vai trò được chỉ định hay không.
									
									@PreAuthorize("hasAnyRole('ROLE_USER', 'ROLE_ADMIN')")
									public void getProduct(int productId) {
										// Lấy thông tin sản phẩm
									}
		
			hasAuthority(String authority):
			
									Kiểm tra xem người dùng hiện tại có quyền cụ thể hay không.
									
									@PreAuthorize("hasAuthority('DELETE_PRODUCT')")
									public void deleteProduct(int productId) {
										// Xóa sản phẩm
									}

			hasAnyAuthority(String... authorities):
			
									@PreAuthorize("hasAnyAuthority('READ_PRODUCT', 'WRITE_PRODUCT')")
									public void getProduct(int productId) {
										// Lấy thông tin sản phẩm
									}
									
			hasPermission(Object target, String permission):
			
									Kiểm tra xem người dùng hiện tại có quyền cụ thể trên một đối tượng cụ thể hay không.
									
									@PreAuthorize("hasPermission(#product, 'write')")
									public void updateProduct(Product product) {
										// Cập nhật thông tin sản phẩm
									}
		
		Các thuộc tính chính của @PreAuthorize bao gồm:
		
			value (hoặc expression):
			
									Đây là điều kiện được xác định bằng cách sử dụng một biểu thức Spring Expression Language (SpEL). Biểu thức này quyết định xem người dùng có quyền truy cập vào phương thức hay không.
									
									@PreAuthorize("hasRole('ROLE_ADMIN')")
									public void deleteProduct(int productId) {
										// Xóa sản phẩm
									}
									
			filterTarget:
			
									Thuộc tính này chỉ định tên của một biến mà biểu thức có thể tham chiếu đến. Nói cách khác, nếu bạn muốn sử dụng một biến cụ thể trong biểu thức SpEL của mình, bạn có thể đặt tên
									biến này ở đây.
									
									@PreAuthorize("hasRole('ROLE_USER') and #productId == 5")
									public void getProduct(int productId) {
										// Lấy thông tin sản phẩm
									}
	@PostAuthorize--Annotation:
								
								- Nếu như @PreAuthorize kiểm tra quyền trước khi method thực thi thì có những tình huống quyết định cho phép truy cập tiếp hay không chỉ sau khi phương thức được thực
								thi. Ví dụ GET /post/{id} sẽ trả về bài viết. Tôi muốn rằng chỉ tác giả của chính bài viết đó mới có thể được xem để sửa. Spring Boot đã có user.id đang đăng nhập,
								nhưng để biết tác giả của bài viết thì cần phải lấy bài viết đó từ CSDL ra đã. @PostAuthorize
								- Các phương thức và thuộc tính giống với @PreAuthorize
								
								@PostAuthorize("#username == authentication.principal.username")
								public String getMyRoles2(String username) {
									//...
								}
								
								@PreAuthorize("isAuthenticated()") //Phải đảm bảo là user login để có principal.id
								@PostAuthorize("returnObject.user.id == authentication.principal.id")  //chỉ trả bài viết nếu user.id == id của login user
								@GetMapping("/post/{id}")
								public Post showEditPostForm(@PathVariable("id") long id) {
									Optional<Post> oPost = postRepo.findById(id);
									if (oPost.isPresent()) {
										return oPost.get();
									} else {
										throw new RuntimeException("Cannot find post with id " + id);
									}
								}
	@PostFilter--Annotation:
								
								- Để lọc dữ liệu trước khi trả về, có 2 cách: để lập trình viên tự viết code trong phương thức hoặc cấu hình bằng annotation @PostFilter.
								- Trong ví dụ này, phương thức getPostsOfAnUser() sẽ trả về một danh sách tất cả bài viết. Tôi muốn lọc ra chỉ trả về những bài viết do chính user đang login
								authentication.principal viết mà thôi.
								
								@PreAuthorize("isAuthenticated()")
								@PostFilter("filterObject.user.id == authentication.principal.id")
								@GetMapping("/post")
								public List<Post> getPostsOfAnUser() {
									return postRepo.findAll();
								}
								
								@PostFilter("filterObject.assignee == authentication.name")
								List<Task> findAll() {
									...
								}
	@PreFilter--Annotation:
								
								@Prefilter lại cho phép lọc dữ liệu truyền vào phương thức trước khi thực thi.
								
								import org.springframework.security.access.prepost.PreAuthorize;
								import org.springframework.security.access.prepost.PreFilter;
								import org.springframework.web.bind.annotation.GetMapping;
								import org.springframework.web.bind.annotation.RestController;
								import java.util.ArrayList;
								import java.util.List;
								@RestController
								public class UserController {
									private List<User> users = new ArrayList<>();									
									public UserController() {
										users.add(new User("admin", "ADMIN"));
										users.add(new User("user1", "USER"));
										users.add(new User("user2", "USER"));
									}
									@GetMapping("/users")
									@PreAuthorize("hasRole('ADMIN') or hasRole('USER')") // phương thức getUsersByRole chỉ có thể được thực thi nếu người dùng có vai trò là "ADMIN" hoặc "USER".
																						 // Nếu một người dùng không có vai trò là "ADMIN" hoặc "USER" cố gắng
																						 // truy cập vào phương thức này, họ sẽ nhận được một ngoại lệ AccessDeniedException từ Spring Security.
									@PreFilter("hasRole('ADMIN') ? filterObject.role == 'ADMIN' : filterObject.role == 'USER'") // chỉ định rằng danh sách người dùng sẽ được lọc trước khi trả về.
																																// Đối với người dùng có vai trò là "ADMIN", danh sách sẽ chỉ chứa các
																																// người dùng có vai trò là "ADMIN". Đối với người dùng có vai trò là
																																// "USER", danh sách sẽ chỉ chứa các người dùng có vai trò là "USER".
																																// Nếu một người dùng không có vai trò là "ADMIN" hoặc "USER" cố gắng
																																// truy cập vào phương thức này, họ sẽ nhận được một ngoại lệ
																																// AccessDeniedException từ Spring Security.
									public List<User> getUsersByRole() {
										return users;
									}
									private static class User {
										private String username;
										private String role;
										public User(String username, String role) {
											this.username = username;
											this.role = role;
										}
										// Getters and setters
									}
								}
								
								@PreFilter("hasRole('MANAGER') or filterObject.assignee == authentication.name")
								Iterable<Task> save(Iterable<Task> entities) {
									// ...
								}
	@ControllerAdvice--Annotation:
									
									- Là một annotation được sử dụng để đánh dấu một lớp như một global controller advice (lời khuyên toàn cục cho controller). Nó cho phép bạn xử lý các ngoại lệ chung
									và thực hiện một số xử lý toàn cục cho tất cả các controller trong ứng dụng.
									- Các phương thức trong lớp đánh dấu bởi @ControllerAdvice có thể được đánh dấu bằng các annotation như @ExceptionHandler, @InitBinder, và @ModelAttribute.
									- Các annotation này cho phép bạn xử lý các ngoại lệ, tiền xử lý (pre-processing), và ánh xạ các thuộc tính mô hình (model attributes) một cách toàn cục cho các
									controller.
									
									import org.springframework.http.HttpStatus;
									import org.springframework.http.ResponseEntity;
									import org.springframework.web.bind.annotation.ControllerAdvice;
									import org.springframework.web.bind.annotation.ExceptionHandler;
									@ControllerAdvice
									public class GlobalExceptionHandler {
										@ExceptionHandler(Exception.class)
										public ResponseEntity<String> handleException(Exception e) {
											return new ResponseEntity<>("Global Exception Handler: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
										}
									}
									
	@ExceptionHandler--Annotation:
									
									- Là một annotation được sử dụng để đánh dấu một phương thức trong controller, cho biết rằng phương thức đó sẽ được sử dụng để xử lý các ngoại lệ (exceptions) được
									ném ra trong phạm vi của controller đó. Annotation này cho phép bạn tách biệt xử lý ngoại lệ khỏi phương thức chính của controller, giúp mã nguồn sạch hơn và dễ
									bảo trì hơn.

									public class ResourceNotFoundException extends RuntimeException {
										public ResourceNotFoundException(String message) {
											super(message);
										}
									}
									import org.springframework.web.bind.annotation.GetMapping;
									import org.springframework.web.bind.annotation.PathVariable;
									import org.springframework.web.bind.annotation.RestController;
									@RestController
									public class UserController {
										@GetMapping("/user/{id}")
										public String getUserById(@PathVariable String id) {
											if ("123".equals(id)) {
												return "User found";
											} else {
												throw new ResourceNotFoundException("User not found with id: " + id);
											}
										}
									}
									import org.springframework.http.HttpStatus;
									import org.springframework.http.ResponseEntity;
									import org.springframework.web.bind.annotation.ExceptionHandler;
									import org.springframework.web.bind.annotation.RestControllerAdvice;
									@RestControllerAdvice
									public class GlobalExceptionHandler {
										@ExceptionHandler(ResourceNotFoundException.class)
										public ResponseEntity<String> handleResourceNotFoundException(ResourceNotFoundException ex) {
											return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
										}
									}
									ResourceNotFoundException là một ngoại lệ tùy chỉnh mở rộng từ RuntimeException.
									UserController chứa phương thức getUserById sẽ ném ResourceNotFoundException nếu người dùng không được tìm thấy.
									GlobalExceptionHandler là một lớp toàn cục để xử lý ngoại lệ, sử dụng @RestControllerAdvice để áp dụng cho tất cả các controller trong ứng dụng.
									@ExceptionHandler(ResourceNotFoundException.class) xử lý ngoại lệ ResourceNotFoundException.
									@ExceptionHandler(Exception.class) xử lý tất cả các ngoại lệ khác chưa được xử lý cụ thể.
									
									@Controller
									public class MyController {

										@GetMapping("/hello")
										public String hello() {
											throw new RuntimeException("Lỗi xảy ra trong quá trình xử lý yêu cầu");
										}

										@ExceptionHandler(RuntimeException.class)
										public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {
											return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Lỗi xảy ra: " + ex.getMessage());
										}
									}								
									
									@ExceptionHandler(NullPointerException.class) // Method processNullPointerException sẽ xử lý tất cả các exception NullPointerException ném ra từ các
																				  // @RequestMapping trong cùng class.
									public String processNullPointerException() {
									  return "null-pointer-exception";
									}
									@RequestMapping(value = "/nullPointerException")
									public String testNullPointerException() throws NullPointerException {
									  throw new NullPointerException("this is null pointer exception");
									}									
	@Enumerated--Annotation:
								
								- Lựa chọn phổ biến nhất để ánh xạ một enum với một cột trong database đó là sử dụng @Enumerated annotation được giới thiệu trong phiên bản JPA 2.1.
								- Bằng cách này, chúng ta có thể chỉ định các JPA provider chuyển đổi một enum thành string hoặc số thứ tự của nó trong tập enum được định nghĩa.
		
		Mapping Ordinal:		
		
								Nếu chúng ta chú thích @Enumerated(EnumType.ORDINAL) annotation lên các trường enum trong một entity. JPA sẽ sử dụng số thứ tự của enum làm giá trị khi thêm mới hoặc
								cập nhật giá trị của trường này.						
									
								public enum Status {
									OPEN, REVIEW, APPROVED, REJECTED;
								}
									
								package entities;
								import javax.persistence.Entity;
								import javax.persistence.EnumType;
								import javax.persistence.Enumerated;
								import javax.persistence.Id;
								@Entity
								public class Article {										
									@Id
									private int id;
									private String title;
									@Enumerated(EnumType.ORDINAL)
									private Status status;
									// getter, setter, constructor
								}
								
								import entities.Article;
								import entities.Status;
								import javax.persistence.EntityManager;
								import javax.persistence.EntityManagerFactory;
								import javax.persistence.Persistence;
								public class Example1 {
									public static void main(String... args) {
										EntityManagerFactory emf = Persistence.createEntityManagerFactory("enum-mapping");
										EntityManager entityManager = emf.createEntityManager();
										entityManager.getTransaction().begin();
										Article article = new Article();
										article.setId(1);
										article.setTitle("ordinal title");
										article.setStatus(Status.OPEN);
										entityManager.persist(article);
										entityManager.getTransaction().commit();
										entityManager.close();
										emf.close();
									}
								}
								
		Mapping String:			
		
								Tương tự, @Enumerated(EnumType.STRING) sẽ sử chuyển đổi giá trị của enum sang string để lưu xuống database.
								
								public enum Type {
									INTERNAL, EXTERNAL
								}
								
								@Entity
								public class Article {
									@Id
									private int id;
									private String title;
									@Enumerated(EnumType.ORDINAL)
									private Status status;
									@Enumerated(EnumType.STRING)
									private Type type;
								}
								
								import entities.Article;
								import entities.Status;
								import entities.Type;
								import javax.persistence.EntityManager;
								import javax.persistence.EntityManagerFactory;
								import javax.persistence.Persistence;
								public class Example2 {
									public static void main(String... args) {
										EntityManagerFactory emf = Persistence.createEntityManagerFactory("enum-mapping");
										EntityManager entityManager = emf.createEntityManager();
										entityManager.getTransaction().begin();
										Article article = new Article();
										article.setId(1);
										article.setTitle("string title");
										article.setStatus(Status.OPEN);
										article.setType(Type.EXTERNAL);
										entityManager.persist(article);
										entityManager.getTransaction().commit();
										entityManager.close();
										emf.close();
									}
								}
	@ResponseStatus--Annotation:
									
									- @ResponseStatus là một cách định nghĩa Http Status trả về cho người dùng.
									- Nếu bạn không muốn sử dụng ResponseEntity thì có thể dùng @ResponseStatus đánh dấu trên Object trả về.
									- @ResponseStatus là một annotation trong Spring, được sử dụng để chỉ định HTTP status code mà Spring sẽ trả về khi một ngoại lệ được ném ra.
									- Khi một exception xảy ra trong ứng dụng Spring, mặc định Spring sẽ trả về HTTP status code 500 (Internal Server Error). Tuy nhiên, trong một số trường hợp, bạn muốn trả về một
									HTTP status code khác, phù hợp với loại ngoại lệ đã xảy ra.
									- Ví dụ, khi một tài nguyên không được tìm thấy (404 Not Found), bạn có thể ném ra một ResourceNotFoundException và sử dụng @ResponseStatus để chỉ định HTTP status code 404
									sẽ được trả về
									- @ResponseStatus cũng có thể được sử dụng ở cấp độ method
									- Ngoài việc chỉ định HTTP status code, @ResponseStatus cũng có thể được sử dụng để chỉ định một custom message cho ngoại lệ
									- Sử dụng @ResponseStatus giúp đơn giản hóa và làm rõ ràng các mã trạng thái HTTP được sử dụng trong các controller của bạn. Điều này giúp cải thiện sự nhất quán và dễ hiểu
									của API, đồng thời cũng làm cho code trở nên sáng sủa và dễ bảo trì hơn.
									
									@ResponseStatus(HttpStatus.NOT_FOUND)
									@GetMapping("/users/{id}")
									public User getUserById(@PathVariable("id") Long id) {
										// code to retrieve user
										return user;
									}
									Trong ví dụ này, nếu không tìm thấy user, phương thức getUserById() sẽ trả về mã trạng thái 404 Not Found.
									
									@ResponseStatus(value = HttpStatus.PAYMENT_REQUIRED, reason = "Insufficient funds")
									@PostMapping("/transactions")
									public void processTransaction(@RequestBody Transaction transaction) {
										// code to process the transaction
									}
									Trong ví dụ này, nếu có lỗi xảy ra (ví dụ như không đủ tiền), phương thức processTransaction() sẽ trả về mã trạng thái 402 Payment Required với lý do "Insufficient funds".
									
									@ResponseStatus(HttpStatus.CONFLICT)
									public class UserAlreadyExistsException extends RuntimeException {
										// exception logic
									}
									@PostMapping("/users")
									public User createUser(@RequestBody User user) {
										try {
											// code to create a new user
										} catch (UserAlreadyExistsException ex) {
											// this exception will be mapped to HTTP 409 Conflict
											throw ex;
										}
										return savedUser;
									}
									Ở đây, chúng ta định nghĩa một custom exception UserAlreadyExistsException và ánh xạ nó đến mã trạng thái HTTP 409 Conflict bằng cách sử dụng @ResponseStatus. Khi exception
									này được ném ra trong phương thức createUser(), Spring sẽ tự động trả về mã trạng thái 409 Conflict.
									
									@ResponseStatus(HttpStatus.NOT_FOUND)
									public class ResourceNotFoundException extends RuntimeException {
										// implementation
									}

									@ResponseStatus(HttpStatus.CREATED)
									@PostMapping("/users")
									public User createUser(@RequestBody User user) {
										// implementation
									}
									Trong ví dụ trên, khi một user mới được tạo thành công, Spring sẽ trả về HTTP status code 201 (Created) thay vì 200 (OK).	

									@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = "Resource not found")
									public class ResourceNotFoundException extends RuntimeException {
										// implementation
									}										
									
									@RestControllerAdvice
									public class ApiExceptionHandler {
										@ExceptionHandler(Exception.class)
										@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
										public ErrorMessage handleAllException(Exception ex, WebRequest request) {
											// quá trình kiểm soat lỗi diễn ra ở đây
											return new ErrorMessage(10000, ex.getLocalizedMessage());
										}
										@ExceptionHandler(IndexOutOfBoundsException.class) // IndexOutOfBoundsException sẽ được xử lý riêng tại đây
										@ResponseStatus(value = HttpStatus.BAD_REQUEST)
										public ErrorMessage TodoException(Exception ex, WebRequest request) {
											return new ErrorMessage(10100, "Đối tượng không tồn tại");
										}
									}
							
	@RestControllerAdvice--Annotation:
										
										- Là một biến thể của annotation @ControllerAdvice trong Spring Framework, nhưng được sử dụng đặc biệt cho các trường hợp khi bạn muốn xử lý các exception và
										trả về phản hồi dưới dạng dữ liệu JSON cho ứng dụng RESTful.
										- Khi bạn đánh dấu một lớp bằng @RestControllerAdvice, các phương thức xử lý exception trong lớp đó sẽ trả về dữ liệu JSON thay vì trang HTML như trong trường
										hợp sử dụng @ControllerAdvice.
										
										import org.springframework.http.ResponseEntity;
										import org.springframework.web.bind.annotation.ControllerAdvice;
										import org.springframework.web.bind.annotation.ExceptionHandler;
										import org.springframework.web.bind.annotation.RestControllerAdvice;
										@RestControllerAdvice
										public class GlobalExceptionHandler {
											@ExceptionHandler(Exception.class)
											public ResponseEntity<String> handleGlobalException(Exception ex) {
												return ResponseEntity.badRequest().body("Something went wrong.");
											}
										}
	@JsonAdapter--Annotation:
										
						- Trong thư viện Gson của Java, @JsonAdapter là một annotation được sử dụng để chỉ định một adapter tùy chỉnh để chuyển đổi giữa đối tượng Java và JSON khi thực hiện quá trình
						serialize và deserialize. Adapter tùy chỉnh này cho phép bạn kiểm soát cách mà Gson chuyển đổi các đối tượng thành JSON và ngược lại.
						- Áp dụng tùy chỉnh TypeAdapter, JsonSerializer, JsonDeserializer với @JsonAdapter
						- Chú thích này có thể được sử dụng field hoặc class để chỉ định lớp tùy chỉnh Gson TypeAdapter, JsonSerializer, JsonDeserializer được sử dụng trong khi serialization/ deserialization.
						- Một vài trường hợp sử dụng phổ biến của @JsonAdapter bao gồm:
							Chuyển đổi các kiểu dữ liệu tùy chỉnh
							Chuyển đổi các cấu trúc dữ liệu phức tạp: Ví dụ, bạn có thể sử dụng @JsonAdapter để chuyển đổi một Map<String, List<Integer>> sang một định dạng JSON tùy chỉnh.
							Áp dụng các quy tắc kiểm tra, xác thực hoặc biến đổi dữ liệu: Bạn có thể tạo một custom adapter để thực hiện các quy tắc này trong quá trình serialization và deserialization.
						- Để tạo một custom adapter, bạn cần tạo một class implements JsonSerializer<T> và JsonDeserializer<T> interfaces từ thư viện Jackson. Bạn có thể sử dụng các phương thức write() và
						read() để triển khai logic chuyển đổi tùy chỉnh.
						
						public class MyClass {
							@JsonAdapter(DateAdapter.class)
							private Date dateField;
							// Getters, setters, and other methods
						}
						public class DateAdapter extends TypeAdapter<Date> {
							@Override
							public void write(JsonWriter out, Date value) throws IOException {
								if (value == null) {
									out.nullValue();
								} else {
									out.value(value.getTime());
								}
							}
							@Override
							public Date read(JsonReader in) throws IOException {
								long timestamp = in.nextLong();
								return new Date(timestamp);
							}
						}
						Trong ví dụ trên, chúng ta có một DateAdapter class, được áp dụng cho dateField sử dụng @JsonAdapter(DateAdapter.class). Khi serializing một instance của MyClass sang
						JSON, DateAdapter sẽ được sử dụng để chuyển đổi dateField (một Date object) sang một số nguyên đại diện cho timestamp (milliseconds since Unix epoch).
						Khi deserializing JSON data trở lại thành một instance của MyClass, DateAdapter sẽ được sử dụng để chuyển đổi số nguyên (timestamp) trở lại thành một Date object.
						
						
						package com.gpcoder.gson.object;
						import java.util.Arrays;
						import java.util.Date;											 
						import com.google.gson.annotations.JsonAdapter;
						import com.gpcoder.gson.annotation.CustomTypeAdapter;										 
						public class AmazonBook {
							private String title;
							private String[] authors;
							private String isbn10;
							private String isbn13;
							private Double price;
							private Date publishedDate;											 
							public String getTitle() {
								return title;
							}											 
							public void setTitle(String title) {
								this.title = title;
							}										 
							public String[] getAuthors() {
								return authors;
							}										 
							public void setAuthors(String[] authors) {
								this.authors = authors;
							}											 
							public String getIsbn10() {
								return isbn10;
							}										 
							public void setIsbn10(String isbn10) {
								this.isbn10 = isbn10;
							}										 
							public String getIsbn13() {
								return isbn13;
							}										 
							public void setIsbn13(String isbn13) {
								this.isbn13 = isbn13;
							}										 
							public Double getPrice() {
								return price;
							}									 
							public void setPrice(Double price) {
								this.price = price;
							}									 
							public Date getPublishedDate() {
								return publishedDate;
							}									 
							public void setPublishedDate(Date publishedDate) {
								this.publishedDate = publishedDate;
							}							 
							@Override
							public String toString() {
								return "Book [title=" + title + ", authors=" + Arrays.toString(authors) + ", isbn10=" + isbn10 + ", isbn13="
										+ isbn13 + ", price=" + price + ", publishedDate=" + publishedDate + "]";
							}									 
						}
						
						package com.gpcoder.gson.annotation;
						import java.io.IOException;
						import java.text.ParseException;
						import java.text.SimpleDateFormat;
						import java.util.ArrayList;
						import java.util.Date;
						import java.util.List;					 
						import com.google.gson.TypeAdapter;
						import com.google.gson.stream.JsonReader;
						import com.google.gson.stream.JsonWriter;
						import com.gpcoder.gson.object.AmazonBook;											 
						public class CustomTypeAdapter extends TypeAdapter<AmazonBook> {										 
							public static final SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");										 
							@Override
							public AmazonBook read(final JsonReader in) throws IOException {
								final AmazonBook book = new AmazonBook();									 
								in.beginObject();
								while (in.hasNext()) {
									switch (in.nextName()) {
									case "title":
										book.setTitle(in.nextString());
										break;
									case "isbn-10":
										book.setIsbn10(in.nextString());
										break;
									case "isbn-13":
										book.setIsbn13(in.nextString());
										break;
									case "price":
										book.setPrice(in.nextDouble());
										break;
									case "publishedDate":
										Date publishedDate = null;
										try {
											publishedDate = sdf.parse(in.nextString());
										} catch (ParseException e) {
											e.printStackTrace();
										}
										book.setPublishedDate(publishedDate);
										break;
									case "authors":
										in.beginArray();
										final List<String> authors = new ArrayList<>();
										while (in.hasNext()) {
											authors.add(in.nextString());
										}
										in.endArray();
										book.setAuthors(authors.toArray(new String[authors.size()]));
										break;
									}
								}
								in.endObject();										
								return book;
							}											 
							@Override
							public void write(final JsonWriter out, final AmazonBook book) throws IOException {
								out.beginObject();
								out.name("title").value(book.getTitle());
								out.name("isbn-10").value(book.getIsbn10());
								out.name("isbn-13").value(book.getIsbn13());
								out.name("price").value(book.getPrice());
								out.name("publishedDate").value(sdf.format(book.getPublishedDate()));
								out.name("authors");
								out.beginArray();
								for (final String author : book.getAuthors()) {
									out.value(author);
								}
								out.endArray();
								out.endObject();
							}
						}
						
						@JsonAdapter(value = CustomTypeAdapter.class)
						public class AmazonBook {
							// Fields ...
						}
						
						package com.gpcoder.gson.annotation;
						import java.util.Calendar;									 
						import com.google.gson.Gson;
						import com.google.gson.GsonBuilder;
						import com.gpcoder.gson.object.AmazonBook;											 
						public class JsonAdapterExample {
							public static void main(String args[]) {
								final GsonBuilder gsonBuilder = new GsonBuilder();
								gsonBuilder.setPrettyPrinting();											 
								final Gson gson = gsonBuilder.create();											 
								final AmazonBook book = new AmazonBook();
								book.setTitle("Head First Design Patterns");
								book.setIsbn10("0596007124");
								book.setIsbn13("978-0596007126");
								book.setPrice(52.41);										 
								Calendar c = Calendar.getInstance();
								c.set(2004, Calendar.OCTOBER, 1);
								book.setPublishedDate(c.getTime());											 
								String[] authors = new String[] { "Eric Freeman", "Bert Bates", "Kathy Sierra", "Elisabeth Robson" };
								book.setAuthors(authors);										 
								System.out.println("Convert Book object to JSON string: ");
								final String json = gson.toJson(book);
								System.out.println(json);										 
								System.out.println("Convert JSON String to Book object: ");
								final AmazonBook parsedBook1 = gson.fromJson(json, AmazonBook.class);
								System.out.println(parsedBook1);
							}
						}
						
						Kết quả thực thi chương trình trên:
						Convert Book object to JSON string: 
						{
						  "title": "Head First Design Patterns",
						  "isbn-10": "0596007124",
						  "isbn-13": "978-0596007126",
						  "price": 52.41,
						  "publishedDate": "01/10/2004",
						  "authors": [
							"Eric Freeman",
							"Bert Bates",
							"Kathy Sierra",
							"Elisabeth Robson"
						  ]
						}
						 
						Convert JSON String to Book object: 
						Book [title=Head First Design Patterns, authors=[Eric Freeman, Bert Bates, Kathy Sierra, Elisabeth Robson], isbn10=0596007124, isbn13=978-0596007126, price=52.41,
						publishedDate=Fri Oct 01 00:00:00 ICT 2004]

	@EnableFeignClients--Annotation:
	
		- @EnableFeignClients là một annotation trong Spring Cloud, được sử dụng để kích hoạt chức năng Feign Client trong một ứng dụng Spring. Feign Client là một thư viện cung cấp cách thức dễ dàng hơn để gọi các
		RESTful API từ các dịch vụ khác trong một hệ thống microservice.
		
		- Khi bạn sử dụng @EnableFeignClients, Spring sẽ tự động:
		
				Quét các package được chỉ định hoặc package gốc của ứng dụng để tìm các interface khai báo Feign Client.
				Tạo ra các implementation của các interface Feign Client đó.
				Đăng ký các bean Feign Client vào Spring IoC container để bạn có thể autowire chúng vào các class khác.
				
		@FeignClient(name = "user-service")
		public interface UserServiceClient {
			@GetMapping("/users/{id}")
			User getUser(@PathVariable("id") Long id);
		}
		Khi bạn thêm @EnableFeignClients vào class @SpringBootApplication chính của ứng dụng, Spring sẽ tự động tạo ra implementation của UserServiceClient và đăng ký nó vào container. Bây giờ bạn có thể autowire
		UserServiceClient vào các class cần sử dụng nó.	
		Annotation @EnableFeignClients cũng có một số tham số khác để cấu hình, ví dụ như chỉ định các package cụ thể cần quét để tìm Feign Client, hay cấu hình các option khác cho Feign Client.
		
	@RequiredArgsConstructor--Annotation:
	
		- @RequiredArgsConstructor là một annotation trong thư viện Lombok, được sử dụng để tự động tạo ra một constructor có các tham số là các trường final hoặc các trường có @NonNull annotation.
		- Khi bạn sử dụng @RequiredArgsConstructor trên một class, Lombok sẽ tự động tạo ra một constructor có các tham số là các trường final hoặc các trường có @NonNull annotation trong class đó.
		
		@Data
		@RequiredArgsConstructor
		public class User {
			private final Long id;
			private final String name;
			@NonNull
			private String email;
			private Integer age;
		}

		Khi bạn sử dụng @RequiredArgsConstructor, Lombok sẽ tự động tạo ra một constructor như sau:

		public User(Long id, String name, @NonNull String email) {
			this.id = id;
			this.name = name;
			this.email = Objects.requireNonNull(email);
		}
		Trong ví dụ trên, id và name là các trường final, nên chúng được đưa vào constructor. email có @NonNull annotation, nên cũng được đưa vào constructor. age không được đưa vào constructor vì nó không phải là
		trường final và cũng không có @NonNull annotation.
		
	@CrossOrigin--Annotation:
		
		- @CrossOrigin là một annotation trong Spring Boot, được sử dụng để cho phép các ứng dụng web trên các miền (domains) khác có thể gửi request tới các endpoint của ứng dụng của bạn.
		- Khi một ứng dụng web (chẳng hạn như một ứng dụng ReactJS) chạy trên một miền (domain) khác với ứng dụng Spring Boot của bạn, nó sẽ gặp vấn đề về "Cross-Origin Resource Sharing" (CORS) khi cố gắng gửi request
		tới các endpoint của ứng dụng Spring Boot. Lúc này, bạn cần phải cấu hình CORS để cho phép các ứng dụng web từ các miền khác có thể truy cập các endpoint của ứng dụng Spring Boot.
		- Bằng cách sử dụng @CrossOrigin, bạn có thể dễ dàng cấu hình CORS cho các endpoint của ứng dụng Spring Boot.
		- @CrossOrigin có một số tham số khác như maxAge, allowedHeaders, exposedHeaders, allowCredentials, methods, v.v. để bạn có thể tuỳ chỉnh CORS theo nhu cầu của ứng dụng.
		- Ngoài việc sử dụng @CrossOrigin trên level class, bạn cũng có thể sử dụng nó trên level method để cấu hình CORS cho từng endpoint riêng biệt.
		
		@CrossOrigin(origins = "http://example.com")
		@RestController
		public class MyController {
			// các endpoint được định nghĩa ở đây
		}
		Trong ví dụ trên, @CrossOrigin(origins = "http://example.com") sẽ cho phép ứng dụng web chạy trên miền http://example.com có thể gửi request tới các endpoint định nghĩa trong MyController.
		
	@KafkaListener--Annotation:
	
		- @KafkaListener là một annotation trong Spring for Apache Kafka, được sử dụng để đánh dấu một phương thức là một listener của một hoặc nhiều topic Kafka.
		- Khi một message được gửi đến một topic mà phương thức có @KafkaListener đang lắng nghe, phương thức đó sẽ được gọi để xử lý message đó.
		- @KafkaListener có nhiều thuộc tính có thể được sử dụng để cấu hình listener:
			topics: chỉ định danh sách các topic mà listener sẽ lắng nghe.
			groupId: chỉ định group ID của consumer.
			containerFactory: chỉ định bean KafkaListenerContainerFactory để tạo container lắng nghe.
			errorHandler: chỉ định bean AsyncListenerErrorHandler để xử lý lỗi.
			clientIdPrefix: chỉ định tiền tố cho client ID.
			idIsGroup: chỉ định liệu client ID có được sử dụng làm group ID hay không.
		- Sử dụng @KafkaListener giúp bạn dễ dàng tích hợp ứng dụng Spring với Apache Kafka, đồng thời cũng cung cấp nhiều tùy chỉnh để đáp ứng các yêu cầu cụ thể của ứng dụng.
		
		@Component
		public class MyKafkaListener {

			@KafkaListener(topics = "my-topic")
			public void processMessage(String message) {
				// Xử lý message
				System.out.println("Received message: " + message);
			}
		}
		Trong ví dụ này, phương thức processMessage() sẽ được gọi mỗi khi một message được gửi đến topic "my-topic".
		
		@KafkaListener(topics = {"topic1", "topic2"}, groupId = "my-group")
		public void processMessages(String message1, String message2) {
			// Xử lý cả 2 message
		}
		Trong ví dụ này, phương thức processMessages() sẽ được gọi mỗi khi có message được gửi đến topic "topic1" hoặc "topic2", và consumer sẽ thuộc về group "my-group".

	@KafkaHandler--Annotation:
	
		- @KafkaHandler là một annotation trong Spring for Apache Kafka, được sử dụng để đánh dấu một phương thức trong một class như một listener cho một chủ đề (topic) Kafka cụ thể.
		- Một số điểm chú ý khi sử dụng @KafkaHandler:
			Các phương thức được đánh dấu @KafkaHandler phải có tham số là kiểu của message mà chúng xử lý.
			Nếu có nhiều phương thức @KafkaHandler với cùng loại tham số, Spring sẽ gọi tất cả chúng để xử lý message.
			Bạn có thể sử dụng các annotation khác như @Header, @Payload, @KafkaKey để truy cập các thông tin khác của message.
		- Việc sử dụng @KafkaHandler giúp code của bạn trở nên rõ ràng, dễ bảo trì và mở rộng hơn, đặc biệt khi bạn cần xử lý nhiều loại message từ Kafka.
		- Annotation @KafkaListener đánh dấu class MyKafkaListener như một Kafka listener cho chủ đề my-topic.
	     - Annotation @KafkaHandler đánh dấu các phương thức trong class MyKafkaListener như các handler để xử lý các loại message khác nhau từ chủ đề Kafka.
		 
		import org.springframework.kafka.annotation.KafkaHandler;
		import org.springframework.kafka.annotation.KafkaListener;
		import org.springframework.stereotype.Component;
		@Component
		@KafkaListener(topics = "my-topic")
		public class MyKafkaListener {
			@KafkaHandler
			public void handleMessage(String message) {
				// Xử lý message từ Kafka
				System.out.println("Received message: " + message);
			}
			@KafkaHandler
			public void handleOtherMessage(AnotherType message) {
				// Xử lý message khác từ Kafka
				System.out.println("Received another message: " + message);
			}
		}
		Khi có message từ chủ đề my-topic được gửi vào, Spring sẽ tự động gọi đến phương thức phù hợp dựa trên loại message.
	
	@Slf4j--Annotation:
	
		- @Slf4j là một annotation từ thư viện Lombok, được sử dụng trong Spring để tạo ra một logger instance của SLF4J (Simple Logging Facade for Java) một cách nhanh chóng và thuận tiện.
		- Khi sử dụng @Slf4j, Lombok sẽ tự động một private static final Logger field với tên log trong class đó. Việc này giúp bạn có thể sử dụng log để ghi log mà không cần phải khai báo và khởi tạo Logger
		object một cách thủ công.
		- Lợi ích của việc sử dụng @Slf4j:
			Giảm lượng code: Bạn không cần phải khai báo và khởi tạo Logger object một cách thủ công.
			Dễ dàng chuyển đổi logging framework: Vì @Slf4j sử dụng SLF4J, bạn có thể dễ dàng chuyển đổi giữa các logging framework như Logback, Log4j, Java Util Logging, v.v.
			Đồng nhất cách sử dụng logging: Việc sử dụng @Slf4j giúp đồng nhất cách sử dụng logging trong toàn bộ ứng dụng.
	
		import lombok.extern.slf4j.Slf4j;
		import org.springframework.stereotype.Service;
		@Slf4j
		@Service
		public class MyService {
			public void doSomething() {
				log.info("Performing some operation...");
				try {
					// some business logic
				} catch (Exception e) {
					log.error("An error occurred: {}", e.getMessage(), e);
				}
			}
		}
		@Slf4j được thêm vào class MyService, cho phép Lombok tạo ra một log field.
		Bên trong doSomething() method, log.info() và log.error() được sử dụng để ghi lại các thông tin và lỗi.
	
	@JsonIgnore--Annotation:
	
		- @JsonIgnore là một annotation trong Spring, được sử dụng để đánh dấu một thuộc tính hoặc một phương thức trong một class sẽ bị bỏ qua (ignore) khi chuyển đổi đối tượng Java sang JSON và ngược lại.
		- Một số lưu ý khi sử dụng @JsonIgnore:
			Nó có thể được sử dụng trên các thuộc tính, getter và setter.
			Nó còn có thể sử dụng trên cấp độ class để bỏ qua toàn bộ các thuộc tính của class.
			Ngoài @JsonIgnore, bạn cũng có thể sử dụng các annotation khác như @JsonProperty để kiểm soát việc chuyển đổi dữ liệu.
			@JsonIgnore rất hữu ích khi bạn muốn ẩn một số thông tin nhạy cảm hoặc không cần thiết khi chuyển đổi đối tượng sang JSON.
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		public class User {
			private int id;
			private String name;
			@JsonIgnore
			private String password;
			// Các getter và setter
			public int getId() { return id; }
			public void setId(int id) { this.id = id; }
			public String getName() { return name; }
			public void setName(String name) { this.name = name; }
			public String getPassword() { return password; }
			public void setPassword(String password) { this.password = password; }
		}
		Thuộc tính password được đánh dấu bằng @JsonIgnore, do đó nó sẽ bị bỏ qua khi chuyển đổi đối tượng User sang JSON.
		Khi chuyển đổi đối tượng User sang JSON, chỉ có các thuộc tính id và name được bao gồm.
		Khi chuyển đổi JSON trở lại thành đối tượng User, thuộc tính password cũng sẽ được bỏ qua.
		
	@Builder--Annotation:
	
		- @Builder là một annotation được sử dụng trong Java để tạo ra một Builder pattern một cách dễ dàng. Builder pattern là một mẫu thiết kế phần mềm cho phép tạo ra các đối tượng phức tạp một cách dễ dàng và
		thể hiện rõ các bước trong quá trình tạo đối tượng.
		- Khi sử dụng @Builder trong Spring, bạn có thể tạo ra một Builder class cho một class khác một cách tự động
		- Việc sử dụng Builder pattern cung cấp một số lợi ích:
			Tính rõ ràng: Cách tạo ra đối tượng trở nên rõ ràng và dễ hiểu hơn.
			Tính linh hoạt: Bạn có thể thêm hoặc bỏ các tham số khi tạo đối tượng mà không ảnh hưởng đến constructor.
			Tính an toàn: Đảm bảo các trường bắt buộc được thiết lập và có giá trị hợp lệ.
		
		import lombok.Builder;
		import lombok.Data;
		@Data
		@Builder
		public class User {
			private int id;
			private String name;
			private String email;
			private int age;
		}
		User user = User.builder()
            .id(1)
            .name("John Doe")
            .email("john.doe@example.com")
            .age(30)
            .build();
			
	@EnableScheduling--Annotation:
		
		- @EnableScheduling là một annotation trong Spring Framework được sử dụng để kích hoạt chức năng lập lịch (scheduling) trong ứng dụng Spring. Khi bạn thêm @EnableScheduling vào một class, nó sẽ tự động cấu
		hình một TaskScheduler để cho phép sử dụng các annotation liên quan đến lập lịch, chẳng hạn như @Scheduled.
		- Sau khi kích hoạt chức năng lập lịch, bạn có thể sử dụng annotation @Scheduled trên các phương thức trong ứng dụng của mình để lên lịch các tác vụ định kỳ.
		- Một số lưu ý khi sử dụng @EnableScheduling:
			Nó yêu cầu bạn sử dụng @Configuration annotation hoặc kích hoạt component scanning để Spring có thể tìm thấy và cấu hình các bean liên quan đến lập lịch.
			Bạn có thể tùy chỉnh cấu hình lập lịch bằng cách cung cấp một TaskScheduler bean riêng.
			@Scheduled annotation hỗ trợ nhiều loại lịch trình khác nhau, chẳng hạn như fixedRate, fixedDelay, cron, v.v.
		
		import org.springframework.context.annotation.Configuration;
		import org.springframework.scheduling.annotation.EnableScheduling;
		@Configuration
		@EnableScheduling
		public class SchedulingConfig {
			// Các bean và cấu hình khác liên quan đến lập lịch
		}
		import org.springframework.scheduling.annotation.Scheduled;
		import org.springframework.stereotype.Component;
		@Component
		public class ScheduledTask {
			@Scheduled(fixedRate = 60000) // Chạy mỗi 60 giây
			public void performTask() {
				// Thực hiện tác vụ ở đây
				System.out.println("Tác vụ định kỳ được thực hiện.");
			}
		}
		
	@EnableSwagger2--Annotation:
	
		- @EnableSwagger2 là một annotation trong Spring được sử dụng để kích hoạt Swagger, một framework giúp tạo và quản lý API documentation cho ứng dụng Spring.
		- Khi bạn thêm @EnableSwagger2 vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết để Swagger hoạt động, bao gồm:
			Servlet để phục vụ Swagger UI
			Swagger Docket bean để cấu hình các thông tin API như title, description, version, etc.
			Các bean khác liên quan đến Swagger như ApiInfoBuilder, Contact, v.v.
		- Sau khi cấu hình Swagger, bạn có thể truy cập Swagger UI tại đường dẫn mặc định /swagger-ui.html. Ví dụ, nếu ứng dụng của bạn chạy trên localhost:8080, thì Swagger UI sẽ có thể truy
		cập tại http://localhost:8080/swagger-ui.html.
		- Một số lưu ý khi sử dụng @EnableSwagger2:
			Bạn có thể tùy chỉnh cấu hình Swagger bằng cách sử dụng các phương thức khác trên Docket bean, chẳng hạn như apiInfo(), useDefaultResponseMessages(), v.v.
			Ngoài ra, bạn cũng có thể sử dụng các annotation như @ApiOperation, @ApiParam, @ApiResponse trên các controller và model để cung cấp thêm thông tin cho Swagger.
			@EnableSwagger2 yêu cầu bạn sử dụng Springfox framework, vì vậy bạn cần thêm các dependency liên quan trong pom.xml hoặc build.gradle của dự án.
		
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import springfox.documentation.builders.PathSelectors;
		import springfox.documentation.builders.RequestHandlerSelectors;
		import springfox.documentation.spi.DocumentationType;
		import springfox.documentation.spring.web.plugins.Docket;
		import springfox.documentation.swagger2.annotations.EnableSwagger2;
		@Configuration
		@EnableSwagger2
		public class SwaggerConfig {
			@Bean
			public Docket api() {
				return new Docket(DocumentationType.SWAGGER_2)
						.select()
						.apis(RequestHandlerSelectors.any())
						.paths(PathSelectors.any())
						.build();
			}
		}
		@EnableSwagger2 kích hoạt Swagger trong ứng dụng.
		Một bean Docket được định nghĩa, cấu hình Swagger để tìm tất cả các controller và generate API documentation.

	@EnableWebSecurity--Annotation:

		- @EnableWebSecurity là một annotation trong Spring Security được sử dụng để kích hoạt và cấu hình bảo mật Web trong ứng dụng Spring.
		- Khi bạn thêm @EnableWebSecurity vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết cho Spring Security, bao gồm:
			HttpSecurity: Cấu hình các chính sách bảo mật cho các endpoint, chẳng hạn như phân quyền, csrf protection, session management, v.v.
			AuthenticationManagerBuilder: Cấu hình các provider để xác thực người dùng, ví dụ như In-Memory Authentication, JDBC Authentication, LDAP Authentication, v.v.
			UserDetailsService: Cung cấp thông tin về người dùng, như tên đăng nhập, mật khẩu, vai trò.
		- Một số lưu ý khi sử dụng @EnableWebSecurity:
			Bạn có thể tùy chỉnh cấu hình bảo mật bằng cách ghi đè các phương thức trong lớp WebSecurityConfigurerAdapter.
			Ngoài In-Memory Authentication, bạn cũng có thể sử dụng các cơ chế xác thực khác như JDBC Authentication, LDAP Authentication, v.v.
			@EnableWebSecurity yêu cầu bạn sử dụng Spring Security, vì vậy bạn cần thêm các dependency liên quan trong pom.xml hoặc build.gradle của dự án.

		import org.springframework.context.annotation.Configuration;
		import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
		import org.springframework.security.config.annotation.web.builders.HttpSecurity;
		import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
		import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
		import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
		@Configuration
		@EnableWebSecurity
		public class SecurityConfig extends WebSecurityConfigurerAdapter {
			@Override
			protected void configure(AuthenticationManagerBuilder auth) throws Exception {
				auth.inMemoryAuthentication()
					.withUser("user")
					.password(passwordEncoder().encode("password"))
					.roles("USER")
					.and()
					.withUser("admin")
					.password(passwordEncoder().encode("admin"))
					.roles("ADMIN");
			}
			@Override
			protected void configure(HttpSecurity http) throws Exception {
				http.authorizeRequests()
					.antMatchers("/admin/**").hasRole("ADMIN")
					.antMatchers("/user/**").hasRole("USER")
					.anyRequest().authenticated()
					.and()
					.formLogin()
					.and()
					.logout();
			}
			public BCryptPasswordEncoder passwordEncoder() {
				return new BCryptPasswordEncoder();
			}
		}
		Lớp SecurityConfig kế thừa từ WebSecurityConfigurerAdapter, cung cấp các phương thức để cấu hình xác thực và ủy quyền.
		Phương thức configure(AuthenticationManagerBuilder) cấu hình In-Memory Authentication, với 2 người dùng "user" và "admin".
		Phương thức configure(HttpSecurity) cấu hình các chính sách bảo mật, chẳng hạn như phân quyền truy cập các endpoint "/admin/" và "/user/".
		Phương thức passwordEncoder() cung cấp một instance của BCryptPasswordEncoder để mã hóa mật khẩu.

	@EnableGlobalMethodSecurity--Annotation:
		
		- @EnableGlobalMethodSecurity là một annotation trong Spring Security được sử dụng để kích hoạt và cấu hình bảo mật phương thức (method-level security) trong ứng dụng Spring.
		- Khi bạn thêm @EnableGlobalMethodSecurity vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết cho Spring Security để áp dụng bảo mật ở mức phương
		thức, bao gồm:
			MethodSecurityInterceptor: Interceptor để chặn các cuộc gọi phương thức và kiểm tra quyền truy cập.
			AccessDecisionManager: Quản lý các quyết định về việc cho phép hay không cho phép truy cập vào phương thức.
			SecurityExpressionHandler: Xử lý các biểu thức an ninh được sử dụng trong các chính sách quyền truy cập.
		- Sau khi cấu hình @EnableGlobalMethodSecurity, bạn có thể sử dụng các chú thích sau trên các phương thức của ứng dụng:
			@PreAuthorize: Kiểm tra quyền truy cập trước khi gọi phương thức.
			@PostAuthorize: Kiểm tra quyền truy cập sau khi gọi phương thức.
			@PreFilter: Lọc các đầu vào trước khi gọi phương thức.
			@PostFilter: Lọc các kết quả trả về từ phương thức.

		import org.springframework.context.annotation.Configuration;
		import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
		import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
		import org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration;
		import org.springframework.security.oauth2.provider.expression.OAuth2MethodSecurityExpressionHandler;
		@Configuration
		@EnableGlobalMethodSecurity(prePostEnabled = true)
		public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
			@Override
			protected MethodSecurityExpressionHandler createExpressionHandler() {
				return new OAuth2MethodSecurityExpressionHandler();
			}
		}			
		Lớp MethodSecurityConfig kế thừ từ GlobalMethodSecurityConfiguration, cung cấp các phương thức để cấu hình bảo mật phương thức.
		Phương thức createExpressionHandler() cung cấp một instance của OAuth2MethodSecurityExpressionHandler, cho phép sử dụng các biểu thức an ninh liên quan đến OAuth2.
		prePostEnabled = true cho phép sử dụng các chú thích như @PreAuthorize và @PostAuthorize trên các phương thức.

		@Service
		public class UserService {
			@PreAuthorize("hasRole('ADMIN')")
			public List<User> getAllUsers() {
				// Implementation
			}
			@PreAuthorize("hasPermission(#id, 'user', 'read')")
			public User getUser(Long id) {
				// Implementation
			}
			@PreAuthorize("hasRole('ADMIN')")
			@PostFilter("filterObject.active == true")
			public List<User> getActiveUsers() {
				// Implementation
			}
		}
		Trong ví dụ trên, phương thức getAllUsers() chỉ có thể được gọi bởi người dùng có vai trò "ADMIN", getUser() yêu cầu quyền "read" trên tài nguyên "user" với ID được cung cấp, và getActiveUsers() trả về danh
		sách người dùng đang hoạt động, nhưng chỉ với người dùng có vai trò "ADMIN".

	@EnableWebSocketMessageBroker--Annotation:

		- @EnableWebSocketMessageBroker là một annotation trong Spring Framework được sử dụng để kích hoạt và cấu hình WebSocket message broker trong ứng dụng Spring.
		- Khi bạn thêm @EnableWebSocketMessageBroker vào một class cấu hình (configuration class) của ứng dụng Spring, nó sẽ tự động cấu hình các bean cần thiết để thiết lập kết nối WebSocket
		và sử dụng message broker để giao tiếp giữa client và server, bao gồm:
			WebSocketMessageBrokerConfigurer: Cấu hình các giải pháp message broker như STOMP, RabbitMQ, Redis, v.v.
			SimpMessageSendingOperations: Cung cấp các phương thức để gửi tin nhắn đến các client đăng ký.
			SimpSubscriptionMappingMethodArgumentResolver: Giải quyết các tham số của phương thức liên quan đến các chủ đề (topic) đăng ký.
		- Sau khi cấu hình @EnableWebSocketMessageBroker, bạn có thể sử dụng các chú thích như @MessageMapping, @SubscribeMapping, @SendTo và @SendToUser trên các phương thức controller để xử lý các
		tin nhắn WebSocket.

		import org.springframework.context.annotation.Configuration;
		import org.springframework.messaging.simp.config.MessageBrokerRegistry;
		import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
		import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
		import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
		@Configuration
		@EnableWebSocketMessageBroker
		public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
			@Override
			public void configureMessageBroker(MessageBrokerRegistry config) {
				config.enableSimpleBroker("/topic", "/queue");
				config.setApplicationDestinationPrefixes("/app");
			}
			@Override
			public void registerStompEndpoints(StompEndpointRegistry registry) {
				registry.addEndpoint("/websocket").withSockJS();
			}
		}
		Lớp WebSocketConfig cài đặt các phương thức để cấu hình message broker và đăng ký các STOMP endpoints.
		Phương thức configureMessageBroker() cấu hình message broker để nhận và gửi tin nhắn đến các chủ đề (topic) và hàng đợi (queue) với các tiền tố "/topic", "/queue" và "/app".
		Phương thức registerStompEndpoints() đăng ký một endpoint STOMP với địa chỉ "/websocket" và sử dụng SockJS fallback options.
		
		import org.springframework.messaging.handler.annotation.MessageMapping;
		import org.springframework.messaging.handler.annotation.SendTo;
		import org.springframework.stereotype.Controller;
		@Controller
		public class ChatController {
			@MessageMapping("/chat.sendMessage")
			@SendTo("/topic/public")
			public ChatMessage sendMessage(ChatMessage chatMessage) {
				return chatMessage;
			}
		}		

	@EqualsAndHashCode--Annotation:

		- @EqualsAndHashCode là một annotation trong Spring Data Lombok, một thư viện tiện ích giúp giảm bớt code boilerplate trong Java. Annotation này được sử dụng để tự động tạo phương thức
		equals() và hashCode() cho các lớp Java.
		- Khi bạn thêm @EqualsAndHashCode vào một lớp, Lombok sẽ tự động tạo các phương thức equals() và hashCode() dựa trên các trường của lớp đó. Điều này giúp bạn tiết kiệm thời gian và công
		sức khi làm việc với các lớp Java.
		- Ngoài ra, @EqualsAndHashCode còn có một số tùy chọn để bạn có thể tùy chỉnh cách tạo các phương thức equals() và hashCode(), chẳng hạn như:
			callSuper: Gọi phương thức equals() và hashCode() của lớp cha.
			exclude: Loại trừ một số trường khỏi việc tạo equals() và hashCode().
			of: Chỉ sử dụng một số trường cụ thể để tạo equals() và hashCode().

		import lombok.EqualsAndHashCode;
		import lombok.Getter;
		import lombok.Setter;
		@Getter
		@Setter
		@EqualsAndHashCode
		public class User {
			private Long id;
			private String name;
			private String email;
		}
		Trong ví dụ trên, chúng ta sử dụng @EqualsAndHashCode để tự động tạo các phương thức equals() và hashCode() dựa trên các trường id, name và email của lớp User.
		Khi bạn tạo một instance của lớp User và so sánh chúng, Lombok sẽ sử dụng các phương thức equals() và hashCode() được tạo tự động để so sánh các trường của các instance.
		
		User user1 = new User();
		user1.setId(1L);
		user1.setName("John Doe");
		user1.setEmail("john.doe@example.com");
		User user2 = new User();
		user2.setId(1L);
		user2.setName("John Doe");
		user2.setEmail("john.doe@example.com");
		System.out.println(user1.equals(user2)); // true
		System.out.println(user1.hashCode() == user2.hashCode()); // true		
		Trong ví dụ trên, hai instance user1 và user2 có cùng giá trị cho các trường id, name và email, nên chúng được coi là bằng nhau khi sử dụng equals() và hashCode().
		
	@Email--Annotation:

		- @Email là một annotation trong Spring Validation, một thư viện để định nghĩa và xác thực các ràng buộc đối với các thuộc tính của một lớp Java.
		- Annotation @Email được sử dụng để đảm bảo rằng một giá trị thuộc tính là một địa chỉ email hợp lệ. Khi bạn sử dụng @Email trên một trường, Spring Validation sẽ tự động kiểm tra xem giá trị của
		trường đó có phải là một địa chỉ email hợp lệ hay không.
		- Ngoài ra, @Email cũng có một số tùy chọn để bạn có thể tùy chỉnh cách xác thực địa chỉ email, chẳng hạn như:
			regexp: Cung cấp một regular expression tùy chỉnh để xác thực địa chỉ email.
			flags: Cung cấp các flag để điều chỉnh cách xác thực regular expression.
			message: Cung cấp một thông báo lỗi tùy chỉnh khi địa chỉ email không hợp lệ.

		import javax.validation.constraints.Email;
		import javax.validation.constraints.NotBlank;
		public class UserDTO {
			@NotBlank
			private String name;
			@NotBlank
			@Email
			private String email;
			// Getters, setters, and other methods
		}
		Trong ví dụ trên, chúng ta sử dụng @Email để đảm bảo rằng giá trị của trường email phải là một địa chỉ email hợp lệ. Ngoài ra, chúng ta cũng sử dụng @NotBlank để đảm bảo rằng trường name
		và email không được để trống.
		Khi bạn gửi một instance của UserDTO đến một controller trong Spring MVC, Spring Validation sẽ tự động kiểm tra các ràng buộc được định nghĩa trên các trường, bao gồm cả ràng buộc @Email. Nếu
		một trường không đáp ứng ràng buộc, Spring Validation sẽ tạo ra một validation error, và bạn có thể xử lý lỗi này trong controller.

		@PostMapping("/users")
		public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
			// Handle the validated user DTO and create a new user
			User newUser = userService.createUser(userDTO);
			return ResponseEntity.status(HttpStatus.CREATED).body(newUser);
		}
		Trong ví dụ trên, khi gửi một request với một UserDTO không hợp lệ (ví dụ, email không hợp lệ), Spring Validation sẽ tạo ra một validation error, và controller sẽ không thể xử lý request này.

	@JsonProperty--Annotation:

		- @JsonProperty là một annotation trong Spring MVC và Spring Boot, được sử dụng để định nghĩa tên của một thuộc tính khi chuyển đổi giữa Java objects và JSON formats.
		- Khi bạn sử dụng @JsonProperty trên một trường hoặc getter/setter method trong một Java class, nó sẽ chỉ định tên của thuộc tính JSON tương ứng. Điều này rất hữu ích khi tên của thuộc tính
		Java khác với tên của thuộc tính JSON.
		- Ngoài việc sử dụng @JsonProperty để đặt tên của các thuộc tính JSON, bạn cũng có thể sử dụng nó để:
			Đổi tên một thuộc tính JSON khi serializing/deserializing
			Bỏ qua một thuộc tính khi serializing/deserializing
			Chỉ định thứ tự của các thuộc tính JSON

		public class UserDTO {
			private int userId;
			@JsonProperty("user_name")
			private String userName;
			@JsonProperty("email_address")
			private String emailAddress;
			// Getters, setters, and other methods
		}
		Trong ví dụ trên, chúng ta có ba thuộc tính: userId, userName, và emailAddress. Khi chuyển đổi một instance của UserDTO sang JSON, các tên của thuộc tính JSON sẽ là "user_name" và
		"email_address", thay vì sử dụng tên của các trường Java.
		
		{
			"userId": 1,
			"user_name": "John Doe",
			"email_address": "john.doe@example.com"
		}
		Khi serializing một instance của UserDTO sang JSON
		Ngược lại, khi deserializing JSON data trở lại thành một instance của UserDTO, Spring sẽ tự động ánh xạ các thuộc tính JSON với các trường Java dựa trên tên được định nghĩa bởi @JsonProperty.
		
		public class UserDTO {
			@JsonProperty(value = "user_id", index = 0)
			private int userId;
			@JsonProperty(value = "full_name", index = 1)
			private String fullName;
			@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
			private String password;
		}
		@JsonProperty(value = "user_id", index = 0) sẽ đặt tên của thuộc tính JSON là "user_id" và chỉ định nó sẽ được serialized/deserialized đầu tiên.
		@JsonProperty(value = "full_name", index = 1) sẽ đặt tên của thuộc tính JSON là "full_name" và chỉ định nó sẽ được serialized/deserialized sau "user_id".
		@JsonProperty(access = JsonProperty.Access.WRITE_ONLY) sẽ bỏ qua thuộc tính password khi serializing (từ Java object sang JSON), nhưng vẫn cho phép nó
		được deserialize (từ JSON sang Java object).

	@JsonCreator--Annotation:
	
		- Trong Spring, đặc biệt là khi làm việc với Jackson để xử lý JSON, annotation @JsonCreator được sử dụng để chỉ định một hàm tạo (constructor) hoặc phương thức factory nào đó sẽ được sử dụng để
		khởi tạo một đối tượng từ JSON. Điều này rất hữu ích khi bạn cần kiểm soát cách thức mà Jackson tạo ra các đối tượng khi giải mã (deserialization) JSON thành các đối tượng Java.
		- Cách sử dụng @JsonCreator
			Constructor-based Deserialization: Bạn có thể sử dụng @JsonCreator trên constructor để chỉ định rằng constructor đó sẽ được sử dụng khi tạo đối tượng từ JSON.
			Factory Method-based Deserialization: Ngoài constructor, bạn cũng có thể sử dụng @JsonCreator trên một phương thức tĩnh (static factory method) để chỉ định rằng
			phương thức này sẽ được sử dụng để tạo đối tượng từ JSON.
			
		import com.fasterxml.jackson.annotation.JsonCreator;
		import com.fasterxml.jackson.annotation.JsonProperty;
		public class Person {
			private String name;
			private int age;
			@JsonCreator
			public Person(@JsonProperty("name") String name, @JsonProperty("age") int age) {
				this.name = name;
				this.age = age;
			}
			// Getters and setters
		}
		@JsonCreator được dùng để chỉ định rằng constructor này sẽ được sử dụng cho quá trình deserialization.
		@JsonProperty được sử dụng để ánh xạ các trường JSON tới các tham số của constructor.
		Với cấu trúc JSON như sau, Jackson sẽ sử dụng constructor đã được chỉ định để tạo đối tượng Person:
			{
			  "name": "John",
			  "age": 30
			}
			
	@JsonTypeInfo--Annotation:
	
		- Trong Spring (thường khi kết hợp với Jackson để xử lý JSON), annotation @JsonTypeInfo được sử dụng để thêm thông tin về kiểu (type) vào JSON khi thực hiện serialization (tuần tự hóa)
		và deserialization (giải tuần tự hóa). Annotation này rất hữu ích trong các tình huống mà bạn cần xử lý đa hình (polymorphism), chẳng hạn như khi bạn có một lớp cha (superclass) và nhiều
		lớp con (subclasses), và bạn muốn Jackson biết phải khởi tạo kiểu nào khi giải mã JSON.
		- Cách sử dụng @JsonTypeInfo
			use: Chỉ định cách thức mà thông tin kiểu được chỉ định. Một số giá trị phổ biến là:
				JsonTypeInfo.Id.CLASS: Sử dụng tên lớp Java hoàn chỉnh.
				JsonTypeInfo.Id.NAME: Sử dụng tên định nghĩa tùy chỉnh cho mỗi lớp.
				JsonTypeInfo.Id.MINIMAL_CLASS: Sử dụng tên lớp Java nhưng ở dạng rút gọn (minimal).
				JsonTypeInfo.Id.NONE: Không sử dụng thông tin kiểu.
			include: Chỉ định vị trí của thông tin kiểu trong JSON. Một số giá trị phổ biến là:
				JsonTypeInfo.As.PROPERTY: Thêm một thuộc tính vào JSON để chỉ định thông tin kiểu.
				JsonTypeInfo.As.WRAPPER_OBJECT: Bao bọc đối tượng trong một đối tượng JSON để chỉ định thông tin kiểu.
				JsonTypeInfo.As.EXTERNAL_PROPERTY: Thông tin kiểu được cung cấp bên ngoài đối tượng thực tế.
				JsonTypeInfo.As.EXISTING_PROPERTY: Sử dụng một thuộc tính hiện có để chỉ định thông tin kiểu.
			property: Tên của thuộc tính JSON được sử dụng để lưu trữ thông tin kiểu (chỉ khi include là PROPERTY hoặc EXISTING_PROPERTY).
			defaultImpl: Chỉ định một lớp mặc định nếu không có thông tin kiểu nào khớp trong quá trình deserialization.
			
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		@JsonTypeInfo(
		  use = JsonTypeInfo.Id.NAME, 
		  include = JsonTypeInfo.As.PROPERTY, 
		  property = "type"
		)
		public abstract class Animal {
			private String name;
			// Constructor, getters, and setters
		}
		public class Dog extends Animal {
			private String breed;
			// Constructor, getters, and setters
		}
		public class Cat extends Animal {
			private int lives;
			// Constructor, getters, and setters
		}
		@JsonTypeInfo được sử dụng trên lớp cha Animal.
		use = JsonTypeInfo.Id.NAME chỉ định rằng chúng ta sẽ sử dụng tên định nghĩa (như "Dog" hoặc "Cat") để biểu thị kiểu của đối tượng.
		include = JsonTypeInfo.As.PROPERTY chỉ định rằng thông tin kiểu sẽ được thêm như một thuộc tính JSON riêng biệt.
		property = "type" chỉ định tên thuộc tính JSON ("type") sẽ chứa thông tin kiểu.
		Với cấu hình này, khi chúng ta thực hiện serialization của một đối tượng Dog hoặc Cat, JSON kết quả sẽ trông như sau:
			{
			  "type": "Dog",
			  "name": "Buddy",
			  "breed": "Golden Retriever"
			}
			hoặc
			{
			  "type": "Cat",
			  "name": "Whiskers",
			  "lives": 9
			}

				
	
	@Log4j2--Annotation:

		- @Log4j2 là một annotation trong Spring Boot, được sử dụng để tạo ra một Logger instance tự động cho một class, mà không cần phải khai báo và khởi tạo nó một cách thủ công.
		- Khi bạn sử dụng @Log4j2 trên một class, Spring Boot sẽ tự động tạo ra một Logger instance với tên tương ứng với tên của class đó, và bạn có thể sử dụng Logger instance này để ghi log trong class.
		- Một số ưu điểm của việc sử dụng @Log4j2:
				Giảm Boilerplate Code: Bạn không cần phải khai báo và khởi tạo Logger instance một cách thủ công. @Log4j2 làm việc này tự động cho bạn.
				Đặt tên Logger tự động: Tên của Logger instance sẽ tự động được đặt dựa trên tên của class.
				Tích hợp tốt với Spring Boot: @Log4j2 hoạt động rất tốt với Spring Boot và có thể được sử dụng trong các ứng dụng Spring Boot.
				Sử dụng Log4j2 Library: @Log4j2 sử dụng thư viện Log4j2 để cung cấp các tính năng logging mạnh mẽ.
		
		import org.springframework.stereotype.Service;
		import org.apache.logging.log4j.LogManager;
		import org.apache.logging.log4j.Logger;
		@Service
		@Log4j2
		public class MyService {
			// Logger instance is automatically created and available as "log"
			public void doSomething() {
				log.info("Doing something...");
				try {
					// Some business logic
				} catch (Exception e) {
					log.error("Error occurred", e);
				}
			}
		}
		Trong ví dụ trên, chúng ta có một MyService class, được đánh dấu bằng @Log4j2. Bây giờ, một Logger instance với tên log sẽ được tự động tạo ra và có thể được sử dụng trong các phương thức của class.

	@Modifying--Annotation:

		- @Modifying là một annotation trong Spring Data JPA, được sử dụng để chỉ định rằng một phương thức trong interface Repository sẽ thực hiện một phép
		sửa đổi (insert, update, delete) trong cơ sở dữ liệu.
		- Khi bạn sử dụng @Modifying, Spring sẽ biết rằng phương thức này không chỉ đơn giản là truy vấn dữ liệu, mà còn có tác dụng thay đổi dữ liệu trong cơ
		sở dữ liệu. Điều này cho phép Spring thực hiện một số xử lý đặc biệt, chẳng hạn như:
			Transaction Management: Spring sẽ tự động bắt đầu một transaction trước khi thực hiện phương thức sửa đổi và commit transaction sau khi hoàn thành. Điều này
			đảm bảo tính nhất quán và an toàn của dữ liệu.
			Clearing Cache: Nếu bạn đang sử dụng caching trong ứng dụng, Spring sẽ tự động xóa các mục liên quan từ cache sau khi thực hiện phương thức sửa đổi. Điều này
			đảm bảo rằng dữ liệu trong cache luôn được cập nhật.
			Flush Mode: Spring sẽ tự động đảm bảo rằng các thay đổi được đẩy về cơ sở dữ liệu ngay lập tức sau khi phương thức sửa đổi được gọi.
		- Lưu ý rằng chúng ta cũng sử dụng @Transactional annotation để đảm bảo rằng transaction được quản lý đúng cách. Điều này là cần thiết khi sử dụng @Modifying.
		- Sử dụng @Modifying giúp bạn tránh các lỗi liên quan đến transaction và cache mà không cần phải xử lý chúng một cách thủ công. Điều này làm cho code của bạn trở
		nên gọn gàng và dễ bảo trì hơn.

		import org.springframework.data.jpa.repository.JpaRepository;
		import org.springframework.data.jpa.repository.Modifying;
		import org.springframework.data.jpa.repository.Query;
		import org.springframework.transaction.annotation.Transactional;
		public interface UserRepository extends JpaRepository<User, Long> {
			@Modifying
			@Transactional
			@Query("UPDATE User u SET u.email = :newEmail WHERE u.id = :userId")
			int updateUserEmail(Long userId, String newEmail);
			@Modifying
			@Transactional
			@Query("DELETE FROM User u WHERE u.id = :userId")
			int deleteUserById(Long userId);
		}
		updateUserEmail: Phương thức này được sử dụng để cập nhật email của một người dùng dựa trên ID. Khi gọi phương thức này, Spring sẽ tự động bắt đầu một transaction,
		cập nhật dữ liệu trong cơ sở dữ liệu, và commit transaction sau khi hoàn thành.
		deleteUserById: Phương thức này được sử dụng để xóa một người dùng dựa trên ID. Tương tự, Spring sẽ tự động xử lý transaction và các cập nhật cache (nếu có) khi
		phương thức này được gọi.

	@EnableDiscoveryClient--Annotation:

		- @EnableDiscoveryClient là một annotation trong Spring Cloud, được sử dụng để kích hoạt tính năng Discovery Client trong ứng dụng của bạn.
		- Discovery Client là một thành phần quan trọng trong việc xây dựng các hệ thống phân tán, microservices-based. Nó giúp các dịch vụ có thể tự động phát hiện và giao
		tiếp với các dịch vụ khác trong hệ thống, mà không cần phải cấu hình tĩnh địa chỉ IP hoặc hostname.
		- Khi bạn sử dụng @EnableDiscoveryClient, Spring Cloud sẽ tự động:
			Đăng ký dịch vụ: Ứng dụng của bạn sẽ được đăng ký với Discovery Server (như Eureka, Consul, hoặc Zookeeper) để các dịch vụ khác có thể tìm và gọi nó.
			Khám phá dịch vụ: Ứng dụng của bạn sẽ có khả năng tự động khám phá và giao tiếp với các dịch vụ khác đã được đăng ký với Discovery Server.
			Load Balancing: Khi gọi các dịch vụ khác, ứng dụng của bạn sẽ được hỗ trợ load balancing tự động, giúp phân tải đều giữa các instances của dịch vụ.
			Health Checking: Ứng dụng của bạn sẽ được giám sát và kiểm tra tình trạng sức khỏe (health checks) định kỳ bởi Discovery Server.
		- Sử dụng @EnableDiscoveryClient giúp đơn giản hóa việc xây dựng các hệ thống phân tán, microservices-based bằng cách tự động xử lý các vấn đề như discovery, load balancing và
		health checking. Điều này giúp code của bạn trở nên sáng sủa, dễ bảo trì và mở rộng hơn.

		import org.springframework.boot.SpringApplication;
		import org.springframework.boot.autoconfigure.SpringBootApplication;
		import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
		@SpringBootApplication
		@EnableDiscoveryClient
		public class MyApplication {
			public static void main(String[] args) {
				SpringApplication.run(MyApplication.class, args);
			}
		}
		Trong ví dụ này, chúng ta đánh dấu class MyApplication với @EnableDiscoveryClient. Điều này sẽ kích hoạt tính năng Discovery Client trong ứng dụng, cho phép nó tự động đăng ký và khám phá
		các dịch vụ khác trong hệ thống.

		spring:
		  application:
			name: my-service
		  cloud:
			discovery:
			  client:
				simple:
				  instances:
					my-service:
					  - http://localhost:8080
		Để hoạt động, ứng dụng cần được cấu hình để kết nối với Discovery Server. Điều này có thể được thực hiện bằng cách thêm các cấu hình liên quan trong file application.properties hoặc application.yml
		Trong cấu hình trên, chúng ta đã cung cấp thông tin về dịch vụ (my-service) và địa chỉ endpoint của nó (http://localhost:8080). Khi ứng dụng khởi động, nó sẽ tự động đăng ký với Discovery Server
		và các dịch vụ khác có thể tìm và giao tiếp với nó.

	@Transient--Annotation:
	
		- @Transient là một annotation trong Spring được sử dụng để đánh dấu một trường trong một entity class sẽ không được lưu vào cơ sở dữ liệu. Nó thường được sử dụng khi bạn có một số trường dữ liệu
		trong class mà không cần lưu trữ chúng trong cơ sở dữ liệu.
		- Một số trường hợp khác khi sử dụng @Transient:
			Tính toán dữ liệu: Bạn có thể sử dụng @Transient cho các trường tính toán được dựa trên các trường khác trong entity.
			Dữ liệu tạm thời: Các trường lưu trữ dữ liệu tạm thời, không liên quan đến cơ sở dữ liệu.
			Bảo mật: Bạn có thể sử dụng @Transient cho các trường chứa thông tin nhạy cảm như mật khẩu hoặc token, để chúng không được lưu trữ trong cơ sở dữ liệu.
		- Tóm lại, @Transient là một annotation hữu ích trong Spring, cho phép bạn loại bỏ các trường không cần thiết khỏi việc lưu trữ trong cơ sở dữ liệu, giúp cải thiện hiệu suất và bảo mật của ứng dụng.

		@Entity
		@Table(name = "users")
		public class User {
			@Id
			@GeneratedValue(strategy = GenerationType.IDENTITY)
			private Long id;
			private String username;
			private String password;
			@Transient
			private String confirmPassword;
			// getters, setters, and other methods
		}
		Trong ví dụ này, confirmPassword là một trường tạm thời, không cần được lưu trữ trong cơ sở dữ liệu. Nó chỉ được sử dụng trong logic của ứng dụng, như để xác nhận mật khẩu khi người dùng đăng ký.
		Lưu ý rằng, @Transient chỉ ảnh hưởng đến việc lưu trữ dữ liệu trong cơ sở dữ liệu, nhưng không ảnh hưởng đến việc sử dụng trường này trong logic ứng dụng. Trường confirmPassword vẫn có thể được
		sử dụng trong các phương thức của entity class và trong controller.
		Trong ví dụ này, confirmPassword là một trường tạm thời, không cần được lưu trữ trong cơ sở dữ liệu. Nó chỉ được sử dụng trong logic của ứng dụng, như để xác nhận mật khẩu khi người dùng đăng ký.

	@NoArgsContructor--Annotation:
	
		- @NoArgsConstructor là một annotation trong Spring được sử dụng để tự động tạo một constructor không tham số (no-args constructor) cho một class.
		- Khi bạn áp dụng @NoArgsConstructor trên một class, Spring sẽ tự động tạo một constructor không tham số cho class đó, ngay cả khi bạn không định nghĩa nó trong code.
		- Sử dụng @NoArgsConstructor có một số lợi ích:
			Tạo đối tượng mới: Khi bạn cần tạo một đối tượng mới của class, constructor không tham số sẽ rất hữu ích, ví dụ như khi sử dụng new User().
			Tích hợp với các framework: Nhiều framework như Spring, Hibernate, và các thư viện khác sử dụng constructor không tham số để tạo và thao tác với các đối tượng. Sử
			dụng @NoArgsConstructor sẽ đảm bảo rằng framework có thể hoạt động đúng cách với class của bạn.
			Serialization và deserialization: Các quá trình serialization và deserialization thường yêu cầu một constructor không tham số để tạo đối tượng mới. @NoArgsConstructor giúp
			đơn giản hóa việc này.
		- Lưu ý rằng, nếu bạn định nghĩa một constructor có tham số cho class, Spring sẽ không tự động tạo constructor không tham số. Trong trường hợp này, bạn có thể sử
		dụng @NoArgsConstructor(force = true) để buộc Spring tạo constructor không tham số.
		- Tóm lại, @NoArgsConstructor là một annotation hữu ích trong Spring để đơn giản hóa việc tạo và quản lý các đối tượng, đặc biệt khi làm việc với các framework và quá trình serialization.

		@Entity
		@Table(name = "users")
		@NoArgsConstructor
		public class User {
			@Id
			@GeneratedValue(strategy = GenerationType.IDENTITY)
			private Long id;
			private String username;
			private String email;
			public User(String username, String email) {
				this.username = username;
				this.email = email;
			}
			// Getters, setters, and other methods
		}
		Trong ví dụ trên, class User có một constructor có tham số và một constructor không tham số. Tuy nhiên, nhờ có @NoArgsConstructor, Spring sẽ tự động tạo ra constructor không tham số cho class này, ngay cả
		khi bạn không định nghĩa nó.

	@AllArgsConstructor--Annotation:
	
		- @AllArgsConstructor là một annotation Lombok, được sử dụng để tự động tạo một constructor có tất cả các tham số của một class. Nó sẽ tạo một constructor với tất cả
		các trường của class làm tham số.
		- Sử dụng @AllArgsConstructor có các lợi ích sau:
			Giảm code boilerplate: Bạn không cần phải tự định nghĩa constructor có tất cả các tham số, Lombok sẽ tự động tạo nó cho bạn.
			Tích hợp với các framework: Nhiều framework như Spring, Hibernate yêu cầu constructor có tất cả các trường làm tham số. @AllArgsConstructor giúp đơn giản hóa việc này.
			Tăng tính rõ ràng: Khi tạo một đối tượng mới, bạn sẽ biết chính xác các trường cần được khởi tạo.

		import lombok.AllArgsConstructor;
		import lombok.Data;
		@Data
		@AllArgsConstructor
		public class User {
			private Long id;
			private String username;
			private String email;
		}
		
		Trong ví dụ trên, Lombok sẽ tự động tạo một constructor có tất cả các trường của class User làm tham số:
		public User(Long id, String username, String email) {
			this.id = id;
			this.username = username;
			this.email = email;
		}

	@Documented--Annotation:
	
		- Trong Spring, @Documented là một annotation được sử dụng để đánh dấu các annotation khác. Nó không có bất kỳ tác dụng trực tiếp nào đối với các class, method, hay field
		được đánh dấu. Thay vào đó, nó đóng vai trò như một metatag để chỉ ra rằng annotation được gắn với nó sẽ được bao gồm trong Javadoc của phần tử được anotationed.
		- Tóm lại, @Documented là một annotation meta-annotation trong Spring, được sử dụng để đánh dấu các annotation khác nhằm đảm bảo chúng được bao gồm trong Javadoc của các phần tử được anotationed.
		- Một số ứng dụng của @JsonIgnoreProperty:
			Loại bỏ các thuộc tính nhạy cảm như mật khẩu, token, v.v. khỏi JSON output: Điều này giúp tăng cường bảo mật cho ứng dụng.
			
		
		@Documented
		@Retention(RetentionPolicy.RUNTIME)
		@Target({ElementType.TYPE, ElementType.METHOD})
		public @interface MyCustomAnnotation {
			String value();
		}	
		Khi bạn sử dụng @MyCustomAnnotation trên một class hoặc method, thông tin về annotation này sẽ được hiển thị trong Javadoc của phần tử được anotationed. Điều này giúp người dùng
		dễ dàng nhận biết và hiểu được ý nghĩa của annotation.
		Ngoài ra, @Documented cũng có thể được sử dụng với các annotation có sẵn trong Spring, như @Component, @Service, @Repository, v.v. Điều này giúp các annotation này được lưu lại
		trong Javadoc của các class, method, và field được đánh dấu.
		Việc sử dụng @Documented không làm thay đổi bất kỳ hành vi hay tính năng nào của các annotation. Thay vào đó, nó chỉ đơn giản là một cách để đảm bảo rằng các annotation được
		lưu lại và hiển thị trong các tài liệu Javadoc.


	@JsonIgnoreProperty--Annotation:
	
		- Annotation @JsonIgnoreProperty trong Spring được sử dụng để chỉ định các thuộc tính của một class sẽ bị bỏ qua khi serialize/deserialize JSON.
		- Một số ứng dụng của @JsonIgnoreProperty:
			Loại bỏ các thuộc tính nhạy cảm như mật khẩu, token, v.v. khỏi JSON output: Điều này giúp tăng cường bảo mật cho ứng dụng.
			Bỏ qua các thuộc tính không cần thiết khi serialize/deserialize: Giúp giảm kích thước dữ liệu được truyền đi.
			Xử lý các trường hợp không tương thích giữa cấu trúc JSON và class: Ví dụ khi JSON có thuộc tính không khớp với class.
		
		public class User {
			private int id;
			private String name;
			@JsonIgnoreProperty
			private String password;
			private String email;
		}
		Khi serialize một đối tượng User thành JSON, thuộc tính password sẽ không được bao gồm trong JSON output:
		{
			"id": 1,
			"name": "John Doe",
			"email": "john.doe@example.com"
		}
		Ngược lại, khi deserialize một JSON object thành đối tượng User, thuộc tính password sẽ không được gán giá trị.

	@EntityScan--Annotation:
	
		- Annotation @EntityScan trong Spring là một annotation dùng để chỉ định các package chứa các thực thể (entity) JPA trong ứng dụng.
		- Khi sử dụng JPA (Java Persistence API) trong một ứng dụng Spring, Spring sẽ cần biết các entity class được sử dụng trong ứng dụng để có thể quản lý và thao tác với
		chúng. Thông thường, Spring sẽ tự động quét các package để tìm các entity class, nhưng trong một số trường hợp, chúng ta cần chỉ định rõ ràng các package chứa các entity.
		- Ngoài ra, @EntityScan cũng có thể được sử dụng để chỉ định các entity class cụ thể
		- Annotation @EntityScan thường được sử dụng khi:
			Các entity class không được đặt trong package mặc định hoặc các package con của package gốc.
			Cần chỉ định danh sách các entity class cụ thể.
			Muốn tách biệt các entity class thành các package riêng biệt.

		@SpringBootApplication
		@EntityScan(basePackages = {"com.example.myapp.entities"})
		public class MyApplication {
			// ...
		}	
		Trong ví dụ trên, @EntityScan chỉ định rằng các entity class được định nghĩa trong package com.example.myapp.entities và các sub-package của nó.

		@SpringBootApplication
		@EntityScan(basePackageClasses = {User.class, Order.class})
		public class MyApplication {
			// ...
		}
		Trong trường hợp này, Spring sẽ quét các package chứa các class User và Order để tìm các entity class.

	@EnableJpaRepositories--Annotation:
	
		- Annotation @EnableJpaRepositories trong Spring là một annotation dùng để kích hoạt tính năng JPA Repository trong một ứng dụng Spring.
		- Khi sử dụng JPA (Java Persistence API) trong ứng dụng Spring, chúng ta thường sử dụng các Repository interface để thực hiện các thao tác
		CRUD (Create, Read, Update, Delete) trên các entity. Spring Data JPA cung cấp một cách tiếp cận rất tiện lợi để triển khai các Repository interface này.
		- Annotation @EnableJpaRepositories cho phép Spring tự động tạo ra các implementation classes cho các interface Repository, dựa trên các quy ước đặt
		tên và các phương thức được định nghĩa trong interface.
		- Ngoài ra, @EnableJpaRepositories cũng có một số tùy chọn khác như:
			entityManagerFactoryRef: Tham chiếu đến bean EntityManagerFactory cần sử dụng.
			transactionManagerRef: Tham chiếu đến bean PlatformTransactionManager cần sử dụng.
			repositoryImplementationPostfix: Đặt hậu tố cho các implementation class của Repository.
		- Annotation @EnableJpaRepositories là một phần quan trọng trong việc cấu hình và kích hoạt tính năng JPA Repository trong ứng dụng Spring. Nó giúp đơn giản
		hóa quá trình triển khai các Repository interface và tự động tạo ra các implementation class.
		
		@SpringBootApplication
		@EnableJpaRepositories(basePackages = "com.example.myapp.repositories")
		public class MyApplication {
			// ...
		}	
		Trong ví dụ trên, @EnableJpaRepositories chỉ định rằng các interface Repository được định nghĩa trong package com.example.myapp.repositories và các sub-package của nó.

		@SpringBootApplication
		@EnableJpaRepositories(
			basePackages = "com.example.myapp.repositories",
			entityManagerFactoryRef = "customEntityManagerFactory",
			transactionManagerRef = "customTransactionManager"
		)
		public class MyApplication {
			// ...
		}
		Trong ví dụ trên, @EnableJpaRepositories chỉ định rằng các Repository interface được định nghĩa trong package com.example.myapp.repositories, sử dụng
		customEntityManagerFactory và customTransactionManager beans.


	@Retention--Annotation:
	
		- Annotation @Retention trong Java (và cũng được sử dụng trong Spring) là một annotation dùng để chỉ định ở mức độ nào (retention policy) một annotation có thể được giữ lại.
		- Có 3 mức độ retention policy được xác định bởi @Retention:
			SOURCE: Annotation chỉ tồn tại ở mức mã nguồn (source code) và sẽ bị bỏ đi khi được biên dịch.
			CLASS: Annotation sẽ được lưu trong file class, nhưng không được runtime environment sử dụng.
			RUNTIME: Annotation sẽ được lưu trong file class và có thể được runtime environment sử dụng, ví dụ như Spring có thể truy cập và sử dụng các annotation này.
		- Ví dụ, trong Spring, một số annotation phổ biến sử dụng @Retention(RetentionPolicy.RUNTIME) như:
			@Component: Đánh dấu một class là một Spring bean.
			@Autowired: Đánh dấu một field, constructor hoặc method để Spring tự động wired dependency.
			@RequestMapping: Đánh dấu một method trong controller class để định nghĩa URL mapping.
		- Bằng cách sử dụng @Retention(RetentionPolicy.RUNTIME), Spring có thể truy cập và sử dụng các annotation này trong quá trình khởi chạy và chạy ứng dụng.
		- Trong khi đó, một số annotation khác chỉ cần tồn tại ở mức mã nguồn, ví dụ như:
			@Deprecated: Đánh dấu một phần của code là đã lỗi thời và không nên sử dụng.
			@SuppressWarnings: Chỉ thị cho trình biên dịch bỏ qua một số cảnh báo.
		- Những annotation này sử dụng @Retention(RetentionPolicy.SOURCE) vì chúng chỉ cần được biên dịch, chứ không cần được runtime environment sử dụng.
		- Việc lựa chọn mức độ retention policy phù hợp là rất quan trọng trong quá trình thiết kế và sử dụng annotation, bởi vì nó ảnh hưởng đến việc annotation đó có thể được truy
		cập và sử dụng ở các giai đoạn khác nhau của vòng đời ứng dụng.
		- Khi bạn muốn tạo một annotation tùy chỉnh trong Java, bạn có thể sử dụng @Retention để chỉ định thời gian tồn tại của nó.
		
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		// Định nghĩa annotation tùy chỉnh
		@Retention(RetentionPolicy.RUNTIME)
		public @interface MyCustomAnnotation {
			String value();
		}
		Trong ví dụ này, annotation MyCustomAnnotation sẽ tồn tại tại runtime, có nghĩa là nó có thể được truy cập thông qua reflection.

	@TaskFlowOder--Annotation:

		- Trong Spring, chúng ta có thể sử dụng @TaskFlowOrder để chỉ định thứ tự thực hiện của các task trong một flow.
		- Để sử dụng @TaskFlowOrder, ta cần:
			Trong lớp định nghĩa task, thêm @TaskFlowOrder(n) với n là số nguyên chỉ định thứ tự thực hiện.
			Trong lớp chủ quản (ví dụ: controller, service, etc.) gọi các task theo thứ tự đã được chỉ định bằng @TaskFlowOrder.
		- Việc sử dụng @TaskFlowOrder giúp ta dễ dàng quản lý và kiểm soát thứ tự thực hiện các task trong một flow, đồng thời cũng giúp code trở nên dễ đọc và bảo trì hơn.
		- Annotation @TaskFlowOrder trong Spring có các thuộc tính sau:
			value: Một số nguyên dương chỉ định thứ tự thực hiện của task. Các task sẽ được thực hiện theo thứ tự tăng dần của giá trị value.
			description: Một chuỗi mô tả về task. Thuộc tính này không ảnh hưởng đến thứ tự thực hiện, mà chỉ dùng để mô tả và lưu trữ thông tin về task.
			dependencies: Một mảng các class để chỉ định các task mà task hiện tại phụ thuộc vào. Khi sử dụng thuộc tính này, Spring sẽ đảm bảo các task phụ
			thuộc được thực hiện trước khi thực hiện task hiện tại.

		@Component
		@TaskFlowOrder(1)
		public class Task1 implements TaskExecutor {
			// Implement the logic for Task1
		}
		@Component
		@TaskFlowOrder(2)
		public class Task2 implements TaskExecutor {
			// Implement the logic for Task2
		}
		@Component
		@TaskFlowOrder(3)
		public class Task3 implements TaskExecutor {
			// Implement the logic for Task3
		}
		Trong ví dụ trên, Task1 sẽ được thực hiện trước Task2, và Task2 sẽ được thực hiện trước Task3.

		@Service
		public class TaskFlowService {
			private final List<TaskExecutor> taskExecutors;
			public TaskFlowService(List<TaskExecutor> taskExecutors) {
				this.taskExecutors = taskExecutors;
			}
			public void executeTaskFlow() {
				taskExecutors.stream()
						.sorted(Comparator.comparingInt(t -> t.getClass().getAnnotation(TaskFlowOrder.class).value()))
						.forEach(TaskExecutor::execute);
			}
		}	
		Trong ví dụ trên, chúng ta sử dụng Stream và sorted() để sắp xếp các TaskExecutor theo thứ tự được chỉ định bằng @TaskFlowOrder, sau đó gọi phương
		thức execute() của từng task theo đúng thứ tự.
		
		@Component
		@TaskFlowOrder(1)
		public class Task1 implements TaskExecutor {
			// Implement the logic for Task1
		}
		@Component
		@TaskFlowOrder(2)
		public class Task2 implements TaskExecutor {
			// Implement the logic for Task2
		}
		
		@Component
		@TaskFlowOrder(value = 1, description = "Initialize the database connection")
		public class Task1 implements TaskExecutor {
			// Implement the logic for Task1
		}

		@Component
		@TaskFlowOrder(value = 2, dependencies = {Task1.class, Task3.class})
		public class Task2 implements TaskExecutor {
			// Implement the logic for Task2
		}

	@Mapper--Annotation:
	
		- Annotation @Mapper trong Spring là một phần của Spring Data Mybatis, được sử dụng để định nghĩa một interface làm nhiệm vụ ánh xạ dữ liệu từ database
		sang các đối tượng Java và ngược lại.
		- Khi một interface được đánh dấu với @Mapper, Spring sẽ tự động tạo ra một implementation class cho interface đó, cung cấp các phương thức để thực hiện
		các truy vấn SQL và ánh xạ dữ liệu.
		- Một số thuộc tính chính của @Mapper:
			componentModel: Xác định component model được sử dụng cho Mapper, thường là "spring".
			MapperScan: Dùng để chỉ định gói chứa các Mapper interface.
			MapperScannerConfigurer: Dùng để cấu hình các tùy chọn cho MapperScan.
		- Việc sử dụng @Mapper giúp giảm thiểu code lặp lại và dễ dàng tích hợp Mybatis vào trong ứng dụng Spring.

		@Mapper(componentModel = "spring")
		public interface UserMapper {
			@Select("SELECT * FROM users WHERE id = #{id}")
			User getUserById(int id);
			@Insert("INSERT INTO users(name, email) VALUES(#{name}, #{email})")
			int insertUser(User user);
		}
		Trong ví dụ trên, UserMapper là một interface được đánh dấu bằng @Mapper. Nó có các phương thức để truy vấn thông tin về user từ database và thêm mới user vào database.
		Spring sẽ tự động tạo ra một implementation class cho UserMapper và quản lý nó như một Spring bean. Các phương thức trong UserMapper sẽ được thực thi bằng các truy vấn SQL tương ứng.
		
	@SpringBootTest--Annotation:

		- Annotation @SpringBootTest trong Spring Boot được sử dụng để tạo ra một môi trường testing hoàn chỉnh cho ứng dụng Spring Boot của bạn.
		- Khi sử dụng @SpringBootTest, Spring sẽ tạo ra một ApplicationContext hoàn chỉnh, tương tự như khi khởi chạy ứng dụng trong môi trường production. Điều này giúp bạn có
		thể thực hiện các test case một cách chính xác và đầy đủ.
		- Một số thuộc tính chính của @SpringBootTest:
			webEnvironment: Xác định loại web environment được sử dụng trong test. Có các giá trị như MOCK, RANDOM_PORT, DEFINED_PORT, NONE.
			properties: Cho phép khai báo các property cần thiết cho test.
			classes: Chỉ định các class cần được loaded trong application context.
			components: Chỉ định các component cần được mocking.
		- Với @SpringBootTest, bạn có thể thực hiện các test case một cách đầy đủ, bao gồm các tương tác với database, các service, controller, etc. Điều này giúp đảm bảo rằng ứng dụng
		của bạn hoạt động chính xác khi được triển khai trong môi trường production.
		
		@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
		class MyServiceTests {
			@Autowired
			private MyService myService;
			@LocalServerPort
			private int randomPort;
			@Test
			void testMyService() {
				// Write your test cases here
				assertThat(myService.doSomething()).isEqualTo("expected_result");
				// ...
			}
		}
		webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT: Chỉ định rằng ứng dụng sẽ được khởi chạy trên một cổng ngẫu nhiên.
		@Autowired được sử dụng để inject MyService vào test case.
		@LocalServerPort được sử dụng để lấy cổng ngẫu nhiên mà ứng dụng đang chạy trên.
		
	@Test--Annotation:

		- Trong Spring, @Test là một annotation được sử dụng để đánh dấu một phương thức là một unit test. Nó được sử dụng trong kết hợp với các framework
		kiểm thử như JUnit để viết các unit test cho ứng dụng Spring.
		- Khi chạy unit test này, framework kiểm thử (như JUnit) sẽ tự động thực thi phương thức đánh dấu bằng @Test và kiểm tra xem kết quả có đúng với mong đợi hay không.
		- Bạn có thể sử dụng @Test annotation kết hợp với các annotation khác như @BeforeEach, @AfterEach, @BeforeAll, @AfterAll để thiết lập và dọn dẹp môi trường
		trước và sau khi chạy các unit test.
		
		import org.junit.jupiter.api.Test;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.boot.test.context.SpringBootTest;
		@SpringBootTest
		public class MyServiceTest {
			@Autowired
			private MyService myService;
			@Test
			public void testMyService() {
				// Arrange
				String input = "Hello, world!";
				// Act
				String output = myService.processString(input);
				// Assert
				assertEquals("HELLO, WORLD!", output);
			}
		}
		@SpringBootTest annotation được sử dụng để đánh dấu lớp là một Spring Boot test case.
		@Autowired annotation được sử dụng để tự động liên kết MyService vào test case.
		@Test annotation được sử dụng để đánh dấu phương thức testMyService() là một unit test.
		Trong phương thức testMyService(), ta thực hiện các bước sau:
			Arrange: Chuẩn bị dữ liệu đầu vào.
			Act: Gọi phương thức processString() của MyService.
			Assert: Kiểm tra xem kết quả trả về có đúng với kỳ vọng không.
		
	@ToString--Annotation:

		- Trong Spring, @ToString là một annotation được sử dụng để tạo ra một phương thức toString() mặc định cho một lớp. Khi được sử dụng, @ToString sẽ tự
		động tạo ra phương thức toString() và hiển thị các trường của lớp.
		- Ngoài ra, @ToString annotation cũng có một số tùy chọn để định cấu hình cách hiển thị của phương thức toString(), chẳng hạn như:
			includeFieldNames: Thiết lập xem có hiển thị tên trường hay không.
			includeStatics: Thiết lập xem có hiển thị các trường static hay không.
			callSuper: Thiết lập xem có gọi phương thức toString() của lớp cha hay không.
		
		import lombok.ToString;
		@ToString
		public class MyClass {
			private String name;
			private int age;
			public MyClass(String name, int age) {
				this.name = name;
				this.age = age;
			}
			// Các phương thức getter/setter
		}
		
		Khi sử dụng @ToString, Spring sẽ tự động tạo ra một phương thức toString() với nội dung như sau:
		public String toString() {
			return "MyClass(name=" + this.getName() + ", age=" + this.getAge() + ")";
		}
		
		Khi bạn in ra một đối tượng của MyClass, kết quả sẽ giống như:
		MyClass(name=John, age=30)
		
		@ToString(includeFieldNames = false, callSuper = true)
		public class MyClass extends ParentClass {
			// ...
		}

	@ApiImplicitParams--Annotation:
	
		- @ApiImplicitParams là một annotation trong Spring được sử dụng để mô tả các tham số đầu vào của một API endpoint trong Swagger documentation.
		- Annotation này được sử dụng khi bạn muốn mô tả các tham số không phải là path variables hoặc request bodies. Ví dụ, các tham số được truyền qua
		query parameters, headers, form data, etc.
		- Khi sử dụng Swagger UI, các tham số được mô tả bởi @ApiImplicitParams sẽ được hiển thị trong phần "Parameters" của API endpoint, giúp người dùng dễ dàng hiểu và sử dụng API.
		- Lưu ý rằng, @ApiImplicitParams chỉ được sử dụng khi bạn không thể sử dụng @RequestParam hoặc @RequestBody annotations để mô tả các tham số đầu vào. Đối với các tham số được truyền
		qua URL path, bạn có thể sử dụng @PathVariable annotation.

		import io.swagger.annotations.ApiImplicitParam;
		import io.swagger.annotations.ApiImplicitParams;
		import io.swagger.annotations.ApiOperation;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.bind.annotation.GetMapping;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.bind.annotation.RequestParam;
		import org.springframework.web.bind.annotation.RestController;
		@RestController
		@RequestMapping("/api/users")
		public class UserController {
			@GetMapping
			@ApiOperation(value = "Get users")
			@ApiImplicitParams({
				@ApiImplicitParam(name = "name", dataType = "string", paramType = "query", value = "User's name"),
				@ApiImplicitParam(name = "age", dataType = "integer", paramType = "query", value = "User's age")
			})
			public ResponseEntity<String> getUsers(@RequestParam(required = false) String name,
												  @RequestParam(required = false) Integer age) {
				// Implement your logic here
				return ResponseEntity.ok("Users retrieved");
			}
		}
		@ApiImplicitParams annotation được sử dụng để mô tả các tham số đầu vào của API endpoint getUsers().
		Bên trong @ApiImplicitParams, có hai @ApiImplicitParam annotations, mỗi annotation mô tả một tham số đầu vào:
			name: Tên của tham số
			dataType: Kiểu dữ liệu của tham số
			paramType: Loại tham số (query, header, form, path, ...)
			value: Mô tả ngắn gọn về tham số
			
	@Before--Annotation:

		- @Before là một annotation trong Spring Framework được sử dụng để chỉ định một phương thức nên được thực thi trước khi một phương thức khác được gọi. Nó thường được
		sử dụng trong lập trình hướng khía cạn (Aspect-Oriented Programming - AOP) để thực hiện các tác vụ chung như logging, validations, transaction management, etc.
		- Bạn có thể sử dụng nhiều @Before annotations để thực hiện nhiều tác vụ trước khi một phương thức được gọi. Ngoài ra, bạn cũng có thể sử dụng các annotation khác
		như @After, @Around, @AfterReturning, @AfterThrowing để thực hiện các tác vụ khác.

		import org.aspectj.lang.JoinPoint;
		import org.aspectj.lang.annotation.Aspect;
		import org.aspectj.lang.annotation.Before;
		import org.springframework.stereotype.Component;
		@Aspect
		@Component
		public class LoggingAspect {
			@Before("execution(* com.example.service.*.*(..))")
			public void logMethodCall(JoinPoint joinPoint) {
				String methodName = joinPoint.getSignature().getName();
				Object[] args = joinPoint.getArgs();

				System.out.println("Calling method: " + methodName + " with arguments: " + args);
			}
		}
		@Aspect annotation chỉ định lớp LoggingAspect là một lớp khía cạn (Aspect).
		@Component annotation chỉ định lớp LoggingAspect là một bean Spring.
		@Before annotation chỉ định rằng phương thức logMethodCall() sẽ được thực thi trước khi bất kỳ phương thức nào trong com.example.service package được gọi.
		Khi một phương thức trong com.example.service package được gọi, phương thức logMethodCall() sẽ được thực thi trước, in ra thông tin về phương thức được gọi.
		Trong phương thức logMethodCall():
			JoinPoint đối tượng được sử dụng để lấy thông tin về phương thức đang được gọi, chẳng hạn như tên phương thức và các đối số.
			
	@Mockbean--Annotation:
	
		- @MockBean là một annotation trong Spring Boot Test để tạo và cấu hình các mock object cho các bean được sử dụng trong các unit test.
		- Khi sử dụng @MockBean, Spring sẽ tự động tạo một mock object và gắn nó vào application context để thay thế cho bean thực sự. Điều này rất hữu ích khi bạn
		muốn kiểm tra một component mà không phụ thuộc vào các dependencies của nó.

		import org.junit.jupiter.api.Test;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.boot.test.context.SpringBootTest;
		import org.springframework.boot.test.mock.mockito.MockBean;
		import com.example.service.UserService;
		import com.example.model.User;
		import static org.mockito.Mockito.when;
		import static org.junit.jupiter.api.Assertions.assertEquals;
		@SpringBootTest
		public class UserControllerTest {
			@Autowired
			private UserController userController;
			@MockBean
			private UserService userService;
			@Test
			public void testGetUser() {
				User mockUser = new User(1, "John Doe");
				when(userService.getUser(1)).thenReturn(mockUser);
				User user = userController.getUser(1);
				assertEquals(mockUser, user);
			}
		}
		@SpringBootTest annotation được sử dụng để tạo một ứng dụng Spring Boot hoàn chỉnh để chạy test.
		@Autowired annotation được sử dụng để tự động inject UserController vào test case.
		@MockBean annotation được sử dụng để tạo một mock UserService bean và đăng ký nó vào application context.
		Trong phương thức testGetUser():
			Khi userService.getUser(1) được gọi, mock object sẽ trả về mockUser.
			Sau đó, test case kiểm tra xem userController.getUser(1) có trả về đúng mockUser hay không.
			
	@Api--Annotation:

		- @Api là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin về một API endpoint.
		- Khi sử dụng @Api, bạn có thể cung cấp các thông tin sau:
			value: Mô tả về API endpoint.
			description: Mô tả chi tiết về API endpoint.
			tags: Nhóm các API endpoints liên quan với nhau.
			produces: Định nghĩa các media types mà API endpoint có thể trả về.
			consumes: Định nghĩa các media types mà API endpoint có thể nhận vào.
			protocols: Định nghĩa các protocols mà API endpoint hỗ trợ (HTTP, HTTPS, v.v.).
			authorizations: Định nghĩa các authorization schemes mà API endpoint sử dụng.
			hidden: Ẩn API endpoint khỏi Swagger UI.
		- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho
		các developer dễ dàng hiểu và sử dụng API.
			
		import io.swagger.annotations.Api;
		import io.swagger.annotations.ApiOperation;
		import org.springframework.web.bind.annotation.GetMapping;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.bind.annotation.RestController;
		@Api(value = "User API", description = "Provides operations to manage users")
		@RequestMapping("/api/users")
		@RestController
		public class UserController {
			@ApiOperation(value = "Get all users", notes = "Returns a list of all users")
			@GetMapping
			public List<User> getAllUsers() {
				// implementation
			}
			@ApiOperation(value = "Get a user by ID", notes = "Returns a user with the specified ID")
			@GetMapping("/{id}")
			public User getUserById(@PathVariable Long id) {
				// implementation
			}
		}
		@Api được sử dụng để mô tả chung về API endpoint, bao gồm tên, mô tả và các media types được hỗ trợ.
		@ApiOperation được sử dụng để mô tả chi tiết về từng phương thức trong controller, bao gồm tên, mô tả và các thông tin khác.
			
	@ApiOperation--Annotation:

		- @ApiOperation là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin chi tiết về một phương thức (method) trong một REST API controller.
		- Khi sử dụng @ApiOperation, bạn có thể cung cấp các thông tin sau:
			value: Mô tả ngắn về chức năng của phương thức.
			notes: Mô tả chi tiết về chức năng của phương thức.
			response: Định nghĩa kiểu dữ liệu trả về của phương thức.
			responseContainer: Định nghĩa kiểu dữ liệu chứa kết quả trả về (ví dụ: List, Set, Map, v.v.).
			responseReference: Định nghĩa một model reference cho kết quả trả về.
			produces: Định nghĩa các media types mà phương thức có thể trả về.
			consumes: Định nghĩa các media types mà phương thức có thể nhận vào.
			tags: Nhóm phương thức vào các tag tương ứng.
			code: Định nghĩa các HTTP status code mà phương thức có thể trả về.
			nickname: Định nghĩa một nickname cho phương thức.
		- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho các developer dễ dàng hiểu và sử dụng API.
			
			import io.swagger.annotations.Api;
			import io.swagger.annotations.ApiOperation;
			import org.springframework.web.bind.annotation.GetMapping;
			import org.springframework.web.bind.annotation.PathVariable;
			import org.springframework.web.bind.annotation.RequestMapping;
			import org.springframework.web.bind.annotation.RestController;
			@Api(value = "User API", description = "Provides operations to manage users")
			@RequestMapping("/api/users")
			@RestController
			public class UserController {
				@ApiOperation(value = "Get all users", notes = "Returns a list of all users")
				@GetMapping
				public List<User> getAllUsers() {
					// implementation
				}
				@ApiOperation(value = "Get a user by ID", notes = "Returns a user with the specified ID")
				@GetMapping("/{id}")
				public User getUserById(@PathVariable Long id) {
					// implementation
				}
			}				
			@ApiOperation được sử dụng để mô tả chi tiết về từng phương thức trong controller, bao gồm tên, mô tả, kiểu dữ liệu trả về và các thông tin khác.
			@Api được sử dụng để mô tả chung về API endpoint, bao gồm tên, mô tả và các media types được hỗ trợ.
			
	@ApiModelProperty--Annotation:

		- @ApiModelProperty là một annotation trong Springfox (một framework để tạo REST API documentation) được sử dụng để cung cấp thông tin chi tiết về một
		trường (field) trong một model class.
		- Khi sử dụng @ApiModelProperty, bạn có thể cung cấp các thông tin sau:
			value: Mô tả ngắn về trường.
			name: Tên của trường.
			required: Chỉ ra liệu trường này có bắt buộc phải có giá trị hay không.
			dataType: Định nghĩa kiểu dữ liệu của trường.
			example: Cung cấp một ví dụ giá trị của trường.
			allowableValues: Chỉ ra các giá trị được phép của trường.
			access: Chỉ ra trường này có thể truy cập (read/write) như thế nào.
			position: Xác định vị trí của trường trong mô tả model.
			notes: Cung cấp thêm thông tin mô tả về trường.
			reference: Tham chiếu đến một model khác.
		- Khi sử dụng Springfox để tạo Swagger documentation, các thông tin được cung cấp bằng các annotation này sẽ được hiển thị trong Swagger UI, giúp cho
		các developer dễ dàng hiểu và sử dụng API.
			
		import io.swagger.annotations.ApiModel;
		import io.swagger.annotations.ApiModelProperty;
		@ApiModel(description = "User model")
		public class User {
			@ApiModelProperty(
				value = "User ID",
				required = true,
				dataType = "long",
				example = "1234",
				position = 1
			)
			private Long id;
			@ApiModelProperty(
				value = "User name",
				required = true,
				dataType = "string",
				example = "John Doe",
				position = 2
			)
			private String name;
			@ApiModelProperty(
				value = "User email",
				required = true,
				dataType = "string",
				example = "john.doe@example.com",
				position = 3
			)
			private String email;
			// getters, setters, and other methods
		}
		@ApiModel được sử dụng để mô tả chung về model class, bao gồm tên và mô tả.
		@ApiModelProperty được sử dụng để mô tả chi tiết về từng trường trong model class, bao gồm tên, mô tả, kiểu dữ liệu, ví dụ và các thông tin khác.
			
	@ServletComponentScan--Annotation:

		- @ServletComponentScan là một annotation trong Spring framework được sử dụng để tự động đăng ký các servlet, filter và listener được khai báo
		bằng annotation @WebServlet, @WebFilter và @WebListener.
		- Sử dụng @ServletComponentScan giúp đơn giản hóa quá trình cấu hình ứng dụng web, đặc biệt là trong các ứng dụng Spring Boot. Nó giúp tách biệt các định nghĩa
		servlet, filter và listener ra khỏi cấu hình chung của ứng dụng, tăng tính modularization và dễ dàng bảo trì hơn.
			
		import org.springframework.boot.SpringApplication;
		import org.springframework.boot.autoconfigure.SpringBootApplication;
		import org.springframework.boot.web.servlet.ServletComponentScan;
		@SpringBootApplication
		@ServletComponentScan
		public class MyApplication {
			public static void main(String[] args) {
				SpringApplication.run(MyApplication.class, args);
			}
		}				
		@ServletComponentScan đánh dấu Spring sẽ tự động quét và đăng ký các servlet, filter và listener được khai báo bằng các annotation @WebServlet, @WebFilter và @WebListener.	
			
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;
		@WebServlet(urlPatterns = "/hello")
		public class HelloServlet extends HttpServlet {
			@Override
			protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
				response.getWriter().write("Hello from HelloServlet!");
			}
		}				
		Trong ví dụ trên, servlet HelloServlet được khai báo bằng @WebServlet với URL pattern /hello. Khi ứng dụng được khởi chạy, Spring sẽ tự động đăng ký servlet này mà
		không cần phải khai báo trong web.xml.	
			
	@DisplayName--Annotation:

		- @DisplayName là một annotation trong Spring Framework, được sử dụng để cung cấp một tên hiển thị cho các test case trong unit test.	
		- Khi sử dụng @DisplayName, thay vì sử dụng tên của phương thức test làm tên hiển thị, bạn có thể cung cấp một tên mô tả rõ ràng hơn cho test case.
		- Khi chạy các test case này, trình chạy test (như JUnit) sẽ hiển thị tên được định nghĩa bằng @DisplayName thay vì tên phương thức. Điều này giúp tăng tính đọc
		hiểu và dễ dàng theo dõi kết quả test.
		- Sử dụng @DisplayName là một cách tốt để làm cho các test case trở nên rõ ràng và dễ hiểu hơn, đặc biệt là trong các dự án lớn với nhiều test case. Nó giúp tăng
		tính đọc hiểu và dễ bảo trì của bộ test.
			
		import org.junit.jupiter.api.DisplayName;
		import org.junit.jupiter.api.Test;
		class MyServiceTest {
			@Test
			@DisplayName("Test add method with positive numbers")
			void testAddPositiveNumbers() {
				// test code
			}
			@Test
			@DisplayName("Test add method with negative numbers")
			void testAddNegativeNumbers() {
				// test code
			}
		}				
		Trong ví dụ này, thay vì sử dụng tên phương thức là testAddPositiveNumbers và testAddNegativeNumbers, chúng ta đã sử dụng @DisplayName để cung cấp tên mô tả rõ ràng hơn cho mỗi test case.	
			
	@FeignClient--Annotation:

		- @FeignClient là một annotation trong Spring Cloud, được sử dụng để tạo ra một client proxy cho các RESTful web service. Nó cho phép bạn định nghĩa và cấu hình một client
		để gọi các API từ các dịch vụ khác.
		- Một số thuộc tính quan trọng của @FeignClient bao gồm:
			name: Đặt tên cho client, được sử dụng để tham chiếu đến nó trong các lớp khác.
			url: Cung cấp URL base của dịch vụ mà client sẽ gọi đến.
			configuration: Cho phép bạn cung cấp một lớp cấu hình tùy chỉnh cho client.
			fallback: Chỉ định một lớp fallback để xử lý trường hợp lỗi khi gọi API.
			path: Chỉ định một đường dẫn chung cho tất cả các phương thức trong client.
		- Khi sử dụng @FeignClient, bạn cũng có thể kết hợp với các annotation khác như @GetMapping, @PostMapping, @PutMapping, v.v. để định nghĩa các phương thức gọi API.
		- Bằng cách sử dụng @FeignClient, bạn có thể tạo ra các client proxy một cách dễ dàng, giúp tách biệt logic gọi API ra khỏi các lớp business logic trong ứng dụng. Điều này
		giúp mã nguồn trở nên gọn gàng, dễ bảo trì và dễ mở rộng hơn.	
			
		import org.springframework.cloud.openfeign.FeignClient;
		import org.springframework.web.bind.annotation.GetMapping;
		@FeignClient(name = "userService", url = "http://example.com/api/users")
		public interface UserServiceClient {
			@GetMapping("/{id}")
			User getUser(@PathVariable("id") Long id);
		}				
		Trong ví dụ này, @FeignClient được sử dụng để tạo ra một client proxy cho dịch vụ "userService", được host tại URL http://example.com/api/users. Một interface UserServiceClient
		được định nghĩa, và nó chứa một phương thức getUser() để gọi API lấy thông tin về một user cụ thể.	
			
	@LocalServerPort--Annotation:

		- @LocalServerPort là một annotation trong Spring Boot được sử dụng để lấy ra port của ứng dụng web đang chạy trên máy local. Nó rất hữu ích khi bạn cần biết port của ứng dụng
		để sử dụng trong các test case hoặc khi gọi API từ một ứng dụng khác.
		- Ngoài ra, bạn cũng có thể sử dụng @Value("${local.server.port}") để lấy ra port của ứng dụng, nhưng @LocalServerPort thì thuận tiện hơn vì nó tự động inject giá trị port vào biến.
			
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.boot.test.context.SpringBootTest;
		import org.springframework.boot.test.web.server.LocalServerPort;
		import org.springframework.test.context.junit4.SpringRunner;
		@RunWith(SpringRunner.class)
		@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
		public class MyControllerTest {
			@LocalServerPort
			private int port;
			@Autowired
			private MyController controller;
			@Test
			public void testMyController() {
				// Use the port value to make a call to the controller
				int actualPort = port;
				// Perform assertions on the controller
			}
		}				
		Chúng ta sử dụng @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) để chạy ứng dụng web trong một môi trường test với một port ngẫu nhiên.
		@LocalServerPort được sử dụng để tự động inject giá trị của port hiện tại vào biến port.
		Trong test case, chúng ta có thể sử dụng biến port để gọi API hoặc thực hiện các assertions khác.
			
	@WebFilter--Annotation:

		- @WebFilter là một annotation trong Spring Boot được sử dụng để đăng ký một javax.servlet.Filter bean. Filters trong Spring Boot được sử dụng để lọc và xử lý các
		request trước khi chúng đến Servlet.
		- Bạn cũng có thể sử dụng @Order annotation để chỉ định thứ tự ưu tiên của filter, nếu ứng dụng có nhiều filter.
		- Ngoài ra, bạn cũng có thể sử dụng @Component và @Filter annotations thay vì @WebFilter nếu muốn có thêm control over filter registration.

		import javax.servlet.Filter;
		import javax.servlet.FilterChain;
		import javax.servlet.FilterConfig;
		import javax.servlet.ServletException;
		import javax.servlet.ServletRequest;
		import javax.servlet.ServletResponse;
		import javax.servlet.http.HttpServletRequest;
		import org.springframework.stereotype.Component;
		@Component
		@WebFilter(urlPatterns = "/*")
		public class MyCustomFilter implements Filter {
			@Override
			public void init(FilterConfig filterConfig) throws ServletException {
				// Initialization logic
			}
			@Override
			public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
					throws IOException, ServletException {
				HttpServletRequest httpRequest = (HttpServletRequest) request;
				System.out.println("Request URI: " + httpRequest.getRequestURI());
				chain.doFilter(request, response);
			}
			@Override
			public void destroy() {
				// Cleanup logic
			}
		}
		Chúng ta sử dụng @WebFilter annotation để đăng ký filter này, với urlPatterns = "/*" để lọc tất cả các request.
		Trong doFilter() method, chúng ta in ra URI của request và sau đó gọi chain.doFilter() để tiếp tục xử lý request.

	@WebMvcTest--Annotation:

		- @WebMvcTest là một annotation trong Spring Boot được sử dụng để tạo ra một bối cảnh test cho các lớp Controller trong ứng dụng web MVC.
		- Khi sử dụng @WebMvcTest, Spring sẽ chỉ khởi tạo các bean liên quan đến Web MVC, như @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter,
		Filter, WebMvcConfigurer và HandlerMethodArgumentResolver. Điều này giúp tăng tốc độ chạy test và giảm bớt các phụ thuộc không cần thiết.
		- Lưu ý rằng @WebMvcTest chỉ test các controller và các thành phần liên quan đến Web MVC. Nếu bạn cần test các service, repository hoặc các thành phần khác, bạn
		cần sử dụng @SpringBootTest thay vì @WebMvcTest.
		- Ngoài ra, bạn cũng có thể sử dụng các annotation khác như @MockBean để mock các dependency của controller.

		import org.junit.jupiter.api.Test;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
		import org.springframework.test.web.servlet.MockMvc;
		import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
		import org.springframework.test.web.servlet.result.MockMvcResultMatchers;=
		@WebMvcTest(controllers = MyController.class)
		public class MyControllerTest {
			@Autowired
			private MockMvc mockMvc;
			@Test
			public void testMyController() throws Exception {
				mockMvc.perform(MockMvcRequestBuilders.get("/myendpoint"))
						.andExpect(MockMvcResultMatchers.status().isOk())
						.andExpect(MockMvcResultMatchers.content().string("Hello, World!"));
			}
		}
		Chúng ta sử dụng @WebMvcTest annotation và chỉ định MyController.class như là controller cần được test.
		Spring sẽ chỉ khởi tạo các bean liên quan đến Web MVC, giúp test chạy nhanh hơn.
		Chúng ta sử dụng MockMvc để mô phỏng các request và kiểm tra kết quả trả về.

	@RunWith--Annotation:
	
		- @RunWith là một annotation trong JUnit (một framework kiểm thử phổ biến trong Java) được sử dụng để chỉ định một class Runner cụ thể sẽ được sử dụng để chạy các test case.
		- Trong Spring, khi bạn sử dụng Spring Test Framework, thường bạn sẽ kết hợp @RunWith với @SpringRunner hoặc @SpringJUnit4ClassRunner để chạy các test case trong môi trường Spring.
		- SpringRunner là một class runner được cung cấp bởi Spring Test Framework. Nó sẽ chịu trách nhiệm khởi tạo và quản lý vòng đời của Spring context trong quá trình chạy test case.
		- Khi sử dụng @RunWith(SpringRunner.class), Spring sẽ tự động:
			Khởi tạo ApplicationContext.
			Tiêm các dependency được khai báo bằng @Autowired.
			Quản lý vòng đời của ApplicationContext.
		- Điều này giúp các test case có thể tương tác với các bean và dịch vụ được định nghĩa trong ứng dụng Spring một cách dễ dàng.

		import org.junit.Test;
		import org.junit.runner.RunWith;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.boot.test.context.SpringBootTest;
		import org.springframework.test.context.junit4.SpringRunner;
		import com.example.myapp.MyService;
		@RunWith(SpringRunner.class)
		@SpringBootTest
		public class MyServiceTest {
			@Autowired
			private MyService myService;
			@Test
			public void testMyService() {
				// Test the MyService class
				myService.doSomething();
				// Add your assertions here
			}
		}
		@RunWith(SpringRunner.class) chỉ định rằng test case này sẽ được chạy bằng cách sử dụng SpringRunner class runner.
		@SpringBootTest chỉ định rằng test case này sẽ được chạy trong một Spring Boot test context.

	@Import--Annotation:

		- @Import là một annotation trong Spring được sử dụng để định nghĩa và import các configuration classes vào trong ứng dụng của bạn.
		- Đây là một số trường hợp bạn có thể sử dụng @Import:
			Chia nhỏ Configuration Classes:
				Khi ứng dụng của bạn trở nên phức tạp, bạn có thể chia nhỏ các configuration classes thành các modules nhỏ hơn.
				Sử dụng @Import để import các configuration classes này vào một configuration class chính.
			Sử dụng Configuration Classes của Bên Thứ Ba:
				Khi sử dụng các thư viện/framework của bên thứ ba, bạn có thể import configuration classes của chúng vào ứng dụng của mình.
		- Bằng cách sử dụng @Import, bạn có thể tổ chức và quản lý các configuration classes của ứng dụng một cách dễ dàng, đặc biệt là khi ứng dụng trở nên phức tạp hơn.
		- Ngoài ra, @Import còn có một số tính năng nâng cao khác như:
			Conditional Import: Chỉ import configuration classes khi một điều kiện cụ thể được đáp ứng.
			Importing Bean Definition Registrars: Import các Bean Definition Registrars để đăng ký các bean động.

		import org.springframework.context.annotation.Configuration;
		import org.springframework.context.annotation.Import;
		@Configuration
		@Import({
			DatabaseConfig.class,
			SecurityConfig.class,
			WebConfig.class
		})
		public class ApplicationConfig {
			// Main application configuration
		}
		@Import annotation được sử dụng để import các configuration classes khác (DatabaseConfig, SecurityConfig, WebConfig) vào ApplicationConfig.
		Khi ApplicationConfig được load, Spring sẽ tự động load và configure các configuration classes được import bằng @Import.

	@interface--Annotation:
	
		- Trong Java, @interface được sử dụng để khai báo một annotation. Trong Spring, bạn có thể tạo các custom annotations để sử dụng cho các mục đích đặc biệt trong ứng dụng của
		mình, ví dụ như đánh dấu các phương thức hoặc lớp cụ thể với một logic kinh doanh hoặc cấu hình nào đó.
		
		package com.example.annotation;
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.METHOD)
		public @interface LogExecutionTime {
		}
		package com.example.aspect;
		import org.aspectj.lang.ProceedingJoinPoint;
		import org.aspectj.lang.annotation.Around;
		import org.aspectj.lang.annotation.Aspect;
		import org.springframework.stereotype.Component;
		@Aspect
		@Component
		public class LoggingAspect {
			@Around("@annotation(com.example.annotation.LogExecutionTime)")
			public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
				long start = System.currentTimeMillis();
				Object proceed = joinPoint.proceed();
				long executionTime = System.currentTimeMillis() - start;
				System.out.println(joinPoint.getSignature() + " executed in " + executionTime + "ms");
				return proceed;
			}
		}
		package com.example.controller;
		import com.example.annotation.LogExecutionTime;
		import org.springframework.web.bind.annotation.GetMapping;
		import org.springframework.web.bind.annotation.RestController;
		@RestController
		public class UserController {
			@LogExecutionTime
			@GetMapping("/user")
			public String getUser() {
				// Simulate a time-consuming task
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				return "User data";
			}
		}
		package com.example;
		import org.springframework.boot.SpringApplication;
		import org.springframework.boot.autoconfigure.SpringBootApplication;
		@SpringBootApplication
		public class Application {
			public static void main(String[] args) {
				SpringApplication.run(Application.class, args);
			}
		}
		Trong đó @Around("@annotation(com.example.annotation.LogExecutionTime)"): Chỉ định rằng phương thức logExecutionTime sẽ được gọi xung quanh (trước và sau) bất kỳ phương thức
		nào được chú thích với @LogExecutionTime.

	@JoinColumn--Annotation:
	
		- @JoinColumn là một annotation được sử dụng để chỉ định cột mà qua đó thực thể này tham chiếu tới thực thể khác trong quan hệ cơ sở dữ liệu.
		
		import javax.persistence.Entity;
		import javax.persistence.Id;
		import javax.persistence.ManyToOne;
		import javax.persistence.JoinColumn;
		@Entity
		public class Employee {
			@Id
			private Long id;
			@ManyToOne
			@JoinColumn(name = "department_id", referencedColumnName = "id")
			private Department department;
			// Getters and setters
		}
		
	@JoinColumns--Annotation:
	
		- @JoinColumns là một annotation được sử dụng để xác định nhiều cột khóa ngoại khi có một quan hệ phức tạp liên quan đến nhiều cột khóa ngoại. Điều này thường được sử dụng
		trong các quan hệ mà bảng con tham chiếu tới bảng cha bằng nhiều cột khóa ngoại.
		
		import javax.persistence.Entity;
		import javax.persistence.Id;
		import javax.persistence.ManyToOne;
		import javax.persistence.JoinColumns;
		import javax.persistence.JoinColumn;
		@Entity
		public class Employee {
			@Id
			private Long id;
			@ManyToOne
			@JoinColumns({
				@JoinColumn(name = "department_id", referencedColumnName = "id"),
				@JoinColumn(name = "location_id", referencedColumnName = "location_id")
			})
			private Department department;
			// Getters and setters
		}	