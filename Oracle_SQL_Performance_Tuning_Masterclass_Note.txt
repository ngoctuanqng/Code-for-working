--- Table s·ª≠ d·ª•ng:

	Index trong c√°c table:
	
		hr:
		
			CHANNELS_PK
			COSTS_PROD_BIX
			COSTS_TIME_BIX
			COUNTRIES_PK
			CUSTOMERS_GENDER_BIX
			CUSTOMERS_MARITAL_BIX
			CUSTOMERS_PK
			CUSTOMERS_YOB_BIX
			DR#$UP_TEXT_IDX$X
			DRC#$UP_TEXT_IDX$R
			FW_PSC_S_MV_CHAN_BIX
			FW_PSC_S_MV_PROMO_BIX
			FW_PSC_S_MV_SUBCAT_BIX
			FW_PSC_S_MV_WD_BIX
			PRODUCTS_PK
			PRODUCTS_PROD_CAT_IX
			PRODUCTS_PROD_STATUS_BIX
			PRODUCTS_PROD_SUBCAT_IX
			PROMO_PK
			SALES_CHANNEL_BIX
			SALES_CUST_BIX
			SALES_PROD_BIX
			SALES_PROMO_BIX
			SALES_TIME_BIX
			SUP_TEXT_IDX
			SYS_C006763
			SYS_IL000007344C00006$$
			SYS_IL000007394C00002$$
			SYS_IOT_TOP_73443
			SYS_IOT_TOP_73445
			TIMES_PK
			
			Noi dung trong bang employees:
			
				EMPLOYEE_ID				Primary key of employees table.
				FIRST_NAME				First name of the employee. A not null column.
				LAST_NAME				Last name of the employee. A not null column.
				EMAIL					Email id of the employee
				PHONE_NUMBER			Phone number of the employee; includes country code and area code
				HIRE_DATE				Date when the employee started on this job. A not null column.
				JOB_ID					"Current job of the employee; foreign key to job_id column of the jobs table. A not null column."
				SALARY					"Monthly salary of the employee. Must be greater than zero (enforced by constraint emp_salary_min)"
				COMMISSION_PCT			"Commission percentage of the employee; Only employees in sales department elgible for commission percentage"
				MANAGER_ID				"Manager id of the employee; has same domain as manager_id in departments table. Foreign key to
										employee_id column of employees table.
										(useful for reflexive joins and CONNECT BY query)"
				DEPARTMENT_ID			"Department id where employee works; foreign key to department_id column of the departments table"
			
		ix:
		
			AQ$_STREAMS_QUEUE_TABLE_Y
			SYS_C007731
			SYS_C007732
			SYS_C007733
			SYS_C007734
			SYS_IL000007344C00036$$
			SYS_IL000007349C00028$$
			SYS_IL000007349C00029$$
			SYS_IOT_TOP_73724
			SYS_IOT_TOP_73726
			SYS_IOT_TOP_73728
			SYS_IOT_TOP_73731
			SYS_IOT_TOP_73733
			SYS_IOT_TOP_73735
			SYS_IOT_TOP_73737
			SYS_IOT_TOP_73740
			SYS_IOT_TOP_73742
			
		oe:
		
			CUST_ACCOUNT_MANAGER_IX
			CUST_EMAIL_IX
			CUST_LNAME_IX
			CUST_UPPER_NAME_IX
			CUSTOMERS_PK
			INV_PRODUCT_IX
			INVENTORY_IX
			ITEM_ORDER_IX
			ITEM_PRODUCT_IX
			ORD_CUSTOMER_IX
			ORD_ORDER_DATE_IX
			ORD_SALES_REP_IX
			ORDER_ITEMS_PK
			ORDER_ITEMS_UK
			ORDER_PK
			PRD_DESC_PK
			PROD_NAME_IX
			PROD_SUPPLIER_IX
			PRODUCT_INFORMATION_PK
			PROMO_ID_PK
			SYS_C007679
			SYS_C007680
			SYS_C007681
			SYS_C007682
			SYS_C007683
			SYS_C007684
			SYS_C007698
			SYS_C007699
			SYS_C007700
			SYS_FK0000074510N00007$
			SYS_FK0000074510N00009$
			WAREHOUSES_PK
			WHS_LOCATION_IX
			
		pm:
		
			ONLINEMEDIA_PK
			PRINTMEDIA_PK
			SYS_C007711
			SYS_FK0000073529N00007$
			
		sh:
		
			CHANNELS_PK
			COSTS_PROD_BIX
			COSTS_TIME_BIX
			COUNTRIES_PK
			CUSTOMERS_GENDER_BIX
			CUSTOMERS_MARITAL_BIX
			CUSTOMERS_PK
			CUSTOMERS_YOB_BIX
			DR#$UP_TEXT_IDX$X
			DRC#$UP_TEXT_IDX$R
			FW_PSC_S_MV_CHAN_BIX
			FW_PSC_S_MV_PROMO_BIX
			FW_PSC_S_MV_SUBCAT_BIX
			FW_PSC_S_MV_WD_BIX
			PRODUCTS_PK
			PRODUCTS_PROD_CAT_IX
			PRODUCTS_PROD_STATUS_BIX
			PRODUCTS_PROD_SUBCAT_IX
			PROMO_PK
			SALES_CHANNEL_BIX
			SALES_CUST_BIX
			SALES_PROD_BIX
			SALES_PROMO_BIX
			SALES_TIME_BIX
			SUP_TEXT_IDX
			SYS_C006763
			SYS_IL000007344C00006$$
			SYS_IL000007394C00002$$
			SYS_IOT_TOP_73443
			SYS_IOT_TOP_73445
			TIMES_PK
			
			Noi dung trong bang sales:
			
				PROD_ID				FK to the products dimension table
				CUST_ID				FK to the customers dimension table
				TIME_ID				FK to the times dimension table
				CHANNEL_ID			FK to the channels dimension table
				PROMO_ID			promotion identifier, without FK constraint (intentionally) to show outer join optimization
				QUANTITY_SOLD		product quantity sold with the transaction
				AMOUNT_SOLD			invoiced amount to the customer


--- Th·ª© t·ª± th·ª±c thi trong explain plan:

	Nguy√™n l√Ω c∆° b·∫£n

		Trong Oracle Execution Plan, c·∫•u tr√∫c l√† c√¢y (tree) g·ªìm nhi·ªÅu ‚Äún√∫t‚Äù (node).

			M·ªói n√∫t ƒë·∫°i di·ªán cho m·ªôt thao t√°c (operation): qu√©t b·∫£ng, qu√©t ch·ªâ m·ª•c, join, sort, filter, v.v.

			D·ªØ li·ªáu ch·∫£y t·ª´ d∆∞·ªõi l√™n: c√°c n√∫t con th·ª±c hi·ªán tr∆∞·ªõc, r·ªìi k·∫øt qu·∫£ ƒë∆∞·ª£c truy·ªÅn l√™n n√∫t cha.

		üëâ Do ƒë√≥, th·ª© t·ª± th·ª±c hi·ªán th·∫≠t s·ª± l√†:

			Th·ª±c hi·ªán t·ª´ d∆∞·ªõi l√™n, t·ª´ tr√°i sang ph·∫£i.

	Quy t·∫Øc ƒë·ªçc th·ª© t·ª± th·ª±c hi·ªán
	
		Quy t·∫Øc											Gi·∫£i th√≠ch
		
		B·∫Øt ƒë·∫ßu t·ª´ c√°c n√∫t ‚Äúl√°‚Äù (leaf)				ƒê√¢y l√† c√°c thao t√°c th·∫•p nh·∫•t ‚Äî v√≠ d·ª• TABLE ACCESS, INDEX SCAN.
		ƒêi l√™n t·ª´ng c·∫•p (parent node)					Khi c√°c n√∫t con ho√†n th√†nh, d·ªØ li·ªáu ƒë∆∞·ª£c ƒë∆∞a l√™n ƒë·ªÉ th·ª±c hi·ªán thao t√°c
														·ªü n√∫t cha (JOIN, SORT, FILTER, v.v.).
		Trong c√πng m·ªôt c·∫•p, ƒë·ªçc t·ª´ tr√°i sang ph·∫£i		Oracle th·ª±c hi·ªán c√°c ngu·ªìn d·ªØ li·ªáu b√™n tr√°i tr∆∞·ªõc trong ph√©p JOIN.
		N√∫t cao nh·∫•t (SELECT STATEMENT)				ƒê√¢y l√† ƒëi·ªÉm cu·ªëi ‚Äî khi t·∫•t c·∫£ d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω xong, k·∫øt qu·∫£ ƒë∆∞·ª£c tr·∫£ v·ªÅ.
	
	V√≠ d·ª• tr·ª±c quan (d·ª±a tr√™n k·∫ø ho·∫°ch c·ªßa b·∫°n)
	
		SELECT STATEMENT
		 ‚îî‚îÄ MERGE JOIN
			 ‚îú‚îÄ TABLE ACCESS BY INDEX ROWID (DEPARTMENTS)
			 ‚îÇ   ‚îî‚îÄ INDEX FULL SCAN (DEPT_ID_PK)
			 ‚îî‚îÄ SORT JOIN
				 ‚îî‚îÄ TABLE ACCESS FULL (EMPLOYEES)


		Theo quy t·∫Øc tr√™n:

			Th·ª© t·ª±	B∆∞·ªõc									Gi·∫£i th√≠ch
			
			‚ë†	TABLE ACCESS FULL (EMPLOYEES)				N√∫t ‚Äúl√°‚Äù b√™n ph·∫£i ‚Äì ƒë·ªçc to√†n b·ªô b·∫£ng nh√¢n vi√™n
			‚ë°	SORT JOIN									S·∫Øp x·∫øp d·ªØ li·ªáu EMPLOYEES theo department_id
			‚ë¢	INDEX FULL SCAN (DEPT_ID_PK)				N√∫t ‚Äúl√°‚Äù b√™n tr√°i ‚Äì qu√©t ch·ªâ m·ª•c c·ªßa b·∫£ng DEPARTMENTS
			‚ë£	TABLE ACCESS BY INDEX ROWID (DEPARTMENTS)	L·∫•y d·ªØ li·ªáu th·ª±c t·ª´ DEPARTMENTS
			‚ë§	MERGE JOIN									N√∫t cha ‚Äì n·ªëi hai t·∫≠p d·ªØ li·ªáu ƒë√£ c√≥
			‚ë•	SELECT STATEMENT							Xu·∫•t k·∫øt qu·∫£
			
	M·∫πo nh·ªõ nhanh

		üß≠ Th·ª© t·ª± th·ª±c hi·ªán = ƒêi t·ª´ d∆∞·ªõi l√™n, tr√°i qua ph·∫£i.

		N·∫øu bi·ªÉu ƒë·ªì c√≥ nhi·ªÅu nh√°nh JOIN ho·∫∑c SUBQUERY th√¨:

			Lu√¥n b·∫Øt ƒë·∫ßu ·ªü b·∫£ng g·ªëc ho·∫∑c INDEX SCAN th·∫•p nh·∫•t.

			Sau ƒë√≥ ƒëi ng∆∞·ª£c l√™n cho ƒë·∫øn khi g·∫∑p JOIN / SORT / FILTER.

			Khi c√≥ nhi·ªÅu nh√°nh, Oracle th∆∞·ªùng x·ª≠ l√Ω nh√°nh tr√°i tr∆∞·ªõc, r·ªìi m·ªõi sang nh√°nh ph·∫£i.	



--- Software Installations:

	- T√¨m hi·ªÉu:

		Connection type la TNS nghia la gi trong sql developer
		
		Network Alias la ORCL nghia la gi trong sql developer
		
		Download oracle database
	
	C·∫ßn ph·∫£i c√†i oracle database v√† sql developer
	
	

	- Google search:
	
		Download vmware
		
		Download oracle pre-build virtual machine
		
		Download oracle database
		
		Download oracle sql developer
		
		
	- SQL:
	
		- sql:
		
			Ch√∫ √Ω ph·∫£i ƒë·ªÉ ƒë√∫ng ƒë∆∞·ªùng d·∫´n c·ªßa SAMPLE_SCHEMAS
	
				sqlplus sys/ngoctuan99@localhost:1521/orclpdb as sysdba;
				alter pluggable database open;
				alter pluggable database orclpdb save state;
				create or replace directory import_dir as 'C:\SAMPLE_SCHEMAS';
				exit
				impdp system/ngoctuan99@localhost:1521/orclpdb schemas=hr directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS
				impdp system/ngoctuan99@localhost:1521/orclpdb schemas=sh directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS
				impdp system/ngoctuan99@localhost:1521/orclpdb schemas=oe directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS
				impdp system/ngoctuan99@localhost:1521/orclpdb schemas=pm directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS
				impdp system/ngoctuan99@localhost:1521/orclpdb schemas=ix directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS
				sqlplus sys/ngoctuan99@localhost:1521/orclpdb as sysdba;
				alter user hr identified by hr account unlock;
				alter user sh identified by ngoctuan99 account unlock;
				alter user oe identified by ngoctuan99 account unlock;
				alter user pm identified by ngoctuan99 account unlock;
				alter user ix identified by ngoctuan99 account unlock;
			
			T·ªïng quan m·ª•c ti√™u c·ªßa chu·ªói l·ªánh

				B·∫°n ƒëang l√†m 3 vi·ªác l·ªõn:

				M·ªü Pluggable Database (PDB) ƒë·ªÉ l√†m vi·ªác.

				Chu·∫©n b·ªã m√¥i tr∆∞·ªùng import (directory logic v√† file dump).

				Import l·∫°i c√°c schema m·∫´u (HR, SH, OE, PM, IX) v√†o PDB ƒë·ªÉ s·ª≠ d·ª•ng trong h·ªçc v√† th·ª±c h√†nh.
				
			Ph√¢n t√≠ch chi ti·∫øt t·ª´ng l·ªánh
			
				M·ªü SQL*Plus v√† k·∫øt n·ªëi SYSDBA v√†o PDB:
				
					sqlplus sys/ngoctuan99@localhost:1521/orclpdb as sysdba;

					M·ª•c ƒë√≠ch:

						K·∫øt n·ªëi ƒë·∫øn Pluggable Database (PDB) c√≥ t√™n orclpdb.

						D√πng t√†i kho·∫£n SYS (quy·ªÅn SYSDBA) ‚Üí quy·ªÅn cao nh·∫•t, c√≥ th·ªÉ th·ª±c hi·ªán m·ªçi thao t√°c h·ªá th·ªëng.

						@localhost:1521/orclpdb: k·∫øt n·ªëi t·ªõi PDB (kh√¥ng ph·∫£i CDB g·ªëc).

					B·∫£n ch·∫•t:

						Trong ki·∫øn tr√∫c Multitenant, Oracle c√≥:

							CDB$ROOT (container ch√≠nh)

							PDBs (c√°c database con ch·ª©a schemas th·∫≠t s·ª±)

						M·ªçi thao t√°c d·ªØ li·ªáu (nh∆∞ import schema) ph·∫£i th·ª±c hi·ªán trong PDB, kh√¥ng ph·∫£i CDB.
						
				M·ªü PDB (n·∫øu ƒëang ·ªü tr·∫°ng th√°i MOUNTED):
				
					alter pluggable database open;

					M·ª•c ƒë√≠ch:

						Khi Oracle kh·ªüi ƒë·ªông, PDB c√≥ th·ªÉ ·ªü tr·∫°ng th√°i MOUNTED (ƒë√≥ng).

						C√¢u l·ªánh n√†y m·ªü PDB ƒë·ªÉ n√≥ s·∫µn s√†ng cho k·∫øt n·ªëi v√† thao t√°c d·ªØ li·ªáu.

					N·ªôi b·ªô Oracle:

						Khi m·ªü PDB, Oracle mount c√°c datafiles li√™n quan.

						Cho ph√©p session k·∫øt n·ªëi t·ªõi PDB ƒë√≥.
						
					Gi·ªØ PDB t·ª± ƒë·ªông m·ªü sau khi restart
					
						alter pluggable database orclpdb save state;

						M·ª•c ƒë√≠ch:

							L∆∞u l·∫°i tr·∫°ng th√°i "OPEN" c·ªßa PDB.

							Khi Oracle Database kh·ªüi ƒë·ªông l·∫°i, PDB orclpdb s·∫Ω t·ª± m·ªü l·∫°i t·ª± ƒë·ªông.

						N·∫øu kh√¥ng c√≥ l·ªánh n√†y:

							Sau m·ªói l·∫ßn restart instance, b·∫°n ph·∫£i th·ªß c√¥ng ALTER PLUGGABLE DATABASE OPEN;
							
					T·∫°o Directory logic cho import/export:
					
						create or replace directory import_dir as 'C:\SAMPLE_SCHEMAS';

						M·ª•c ƒë√≠ch:

							T·∫°o Oracle Directory Object tr·ªè ƒë·∫øn th∆∞ m·ª•c v·∫≠t l√Ω tr√™n h·ªá th·ªëng ch·ª©a file .dmp.

						B·∫£n ch·∫•t:

							import_dir ch·ªâ l√† t√™n logic b√™n trong Oracle.

							Oracle kh√¥ng truy c·∫≠p tr·ª±c ti·∫øp file system, m√† ch·ªâ qua directory object ƒë∆∞·ª£c c·∫•p quy·ªÅn.

							Th∆∞ m·ª•c C:\SAMPLE_SCHEMAS ph·∫£i t·ªìn t·∫°i v√† ng∆∞·ªùi d√πng Oracle c√≥ quy·ªÅn ƒë·ªçc/ghi.
							
					Tho√°t SQL*Plus:
					
						exit

						M·ª•c ƒë√≠ch:

							Quay v·ªÅ d√≤ng l·ªánh h·ªá ƒëi·ªÅu h√†nh (Windows CMD).

							V√¨ c√¥ng c·ª• import (impdp) ch·∫°y ngo√†i SQL*Plus.
							
					Import c√°c schema m·∫´u (b·ªô Sample Schemas):
					
						impdp system/ngoctuan99@localhost:1521/orclpdb schemas=hr directory=import_dir dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp logfile=import.log remap_tablespace=EXAMPLE:USERS

						M·ª•c ƒë√≠ch:

							S·ª≠ d·ª•ng c√¥ng c·ª• Data Pump Import (impdp) ƒë·ªÉ n·∫°p l·∫°i d·ªØ li·ªáu cho schema HR.

							File ngu·ªìn l√† EXPORTED_SAMPLE_SCHEMAS.dmp ‚Äî dump ch·ª©a t·∫•t c·∫£ schemas m·∫´u c·ªßa Oracle.

						Tham s·ªë:
						
							Tham s·ªë											√ù nghƒ©a
							
							system/ngoctuan99@localhost:1521/orclpdb		K·∫øt n·ªëi user system trong PDB
							schemas=hr										Import schema HR
							directory=import_dir							ƒê∆∞·ªùng d·∫´n logic ch·ª©a file dump
							dumpfile=EXPORTED_SAMPLE_SCHEMAS.dmp			File dump ƒë√£ export tr∆∞·ªõc ƒë√≥
							logfile=import.log								Ghi log import v√†o file log
							remap_tablespace=EXAMPLE:USERS					Chuy·ªÉn d·ªØ li·ªáu t·ª´ tablespace g·ªëc EXAMPLE sang USERS (v√¨ c√≥ th·ªÉ
																			PDB kh√¥ng c√≥ tablespace EXAMPLE)
																			
					ƒêƒÉng nh·∫≠p l·∫°i SYS ƒë·ªÉ m·ªü kh√≥a ng∆∞·ªùi d√πng:
					
						sqlplus sys/ngoctuan99@localhost:1521/orclpdb as sysdba;

						M·ªü l·∫°i SQL*Plus ƒë·ªÉ c·∫•p quy·ªÅn v√† m·ªü kh√≥a c√°c schema m·ªõi import.
						
					M·ªü kh√≥a v√† ƒë·∫∑t m·∫≠t kh·∫©u cho c√°c user:
					
						alter user hr identified by hr account unlock;
						alter user sh identified by ngoctuan99 account unlock;
						alter user oe identified by ngoctuan99 account unlock;
						alter user pm identified by ngoctuan99 account unlock;
						alter user ix identified by ngoctuan99 account unlock;

						M·ª•c ƒë√≠ch:

						Sau khi import, c√°c user th∆∞·ªùng b·ªã kh√≥a (LOCKED) ƒë·ªÉ b·∫£o m·∫≠t.

						L·ªánh n√†y:

							identified by ...: ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u.

							account unlock: m·ªü kh√≥a t√†i kho·∫£n ƒë·ªÉ c√≥ th·ªÉ ƒëƒÉng nh·∫≠p.

						Th·ª±c t·∫ø:

							Sau khi unlock, b·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p b·∫±ng v√≠ d·ª•:

								sqlplus hr/hr@localhost:1521/orclpdb
								sqlplus sh/ngoctuan99@localhost:1521/orclpdb		
		
		

	C√°ch ƒë·ªÉ c√≥ ƒë∆∞·ª£c m·ªôt c∆° s·ªü d·ªØ li·ªáu:
	
		Virtual Machine (M√°y ·∫£o):

			S·ª≠ d·ª•ng m·ªôt m√°y ·∫£o ƒë·ªÉ ch·∫°y c∆° s·ªü d·ªØ li·ªáu. ƒêi·ªÅu n√†y cho ph√©p ng∆∞·ªùi d√πng thao t√°c trong m·ªôt m√¥i
			tr∆∞·ªùng ƒë∆∞·ª£c c√°ch ly, c√≥ th·ªÉ d·ªÖ d√†ng c·∫•u h√¨nh v√† qu·∫£n l√Ω.
		
		Local Installation (C√†i ƒë·∫∑t c·ª•c b·ªô):

			C√†i ƒë·∫∑t c∆° s·ªü d·ªØ li·ªáu tr·ª±c ti·∫øp tr√™n m√°y t√≠nh c√° nh√¢n ho·∫∑c m√°y ch·ªß c·ªßa b·∫°n. ƒê√¢y l√† c√°ch truy·ªÅn
			th·ªëng v√† ph·ªï bi·∫øn ƒë·ªÉ s·ª≠ d·ª•ng c∆° s·ªü d·ªØ li·ªáu, cho ph√©p truy c·∫≠p tr·ª±c ti·∫øp v√† t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t.
		
		Oracle Live SQL:

			M·ªôt d·ªãch v·ª• tr·ª±c tuy·∫øn cho ph√©p ng∆∞·ªùi d√πng th·ª±c hi·ªán c√°c truy v·∫•n SQL m√† kh√¥ng c·∫ßn c√†i ƒë·∫∑t
			ph·∫ßn m·ªÅm. Th√≠ch h·ª£p cho vi·ªác h·ªçc t·∫≠p v√† th·ª≠ nghi·ªám nhanh ch√≥ng.
			
	Software Installations - Pluggable Database (PDB):
	
		ƒê·ªãnh nghƒ©a c·ªët l√µi

			Pluggable Database (PDB) l√† m·ªôt c∆° s·ªü d·ªØ li·ªáu con (database con) ch·∫°y b√™n trong m·ªôt Container Database (CDB).

			Hi·ªÉu n√¥m na:

				CDB gi·ªëng nh∆∞ ‚Äúh·ªá th·ªëng ch√≠nh‚Äù ho·∫∑c ‚Äúng√¥i nh√† chung‚Äù.

				M·ªói PDB l√† ‚Äúm·ªôt cƒÉn h·ªô ri√™ng‚Äù trong ng√¥i nh√† ƒë√≥, c√≥ d·ªØ li·ªáu, user, schema, tablespace ri√™ng c·ªßa n√≥.

			M·ªôt Oracle instance (b·ªô nh·ªõ, ti·∫øn tr√¨nh) c√≥ th·ªÉ ch·∫°y nhi·ªÅu PDB c√πng l√∫c th√¥ng qua m·ªôt CDB duy nh·∫•t.
			
			C·∫•u tr√∫c c∆° b·∫£n trong ki·∫øn tr√∫c Multitenant:

				T·ª´ Oracle 12c tr·ªü ƒëi, ta c√≥:

					Th√†nh ph·∫ßn				Vi·∫øt t·∫Øt			Vai tr√≤
					
					Container Database		CDB					‚ÄúTh√πng ch·ª©a‚Äù ch√≠nh, c√≥ th·ªÉ ch·ª©a nhi·ªÅu PDB
					Root container			CDB$ROOT			Ch·ª©a metadata, d·ªØ li·ªáu h·ªá th·ªëng Oracle
					Seed PDB				PDB$SEED			M·∫´u chu·∫©n ƒë·ªÉ t·∫°o PDB m·ªõi (read-only)
					Pluggable Database		PDB					Database ng∆∞·ªùi d√πng th·ª±c t·∫ø (VD: HR, SALES, APPDB, ORCLPDB, v.v.)
					
			L·ª£i √≠ch c·ªßa ki·∫øn tr√∫c Pluggable:
			
				L·ª£i √≠ch						M√¥ t·∫£
				
				D·ªÖ qu·∫£n l√Ω					M·ªôt instance qu·∫£n l√Ω nhi·ªÅu PDB ‚Üí √≠t t·ªën t√†i nguy√™n h∆°n
				D·ªÖ backup/restore			C√≥ th·ªÉ export/import ho·∫∑c unplug/plug t·ª´ng PDB
				C√¥ l·∫≠p d·ªØ li·ªáu				M·ªói PDB ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p, l·ªói 1 PDB kh√¥ng ·∫£nh h∆∞·ªüng PDB kh√°c
				N√¢ng c·∫•p d·ªÖ d√†ng			C√≥ th·ªÉ n√¢ng c·∫•p CDB m√† kh√¥ng c·∫ßn rebuild t·ª´ng database
				Tri·ªÉn khai nhanh			T·∫°o PDB m·ªõi ch·ªâ c·∫ßn clone t·ª´ PDB$SEED (r·∫•t nhanh)
			
			C√°ch ho·∫°t ƒë·ªông trong th·ª±c t·∫ø

				Khi b·∫°n c√†i Oracle 19c, b·∫°n c√≥ th·ªÉ c√≥:

					M·ªôt CDB: ORCLCDB

					M·ªôt PDB m·∫∑c ƒë·ªãnh: ORCLPDB

					Khi b·∫°n m·ªü SQL*Plus v√† k·∫øt n·ªëi nh∆∞:

						sqlplus system/password@localhost:1521/orclpdb
							
							B·∫°n ƒëang k·∫øt n·ªëi tr·ª±c ti·∫øp v√†o PDB (t·ª©c database con).
							
							N·∫øu kh√¥ng ch·ªâ r√µ /orclpdb, b·∫°n m·∫∑c ƒë·ªãnh v√†o CDB$ROOT.
							
			C√°c l·ªánh c∆° b·∫£n v·ªõi PDB
			
			M·ª•c ti√™u				L·ªánh v√≠ d·ª•
			
			Xem danh s√°ch PDB		SHOW PDBS; ho·∫∑c SELECT name FROM v$pdbs;
			M·ªü PDB					ALTER PLUGGABLE DATABASE orclpdb OPEN;
			ƒê√≥ng PDB				ALTER PLUGGABLE DATABASE orclpdb CLOSE;
			Chuy·ªÉn container		ALTER SESSION SET CONTAINER=orclpdb;
			T·∫°o PDB m·ªõi				CREATE PLUGGABLE DATABASE newpdb ADMIN USER pdbadmin IDENTIFIED BY 123;


üëâ B·∫°n ƒëang k·∫øt n·ªëi tr·ª±c ti·∫øp v√†o PDB (t·ª©c database con).
N·∫øu kh√¥ng ch·ªâ r√µ /orclpdb, b·∫°n m·∫∑c ƒë·ªãnh v√†o CDB$ROOT.
			
	
--- Oracle Database Architecture:

	Oracle Database Architecture - Ki·∫øn tr√∫c trong Oracle:
	
		T·ªïng quan ki·∫øn tr√∫c (Client ‚Äî Server)

			Client (User process): ch∆∞∆°ng tr√¨nh ng∆∞·ªùi d√πng (v√≠ d·ª• SQL*Plus, ·ª©ng d·ª•ng) kh·ªüi t·∫°o user
			process ƒë·ªÉ g·ª≠i y√™u c·∫ßu t·ªõi database.

			Server: khi nh·∫≠n k·∫øt n·ªëi, Oracle g√°n server process (ho·∫∑c dispatcher/PMON trong shared server)
			ƒë·ªÉ x·ª≠ l√Ω y√™u c·∫ßu c·ªßa user process. Server process ch·ªãu tr√°ch nhi·ªám th·ª±c hi·ªán parsing, execution,
			fetch d·ªØ li·ªáu t·ª´ b·ªô nh·ªõ/disk.

			M·ªëi quan h·ªá: user process ‚Üî server process (request/response). Ki·∫øn tr√∫c client/server n√†y t√°ch
			r√µ ph·∫ßn client (giao di·ªán) v√† ph·∫ßn x·ª≠ l√Ω DB (server).
			
		SGA (System Global Area) ‚Äî v√πng nh·ªõ chia s·∫ª

			SGA l√† v√πng nh·ªõ chung cho t·∫•t c·∫£ c√°c server process. ·∫¢nh bi·ªÉu di·ªÖn m·ªôt kh·ªëi l·ªõn g·ªçi l√† SGA ch·ª©a nhi·ªÅu th√†nh ph·∫ßn con:

			C√°c th√†nh ph·∫ßn ch√≠nh trong SGA:

				Database Buffer Cache (buffer cache):

					L∆∞u c√°c block d·ªØ li·ªáu (data blocks) ƒë√£ ƒë·ªçc t·ª´ datafiles.

					Khi m·ªôt truy v·∫•n SELECT c·∫ßn block, server process t√¨m trong buffer cache tr∆∞·ªõc; n·∫øu kh√¥ng
					c√≥, ƒë·ªçc t·ª´ datafile v√†o buffer cache.

					Th·ª±c hi·ªán dirty buffer (ghi thay ƒë·ªïi) cho UPDATE/INSERT ‚Üí s·∫Ω ƒë∆∞·ª£c DBWR (database writer) ghi
					ra datafiles theo th·ªùi ƒëi·ªÉm checkpoint ho·∫∑c khi c·∫ßn b·ªô nh·ªõ.

				Shared Pool:

					Library cache: ch·ª©a parsed SQL, execution plans, cursors. Quan tr·ªçng cho vi·ªác reuse k·∫ø ho·∫°ch (soft parse).

					Data dictionary cache (row cache): cache metadata (schema, quy·ªÅn, th·ªëng k√™).

					Result cache (n·∫øu b·∫≠t): l∆∞u k·∫øt qu·∫£ truy v·∫•n hay function ƒë·ªÉ tr·∫£ l·∫°i nhanh.

					Shared pool c√†ng l·ªõn th√¨ kh·∫£ nƒÉng reuse cursor & gi·∫£m hard-parse c√†ng t·ªët.

				Redo Log Buffer:

					L∆∞u th√¥ng tin redo (nh·ªØng thay ƒë·ªïi nh·ªù DML) tr∆∞·ªõc khi ghi v√†o redo log files.

					Khi commit, LGWR (log writer) s·∫Ω flush redo buffer ra redo log files; vi·ªác n√†y ƒë·∫£m b·∫£o durability.

				Large pool / Java pool / Streams pool:

					Large pool: d√πng cho backup/restore (RMAN), parallel query ho·∫∑c session memory for shared server.

					Java pool: b·ªô nh·ªõ cho Java VM trong Oracle.

					Streams pool: d√πng n·∫øu d√πng Oracle Streams cho replication.

				SGA: Shared SQL area, Private SQL area (tho√°ng qua)

					Private SQL area th·ª±c t·∫ø l√† trong PGA cho bind variables, runtime state (sort area) cho session.
					
			PGA (Program Global Area) ‚Äî v√πng nh·ªõ ri√™ng c·ªßa server process:

				PGA l√† v√πng nh·ªõ ri√™ng cho m·ªói server process (ho·∫∑c m·ªói background process), kh√¥ng chia s·∫ª.

				Ch·ª©a: private SQL area (runtime structures, bind variable values, sort area, hash join memory).

				C·∫•u h√¨nh: PGA_AGGREGATE_TARGET ho·∫∑c PGA_AGGREGATE_LIMIT ƒë·ªÉ gi·ªõi h·∫°n t·ªïng PGA d√πng.
				
			Datafiles / Redo Logs (v·∫≠t l√Ω tr√™n disk)

				Datafiles: n∆°i l∆∞u th·ª±c t·∫ø d·ªØ li·ªáu (tables, indexes). Buffer cache ch·ª©a c√°c block copy t·ª´ datafiles.

				Redo log files (online redo logs): l∆∞u lu·ªìng redo ƒë·ªÉ recover DB khi crash. LGWR ghi t·ª´
				redo log buffer ‚Üí redo files.

				·∫¢nh cho th·∫•y nhi·ªÅu ‚Äúƒëƒ©a‚Äù bi·ªÉu di·ªÖn data + 1 cu·ªôn cho Redo Log.
				
			Lu·ªìng ho·∫°t ƒë·ªông khi th·ª±c hi·ªán 1 truy v·∫•n (v√≠ d·ª• UPDATE):

				T√≥m t·∫Øt b∆∞·ªõc-by-step:

					User process g·ª≠i SQL t·ªõi Server process.

					Server process ki·ªÉm tra library cache (shared pool) ƒë·ªÉ xem c√≥ cursor/existing execution
					plan (soft parse).

						N·∫øu kh√¥ng c√≥ ‚Üí hard parse (ki·ªÉm tra c√∫ ph√°p, truy v·∫•n optimizer, t·∫°o execution plan) v√† l∆∞u
						v√†o library cache.

					Server process x√°c ƒë·ªãnh block c·∫ßn ƒë·ªçc ‚Üí ki·ªÉm tra Database Buffer Cache:

						N·∫øu block c√≥ trong cache ‚Üí ƒë·ªçc t·ª´ cache (fast).

						N·∫øu kh√¥ng ‚Üí ƒë·ªçc t·ª´ datafile v√†o buffer cache (I/O physical read).

					N·∫øu l√† UPDATE/INSERT: server process thay ƒë·ªïi block trong buffer cache (ƒë√°nh d·∫•u dirty), t·∫°o redo entry
					v√† ghi v√†o Redo Log Buffer.

					Khi commit: LGWR s·∫Ω flush redo log buffer ra physical redo log file. Commit ch·ªâ ho√†n t·∫•t khi redo ƒë√£ ƒë∆∞·ª£c
					ghi (ƒë·∫£m b·∫£o durability).

					DBWR (database writer) s·∫Ω ghi dirty buffers t·ª´ buffer cache ra datafiles khi:

						C√≥ checkpoint, hay buffer cache c·∫ßn kh√¥ng gian, ho·∫∑c theo ch√≠nh s√°ch.

					Trong s·ª± c·ªë, d√πng redo + datafiles ƒë·ªÉ recover.
					
			C√°c background processes (li√™n quan tuning & ho·∫°t ƒë·ªông)

				Diagram kh√¥ng li·ªát k√™ t√™n t·∫•t c·∫£, nh∆∞ng ƒë√¢y l√† nh·ªØng process quan tr·ªçng:

					LGWR ‚Äî Log Writer (ghi redo buffer ‚Üí redo files).

					DBWR ‚Äî Database Writer (ghi dirty buffers ‚Üí datafiles).

					SMON ‚Äî System Monitor (instance recovery).

					PMON ‚Äî Process Monitor (d·ªçn session/clean up).

					CKPT ‚Äî Checkpoint (c·∫≠p nh·∫≠t headers, SCN).

					ARCH ‚Äî Archiver (n·∫øu database ·ªü ARCHIVELOG mode, copy redo logs sang archive).

					MMON/MMON/ARC/RECO ... t√πy t√≠nh nƒÉng.
		
			Hi·ªÉu r√µ v·ªÅ parse / execute / fetch v√† v·∫•n ƒë·ªÅ performance

				Hard parse: optimizer t·∫°o plan ‚Üí t·ªën CPU, latch contention tr√™n library cache. Gi·∫£m hard-parse b·∫±ng:

					D√πng bind variables (kh√¥ng concat gi√° tr·ªã v√†o SQL).

					Reuse cursors (cursor_sharing, FORCE ch·ªâ d√πng c·∫©n tr·ªçng).

				Soft parse: reuse plan t·ª´ library cache ‚Üí nhanh.

				Sort & temp space: n·∫øu sort l·ªõn h∆°n memory (PGA), Oracle s·∫Ω s·ª≠ d·ª•ng temporary tablespace (disk) ‚Üí ch·∫≠m.
				
			C√°c ch·ªâ s·ªë/Views ƒë·ªÉ ki·ªÉm tra trong Oracle

				Xem SGA/PGA k√≠ch th∆∞·ªõc:

					SHOW PARAMETER sga_target; SHOW PARAMETER pga_aggregate_target;

					SELECT * FROM V$SGA; SELECT * FROM V$SGA_DYNAMIC_COMPONENTS;

				Monitor buffer cache / I/O:

					SELECT * FROM V$BUFFER_POOL;

					SELECT name, value FROM v$sysstat WHERE name LIKE '%physical reads%';

				Library cache / SQL:

					SELECT namespace, pin_sleeps, pins FROM v$librarycache;

					SELECT * FROM v$sql WHERE sql_text LIKE '%...%';

				Redo / log:

					SELECT group#, members, archival_status FROM v$log;

					SELECT * FROM v$log_history;

				Wait events & AWR:

					SELECT event, total_waits, time_waited FROM v$system_event ORDER BY time_waited DESC;

					AWR/ASH reports (Enterprise) ƒë·ªÉ t√¨m bottlenecks.
					
			Nh·ªØng ƒëi·ªÉm tuning quan tr·ªçng d·ª±a tr√™n ki·∫øn tr√∫c n√†y:

				K√≠ch th∆∞·ªõc SGA ƒë√∫ng: too small ‚Üí nhi·ªÅu physical reads, too big ‚Üí l√£ng ph√≠.

					TƒÉng shared_pool n·∫øu nhi·ªÅu hard parses.

					T·ªëi ∆∞u buffer cache ƒë·ªÉ tƒÉng hit ratio (reduce physical I/O).

				Gi·∫£m hard parse: d√πng bind variables, tr√°nh dynamic SQL kh√¥ng c·∫ßn thi·∫øt, cache prepared statements ·ªü ·ª©ng d·ª•ng.

				PGA ƒë·ªß cho sorts/joins: tr√°nh spill to disk (gi·∫£m temp I/O).

				Redo log sizing & group count: nh·ªè qu√° ‚Üí LGWR flush nhi·ªÅu ‚Üí hi·ªáu nƒÉng k√©m; n√™n c√≥ ƒë·ªß size v√† nh√≥m, v√† d√πng multiplexed members.

				I/O subsystem: n·∫øu physical reads/writes cao, c·∫ßn check storage (throughput/latency).

				Concurrency contention: library cache latches, buffer busy waits ‚Üí c·∫ßn ph√¢n t√≠ch SQL hot spots, partitioning, ho·∫∑c redesign.

				Use EXPLAIN PLAN / SQL Trace: ƒë·ªÉ th·∫•y execution plan v√† chi ph√≠.
				
			V√≠ d·ª• th·ª±c t·∫ø ‚Äî chu tr√¨nh truy v·∫•n SELECT ƒë∆°n gi·∫£n:

				Client g·ª≠i SELECT * FROM employees WHERE deptno = 10;

				Server process t√¨m SQL trong library cache:

				N·∫øu c√≥: reuse plan ‚Üí lookup blocks trong buffer cache.

				N·∫øu kh√¥ng: hard parse ‚Üí optimizer ch·ªçn plan (index scan hay full table scan).

				N·∫øu block kh√¥ng c√≥ trong buffer cache ‚Üí physical read t·ª´ datafile ‚Üí load v√†o buffer cache ‚Üí tr·∫£ k·∫øt qu·∫£ cho client.
				
			L·ªùi khuy√™n khi ƒë·ªçc/√°p d·ª•ng ki·∫øn tr√∫c n√†y

				Khi debug performance: b·∫Øt ƒë·∫ßu xem wait events (v$session_wait, AWR), X√°c ƒë·ªãnh xem
				bottleneck l√† CPU / IO / contention / memory.

				Lu√¥n ki·ªÉm tra top SQL (V$SQL) ƒë·ªÉ t√¨m queries g√¢y I/O/CPU nhi·ªÅu nh·∫•t v√† t·ªëi ∆∞u ch√∫ng (index, rewrite, statistics).

				Th·ª±c hi·ªán ph√¢n b·ªï h·ª£p l√Ω cho SGA/PGA, v√† c√¢n nh·∫Øc Automatic Memory Management (AMM/ASMM) n·∫øu ph√π h·ª£p.
				
			T√≥m t·∫Øt ng·∫Øn (one-liner)

				·∫¢nh m√¥ t·∫£: client g·ª≠i y√™u c·∫ßu ‚Üí server process x·ª≠ l√Ω, d√πng SGA (shared pool, buffer cache, redo buffer, large/java/streams pools)
				v√† PGA (private memory) ƒë·ªÉ th·ª±c hi·ªán truy v·∫•n; thay ƒë·ªïi ƒë∆∞·ª£c ghi v√†o redo buffer tr∆∞·ªõc, commit flush b·∫±ng LGWR; dirty blocks ƒë∆∞·ª£c
				DBWR ghi ra datafiles ‚Äî to√†n b·ªô ki·∫øn tr√∫c h∆∞·ªõng t·ªõi ƒë·∫£m b·∫£o hi·ªáu nƒÉng (caching) v√† ƒë·ªô b·ªÅn (redo + background processes).
				
				
--- Execution Plans & Statistics:

	- Tool -> Preference -> Database -> Autotrace/Explain plan

	- T√¨m hi·ªÉu:
	
		C·∫ßn ph√¢n bi·ªát system statistic v√† optimizer statistic
		
		Giai thich ve explain plan, autotrace va V$SQL_PLAN

	Execution Plans & Statistics - SYSTEM l√† m·ªôt t√†i kho·∫£n qu·∫£n tr·ªã m·∫∑c ƒë·ªãnh c·ªßa Oracle Database:
	
		Oracle c√≥ v√†i user m·∫∑c ƒë·ªãnh khi c√†i DB:

			SYS: superuser c·∫•p cao nh·∫•t, s·ªü h·ªØu to√†n b·ªô dictionary.

			SYSTEM: user qu·∫£n tr·ªã c·∫•p cao, th∆∞·ªùng d√πng ƒë·ªÉ qu·∫£n l√Ω c·∫•u h√¨nh, th·ªëng k√™, t·∫°o schema, nh∆∞ng √≠t quy·ªÅn h∆°n SYS.
			
	- SQL:
	
		- sql: exec dbms_stats.gather_system_stats('Start');
		
			L√† m·ªôt l·ªánh quan tr·ªçng trong Oracle Database, ƒë∆∞·ª£c d√πng trong qu√° tr√¨nh thu th·∫≠p th·ªëng k√™ h·ªá th·ªëng (System Statistics)
			ƒë·ªÉ gi√∫p Oracle Optimizer t·ªëi ∆∞u k·∫ø ho·∫°ch th·ª±c thi SQL t·ªët h∆°n.

			ƒê·ªãnh nghƒ©a c·ªët l√µi:

				DBMS_STATS.GATHER_SYSTEM_STATS l√† th·ªß t·ª•c (procedure) thu·ªôc package DBMS_STATS do Oracle cung c·∫•p.
				‚Üí N√≥ d√πng ƒë·ªÉ thu th·∫≠p th√¥ng tin v·ªÅ hi·ªáu nƒÉng ph·∫ßn c·ª©ng c·ªßa h·ªá th·ªëng: t·ªëc ƒë·ªô CPU, t·ªëc ƒë·ªô I/O, t·ªâ l·ªá ch·ªù, v.v.

				Oracle Optimizer s·∫Ω d·ª±a tr√™n c√°c th·ªëng k√™ n√†y ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng chi ph√≠ th·ª±c thi truy v·∫•n (cost) ch√≠nh x√°c h∆°n ‚Äî t·ª´ ƒë√≥
				ch·ªçn k·∫ø ho·∫°ch t·ªëi ∆∞u nh·∫•t.

			B·∫£n ch·∫•t & c∆° ch·∫ø ho·∫°t ƒë·ªông:
			
			Khi b·∫°n ch·∫°y:
				
				EXEC DBMS_STATS.GATHER_SYSTEM_STATS('START');

				Oracle b·∫Øt ƒë·∫ßu ghi nh·∫≠n (b·∫Øt m·∫´u th·ªëng k√™) c√°c ƒë·∫∑c t√≠nh ho·∫°t ƒë·ªông c·ªßa h·ªá th·ªëng:

					Th·ªùi gian CPU trung b√¨nh cho m·ªôt thao t√°c.

					T·ªëc ƒë·ªô ƒë·ªçc I/O tr√™n ƒëƒ©a.

					T·ª∑ l·ªá gi·ªØa th·ªùi gian ch·ªù I/O v√† CPU.

					S·ªë l∆∞·ª£ng I/O th·ª±c t·∫ø trong c√°c truy v·∫•n.

				C·ª• th·ªÉ, Oracle ghi l·∫°i trong n·ªÅn (background):

					M·ª©c ƒë·ªô s·ª≠ d·ª•ng CPU.

					S·ªë block ƒë·ªçc ƒë∆∞·ª£c trong m·ªói I/O.

					T·ªëc ƒë·ªô x·ª≠ l√Ω I/O (MB/s ho·∫∑c block/s).

			Khi b·∫°n ch·∫°y ti·∫øp:
			
				EXEC DBMS_STATS.GATHER_SYSTEM_STATS('STOP');

				Oracle k·∫øt th√∫c qu√° tr√¨nh thu th·∫≠p, v√† ghi d·ªØ li·ªáu thu ƒë∆∞·ª£c v√†o b·∫£ng th·ªëng k√™ h·ªá th·ªëng
				trong data dictionary (SYS.AUX_STATS$).

				Optimizer sau ƒë√≥ s·∫Ω s·ª≠ d·ª•ng c√°c gi√° tr·ªã n√†y ƒë·ªÉ ƒë√°nh gi√° ‚Äúchi ph√≠‚Äù (cost) cho c√°c ph√©p join,
				full scan, index scan... d·ª±a v√†o ƒëi·ªÅu ki·ªán th·ª±c t·∫ø c·ªßa h·ªá th·ªëng.

			C√°c tham s·ªë kh√°c c·ªßa h√†m n√†y

				C√∫ ph√°p ƒë·∫ßy ƒë·ªß:

					DBMS_STATS.GATHER_SYSTEM_STATS (
					   gathering_mode  IN  VARCHAR2 DEFAULT 'NOWORKLOAD',
					   interval         IN  NUMBER   DEFAULT NULL,
					   stattab          IN  VARCHAR2 DEFAULT NULL,
					   statid           IN  VARCHAR2 DEFAULT NULL,
					   statown          IN  VARCHAR2 DEFAULT NULL
					);

				Tham s·ªë	√ù nghƒ©a:
				
					'START'	B·∫Øt ƒë·∫ßu thu th·∫≠p th·ªëng k√™ (workload statistics).
					'STOP'	D·ª´ng v√† ghi k·∫øt qu·∫£ th·ªëng k√™ ƒë√£ thu.
					'INTERVAL'	Cho ph√©p t·ª± thu th·∫≠p trong kho·∫£ng th·ªùi gian x√°c ƒë·ªãnh (theo ph√∫t).
					'NOWORKLOAD'	Thu th·∫≠p nhanh m√† kh√¥ng c·∫ßn ch·∫°y truy v·∫•n th·ª±c t·∫ø (Oracle ∆∞·ªõc l∆∞·ª£ng th√¥ng qua I/O test).

			Ph√¢n bi·ªát hai ki·ªÉu th·ªëng k√™
			
				Ki·ªÉu th·ªëng k√™				C√°ch ch·∫°y									√ù nghƒ©a
				Workload Statistics			'START' ‚Üí ch·∫°y workload th·ª±c t·∫ø ‚Üí 'STOP'	Oracle quan s√°t truy v·∫•n th·∫≠t ‚Üí ch√≠nh x√°c h∆°n.
				Noworkload Statistics		'NOWORKLOAD'								Oracle t·ª± ki·ªÉm tra hi·ªáu nƒÉng I/O v√† CPU ‚Üí nhanh nh∆∞ng k√©m ch√≠nh x√°c.					
		
		- sql: select * from sys.aux_stats$;
		
			L√† b∆∞·ªõc quan tr·ªçng ƒë·ªÉ xem k·∫øt qu·∫£ m√† b·∫°n ƒë√£ thu th·∫≠p ƒë∆∞·ª£c b·∫±ng l·ªánh DBMS_STATS.GATHER_SYSTEM_STATS.
	
			SYS.AUX_STATS$ l√† m·ªôt b·∫£ng h·ªá th·ªëng n·ªôi b·ªô (data dictionary table) do Oracle
			Database qu·∫£n l√Ω.

				B·∫£ng n√†y ch·ª©a c√°c th·ªëng k√™ h·ªá th·ªëng (System Statistics) ƒë∆∞·ª£c thu th·∫≠p
				b·ªüi package DBMS_STATS.

				C√°c gi√° tr·ªã trong b·∫£ng n√†y gi√∫p Cost-Based Optimizer (CBO) ∆∞·ªõc l∆∞·ª£ng chi
				ph√≠ CPU, I/O, t·ªëc ƒë·ªô ƒë·ªçc ƒëƒ©a, v.v.
				
			Khi b·∫°n ch·∫°y:

				SELECT * FROM sys.aux_stats$;

				‚Üí b·∫°n ƒëang xem to√†n b·ªô d·ªØ li·ªáu th·ªëng k√™ v·ªÅ hi·ªáu nƒÉng ph·∫ßn c·ª©ng m√† Oracle l∆∞u
				tr·ªØ ƒë·ªÉ t·ªëi ∆∞u h√≥a truy v·∫•n.
				
			C·∫•u tr√∫c b·∫£ng SYS.AUX_STATS$

				B·∫£ng n√†y c√≥ c√°c c·ªôt ch√≠nh nh∆∞ sau:

					C·ªôt	 		Ki·ªÉu d·ªØ li·ªáu	√ù nghƒ©a
					SNAME		VARCHAR2		T√™n nh√≥m th·ªëng k√™ (v√≠ d·ª•: SYSSTATS_MAIN, SYSSTATS_INFO)
					PNAME		VARCHAR2		T√™n th√¥ng s·ªë c·ª• th·ªÉ (v√≠ d·ª•: CPUSPEEDNW, IOSEEKTIM)
					PVAL1		NUMBER			Gi√° tr·ªã s·ªë c·ªßa th·ªëng k√™ (v√≠ d·ª•: 1700, 10, 4096, ...)
					PVAL2		VARCHAR2		Gi√° tr·ªã ph·ª• (√≠t d√πng, ƒë√¥i khi null)
					
			C√°c nh√≥m th·ªëng k√™ ch√≠nh trong SYS.AUX_STATS$

				Sau khi thu th·∫≠p, b·∫°n s·∫Ω th·∫•y 2 nh√≥m l·ªõn:

					Nh√≥m 1 ‚Äî SYSSTATS_MAIN

						ƒê√¢y l√† System Statistics ch√≠nh (quan tr·ªçng nh·∫•t cho Optimizer).

						PNAME		√ù nghƒ©a											M√¥ t·∫£
						CPUSPEEDNW	T·ªëc ƒë·ªô CPU (Noworkload)							Oracle ƒëo t·ªëc ƒë·ªô CPU khi kh√¥ng c√≥ workload.
						IOSEEKTIM	Th·ªùi gian t√¨m I/O (ms)							M·∫•t bao l√¢u ƒë·ªÉ ‚Äúseek‚Äù ƒë·∫øn block d·ªØ li·ªáu.
						IOTFRSPEED	T·ªëc ƒë·ªô truy·ªÅn I/O (bytes/ms)					T·ªëc ƒë·ªô ƒë·ªçc d·ªØ li·ªáu t·ª´ ƒëƒ©a.
						SREADTIM	Th·ªùi gian ƒë·ªçc ƒë∆°n block							D√†nh cho workload-based stats.
						MREADTIM	Th·ªùi gian ƒë·ªçc nhi·ªÅu block (multi-block read).	
						CPUSPEED	T·ªëc ƒë·ªô CPU (Workload-based)						Ghi nh·∫≠n t·ª´ th·ª±c t·∫ø truy v·∫•n khi ch·∫°y START/STOP.
						MBRC		Multi Block Read Count							S·ªë block trung b√¨nh ƒë·ªçc ƒë∆∞·ª£c trong m·ªôt l·∫ßn I/O.
						MAXTHR		Max Throughput									T·ªëc ƒë·ªô t·ªëi ƒëa h·ªá th·ªëng c√≥ th·ªÉ x·ª≠ l√Ω I/O.
						SLAVETHR	Slave Throughput								T·ªëc ƒë·ªô ƒë·ªçc ghi khi song song (Parallel Query).
						
					Nh√≥m 2 ‚Äî SYSSTATS_INFO

						Ch·ª©a th√¥ng tin meta (v·ªÅ th·ªùi gian thu th·∫≠p, ng∆∞·ªùi thu th·∫≠p, v.v.).

						PNAME	√ù nghƒ©a					V√≠ d·ª•
						STATUS	Tr·∫°ng th√°i th·ªëng k√™		‚ÄòCOMPLETED‚Äô ho·∫∑c ‚ÄòIN PROGRESS‚Äô
						DSTART	Ng√†y b·∫Øt ƒë·∫ßu thu th·∫≠p	19-OCT-25
						DSTOP	Ng√†y k·∫øt th√∫c thu th·∫≠p	19-OCT-25
						FLAGS	Th√¥ng tin n·ªôi b·ªô		D√πng b·ªüi Oracle engine
						
			Oracle Optimizer d√πng d·ªØ li·ªáu n√†y nh∆∞ th·∫ø n√†o

				Optimizer d·ª±a tr√™n system statistics ƒë·ªÉ t√≠nh ‚Äúcost‚Äù khi quy·∫øt ƒë·ªãnh k·∫ø ho·∫°ch truy v·∫•n.

				V√≠ d·ª•:

					T√¨nh hu·ªëng							Oracle s·ª≠ d·ª•ng gi√° tr·ªã n√†o
					T√≠nh chi ph√≠ CPU					CPUSPEED ho·∫∑c CPUSPEEDNW
					∆Ø·ªõc l∆∞·ª£ng chi ph√≠ I/O				IOSEEKTIM, IOTFRSPEED, SREADTIM, MREADTIM
					T√≠nh to√°n hi·ªáu nƒÉng ƒë·ªçc song song	MBRC, MAXTHR, SLAVETHR

					‚Üí Nh·ªù ƒë√≥, Oracle ch·ªçn ch√≠nh x√°c gi·ªØa Full Table Scan, Index Scan, hay Nested Loop Join.
					
		- sql: exec dbms_stats.gather_table_stats(ownname => 'SH', tabname => 'SALES', cascade=> true);
		
			L·ªánh n√†y d√πng ƒë·ªÉ thu th·∫≠p th·ªëng k√™ (statistics) cho b·∫£ng SALES trong schema SH.
			
			C√°c th·ªëng k√™ n√†y bao g·ªìm:

				S·ªë l∆∞·ª£ng h√†ng (rows)

				S·ªë l∆∞·ª£ng block

				K√≠ch th∆∞·ªõc d·ªØ li·ªáu

				Gi√° tr·ªã kh√°c bi·ªát (distinct) trong t·ª´ng c·ªôt

				T·∫ßn su·∫•t null, gi√° tr·ªã ph·ªï bi·∫øn (histogram)

				V√† n·∫øu c√≥ cascade => true ‚Üí c·∫£ th·ªëng k√™ cho ch·ªâ m·ª•c (indexes) li√™n quan
				c≈©ng ƒë∆∞·ª£c thu th·∫≠p.
				
			Nh·ªØng th·ªëng k√™ n√†y l√† ‚Äúnguy√™n li·ªáu ƒë·∫ßu v√†o‚Äù ƒë·ªÉ Oracle Cost-Based Optimizer (CBO)
			ch·ªçn k·∫ø ho·∫°ch truy v·∫•n t·ªët nh·∫•t.
			
			C·∫•u tr√∫c c√∫ ph√°p chi ti·∫øt:
			
				DBMS_STATS.GATHER_TABLE_STATS(
				   ownname   IN VARCHAR2,   -- T√™n schema
				   tabname   IN VARCHAR2,   -- T√™n b·∫£ng
				   partname  IN VARCHAR2 DEFAULT NULL,  -- (tu·ª≥ ch·ªçn) thu th·∫≠p ri√™ng partition
				   estimate_percent IN NUMBER DEFAULT NULL, -- % d·ªØ li·ªáu m·∫´u (sample)
				   method_opt IN VARCHAR2 DEFAULT 'FOR ALL COLUMNS SIZE AUTO', -- histogram
				   degree IN NUMBER DEFAULT NULL, -- song song
				   cascade IN BOOLEAN DEFAULT FALSE, -- c√≥ thu th·∫≠p index kh√¥ng
				   no_invalidate IN BOOLEAN DEFAULT FALSE -- c√≥ invalidate cursor c≈© kh√¥ng
				);

			Nh·ªØng g√¨ Oracle th·ª±c s·ª± l√†m khi ch·∫°y l·ªánh n√†y:

				Khi b·∫°n ch·∫°y:

					EXEC DBMS_STATS.GATHER_TABLE_STATS(ownname => 'SH', tabname => 'SALES', cascade => TRUE);

				Oracle th·ª±c hi·ªán 4 b∆∞·ªõc n·ªôi b·ªô sau:
				
					B∆∞·ªõc 1: ƒê·ªçc d·ªØ li·ªáu m·∫´u

						Oracle ƒë·ªçc m·ªôt ph·∫ßn ho·∫∑c to√†n b·ªô d·ªØ li·ªáu t·ª´ b·∫£ng SALES (t√πy thu·ªôc
						v√†o estimate_percent).

						N·∫øu b·∫°n kh√¥ng ch·ªâ ƒë·ªãnh, Oracle t·ª± ƒë·ªông ch·ªçn t·ª∑ l·ªá m·∫´u th√≠ch h·ª£p
						(Adaptive Sampling).
						
					B∆∞·ªõc 2: T√≠nh to√°n th·ªëng k√™ b·∫£ng

						Oracle l∆∞u c√°c th√¥ng tin nh∆∞:

							Th·ªëng k√™			√ù nghƒ©a
							
							NUM_ROWS			S·ªë l∆∞·ª£ng h√†ng (rows)
							BLOCKS				S·ªë l∆∞·ª£ng blocks v·∫≠t l√Ω ch·ª©a d·ªØ li·ªáu
							AVG_ROW_LEN			ƒê·ªô d√†i trung b√¨nh c·ªßa m·ªói h√†ng
							SAMPLE_SIZE			S·ªë l∆∞·ª£ng h√†ng ƒë∆∞·ª£c d√πng l√†m m·∫´u
							LAST_ANALYZED		Th·ªùi ƒëi·ªÉm thu th·∫≠p cu·ªëi c√πng

						T·∫•t c·∫£ ƒë∆∞·ª£c l∆∞u trong b·∫£ng d·ªØ li·ªáu h·ªá th·ªëng:
						
							DBA_TABLES ho·∫∑c USER_TABLES.
							
					B∆∞·ªõc 3: Thu th·∫≠p th·ªëng k√™ cho c·ªôt (Column Stats)

						Oracle qu√©t d·ªØ li·ªáu t·ª´ng c·ªôt ƒë·ªÉ ghi nh·∫≠n:

							Th·ªëng k√™ c·ªôt			√ù nghƒ©a
							
							NUM_DISTINCT			S·ªë l∆∞·ª£ng gi√° tr·ªã kh√°c bi·ªát
							NUM_NULLS				S·ªë l∆∞·ª£ng gi√° tr·ªã null
							DENSITY					T·∫ßn su·∫•t xu·∫•t hi·ªán
							HISTOGRAM				Ph√¢n b·ªë gi√° tr·ªã (n·∫øu c√≥)

						L∆∞u trong DBA_TAB_COLUMNS ho·∫∑c USER_TAB_COL_STATISTICS.
						
					B∆∞·ªõc 4: Thu th·∫≠p th·ªëng k√™ cho index (do cascade => true)

						Oracle ti·∫øp t·ª•c thu th·∫≠p:

							Th·ªëng k√™ index			√ù nghƒ©a
							
							BLEVEL					ƒê·ªô s√¢u c√¢y B-Tree
							LEAF_BLOCKS				S·ªë l∆∞·ª£ng block l√°
							DISTINCT_KEYS			S·ªë l∆∞·ª£ng gi√° tr·ªã kh√≥a duy nh·∫•t
							CLUSTERING_FACTOR		M·ª©c ƒë·ªô tr·∫≠t t·ª± d·ªØ li·ªáu (·∫£nh h∆∞·ªüng ƒë·∫øn index scan cost)

						L∆∞u trong DBA_INDEXES ho·∫∑c USER_INDEXES.
						
				Oracle Optimizer d√πng th·ªëng k√™ n√†y ƒë·ªÉ l√†m g√¨?

					CBO (Cost-Based Optimizer) d·ª±a v√†o nh·ªØng th·ªëng k√™ n√†y ƒë·ªÉ ch·ªçn:

						C√≥ n√™n d√πng Index kh√¥ng?

						C√≥ n√™n Full Table Scan kh√¥ng?

						C√≥ n√™n Hash Join, Merge Join, hay Nested Loop kh√¥ng?

						C√≥ n√™n Parallel Execution hay kh√¥ng?

					V√≠ d·ª•:

						Tr∆∞·ªõc khi thu th·∫≠p								Sau khi thu th·∫≠p
						
						Oracle kh√¥ng bi·∫øt b·∫£ng c√≥ bao nhi√™u h√†ng 		Oracle bi·∫øt r√µ s·ªë h√†ng, ph√¢n b·ªë d·ªØ li·ªáu 
						‚Üí c√≥ th·ªÉ ch·ªçn sai k·∫ø ho·∫°ch						‚Üí ch·ªçn k·∫ø ho·∫°ch t·ªëi ∆∞u h∆°n
						Query ch·∫°y ch·∫≠m									Query ch·∫°y nhanh h∆°n r√µ r·ªát
						
		- sql: select * from dba_tab_statistics where table_name = 'SALES';
		
			L√† m·ªôt truy v·∫•n h·ªá th·ªëng r·∫•t quan tr·ªçng trong SQL Tuning v√† qu·∫£n tr·ªã
			Oracle Database.
			
			N√≥ cho ph√©p b·∫°n xem chi ti·∫øt to√†n b·ªô th√¥ng tin th·ªëng k√™ (statistics) m√† Oracle
			Optimizer s·ª≠ d·ª•ng cho b·∫£ng SALES.
			
			M·ª•c ƒë√≠ch c·ªßa c√¢u l·ªánh:

				L·ªánh n√†y truy xu·∫•t th√¥ng tin th·ªëng k√™ (table statistics) ƒë√£ ƒë∆∞·ª£c thu
				th·∫≠p b·ªüi g√≥i DBMS_STATS cho b·∫£ng SALES.

				N√≥i c√°ch kh√°c:
				
					N√≥ cho b·∫°n bi·∫øt Oracle Optimizer bi·∫øt g√¨ v·ªÅ b·∫£ng SALES.
					
					Nh·ªØng th√¥ng tin n√†y ƒë∆∞·ª£c d√πng ƒë·ªÉ t√≠nh cost, ch·ªçn k·∫ø ho·∫°ch
					truy v·∫•n (execution plan), v√† t·ªëi ∆∞u hi·ªáu nƒÉng SQL.
					
			Ngu·ªìn d·ªØ li·ªáu: DBA_TAB_STATISTICS

				DBA_TAB_STATISTICS l√† view ƒë·ªông trong Data Dictionary.
				
				N√≥ l∆∞u metadata v·ªÅ c√°c th·ªëng k√™ c·ªßa t·∫•t c·∫£ c√°c b·∫£ng trong to√†n b·ªô
				database (DBA-level view).

				T∆∞∆°ng t·ª±, b·∫°n c√≤n c√≥ c√°c view kh√°c:

					View					M·ª©c truy c·∫≠p			M√¥ t·∫£
					DBA_TAB_STATISTICS		DBA (t·∫•t c·∫£ user)		Th·ªëng k√™ c·ªßa t·∫•t c·∫£ b·∫£ng trong DB
					ALL_TAB_STATISTICS		User c√≥ quy·ªÅn SELECT	Th·ªëng k√™ c·ªßa c√°c b·∫£ng m√† user c√≥ quy·ªÅn
					USER_TAB_STATISTICS		User hi·ªán t·∫°i			Th·ªëng k√™ c·ªßa b·∫£ng trong schema hi·ªán t·∫°i
					
			Gi·∫£i th√≠ch chi ti·∫øt t·ª´ng c·ªôt quan tr·ªçng trong DBA_TAB_STATISTICS:
			
				C·ªôt					√ù nghƒ©a chi ti·∫øt
				
				OWNER				Schema (user) ch·ª©a b·∫£ng, v√≠ d·ª• 'SH'.
				TABLE_NAME			T√™n b·∫£ng, ·ªü ƒë√¢y l√† 'SALES'.
				PARTITION_NAME		N·∫øu b·∫£ng ƒë∆∞·ª£c partition, t√™n partition t∆∞∆°ng ·ª©ng. N·∫øu kh√¥ng partition th√¨ NULL.
				OBJECT_TYPE			Lo·∫°i ƒë·ªëi t∆∞·ª£ng ‚Äî TABLE, TABLE PARTITION, ho·∫∑c TABLE SUBPARTITION.
				NUM_ROWS			T·ªïng s·ªë d√≤ng (rows) trong b·∫£ng. ƒê√¢y l√† th·ªëng k√™ c·ª±c k·ª≥ quan tr·ªçng ƒë·ªÉ CBO t√≠nh cost.
				BLOCKS				S·ªë l∆∞·ª£ng block d·ªØ li·ªáu m√† b·∫£ng chi·∫øm trong tablespace.
				AVG_ROW_LEN			Chi·ªÅu d√†i trung b√¨nh c·ªßa m·ªôt d√≤ng (byte).
				SAMPLE_SIZE			S·ªë l∆∞·ª£ng d√≤ng ƒë∆∞·ª£c l·∫•y m·∫´u khi thu th·∫≠p th·ªëng k√™.
				LAST_ANALYZED		Th·ªùi ƒëi·ªÉm thu th·∫≠p th·ªëng k√™ g·∫ßn nh·∫•t (SYSDATE t·∫°i th·ªùi ƒëi·ªÉm ch·∫°y DBMS_STATS).
				STALE_STATS			Cho bi·∫øt th·ªëng k√™ c√≥ l·ªói th·ªùi hay kh√¥ng (YES ho·∫∑c NO).
				GLOBAL_STATS		YES n·∫øu th·ªëng k√™ thu th·∫≠p to√†n b·∫£ng; NO n·∫øu ∆∞·ªõc l∆∞·ª£ng ho·∫∑c k·∫ø th·ª´a t·ª´ partition.
				USER_STATS			YES n·∫øu ng∆∞·ªùi d√πng ch·ªânh tay; NO n·∫øu h·ªá th·ªëng t·ª± thu th·∫≠p.
				NOTES				C√≥ th·ªÉ ch·ª©a ghi ch√∫ v·ªÅ lo·∫°i th·ªëng k√™ (v√≠ d·ª•: incremental stats, locked stats, v.v.).
				SCOPE				Cho bi·∫øt ph·∫°m vi: GLOBAL ho·∫∑c PARTITION.
				
			C√°ch Oracle s·ª≠ d·ª•ng d·ªØ li·ªáu n√†y:

				C√°c gi√° tr·ªã trong DBA_TAB_STATISTICS ƒë∆∞·ª£c Oracle Optimizer s·ª≠ d·ª•ng ƒë·ªÉ:

					∆Ø·ªõc l∆∞·ª£ng cardinality (s·ªë d√≤ng d·ª± ki·∫øn) khi th·ª±c thi query.

					T√≠nh to√°n cost cho t·ª´ng ph∆∞∆°ng √°n truy v·∫•n.

					Ch·ªçn gi·ªØa Full Table Scan, Index Range Scan, Hash Join, Nested Loop, v.v.

					C·∫≠p nh·∫≠t t·ª± ƒë·ªông khi b·∫°n d√πng l·ªánh:

						EXEC DBMS_STATS.GATHER_TABLE_STATS('SH','SALES');
						
			Khi n√†o n√™n xem DBA_TAB_STATISTICS:
			
				Tr∆∞·ªùng h·ª£p						M·ª•c ƒë√≠ch
				
				Sau khi ch·∫°y DBMS_STATS			Ki·ªÉm tra k·∫øt qu·∫£ thu th·∫≠p c√≥ h·ª£p l·ªá kh√¥ng
				Khi query ch·∫°y ch·∫≠m				Xem th·ªëng k√™ c√≥ l·ªói th·ªùi (STALE_STATS='YES') ho·∫∑c ch∆∞a c√≥ (NUM_ROWS=NULL)
				Khi so s√°nh hi·ªáu nƒÉng			So s√°nh th·ªëng k√™ c≈© v√† m·ªõi ƒë·ªÉ xem s·ª± kh√°c bi·ªát
				Khi c·∫ßn tuning optimizer		Xem optimizer ƒëang d·ª±a v√†o d·ªØ li·ªáu g√¨ ƒë·ªÉ t√≠nh to√°n cost
				
		- cmd: sqlplus
		
			L·ªánh sqlplus l√† c√¥ng c·ª• d√≤ng l·ªánh (command-line tool) c·ªßa Oracle d√πng ƒë·ªÉ k·∫øt n·ªëi v√†
			t∆∞∆°ng t√°c v·ªõi c∆° s·ªü d·ªØ li·ªáu Oracle Database. ƒê√¢y l√† client truy·ªÅn th·ªëng ƒë∆∞·ª£c s·ª≠ d·ª•ng
			r·∫•t ph·ªï bi·∫øn cho qu·∫£n tr·ªã vi√™n (DBA), l·∫≠p tr√¨nh vi√™n PL/SQL v√† ng∆∞·ªùi h·ªçc Oracle.
			
			M·ª•c ƒë√≠ch ch√≠nh c·ªßa sqlplus

				SQL*Plus d√πng ƒë·ªÉ:

					K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu Oracle

					Th·ª±c thi c√°c l·ªánh SQL (SELECT, INSERT, UPDATE, DELETE, v.v.)

					Ch·∫°y c√°c script PL/SQL (*.sql, *.pls‚Ä¶)

					Th·ª±c hi·ªán qu·∫£n tr·ªã database (t·∫°o user, ph√¢n quy·ªÅn, th·ªëng k√™, backup logic,‚Ä¶)

					Hi·ªÉn th·ªã v√† ki·ªÉm tra k·∫øt qu·∫£ truy v·∫•n
					
			C√∫ ph√°p chung:
			
				sqlplus [username[/password]@[hostname:port/SERVICE_NAME]] [AS SYSDBA]
				
				V√≠ d·ª• 1: K·∫øt n·ªëi th√¥ng th∆∞·ªùng

					sqlplus system/oracle@localhost:1521/orclpdb

				V√≠ d·ª• 2: K·∫øt n·ªëi v·ªõi quy·ªÅn SYSDBA (qu·∫£n tr·ªã cao nh·∫•t)

					sqlplus sys/oracle@localhost:1521/orclpdb as sysdba

				V√≠ d·ª• 3: K·∫øt n·ªëi n·ªôi b·ªô (kh√¥ng c·∫ßn m·∫≠t kh·∫©u n·∫øu OS user c√≥ quy·ªÅn)

					sqlplus / as sysdba
					
			M·ªôt s·ªë v√≠ d·ª• thao t√°c trong SQL*Plus:
			
				L·ªánh									Ch·ª©c nƒÉng
				
				SELECT * FROM emp;						Truy v·∫•n d·ªØ li·ªáu
				DESC employees;							Xem c·∫•u tr√∫c b·∫£ng
				SHOW USER;								Hi·ªÉn th·ªã user hi·ªán t·∫°i
				SHOW PARAMETER db_name;					Xem tham s·ªë database
				START script.sql ho·∫∑c @script.sql		Ch·∫°y file script
				EXIT ho·∫∑c QUIT							Tho√°t SQL*Plus
				
			M√¥i tr∆∞·ªùng ho·∫°t ƒë·ªông:

				SQL*Plus c√≥ th·ªÉ ch·∫°y ·ªü:

					Command Prompt (Windows)

					Terminal (Linux/Unix)

					Oracle SQL Developer (·ªü tab "SQL Worksheet" ‚Äî n·ªÅn t·∫£ng ƒë·ªì h·ªça)

				M·∫∑c ƒë·ªãnh ƒë∆∞·ª£c c√†i c√πng v·ªõi Oracle Client ho·∫∑c Oracle Database.
				
		- cmd: sqlplus / as sysdba
		- sql: alter session set container=orclpdb (da giai thich o tren)	
		- sql: alter pluggable database open; (da giai thich o tren)
		- sql: alter pluggable database orclpdb save state; (da giai thich o tren)
		- sql: alter user hr identified by hr account unlock; (da giai thich o tren)	
		- sql: SELECT username, account_status FROM dba_users WHERE username = 'HR';
		
			M·ª•c ƒë√≠ch:

				C√¢u l·ªánh n√†y ki·ªÉm tra tr·∫°ng th√°i t√†i kho·∫£n ng∆∞·ªùi d√πng HR trong Oracle Database.
				
				C·ª• th·ªÉ, n√≥ truy v·∫•n b·∫£ng h·ªá th·ªëng DBA_USERS, n∆°i ch·ª©a th√¥ng tin v·ªÅ t·∫•t c·∫£ ng∆∞·ªùi
				d√πng (users) trong c∆° s·ªü d·ªØ li·ªáu Oracle.		
		
		- sql: explain plan for select * from employees;
	
			M·ª•c ƒë√≠ch c·ªßa l·ªánh:

				L·ªánh n√†y kh√¥ng th·ª±c thi truy v·∫•n, m√† d√πng ƒë·ªÉ ph√¢n t√≠ch k·∫ø ho·∫°ch th·ª±c thi (execution plan)
				m√† Oracle Optimizer s·∫Ω s·ª≠ d·ª•ng khi ch·∫°y c√¢u l·ªánh SQL ƒë√≥.

				N√≥i c√°ch kh√°c:

					N√≥ cho b·∫°n bi·∫øt Oracle s·∫Ω truy c·∫≠p d·ªØ li·ªáu nh∆∞ th·∫ø n√†o ‚Äî qu√©t b·∫£ng, d√πng index, n·ªëi
					b·∫£ng (join) ki·ªÉu g√¨, v.v.

			Gi·∫£i th√≠ch t·ª´ng ph·∫ßn:
			
			Th√†nh ph·∫ßn						Gi·∫£i th√≠ch
			
			EXPLAIN PLAN FOR				B·∫£o Oracle l∆∞u k·∫ø ho·∫°ch th·ª±c thi (execution plan) cho c√¢u l·ªánh SQL theo sau v√†o b·∫£ng h·ªá th·ªëng PLAN_TABLE.
			SELECT * FROM employees;		L√† c√¢u l·ªánh SQL c·∫ßn ph√¢n t√≠ch ‚Äî ·ªü ƒë√¢y l√† l·∫•y to√†n b·ªô d·ªØ li·ªáu t·ª´ b·∫£ng EMPLOYEES.
			
			C∆° ch·∫ø ho·∫°t ƒë·ªông

				Khi b·∫°n ch·∫°y:

					EXPLAIN PLAN FOR SELECT * FROM employees;

					Oracle kh√¥ng ch·∫°y c√¢u SELECT, m√† ch·ªâ:

						Ph√¢n t√≠ch c√∫ ph√°p (parse) c√¢u SQL.

						D√πng Cost-Based Optimizer (CBO) ƒë·ªÉ x√¢y d·ª±ng k·∫ø ho·∫°ch th·ª±c thi t·ªëi ∆∞u.

						Ghi k·∫ø ho·∫°ch n√†y v√†o b·∫£ng PLAN_TABLE (m·ªôt b·∫£ng ƒë·∫∑c bi·ªát trong schema hi·ªán t·∫°i).

			Xem k·∫ø ho·∫°ch th·ª±c thi

				Sau khi ch·∫°y l·ªánh tr√™n, b·∫°n c·∫ßn xem k·∫øt qu·∫£ b·∫±ng:

					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

				L·ªánh n√†y hi·ªÉn th·ªã n·ªôi dung c·ªßa PLAN_TABLE d∆∞·ªõi d·∫°ng d·ªÖ ƒë·ªçc.						
		
		- sql: select * from plan_table;
		
			M·ª•c ƒë√≠ch:

				L·ªánh n√†y d√πng ƒë·ªÉ xem to√†n b·ªô n·ªôi dung c·ªßa b·∫£ng PLAN_TABLE, l√† n∆°i Oracle l∆∞u tr·ªØ t·∫°m th·ªùi c√°c
				k·∫ø ho·∫°ch th·ª±c thi (execution plans) ƒë∆∞·ª£c t·∫°o ra b·ªüi l·ªánh:

					EXPLAIN PLAN FOR <c√¢u l·ªánh SQL>;

				N√≥i ng·∫Øn g·ªçn:

					PLAN_TABLE l√† b·∫£ng h·ªá th·ªëng (system table) ch·ª©a chi ti·∫øt v·ªÅ c√°ch Oracle d·ª± ƒë·ªãnh th·ª±c hi·ªán c√¢u SQL,
					v√† l·ªánh SELECT * FROM plan_table; gi√∫p xem t·∫•t c·∫£ c√°c b·∫£n ghi k·∫ø ho·∫°ch ƒë√£ ƒë∆∞·ª£c l∆∞u trong ƒë√≥.

			Gi·∫£i th√≠ch t·ª´ng ph·∫ßn:
			
				Th√†nh ph·∫ßn				Gi·∫£i th√≠ch
				
				SELECT *				Ch·ªçn to√†n b·ªô c√°c c·ªôt trong b·∫£ng.
				FROM plan_table			L·∫•y d·ªØ li·ªáu t·ª´ b·∫£ng PLAN_TABLE ‚Äì n∆°i ch·ª©a k·∫øt qu·∫£ c·ªßa c√°c l·ªánh EXPLAIN PLAN.

			V·ªÅ b·∫£ng PLAN_TABLE

				PLAN_TABLE l√† b·∫£ng metadata ƒë·∫∑c bi·ªát, th∆∞·ªùng ƒë∆∞·ª£c t·∫°o s·∫µn b·ªüi script Oracle (utlxplan.sql).

				Khi b·∫°n th·ª±c hi·ªán:

					EXPLAIN PLAN FOR SELECT * FROM employees;


				th√¨ Oracle ghi d·ªØ li·ªáu v√†o PLAN_TABLE ‚Äî v√≠ d·ª• nh∆∞ lo·∫°i thao t√°c (TABLE ACCESS, INDEX SCAN), th·ª©
				t·ª± th·ª±c hi·ªán, chi ph√≠ ∆∞·ªõc t√≠nh, v.v.

			C·∫•u tr√∫c ph·ªï bi·∫øn c·ªßa PLAN_TABLE:

				M·ªôt s·ªë c·ªôt quan tr·ªçng trong PLAN_TABLE:

				C·ªôt				√ù nghƒ©a
				
				STATEMENT_ID	M√£ ƒë·ªãnh danh cho k·∫ø ho·∫°ch (c√≥ th·ªÉ r·ªóng n·∫øu kh√¥ng ch·ªâ ƒë·ªãnh).
				PLAN_ID			ID c·ªßa k·∫ø ho·∫°ch th·ª±c thi.
				TIMESTAMP		Th·ªùi ƒëi·ªÉm ghi k·∫ø ho·∫°ch.
				OPERATION		Lo·∫°i thao t√°c (SELECT STATEMENT, TABLE ACCESS FULL, INDEX RANGE SCAN, v.v.).
				OPTIONS	T√πy 	ch·ªçn c·ªßa thao t√°c (v√≠ d·ª•: FULL, UNIQUE, RANGE).
				OBJECT_NAME		T√™n b·∫£ng ho·∫∑c index m√† thao t√°c √°p d·ª•ng.
				OBJECT_TYPE		Ki·ªÉu ƒë·ªëi t∆∞·ª£ng (TABLE, INDEX, VIEW, ‚Ä¶).
				ID				S·ªë th·ª© t·ª± (m·ª©c) c·ªßa b∆∞·ªõc trong k·∫ø ho·∫°ch.
				PARENT_ID		Ch·ªâ ra b∆∞·ªõc cha (ƒë·ªÉ x√°c ƒë·ªãnh th·ª© t·ª± th·ª±c thi).
				COST, CARDINALITY, BYTES	Th√¥ng tin ∆∞·ªõc l∆∞·ª£ng v·ªÅ chi ph√≠, s·ªë d√≤ng v√† k√≠ch th∆∞·ªõc d·ªØ li·ªáu.
				
			Khi n√†o d√πng SELECT * FROM PLAN_TABLE:
			
				D√πng khi:

					B·∫°n mu·ªën xem d·ªØ li·ªáu th√¥ (raw) m√† EXPLAIN PLAN ghi ra.

					B·∫°n mu·ªën ki·ªÉm tra nhi·ªÅu k·∫ø ho·∫°ch th·ª±c thi kh√°c nhau n·∫øu b·∫°n ƒë√£ ch·∫°y nhi·ªÅu l·ªánh EXPLAIN PLAN li√™n ti·∫øp.

				Tuy nhi√™n:

				K·∫øt qu·∫£ SELECT * FROM plan_table; kh√≥ ƒë·ªçc v√¨ c√≥ qu√° nhi·ªÅu c·ªôt k·ªπ thu·∫≠t.
				
				Th∆∞·ªùng ng∆∞·ªùi ta d√πng c√°ch hi·ªÉn th·ªã ƒë·∫πp h∆°n:

					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

					C√°ch n√†y ƒë·ªãnh d·∫°ng k·∫ø ho·∫°ch r√µ r√†ng, d·ªÖ hi·ªÉu v√† s·∫Øp x·∫øp theo th·ª© t·ª± th·ª±c thi.

		- sql: select * from table(dbms_xplan.display());
		 
			M·ª•c ƒë√≠ch

				L·ªánh n√†y ƒë∆∞·ª£c d√πng ƒë·ªÉ hi·ªÉn th·ªã k·∫ø ho·∫°ch th·ª±c thi (execution plan) c·ªßa c√¢u SQL m√† b·∫°n
				v·ª´a ph√¢n t√≠ch b·∫±ng:

					EXPLAIN PLAN FOR <c√¢u_l·ªánh_SQL>;


				N√≥i ng·∫Øn g·ªçn:

					ƒê√¢y l√† c√°ch ƒë·ªçc k·∫ø ho·∫°ch th·ª±c thi trong Oracle d∆∞·ªõi d·∫°ng ƒë·∫πp, r√µ r√†ng v√† d·ªÖ hi·ªÉu, thay v√¨
					xem d·ªØ li·ªáu th√¥ trong PLAN_TABLE.

			Gi·∫£i th√≠ch t·ª´ng ph·∫ßn
			
				Th√†nh ph·∫ßn				Gi·∫£i th√≠ch
				DBMS_XPLAN				L√† package (g√≥i PL/SQL) do Oracle cung c·∫•p ƒë·ªÉ hi·ªÉn th·ªã c√°c execution plan.
				DISPLAY()				L√† h√†m trong g√≥i DBMS_XPLAN ‚Äî ƒë·ªçc d·ªØ li·ªáu t·ª´ b·∫£ng PLAN_TABLE v√† tr·∫£ v·ªÅ k·∫ø
										ho·∫°ch th·ª±c thi ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng r√µ r√†ng.
				TABLE()					L√† h√†m chuy·ªÉn ƒë·ªïi (table function) gi√∫p Oracle c√≥ th·ªÉ tr·∫£ v·ªÅ k·∫øt qu·∫£ nhi·ªÅu
										d√≤ng (v√¨ DBMS_XPLAN.DISPLAY() tr·∫£ v·ªÅ m·ªôt t·∫≠p h·ª£p d√≤ng d·∫°ng b·∫£ng).
				SELECT * FROM ...		L·∫•y to√†n b·ªô n·ªôi dung m√† h√†m DBMS_XPLAN.DISPLAY() tr·∫£ v·ªÅ ƒë·ªÉ hi·ªÉn th·ªã tr√™n m√†n h√¨nh.
			
			Tr√¨nh t·ª± s·ª≠ d·ª•ng chu·∫©n

				Ph√¢n t√≠ch k·∫ø ho·∫°ch th·ª±c thi (t·∫°o plan trong PLAN_TABLE):

					EXPLAIN PLAN FOR SELECT * FROM employees;

				Hi·ªÉn th·ªã k·∫ø ho·∫°ch ƒë√≥:

					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());

			K·∫øt qu·∫£ hi·ªÉn th·ªã v√≠ d·ª•

				Khi b·∫°n ch·∫°y l·ªánh tr√™n, k·∫øt qu·∫£ c√≥ th·ªÉ nh∆∞ sau:

				------------------------------------------------------------------------------------
				| Id | Operation          | Name       | Rows | Bytes | Cost (%CPU)| Time          |
				------------------------------------------------------------------------------------
				|  0 | SELECT STATEMENT   |            |  100 |  8700 |     4   (0)| 00:00:01      |
				|  1 |  TABLE ACCESS FULL | EMPLOYEES  |  100 |  8700 |     4   (0)| 00:00:01      |
				------------------------------------------------------------------------------------

			√ù nghƒ©a c√°c c·ªôt
			
				C·ªôt			√ù nghƒ©a
				
				Id			Th·ª© t·ª± ho·∫∑c c·∫•p ƒë·ªô c·ªßa b∆∞·ªõc trong k·∫ø ho·∫°ch
				Operation	Lo·∫°i thao t√°c m√† Oracle th·ª±c hi·ªán (SELECT, TABLE ACCESS, INDEX SCAN, ‚Ä¶)
				Name		T√™n b·∫£ng ho·∫∑c ch·ªâ m·ª•c (index) ƒë∆∞·ª£c d√πng
				Rows		S·ªë l∆∞·ª£ng d√≤ng Oracle ∆∞·ªõc l∆∞·ª£ng x·ª≠ l√Ω
				Bytes		K√≠ch th∆∞·ªõc d·ªØ li·ªáu t∆∞∆°ng ·ª©ng
				Cost		Chi ph√≠ ∆∞·ªõc t√≠nh ƒë·ªÉ th·ª±c thi b∆∞·ªõc n√†y (Cost-Based Optimizer t√≠nh to√°n)
				Time		Th·ªùi gian ∆∞·ªõc t√≠nh ƒë·ªÉ ho√†n t·∫•t
			
			C√°c tham s·ªë n√¢ng cao (t√πy ch·ªçn c·ªßa DISPLAY())

				B·∫°n c√≥ th·ªÉ t√πy ch·ªânh c√°ch hi·ªÉn th·ªã b·∫±ng c√°ch truy·ªÅn tham s·ªë:

					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(
					   table_name => 'PLAN_TABLE',   -- t√™n b·∫£ng ch·ª©a k·∫ø ho·∫°ch
					   statement_id => NULL,         -- ID k·∫ø ho·∫°ch (n·∫øu c√≥ nhi·ªÅu k·∫ø ho·∫°ch trong b·∫£ng)
					   format => 'ALL'               -- m·ª©c ƒë·ªô chi ti·∫øt ('BASIC', 'TYPICAL', 'ALL')
					));

				V√≠ d·ª•:

					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'ALL'));

					‚Üí Hi·ªÉn th·ªã to√†n b·ªô th√¥ng tin chi ti·∫øt nh·∫•t.

			So s√°nh nhanh v·ªõi SELECT * FROM PLAN_TABLE;
			
				Ti√™u ch√≠			SELECT * FROM PLAN_TABLE				SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY())
				D·ªØ li·ªáu hi·ªÉn th·ªã	D·∫°ng th√¥, nhi·ªÅu c·ªôt k·ªπ thu·∫≠t			D·∫°ng b·∫£ng g·ªçn g√†ng, d·ªÖ ƒë·ªçc
				M·ª•c ƒë√≠ch			Ki·ªÉm tra d·ªØ li·ªáu raw trong PLAN_TABLE	ƒê·ªçc v√† ph√¢n t√≠ch k·∫ø ho·∫°ch th·ª±c thi
				D·ªÖ hi·ªÉu				‚ùå Kh√≥ ƒë·ªçc								‚úÖ R·∫•t r√µ r√†ng
				
		- sql: EXPLAIN PLAN SET statement_id = 'MyID' FOR SELECT * FROM employees WHERE employee_id= 100;
		
			L·ªánh b·∫°n h·ªèi l√† m·ªôt phi√™n b·∫£n m·ªü r·ªông c·ªßa EXPLAIN PLAN, r·∫•t hay d√πng khi ta mu·ªën qu·∫£n l√Ω nhi·ªÅu Execution Plan
			c√πng l√∫c trong b·∫£ng PLAN_TABLE.
			
			C√∫ ph√°p t·ªïng qu√°t c·ªßa EXPLAIN PLAN:
			
				EXPLAIN PLAN 
				  [SET STATEMENT_ID = 'some_id']
				  [INTO table_name]
				FOR <SQL_statement>;

				Trong ƒë√≥:

					SET STATEMENT_ID ‚Üí g√°n m·ªôt nh√£n (ID) ƒë·ªÉ ph√¢n bi·ªát k·∫ø ho·∫°ch n√†y v·ªõi c√°c k·∫ø ho·∫°ch kh√°c.

					INTO table_name ‚Üí ch·ªâ ƒë·ªãnh b·∫£ng n√†o ƒë·ªÉ l∆∞u plan (th∆∞·ªùng l√† PLAN_TABLE).

					FOR <SQL> ‚Üí ch·ªâ ƒë·ªãnh c√¢u SQL b·∫°n mu·ªën Oracle ph√¢n t√≠ch.
					
			C·ª• th·ªÉ v·ªõi v√≠ d·ª• c·ªßa b·∫°n:
			
				EXPLAIN PLAN 
				SET statement_id = 'MyID'
				FOR 
				SELECT * FROM employees WHERE employee_id = 100;

				√ù nghƒ©a t·ª´ng ph·∫ßn:
				
					Th√†nh ph·∫ßn												Gi·∫£i th√≠ch
					EXPLAIN PLAN											Y√™u c·∫ßu Oracle ph√¢n t√≠ch (nh∆∞ng kh√¥ng th·ª±c thi) c√¢u SQL ph√≠a
																			sau ƒë·ªÉ xem Oracle d·ª± ƒë·ªãnh ch·∫°y n√≥ nh∆∞ th·∫ø n√†o.
					SET statement_id = 'MyID'								ƒê·∫∑t t√™n (ID) cho plan n√†y l√† 'MyID' ‚Äî n√≥ s·∫Ω ƒë∆∞·ª£c l∆∞u trong
																			c·ªôt STATEMENT_ID c·ªßa b·∫£ng PLAN_TABLE. D√πng ƒë·ªÉ ph√¢n bi·ªát n·∫øu
																			b·∫°n c√≥ nhi·ªÅu k·∫ø ho·∫°ch kh√°c nhau.
					FOR SELECT * FROM employees WHERE employee_id = 100;	ƒê√¢y l√† c√¢u SQL m√† b·∫°n mu·ªën Oracle l·∫≠p k·∫ø ho·∫°ch th·ª±c thi cho.
					
			K·∫øt qu·∫£ Oracle l√†m g√¨ ph√≠a sau?

				Khi ch·∫°y l·ªánh tr√™n, Oracle s·∫Ω:

					Ph√¢n t√≠ch c√¢u SQL (SELECT * FROM employees WHERE employee_id = 100).

					T·∫°o Execution Plan cho c√¢u ƒë√≥.

					Ghi d·ªØ li·ªáu k·∫ø ho·∫°ch v√†o b·∫£ng PLAN_TABLE (m·∫∑c ƒë·ªãnh trong schema hi·ªán t·∫°i).

					G·∫Øn nh√£n cho k·∫ø ho·∫°ch b·∫±ng STATEMENT_ID = 'MyID'.

			L√†m sao xem k·∫øt qu·∫£ c·ªßa k·∫ø ho·∫°ch n√†y?

				B·∫°n c√≥ hai c√°ch xem l·∫°i:

				üîπ C√°ch 1: Xem th√¥ t·ª´ b·∫£ng PLAN_TABLE
				
					SELECT * FROM plan_table WHERE statement_id = 'MyID';


					‚Üí Oracle s·∫Ω tr·∫£ v·ªÅ c√°c c·ªôt nh∆∞:

						STATEMENT_ID (·ªü ƒë√¢y l√† 'MyID')

						PLAN_ID

						OPERATION

						OPTIONS

						OBJECT_NAME

						COST, CARDINALITY, DEPTH, ‚Ä¶

				üîπ C√°ch 2: Xem d·∫°ng ƒë·∫πp b·∫±ng DBMS_XPLAN
				
					SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, 'MyID', 'TYPICAL'));


					Gi·∫£i th√≠ch c√°c tham s·ªë:

						NULL: v√¨ b·∫°n d√πng b·∫£ng PLAN_TABLE m·∫∑c ƒë·ªãnh.

						'MyID': l√† statement_id b·∫°n ƒë√£ ƒë·∫∑t l√∫c EXPLAIN PLAN.

						'TYPICAL': ki·ªÉu hi·ªÉn th·ªã (c√≥ th·ªÉ d√πng 'ALL', 'BASIC', 'SERIAL', ...).
						
				T·∫°i sao c·∫ßn STATEMENT_ID?

					V√¨ PLAN_TABLE l√† b·∫£ng d√πng chung (Oracle ch·ªâ c√≥ m·ªôt trong m·ªói schema).
					N·∫øu b·∫°n ch·∫°y nhi·ªÅu EXPLAIN PLAN cho c√°c c√¢u SQL kh√°c nhau, m√† kh√¥ng g√°n statement_id, ch√∫ng c√≥ th·ªÉ ƒë√® l√™n nhau ho·∫∑c l·∫´n l·ªôn.

					‚Üí Khi b·∫°n g√°n statement_id, b·∫°n c√≥ th·ªÉ:

						Ph√¢n bi·ªát t·ª´ng plan.

						So s√°nh nhi·ªÅu plan kh√°c nhau.

						D·ªÖ xo√° plan c≈©:

							DELETE FROM plan_table WHERE statement_id = 'MyID';
				
		- sql:
			 
			exec dbms_stats.gather_database_stats;
			exec dbms_stats.gather_dictionary_stats;
			exec dbms_stats.gather_schema_stats(ownname => 'SH');
			exec dbms_stats.gather_table_stats(ownname => 'SH', tabname => 'SALES', cascade=>true);
			select * from user_part_col_statistics;
			select * from dba_tab_statistics where table_name = 'SALES';
			 
			select * from	DBA_TABLES; 
			select * from	DBA_TAB_STATISTICS;
			select * from                   DBA_TAB_COL_STATISTICS; 
			select * from	DBA_INDEXES; 
			select * from	DBA_CLUSTERS; 
			select * from	DBA_TAB_PARTITIONS; 
			select * from	DBA_IND_PARTITIONS; 
			select * from	DBA_PART_COL_STATISTICS;
			
		- sql: set autotrace traceonly explain;
		
			L√† m·ªôt t√πy ch·ªçn trong SQL*Plus ho·∫∑c SQL Developer d√πng ƒë·ªÉ ph√¢n t√≠ch k·∫ø ho·∫°ch th·ª±c thi (execution plan)
			c·ªßa c√¢u l·ªánh SQL m√† kh√¥ng th·ª±c s·ª± ch·∫°y n√≥.
			
			üëâ N√≥i c√°ch kh√°c: n√≥ cho b·∫°n xem Oracle s·∫Ω ch·∫°y c√¢u l·ªánh nh∆∞ th·∫ø n√†o, nh∆∞ng kh√¥ng t·ªën th·ªùi gian th·ª±c thi th·ª±c t·∫ø.

			Gi·∫£i th√≠ch chi ti·∫øt t·ª´ng ph·∫ßn
			
				1. SET AUTOTRACE

					L√† m·ªôt l·ªánh m√¥i tr∆∞·ªùng trong SQL*Plus/SQL Developer, d√πng ƒë·ªÉ t·ª± ƒë·ªông hi·ªÉn th·ªã th√¥ng tin
					truy v·∫øt (trace) sau m·ªói c√¢u l·ªánh SQL.

					T√≠nh nƒÉng n√†y cho ph√©p b·∫°n xem:

					Execution plan (k·∫ø ho·∫°ch th·ª±c thi)

					Statistics (th·ªëng k√™ th·ª±c thi) ‚Äî nh∆∞ s·ªë block ƒë·ªçc, s·ªë h√†ng x·ª≠ l√Ω, v.v.

				2. TRACEONLY

					Nghƒ©a l√†: kh√¥ng hi·ªÉn th·ªã k·∫øt qu·∫£ d·ªØ li·ªáu th·∫≠t t·ª´ c√¢u l·ªánh SQL.

					Oracle s·∫Ω ph√¢n t√≠ch v√† hi·ªÉn th·ªã th√¥ng tin truy v·∫øt, nh∆∞ng kh√¥ng ch·∫°y truy v·∫•n th·ª±c s·ª± ƒë·ªÉ
					l·∫•y d·ªØ li·ªáu.

					‚úÖ T√°c d·ª•ng: nhanh h∆°n, kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn d·ªØ li·ªáu th·∫≠t (ƒë·∫∑c bi·ªát h·ªØu √≠ch khi b·∫°n ch·ªâ mu·ªën
					ki·ªÉm tra hi·ªáu nƒÉng, kh√¥ng mu·ªën ƒë·ªçc h√†ng tri·ªáu b·∫£n ghi).

				3. EXPLAIN

					Ch·ªâ hi·ªÉn th·ªã execution plan (k·∫ø ho·∫°ch th·ª±c thi).

					Kh√¥ng hi·ªÉn th·ªã th·ªëng k√™ th·ª±c t·∫ø (nh∆∞ buffer gets, physical reads, etc.).

					D·ª±a tr√™n EXPLAIN PLAN n·ªôi b·ªô c·ªßa Oracle, t∆∞∆°ng t·ª± nh∆∞ b·∫°n ch·∫°y th·ªß c√¥ng:

						EXPLAIN PLAN FOR <your query>;
						SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

		- sql: SQL > set linesize 200;
		
			ƒê∆∞·ª£c d√πng trong SQL*Plus (ho·∫∑c SQL Developer ·ªü ch·∫ø ƒë·ªô SQL Worksheet / SQL*Plus compatible) ƒë·ªÉ
			ƒëi·ªÅu ch·ªânh ƒë·ªô r·ªông c·ªßa d√≤ng hi·ªÉn th·ªã k·∫øt qu·∫£ truy v·∫•n.

			üß† Gi·∫£i th√≠ch chi ti·∫øt:

				LINESIZE (hay vi·∫øt t·∫Øt l√† LINES) quy ƒë·ªãnh s·ªë k√Ω t·ª± t·ªëi ƒëa tr√™n m·ªói d√≤ng khi hi·ªÉn th·ªã k·∫øt qu·∫£ trong c·ª≠a s·ªï SQL*Plus.

				M·∫∑c ƒë·ªãnh, LINESIZE th∆∞·ªùng l√† 80 k√Ω t·ª±.
				‚Üí N·∫øu k·∫øt qu·∫£ truy v·∫•n c√≥ d√≤ng d√†i h∆°n 80 k√Ω t·ª±, SQL*Plus s·∫Ω t·ª± ƒë·ªông xu·ªëng d√≤ng.
				‚Üí ƒêi·ªÅu n√†y khi·∫øn b·∫£ng b·ªã v·ª° c·ªôt, kh√≥ ƒë·ªçc ho·∫∑c kh√¥ng cƒÉn th·∫≥ng h√†ng.
				
		- sql: SQL> set autotrace traceonly statistics;
		
			L√† m·ªôt l·ªánh trong SQL*Plus (ho·∫∑c SQL Developer ·ªü ch·∫ø ƒë·ªô SQL*Plus) d√πng ƒë·ªÉ ph√¢n t√≠ch hi·ªáu nƒÉng c·ªßa truy
			v·∫•n SQL ‚Äî nh∆∞ng ch·ªâ hi·ªÉn th·ªã ph·∫ßn th·ªëng k√™ (statistics) m√† kh√¥ng hi·ªÉn th·ªã d·ªØ li·ªáu truy v·∫•n.
			
		- sql: SQL> set autotrace traceonly;
		
			L√† m·ªôt l·ªánh trong SQL*Plus (v√† c√≥ th·ªÉ d√πng trong SQL Developer ·ªü ch·∫ø ƒë·ªô SQL*Plus) d√πng ƒë·ªÉ ph√¢n t√≠ch hi·ªáu
			nƒÉng c·ªßa truy v·∫•n SQL, hi·ªÉn th·ªã Execution Plan v√† th·ªëng k√™ (Statistics), nh∆∞ng KH√îNG hi·ªÉn th·ªã d·ªØ li·ªáu
			truy v·∫•n.
			
		- sql: SQL> set autotrace on;
		
			L√† m·ªôt l·ªánh trong SQL*Plus (c√¥ng c·ª• d√≤ng l·ªánh c·ªßa Oracle) d√πng ƒë·ªÉ b·∫≠t Autotrace. ƒê√¢y l√† c√°ch nhanh ch√≥ng
			ƒë·ªÉ xem th·ªëng k√™ th·ª±c thi v√† k·∫ø ho·∫°ch th·ª±c hi·ªán (execution plan) c·ªßa m·ªôt truy v·∫•n SQL m√† kh√¥ng c·∫ßn ph·∫£i
			ch·∫°y c√°c l·ªánh ph·ª©c t·∫°p nh∆∞ EXPLAIN PLAN.
			
			Sau khi ch·∫°y, b·∫°n s·∫Ω th·∫•y:

				K·∫øt qu·∫£ truy v·∫•n (d·ªØ li·ªáu c·ªßa employee_id=100)

				K·∫ø ho·∫°ch th·ª±c thi truy v·∫•n

				Th·ªëng k√™ chi ti·∫øt (logical reads, physical reads, CPU, v.v.)

		- sql:
		
			L√† m·ªôt truy v·∫•n Oracle ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ view V$SQL. ƒê√¢y l√† m·ªôt view h·ªá th·ªëng (dynamic performance view)
			quan tr·ªçng trong Oracle, ch·ª©a th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c c√¢u l·ªánh SQL ƒë√£ ƒë∆∞·ª£c th·ª±c thi trong b·ªô nh·ªõ shared pool.
			
			v$sql l√† g√¨?

				L√† Dynamic Performance View (c√≤n g·ªçi l√† V$ view).

				L∆∞u tr·ªØ m·ªçi c√¢u l·ªánh SQL hi·ªán ƒëang ·ªü Shared Pool, bao g·ªìm:

					Truy v·∫•n SELECT

					C√¢u l·ªánh INSERT, UPDATE, DELETE

					C√°c PL/SQL block

				M·ªói h√†ng ƒë·∫°i di·ªán cho m·ªôt statement SQL ƒë√£ ƒë∆∞·ª£c parse (bi√™n d·ªãch) trong b·ªô nh·ªõ.
				
			Th√¥ng tin ch·ª©a trong v$sql

				M·ªôt s·ªë c·ªôt quan tr·ªçng:

					SQL_ID: M√£ ƒë·ªãnh danh duy nh·∫•t c·ªßa c√¢u l·ªánh SQL trong shared pool.

					CHILD_NUMBER: S·ªë con c·ªßa c√¢u l·ªánh (n·∫øu c√πng SQL nh∆∞ng parse nhi·ªÅu l·∫ßn v·ªõi c√°c bind variable kh√°c nhau).

					SQL_TEXT: N·ªôi dung c√¢u l·ªánh SQL.

					EXECUTIONS: S·ªë l·∫ßn c√¢u l·ªánh n√†y ƒë∆∞·ª£c th·ª±c thi.

					ELAPSED_TIME: T·ªïng th·ªùi gian th·ª±c thi c√¢u l·ªánh (nano gi√¢y).

					BUFFER_GETS: S·ªë l∆∞·ª£ng block logical ƒë√£ ƒë·ªçc (ƒë√°nh gi√° I/O).

					DISK_READS: S·ªë block v·∫≠t l√Ω ƒë·ªçc t·ª´ ƒëƒ©a.

					ROWS_PROCESSED: S·ªë d√≤ng ƒë√£ tr·∫£ v·ªÅ ho·∫∑c thao t√°c.

			M·ª•c ƒë√≠ch s·ª≠ d·ª•ng

				Ph√¢n t√≠ch hi·ªáu su·∫•t SQL: Xem c√¢u l·ªánh n√†o t·ªën nhi·ªÅu CPU, ƒë·ªçc nhi·ªÅu block, hay ch·∫°y ch·∫≠m.

				T·ªëi ∆∞u h√≥a truy v·∫•n: K·∫øt h·ª£p v·ªõi V$SQL_PLAN ƒë·ªÉ xem k·∫ø ho·∫°ch th·ª±c thi c·ªßa SQL ƒë√≥.

				Theo d√µi activity trong shared pool: Qu·∫£n l√Ω b·ªô nh·ªõ v√† cache c·ªßa Oracle.
						
	- Xem optimizer statistics:
	
		Danh s√°ch c√°c b·∫£ng h·ªá th·ªëng m√† ng∆∞·ªùi d√πng c√≥ th·ªÉ truy c·∫≠p ƒë·ªÉ xem th√¥ng tin th·ªëng k√™:
		
			DBA_TABLES: Ch·ª©a th√¥ng tin v·ªÅ c√°c b·∫£ng trong c∆° s·ªü d·ªØ li·ªáu.
			
			DBA_TAB_STATISTICS: Ch·ª©a th·ªëng k√™ cho t·ª´ng b·∫£ng.
			
			DBA_TAB_COL_STATISTICS: Ch·ª©a th·ªëng k√™ cho c√°c c·ªôt trong b·∫£ng.
			
			DBA_INDEXES: Ch·ª©a th√¥ng tin v·ªÅ c√°c ch·ªâ m·ª•c trong c∆° s·ªü d·ªØ li·ªáu.
			
			DBA_CLUSTERS: Ch·ª©a th√¥ng tin v·ªÅ c√°c cluster trong c∆° s·ªü d·ªØ li·ªáu.
			
			DBA_IND_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng c·ªßa ch·ªâ m·ª•c.
			
			DBA_TAB_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng c·ªßa b·∫£ng.
			
			DBA_PART_COL_STATISTICS: Th·ªëng k√™ cho c√°c c·ªôt trong c√°c ph√¢n v√πng.
			
			
			
			
			
			USER_TABLES: Ch·ª©a th√¥ng tin v·ªÅ c√°c b·∫£ng thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_TAB_STATISTICS: Cung c·∫•p th·ªëng k√™ cho c√°c b·∫£ng c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_TAB_COL_STATISTICS: Cung c·∫•p th·ªëng k√™ cho c√°c c·ªôt trong c√°c b·∫£ng c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_INDEXES: Th√¥ng tin v·ªÅ c√°c ch·ªâ m·ª•c thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_CLUSTERS: Th√¥ng tin v·ªÅ c√°c cluster thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_TAB_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng c·ªßa b·∫£ng thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_IND_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng ch·ªâ m·ª•c thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			USER_PART_COL_STATISTICS: Th·ªëng k√™ cho c√°c c·ªôt trong c√°c ph√¢n v√πng c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			
			
			
			ALL_TABLES: Ch·ª©a th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c b·∫£ng m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p, kh√¥ng ch·ªâ
						c√°c b·∫£ng thu·ªôc s·ªü h·ªØu c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i.
			
			ALL_TAB_STATISTICS: Cung c·∫•p th·ªëng k√™ cho t·∫•t c·∫£ c√°c b·∫£ng m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_TAB_COL_STATISTICS: Cung c·∫•p th·ªëng k√™ cho c√°c c·ªôt trong t·∫•t c·∫£ c√°c b·∫£ng m√† ng∆∞·ªùi
									d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_INDEXES: Th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c ch·ªâ m·ª•c m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_CLUSTERS: Th√¥ng tin v·ªÅ t·∫•t c·∫£ c√°c cluster m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_TAB_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng c·ªßa b·∫£ng m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_IND_PARTITIONS: Th√¥ng tin v·ªÅ c√°c ph√¢n v√πng ch·ªâ m·ª•c m√† ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p.
			
			ALL_PART_COL_STATISTICS: Th·ªëng k√™ cho c√°c c·ªôt trong t·∫•t c·∫£ c√°c ph√¢n v√πng m√† ng∆∞·ªùi d√πng
									 c√≥ quy·ªÅn truy c·∫≠p.
									 
									 
	Execution Plans & Statistics - V√¨ sao tr∆∞·ªõc ƒë√≥ sqlplus hr/hr KH√îNG ƒëƒÉng nh·∫≠p ƒë∆∞·ª£c?
	
		V√¨ sao tr∆∞·ªõc ƒë√≥ sqlplus hr/hr KH√îNG ƒëƒÉng nh·∫≠p ƒë∆∞·ª£c?
	
			Khi b·∫°n ch·ªâ g√µ:

				sqlplus hr/hr

			Oracle m·∫∑c ƒë·ªãnh k·∫øt n·ªëi t·ªõi CDB$ROOT (container g·ªëc) c·ªßa instance.
			
			M√† schema HR kh√¥ng t·ªìn t·∫°i trong CDB$ROOT, n√≥ ch·ªâ t·ªìn t·∫°i trong Pluggable Database (PDB) c√≥ t√™n ORCLPDB.
			
			=> K·∫øt qu·∫£: Oracle b√°o ORA-01017: invalid username/password (do kh√¥ng t√¨m th·∫•y user trong container hi·ªán t·∫°i).
			
		V√¨ sao sqlplus hr/hr@localhost:1521/orclpdb ho·∫°t ƒë·ªông?

			C√¢u l·ªánh n√†y ƒë√£ ch·ªâ r√µ t∆∞·ªùng minh PDB ƒë√≠ch qua connect string:

				@localhost:1521/orclpdb

					localhost = m√°y c·ª•c b·ªô c·ªßa b·∫°n

					1521 = c·ªïng l·∫Øng nghe m·∫∑c ƒë·ªãnh c·ªßa Oracle Listener

					orclpdb = service name c·ªßa PDB ch·ª©a schema HR

			Oracle l√∫c n√†y hi·ªÉu:

				‚ÄúH√£y k·∫øt n·ªëi t·ªõi PDB c√≥ t√™n orclpdb, v√† ƒëƒÉng nh·∫≠p user hr b·∫±ng m·∫≠t kh·∫©u hr trong PDB ƒë√≥.‚Äù

			HR t·ªìn t·∫°i trong PDB n√†y ‚Üí ƒëƒÉng nh·∫≠p th√†nh c√¥ng.
		
		Hi·ªÉu b·∫£n ch·∫•t c·ªßa ki·∫øn tr√∫c CDB / PDB

			T·ª´ Oracle 12c tr·ªü ƒëi, ki·∫øn tr√∫c multitenant chia database th√†nh:

			Th√†nh ph·∫ßn				Vai tr√≤									Ch·ª©a g√¨
			
			CDB$ROOT				Container g·ªëc (gi·ªëng h·ªá ƒëi·ªÅu h√†nh)		Metadata, dictionary, views h·ªá th·ªëng
			PDB (v√≠ d·ª•: ORCLPDB)	Database con (gi·ªëng m√°y ·∫£o)				C√°c schemas th·∫≠t: HR, SH, OE, ...

			M·ªói PDB ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p, c√≥ ng∆∞·ªùi d√πng, tablespace, d·ªØ li·ªáu ri√™ng.
			
		Khi n√†o c·∫ßn d√πng c√∫ ph√°p @localhost:1521/orclpdb

			Lu√¥n d√πng khi:

				B·∫°n l√†m vi·ªác v·ªõi schema d·ªØ li·ªáu (HR, SH, OE, ‚Ä¶)

				B·∫°n mu·ªën import/export (Data Pump)

				B·∫°n k·∫øt n·ªëi qua ·ª©ng d·ª•ng, JDBC, SQL Developer, hay SQL*Plus
				
	Execution Plans & Statistics - So s√°nh SELECT * FROM PLAN_TABLE; v√† SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());
	
		EXPLAIN PLAN FOR ... t·∫°o ra c√°i g√¨?

			Khi b·∫°n ch·∫°y:

				EXPLAIN PLAN FOR SELECT * FROM employees WHERE employee_id = 100;

			Oracle kh√¥ng ch·∫°y c√¢u query th·∫≠t, m√† ph√¢n t√≠ch v√† ghi k·∫ø ho·∫°ch th·ª±c thi (execution plan) v√†o b·∫£ng
			PLAN_TABLE (m·∫∑c ƒë·ªãnh l√† PLAN_TABLE$ ho·∫∑c PLAN_TABLE trong schema c·ªßa b·∫°n).
			
		SELECT * FROM PLAN_TABLE;

			C√¢u n√†y ƒë·ªçc tr·ª±c ti·∫øp d·ªØ li·ªáu th√¥ trong b·∫£ng PLAN_TABLE.
			
			N√≥ hi·ªÉn th·ªã c√°c c·ªôt k·ªπ thu·∫≠t m√† Oracle l∆∞u v√†o ‚Äî v√≠ d·ª•:

				| STATEMENT_ID | PLAN_ID | OPERATION | OPTIONS | OBJECT_NAME | COST | ... |
				|---------------|----------|------------|----------|--------------|------|
				| (null) | 2 | SELECT STATEMENT | | | |
				| (null) | 2 | TABLE ACCESS | BY INDEX ROWID | EMPLOYEES | |
				| (null) | 2 | INDEX | UNIQUE SCAN | EMP_EMP_ID_PK | |

			üîπ ∆Øu ƒëi·ªÉm:

				Cho b·∫°n xem m·ªçi c·ªôt chi ti·∫øt Oracle l∆∞u (PLAN_ID, DEPTH, PARENT_ID, COST, CARDINALITY‚Ä¶).

				D·ªØ li·ªáu ‚Äúraw‚Äù, n√™n c√≥ th·ªÉ d√πng cho ph√¢n t√≠ch s√¢u ho·∫∑c tool t·ª± ƒë·ªông.

			üîπ Nh∆∞·ª£c ƒëi·ªÉm:

				R·∫•t kh√≥ ƒë·ªçc ‚Äî v√¨ d·ªØ li·ªáu th√¥, kh√¥ng c√≥ indent, kh√¥ng tr√¨nh b√†y d·∫°ng c√¢y (tree structure).

				Kh√¥ng c√≥ ‚ÄúNote‚Äù ho·∫∑c th√¥ng tin d·ªÖ hi·ªÉu nh∆∞ dbms_xplan.
				
		SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());

			ƒê√¢y l√† h√†m hi·ªÉn th·ªã (display) k·∫ø ho·∫°ch th·ª±c thi ƒë∆∞·ª£c format ƒë·∫πp t·ª´ PLAN_TABLE.

			Oracle cung c·∫•p g√≥i DBMS_XPLAN ƒë·ªÉ:

				ƒê·ªçc d·ªØ li·ªáu t·ª´ PLAN_TABLE.

				Format l·∫°i th√†nh c√¢y k·∫ø ho·∫°ch d·ªÖ hi·ªÉu, c√≥ indent v√† ch√∫ th√≠ch.

			V√≠ d·ª•:

				EXPLAIN PLAN FOR SELECT * FROM employees WHERE employee_id = 100;
				SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());


				K·∫øt qu·∫£:

					Plan hash value: 395616093

					---------------------------------------------------------------------------------
					| Id  | Operation                   | Name          | Rows | Bytes | Cost (%CPU)|
					---------------------------------------------------------------------------------
					|   0 | SELECT STATEMENT            |               |     1|    13 |     2   (0) |
					|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES     |     1|    13 |     2   (0) |
					|   2 |   INDEX UNIQUE SCAN         | EMP_EMP_ID_PK |     1|       |     1   (0) |
					---------------------------------------------------------------------------------


			üîπ ∆Øu ƒëi·ªÉm:

				D·ªÖ ƒë·ªçc (c√≥ indent th·ªÉ hi·ªán quan h·ªá cha‚Äìcon).

				C√≥ th√™m th√¥ng tin nh∆∞ Rows, Cost, CPU, v√† Plan hash value.

				Chu·∫©n format khi b·∫°n xem Execution Plan trong th·ª±c t·∫ø.

			üîπ Nh∆∞·ª£c ƒëi·ªÉm:

				Kh√¥ng hi·ªÉn th·ªã t·∫•t c·∫£ c·ªôt k·ªπ thu·∫≠t nh∆∞ b·∫£ng g·ªëc.


	- Code khi th·ª±c thi l·ªánh:
	
		Case 1:
		
			explain plan for select * from employees where employee_id = 100;

			select * from table(dbms_xplan.display());
			
				Plan hash value: 1833546154
				 
				---------------------------------------------------------------------------------------------
				| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
				---------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT            |               |     1 |    69 |     1   (0)| 00:00:01 |
				|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES     |     1 |    69 |     1   (0)| 00:00:01 |
				|*  2 |   INDEX UNIQUE SCAN         | EMP_EMP_ID_PK |     1 |       |     0   (0)| 00:00:01 |
				---------------------------------------------------------------------------------------------
				 
				Predicate Information (identified by operation id):
				---------------------------------------------------
				 
				   2 - access("EMPLOYEE_ID"=100)
				   
			select * from plan_table;
			
				"STATEMENT_ID"                "PLAN_ID"                     "TIMESTAMP"                   "REMARKS"                     "OPERATION"                   "OPTIONS"                     "OBJECT_NODE"                 "OBJECT_OWNER"                "OBJECT_NAME"                 "OBJECT_ALIAS"           
				""                            "2"                           "19-OCT-25"                   ""                            "SELECT STATEMENT"            ""                            ""                            ""                            ""                            ""                       
				""                            "2"                           "19-OCT-25"                   ""                            "TABLE ACCESS"                "BY INDEX ROWID"              ""                            "HR"                          "EMPLOYEES"                   """EMPLOYEES""@""SEL$1"""
				""                            "2"                           "19-OCT-25"                   ""                            "INDEX"                       "UNIQUE SCAN"                 ""                            "HR"                          "EMP_EMP_ID_PK"               """EMPLOYEES""@""SEL$1"""
			
		Case 2:
		
			EXPLAIN PLAN SET statement_id = 'MyID' FOR SELECT * FROM employees WHERE employee_id= 100;

			select * from table(dbms_xplan.display());

				Plan hash value: 1833546154
				 
				---------------------------------------------------------------------------------------------
				| Id  | Operation                   | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
				---------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT            |               |     1 |    69 |     1   (0)| 00:00:01 |
				|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES     |     1 |    69 |     1   (0)| 00:00:01 |
				|*  2 |   INDEX UNIQUE SCAN         | EMP_EMP_ID_PK |     1 |       |     0   (0)| 00:00:01 |
				---------------------------------------------------------------------------------------------
				 
				Predicate Information (identified by operation id):
				---------------------------------------------------
				 
				   2 - access("EMPLOYEE_ID"=100)

		Case 3:
		
			set autotrace traceonly explain;
		
			SQL> set linesize 200;
			
			SQL> select * from sales s, customers c where s.cust_id = c.cust_id and s.cust_id = 987;

				Execution Plan
				----------------------------------------------------------
				Plan hash value: 1438316797

				------------------------------------------------------------------------------------------------------------------------------
				| Id  | Operation                                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
				------------------------------------------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT                            |                |   130 | 27300 |    56   (0)| 00:00:01 |       |       |
				|*  1 |  HASH JOIN                                  |                |   130 | 27300 |    56   (0)| 00:00:01 |       |       |
				|   2 |   TABLE ACCESS BY INDEX ROWID               | CUSTOMERS      |     1 |   181 |     2   (0)| 00:00:01 |       |       |
				|*  3 |    INDEX UNIQUE SCAN                        | CUSTOMERS_PK   |     1 |       |     1   (0)| 00:00:01 |       |       |
				|   4 |   PARTITION RANGE ALL                       |                |   130 |  3770 |    54   (0)| 00:00:01 |     1 |    28 |
				|   5 |    TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES          |   130 |  3770 |    54   (0)| 00:00:01 |     1 |    28 |
				|   6 |     BITMAP CONVERSION TO ROWIDS             |                |       |       |            |          |       |       |
				|*  7 |      BITMAP INDEX SINGLE VALUE              | SALES_CUST_BIX |       |       |            |          |     1 |    28 |
				------------------------------------------------------------------------------------------------------------------------------

				Predicate Information (identified by operation id):
				---------------------------------------------------

				   1 - access("S"."CUST_ID"="C"."CUST_ID")
				   3 - access("C"."CUST_ID"=987)
				   7 - access("S"."CUST_ID"=987)

		Case 4:
		
			SQL> set autotrace traceonly statistics;
			SQL> select * from sales s, customers c where s.cust_id = c.cust_id and s.cust_id = 987;

			180 rows selected.


			Statistics
			----------------------------------------------------------
					  0  recursive calls
					  0  db block gets
					195  consistent gets
					  4  physical reads
					484  redo size
				  13193  bytes sent via SQL*Net to client
					565  bytes received via SQL*Net from client
					 13  SQL*Net roundtrips to/from client
					  0  sorts (memory)
					  0  sorts (disk)
					180  rows processed

		Case 5:
		
			SQL> set autotrace traceonly;
			
			SQL> select * from sales s, customers c where s.cust_id = c.cust_id and s.cust_id = 987;

				180 rows selected.


				Execution Plan
				----------------------------------------------------------
				Plan hash value: 1438316797

				------------------------------------------------------------------------------------------------------------------------------
				| Id  | Operation                                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
				------------------------------------------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT                            |                |   130 | 27300 |    56   (0)| 00:00:01 |       |       |
				|*  1 |  HASH JOIN                                  |                |   130 | 27300 |    56   (0)| 00:00:01 |       |       |
				|   2 |   TABLE ACCESS BY INDEX ROWID               | CUSTOMERS      |     1 |   181 |     2   (0)| 00:00:01 |       |       |
				|*  3 |    INDEX UNIQUE SCAN                        | CUSTOMERS_PK   |     1 |       |     1   (0)| 00:00:01 |       |       |
				|   4 |   PARTITION RANGE ALL                       |                |   130 |  3770 |    54   (0)| 00:00:01 |     1 |    28 |
				|   5 |    TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES          |   130 |  3770 |    54   (0)| 00:00:01 |     1 |    28 |
				|   6 |     BITMAP CONVERSION TO ROWIDS             |                |       |       |            |          |       |       |
				|*  7 |      BITMAP INDEX SINGLE VALUE              | SALES_CUST_BIX |       |       |            |          |     1 |    28 |
				------------------------------------------------------------------------------------------------------------------------------

				Predicate Information (identified by operation id):
				---------------------------------------------------

				   1 - access("S"."CUST_ID"="C"."CUST_ID")
				   3 - access("C"."CUST_ID"=987)
				   7 - access("S"."CUST_ID"=987)


				Statistics
				----------------------------------------------------------
						  0  recursive calls
						  0  db block gets
						190  consistent gets
						  0  physical reads
						  0  redo size
					  13193  bytes sent via SQL*Net to client
						565  bytes received via SQL*Net from client
						 13  SQL*Net roundtrips to/from client
						  0  sorts (memory)
						  0  sorts (disk)
						180  rows processed

		Case 6:
		
			SQL> set autotrace on;
			SQL> select * from sales s, customers c where s.cust_id = c.cust_id and s.cust_id = 987;
			
				K·∫øt qu·∫£ c√≥ log r·∫•t d√†i

		Case 7:
		
			select s.prod_id
			from sales s, customers c
			where s.cust_id = c.cust_id;

			select * from v$sql;

			select * from v$sql where sql_text like '%SELECT s.prod_id
														FROM sales s, customers c
															WHERE s.cust_id = c.cust_id%';
										
			select * from v$sql where sql_text like '%SELECT s.prod_id FROM sales s, customers c WHERE s.cust_id = c.cust_id%';

			SELECT /* my query */ s.prod_id
			FROM sales s, customers c
			WHERE s.cust_id = c.cust_id;

			select * from v$sql where sql_text like '%my_query%';

			select * from v$sql_plan where sql_id = '599vq9ss0qzv6';

			select * from table(dbms_xplan.display_cursor('599vq9ss0qzv6'));
			
		Case 8:
		
			SELECT /* my query*/ p.prod_id, p.prod_name, s.amount_sold, s.quantity_sold
			FROM sales s, products p
			WHERE s.prod_id = p.prod_id
			and p.prod_id = 13;

			select * from v$sql where sql_text like '%my query%';
				 
			select * from table(dbms_xplan.display_cursor('0a5k2fj0yfs40'));
			
				SQL_ID  0a5k2fj0yfs40, child number 0
				-------------------------------------
				SELECT /* my query*/ p.prod_id, p.prod_name, s.amount_sold, 
				s.quantity_sold FROM sales s, products p WHERE s.prod_id = p.prod_id 
				and p.prod_id = 13
				 
				Plan hash value: 662052938
				 
				------------------------------------------------------------------------------------------------------------------------------
				| Id  | Operation                                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
				------------------------------------------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT                            |                |       |       |   362 (100)|          |       |       |
				|   1 |  NESTED LOOPS                               |                |  6002 |   246K|   362   (1)| 00:00:01 |       |       |
				|   2 |   TABLE ACCESS BY INDEX ROWID               | PRODUCTS       |     1 |    30 |     1   (0)| 00:00:01 |       |       |
				|*  3 |    INDEX UNIQUE SCAN                        | PRODUCTS_PK    |     1 |       |     0   (0)|          |       |       |
				|   4 |   PARTITION RANGE ALL                       |                |  6002 | 72024 |   362   (1)| 00:00:01 |     1 |    28 |
				|   5 |    TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES          |  6002 | 72024 |   362   (1)| 00:00:01 |     1 |    28 |
				|   6 |     BITMAP CONVERSION TO ROWIDS             |                |       |       |            |          |       |       |
				|*  7 |      BITMAP INDEX SINGLE VALUE              | SALES_PROD_BIX |       |       |            |          |     1 |    28 |
				------------------------------------------------------------------------------------------------------------------------------
				 
				Predicate Information (identified by operation id):
				---------------------------------------------------
				 
				   3 - access("P"."PROD_ID"=13)
				   7 - access("S"."PROD_ID"=13)
					   filter("S"."PROD_ID"="P"."PROD_ID")
				 
		Case 9:
		
			explain plan for
			SELECT p.pro_id, p.prod_name, s.amount_sold, s.quantity_sold
			FROM sales s, products p, customers c
			WHERE s.pro_id = p.prod_id
			and s.CUST_ID =  c.CUST_ID
			and s.cust_id between 2 and 5;

			select * from table(dbms_xplan.display());

				Plan hash value: 662052938
				 
				------------------------------------------------------------------------------------------------------------------------------
				| Id  | Operation                                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     | Pstart| Pstop |
				------------------------------------------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT                            |                |  6002 |   246K|   362   (1)| 00:00:01 |       |       |
				|   1 |  NESTED LOOPS                               |                |  6002 |   246K|   362   (1)| 00:00:01 |       |       |
				|   2 |   TABLE ACCESS BY INDEX ROWID               | PRODUCTS       |     1 |    30 |     1   (0)| 00:00:01 |       |       |
				|*  3 |    INDEX UNIQUE SCAN                        | PRODUCTS_PK    |     1 |       |     0   (0)| 00:00:01 |       |       |
				|   4 |   PARTITION RANGE ALL                       |                |  6002 | 72024 |   362   (1)| 00:00:01 |     1 |    28 |
				|   5 |    TABLE ACCESS BY LOCAL INDEX ROWID BATCHED| SALES          |  6002 | 72024 |   362   (1)| 00:00:01 |     1 |    28 |
				|   6 |     BITMAP CONVERSION TO ROWIDS             |                |       |       |            |          |       |       |
				|*  7 |      BITMAP INDEX SINGLE VALUE              | SALES_PROD_BIX |       |       |            |          |     1 |    28 |
				------------------------------------------------------------------------------------------------------------------------------
				 
				Predicate Information (identified by operation id):
				---------------------------------------------------
				 
				   3 - access("P"."PROD_ID"=13)
				   7 - access("S"."PROD_ID"=13)
					   filter("S"."PROD_ID"="P"."PROD_ID")

--- Table & Index Access Paths:

	- T√¨m hi·ªÉu:
	
		B-TREE indexes v√† BITMAP indexes
		
		Table access paths va index access paths
		
			Table access paths:
			
				Table access full
				
				Table access by rowid
				
				Sample table scan
				
			Index access paths:
			
				Index unique scan
				
				Index range scan
				
				Index full scan
				
				Index fast full scan
				
				Index skip scan
				
				Index join scan
				
				Index organized tables
				
				Bitmap access paths
				
	Table & Index Access Paths - Table access paths va index access paths:
	
		Table Access Paths (C√°ch truy c·∫≠p b·∫£ng)

			Table Access Paths l√† c√°ch Oracle ƒë·ªçc d·ªØ li·ªáu tr·ª±c ti·∫øp t·ª´ b·∫£ng. C√≥ ba lo·∫°i ch√≠nh:

				Table access full (Full Table Scan ‚Äì FTS)

					√ù nghƒ©a: Oracle qu√©t to√†n b·ªô b·∫£ng t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi ƒë·ªÉ l·∫•y d·ªØ li·ªáu.

					Khi n√†o x·∫£y ra:

						Kh√¥ng c√≥ index ph√π h·ª£p v·ªõi ƒëi·ªÅu ki·ªán WHERE.

						Truy v·∫•n y√™u c·∫ßu h·∫ßu h·∫øt d·ªØ li·ªáu trong b·∫£ng.

						B·∫£ng nh·ªè, full scan ƒë√¥i khi nhanh h∆°n d√πng index.

					∆Øu/Nh∆∞·ª£c:

						‚úÖ D·ªÖ th·ª±c hi·ªán.

						‚ùå Ch·∫≠m n·∫øu b·∫£ng l·ªõn v√¨ ph·∫£i ƒë·ªçc t·∫•t c·∫£ d·ªØ li·ªáu.

			Table access by rowid

				√ù nghƒ©a: Oracle bi·∫øt ch√≠nh x√°c v·ªã tr√≠ v·∫≠t l√Ω (ROWID) c·ªßa b·∫£n ghi, n√™n truy c·∫≠p nhanh h∆°n full scan.

				Khi n√†o x·∫£y ra:

					Th∆∞·ªùng d√πng k·∫øt h·ª£p v·ªõi index: index t√¨m ƒë∆∞·ª£c ROWID, r·ªìi Oracle d√πng ROWID ƒë·ªÉ truy c·∫≠p b·∫£ng.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ R·∫•t nhanh v√¨ truy c·∫≠p tr·ª±c ti·∫øp b·∫±ng ROWID.

					‚ùå C·∫ßn c√≥ index t√¨m ƒë∆∞·ª£c ROWID tr∆∞·ªõc.

			Sample table scan

				√ù nghƒ©a: Oracle ƒë·ªçc ng·∫´u nhi√™n m·ªôt ph·∫ßn d·ªØ li·ªáu trong b·∫£ng (v√≠ d·ª• 10% b·∫£n ghi).

				Khi n√†o x·∫£y ra:

					Th∆∞·ªùng d√πng trong th·ªëng k√™, th·ª≠ nghi·ªám query, ho·∫∑c ph√¢n t√≠ch d·ªØ li·ªáu m·∫´u.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Ti·∫øt ki·ªám th·ªùi gian, gi·∫£m I/O.

					‚ùå Kh√¥ng tr·∫£ v·ªÅ t·∫•t c·∫£ d·ªØ li·ªáu.			
					
		Index Access Paths (C√°ch truy c·∫≠p th√¥ng qua index)

			Index Access Paths l√† c√°ch Oracle d√πng ch·ªâ m·ª•c ƒë·ªÉ t√¨m d·ªØ li·ªáu m√† kh√¥ng c·∫ßn qu√©t to√†n b·ªô b·∫£ng.

			Index unique scan

				√ù nghƒ©a: Truy c·∫≠p m·ªôt b·∫£n ghi duy nh·∫•t th√¥ng qua unique index (v√≠ d·ª•: primary key).

				Khi n√†o x·∫£y ra:

					ƒêi·ªÅu ki·ªán WHERE s·ª≠ d·ª•ng unique column.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Nhanh nh·∫•t, ch·ªâ m·ªôt b·∫£n ghi ƒë∆∞·ª£c ƒë·ªçc.

			Index range scan

				√ù nghƒ©a: Truy c·∫≠p m·ªôt ph·∫°m vi c√°c gi√° tr·ªã trong index.

				Khi n√†o x·∫£y ra:

					WHERE col BETWEEN x AND y, ho·∫∑c col > x AND col < y.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Hi·ªáu qu·∫£ khi ch·ªâ c·∫ßn m·ªôt ph·∫ßn d·ªØ li·ªáu.

					‚ùå Kh√¥ng nhanh b·∫±ng unique scan n·∫øu ph·∫°m vi qu√° r·ªông.

			Index full scan

				√ù nghƒ©a: Oracle qu√©t to√†n b·ªô index t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi.

				Khi n√†o x·∫£y ra:

					D·ªØ li·ªáu c·∫ßn nhi·ªÅu ho·∫∑c index nh·ªè h∆°n b·∫£ng.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ √çt t·ªën I/O h∆°n full table scan n·∫øu index nh·ªè.

					‚ùå Ch·∫≠m h∆°n range scan n·∫øu ch·ªâ c·∫ßn m·ªôt ph·∫ßn d·ªØ li·ªáu.

			Index fast full scan

				√ù nghƒ©a: Qu√©t to√†n b·ªô index nhanh h∆°n index full scan, v√¨ ƒë·ªçc theo block, kh√¥ng theo th·ª© t·ª± index.

				Khi n√†o x·∫£y ra:

					Khi query c·∫ßn t·∫•t c·∫£ gi√° tr·ªã c·ªßa m·ªôt ho·∫∑c v√†i c·ªôt trong index.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ R·∫•t nhanh v·ªõi index nh·ªè.

			Index skip scan

				√ù nghƒ©a: Oracle b·ªè qua m·ªôt v√†i ph√¢n v√πng trong index, d√πng khi column ƒë·∫ßu ti√™n c·ªßa index kh√¥ng ƒë∆∞·ª£c filter.

				Khi n√†o x·∫£y ra:

					Index composite (nhi·ªÅu c·ªôt), nh∆∞ng filter ch·ªâ d√πng c·ªôt th·ª© 2, th·ª© 3.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Cho ph√©p d√πng index d√π kh√¥ng filter c·ªôt ƒë·∫ßu.

					‚ùå Ch·∫≠m h∆°n range scan.

			Index join scan

				√ù nghƒ©a: Oracle truy c·∫≠p index c·ªßa hai b·∫£ng c√πng l√∫c ƒë·ªÉ join, kh√¥ng c·∫ßn table scan.

				Khi n√†o x·∫£y ra:

					Query JOIN hai b·∫£ng, c·∫£ hai c√≥ index.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Ti·∫øt ki·ªám I/O so v·ªõi join b·∫±ng full table scan.

			Index organized tables (IOT)

				√ù nghƒ©a: B·∫£ng ƒë∆∞·ª£c l∆∞u trong c·∫•u tr√∫c index thay v√¨ l∆∞u ri√™ng b·∫£ng + index.

				Khi n√†o x·∫£y ra:

					B·∫£ng nh·ªè, ho·∫∑c c·∫ßn truy c·∫≠p theo primary key r·∫•t nhanh.

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Truy c·∫≠p theo key c·ª±c nhanh.

					‚ùå Kh√¥ng linh ho·∫°t nh∆∞ b·∫£ng b√¨nh th∆∞·ªùng.

			Bitmap access paths

				√ù nghƒ©a: S·ª≠ d·ª•ng bitmap index ƒë·ªÉ t√¨m d·ªØ li·ªáu, ph√π h·ª£p v·ªõi c·ªôt c√≥ √≠t gi√° tr·ªã kh√°c nhau (low cardinality).

				Khi n√†o x·∫£y ra:

					C·ªôt gender, tr·∫°ng th√°i, lo·∫°i‚Ä¶

				∆Øu/Nh∆∞·ª£c:

					‚úÖ Hi·ªáu qu·∫£ v·ªõi query nhi·ªÅu ƒëi·ªÅu ki·ªán AND/OR.

					‚ùå Kh√¥ng th√≠ch h·ª£p b·∫£ng th∆∞·ªùng xuy√™n UPDATE/INSERT v√¨ bitmap index t·ªën t√†i nguy√™n.					
						
	Table & Index Access Paths - Index ‚Äút√¨m ƒë∆∞·ª£c ROWID‚Äù nghƒ©a l√† g√¨?

		ROWID l√† g√¨?

			ROWID l√† m√£ ƒë·ªãnh danh duy nh·∫•t cho m·ªói b·∫£n ghi trong b·∫£ng.

			N√≥ cho bi·∫øt v·ªã tr√≠ v·∫≠t l√Ω c·ªßa b·∫£n ghi tr√™n ·ªï ƒëƒ©a, g·ªìm: datafile, block, row trong block.

			V√≠ d·ª•: AAABBBCCC ‚Äì Oracle bi·∫øt ngay b·∫£n ghi n·∫±m ·ªü ƒë√¢u trong b·∫£ng, kh√¥ng c·∫ßn qu√©t to√†n b·ªô b·∫£ng.

			N√≥i n√¥m na: ROWID gi·ªëng nh∆∞ ‚Äúƒë·ªãa ch·ªâ nh√†‚Äù c·ªßa m·ªói b·∫£n ghi.	
					
		Index ‚Äút√¨m ƒë∆∞·ª£c ROWID‚Äù nghƒ©a l√† g√¨?

			Khi b·∫°n t·∫°o index tr√™n m·ªôt c·ªôt (ho·∫∑c nhi·ªÅu c·ªôt), Oracle kh√¥ng l∆∞u c·∫£ b·∫£n ghi trong index, m√† l∆∞u:
			
				gi√° tr·ªã c·ªôt + ROWID c·ªßa b·∫£n ghi t∆∞∆°ng ·ª©ng

			V√≠ d·ª•: b·∫£ng employees(id, name, dept) c√≥ index tr√™n id:

				id		ROWID
				
				101		AAA111
				102		AAA112
				103		AAA113

			Khi b·∫°n query:

				SELECT * FROM employees WHERE id = 102;


				Oracle t√¨m trong index id gi√° tr·ªã 102.

				Index tr·∫£ v·ªÅ ROWID = AAA112.

				Oracle d√πng ROWID n√†y ƒë·ªÉ truy c·∫≠p tr·ª±c ti·∫øp b·∫£n ghi trong b·∫£ng (table access by rowid).

			∆Øu ƒëi·ªÉm: nhanh, v√¨ kh√¥ng ph·∫£i qu√©t b·∫£ng, ch·ªâ c·∫ßn ‚Äúƒëi th·∫≥ng ƒë·∫øn ƒë·ªãa ch·ªâ nh√†‚Äù c·ªßa b·∫£n ghi.					
					
	- Code sql:

		Case 1 (table access full):
		
			###
			select * from sales;

			select * from sales where amount_sold > 1770; # full table vi khong co condition cho index

			select * from employees where employee_id > 100; # full table vi bang qua nho nen khong can dung index

			###
			explain plan for
			select * from employees e, departments d
			where e.employee_id = d.manager_id;

			select * from table (dbms_xplan.display()); # full table cho ca 2 bang

			###
			explain plan for
			select * from employees e, departments d
			where e.department_id = d.department_id;

			select * from table(dbms_xplan.display()); # index scan cho bang departments vi department_id la khoa ngoai tro toi bang departments

				Plan hash value: 1343509718
				 
				--------------------------------------------------------------------------------------------
				| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
				--------------------------------------------------------------------------------------------
				|   0 | SELECT STATEMENT             |             |   106 |  9540 |     6  (17)| 00:00:01 |
				|   1 |  MERGE JOIN                  |             |   106 |  9540 |     6  (17)| 00:00:01 |
				|   2 |   TABLE ACCESS BY INDEX ROWID| DEPARTMENTS |    27 |   567 |     2   (0)| 00:00:01 |
				|   3 |    INDEX FULL SCAN           | DEPT_ID_PK  |    27 |       |     1   (0)| 00:00:01 |
				|*  4 |   SORT JOIN                  |             |   107 |  7383 |     4  (25)| 00:00:01 |
				|   5 |    TABLE ACCESS FULL         | EMPLOYEES   |   107 |  7383 |     3   (0)| 00:00:01 |
				--------------------------------------------------------------------------------------------
				 
				Predicate Information (identified by operation id):
				---------------------------------------------------
				 
				   4 - access("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
					   filter("E"."DEPARTMENT_ID"="D"."DEPARTMENT_ID")
		Case 2 (Table Access by ROWID):
		
			select * from sales where prod_id = 116 and cust_id = 100090; # 2 bitmap index scans tren SALES_CUST_BIX va SALES_PROD_BIX

			select * from sales where rowid = 'AAAR3DAAMAAAA5MAHl';

			create index prod_cust_ix on sales (prod_id, cust_id);

			select prod_id, cust_id from sales where prod_id = 116; # index range scan, but did not use ROWIDs and read from the table

			select prod_id, cust_id, promo_id from sales where prod_id = 116; # table access by rowid
			
				Adding the promo_id column does not increase the performance. It actually decreases as we saw in the
				example. As explained in the example, if we just write the prod_id and cust_id columns, as these two
				columns are already stored in the index, there is no need to go to the table, so no need to use the
				rowids. However, when we add the promo_id column, as this column does not exist in the index, it uses
				the rowids to go to the table and get the whole row data and extract the promo_id from the actual table.

			drop index prod_cust_ix;


		Case 3 (Index Unique Scan):
					
			select * from employees where employee_id = 103; # index unique scan EMP_EMP_ID_PK
			
		Cse 4 (Index Range Scan):
		
			select * from sales where time_id > to_date('01-NOV-01', 'DD-MON-RR'); # index range scan SALES_TIME_BIX

			select * from sales where time_id between to_date('01-NOV-00', 'DD-MON-RR') and to_date('05-NOV-00', 'DD-MON-RR'); # index range scan SALES_TIME_BIX

			select * from employees where employee_id > 190; # index range scan EMP_EMP_ID_PK

			select * from employees where department_id > 80; # index range scan EMP_EMP_ID_PK

			select * from employees where employee_id > 190 order by email; # index range scan EMP_EMP_ID_PK, perform sort

			select * from employees where employee_id > 190 order by employee_id; # index range scan EMP_EMP_ID_PK, did not perform sort, because it is already sorted

			select * from employees where employee_id < 190 order by employee_id; # index range scan EMP_EMP_ID_PK, did not perform sort, because it is already sorted

			select * from employees where department_id > 80 order by department_id desc; # index range scan EMP_EMP_ID_PK, did not perform sort

			select * from employees where department_id > 80 order by department_id; # index range scan EMP_EMP_ID_PK, did not perform sort

			select * from employees where department_id > 80 order by department_id desc; # index range scan EMP_EMP_ID_PK, did not perform sort

			select * from products where prod_subcategory like 'Accessories%'; # index range scan PRODUCTS_PROD_SUBCAT_IX

			select * from products where prod_subcategory like '%Accessories'; # full table scan PRODUCTS

			select * from products where prod_subcategory like '%Accessories%'; # full table scan PRODUCTS
			
		Case 5 (Index Full Scan):

			select * from departments order by department_id; # index full scan DEPT_ID_PK

			select last_name, first_name from employees order by last_name; # index full scan EMP_NAME_IX

			select first_name, last_name from employees order by last_name; # index full scan EMP_NAME_IX

			select last_name, first_name from employees order by first_name; # index full scan EMP_NAME_IX, sort. because the index sorted based on the last name

			select last_name, first_name from employees order by first_name, last_name; # index full scan EMP_NAME_IX, sort

			select last_name, first_name from employees order by last_name, first_name; # index full scan EMP_NAME_IX

			select last_name, first_name from employees order by last_name, salary; # full table scan, sort

			select * from employees order by last_name, first_name; # full table scan, sort

			select salary, count(*) from employees e # full table scan, using a column with no index leads a full table scan
			where salary is not null
			group by salary;

			select department_id, count(*) from employees e # index full scan, sort since we use indexed columns in the group by clause
			where department_id is not null
			group by department_id;

			select department_id, manager_id, count(*) from employees e # full table scan, using more columns than one index has may prevent index full scan
			where department_id is not null
			group by department_id, manager_id;

			select e.employee_id, e.last_name, e.first_name, e.department_id, d.department_name # index full scan DEPT_ID_PK
			from employees e, departments d
			where e.department_id = d.department_id;		
		
		Case 6 (Index Fast Full Scan):

			###
			select e.employee_id, d.department_id, e.first_name, d.department_name # index full scan DEPT_ID_PK, sort
			from employees e, departments d
			where e.department_id = d.department_id;

			###
			select e.employee_id, d.department_id, d.department_name # index fast full scan EMP_EMP_ID_PK, EMP_DEPARTMENT_IX, since all the columns are in the index
			from employees e, departments d
			where e.department_id = d.department_id;


			###
			select prod_id from sales order by prod_id; # bitmap index fast full scan SALES_PROD_BIX

			###
			select time_id from sales order by time_id; # index full scan SALES_TIME_BIX

			###
			select time_id from sales; # bitmap index fast full scan SALES_TIME_BIX		
					
		Case 7 (Index Skip Scan):
		
			###
			select * from employees where first_name = 'Alex'; # index skip scan EMP_NAME_IX

			###
			select * from employees where last_name = 'King' # index range scan EMP_NAME_IX, we use the first column of the index

			###
			select * from employees where salary between 6000 and 7000; # full table scan EMPLOYEES

			###
			create index dept_sal_ix on employees (department_id, salary);
			select * from employees where salary between 6000 and 7000; # index skip scan DEPT_SAL_IX

			###
			select * from employees where salary between 6500 and 7000; # index skip scan DEPT_SAL_IX

			###
			drop index dept_sal_ix;
			select * from employees where salary between 6500 and 7000; # full table scan EMPLOYEES

			###
			alter index customers_yob_bix invisible;
			select * from customers where cust_year_of_birth between 1989 and 1990; # full table scan CUSTOMERS

			###
			create index customers_gen_dob_ix on customers (cust_gender, cust_year_of_birth);
			select * from customers where cust_year_of_birth between 1989 and 1990; # index skip scan CUSTOMERS_GEN_DOB_IX
			drop index customers_gen_dob_ix;
			alter index customers_yob_bix visible;
					
		Case 8 (Index Join Scan):

			/* Index join scan with two indexes */
			select employee_id, email from employees; ## index fast full scan EMP_EMAIL_UK, EMP_EMP_ID_PK, hash join

			/* Index join scan with two indexes, but with range scan included */
			select last_name, email from employees where last_name like 'B%'; # index full scan EMP_EMAIL_UK, index range scan EMP_NAME_IX, hash join

			/* Index join scan is not performd when we add rowid to the select clause */
			select rowid, employee_id, email from employees; # full table scan		
					
--- Optimizer Hints:

	- Code sql:
	
		Case 1:
		
			/* A query without a hint. It performs a range scan */
			select employee_id, last_name # index range scan EMP_NAME_IX
			from employees e
			where last_name like 'A%';

			/* Using a hint to command the optimizer to use full table scan */
			select /*+ full(e) */ employee_id, last_name # full table scan EMPLOYEES
			from employees e
			where last_name like 'A%';

			/* Using the hint with the table name as the parameter */
			select /*+ full(employees) */ employee_id, last_name # full table scan EMPLOYEES
			from employees
			where last_name like 'A%';

			/* Using the hint with the table name when it has an alias */
			select /*+ full(employees) */ employee_id, last_name # index range scan EMP_NAME_IX
			from employees e
			where last_name like 'A%'

			/* Using an unreasonable hint. The optimizer will not consider this hint */
			select /*+ index(e EMP_DEPARTMENT_IX) */ employee_id, last_name # index range scan EMP_NAME_IX since it is lass constly than the full table scan
			from employees e
			where last_name like 'A%'

			/* Using mutiple hints. but they aim for the same source. So, unresonable.
			   The optimizer picks the index scan as the best choice */
			select /* index(e EMP_NAME_IX) full(e) */ employee_id, last_name # index range scan EMP_NAME_IX
			from employees e
			where last_name like 'A%'

			/* Changing the order of the hints. It dose not change the optimizer's decision */
			select /*+ full(e) index(e EMP_NAME_IX) */ employee_id, last_name # index range scan EMP_NAME_IX
			from employees e
			where last_name like 'A%'

			/* Using no hint to see the execution plan to compare with the next one */
			select e.department_id, d.department_name, MAX(salary), AVG(salary) # full table scan EMPLOYEES, DEPARTMENTS
			from employees e, departments d
			where e.department_id = e.department_id
			group by e.department_id, d.department_name

			/* Using multiple hint to change the execution plan */
			select /* leading (e d) index(d DEPT_ID_PK) index(e EMP_DEPARTMENT_IX) */ # index full scan DEPT_ID_PK, EMP_DEPARTMENT_IX
			e.department_id, d.department_name, MAX(salary), AVG(salary)
			from employees e, departments d
			where e.department_id = e.department_id
			group by e.department_id, d.department_name

			/* There are two access paths: job_id and department_id.
			   It will select the access path which has the lowest cost.*/
			select employee_id, last_name # index range scan EMP_JOB_IX
			from employees e
			where job_id = 'SA_MAN'
			and department_id < 90;

			/* Since we use the hint, it will use the index even if the cost is a lot higher */
			select /*+ index(e EMP_DEPARTMENT_IX) */ employee_id, last_name # index range scan EMP_DEPARTMENT_IX
			from employees e
			where job_id = 'SA_MAN'
			and department_id < 90;

			/* It will not select the index we specified with the hint since there is no access path for it. */
			select /*+ index(e EMP_DEPARTMENT_IX) */ employee_id, last_name # index range scan EMP_JOB_IX
			from employees e
			where job_id = 'SA_MAN'

			/* Another example with mutiple joins, groups, etc. But with no hint */
			select customers.cust_first_name, customers.cust_last_name,
				max(quantity_sold), avg(quantity_sold)
			from sales, customers
			where sales.cust_id = customers.cust_id
			group by customers.cust_first_name, customers.cust_last_name;

			/* Performance effect of using the parallel hint */
			select /*+ parallel(4) */ customers.cust_first_name, customers.cust_last_name,
				max(quantity_sold), avg(quantity_sold)
			from sales, customers
			where sales.cust_id = customers.cust_id
			group by customers.cust_first_name, customers.cust_last_name;
					
--- Join Operations:

	-  T√¨m hi·ªÉu:
	
		Join method v√† join oder
		
		join methods:
		
			nested loop join, sort merge join, hash join, cartesian join
			
	- Code sql:
	
		Case 1 (Nested Loop Joins):
		
			/* Nested loop join example */
			select * from employees e join departments d # nested loop join
			on d.department_id = e.department_id
			where d.department_id = 60

			/* even if we change the join order and on clause order, the plan did not change */
			select * from departments d join employees e # nested loop join
			on e.department_id = d.department_id
			where d.department_id = 60

			/* We can you leading hint to change the driving table */
			select /*+ leading(e) */ * from employees e join departments d # index uniqye scan DEPT_ID_PK, index range scan EMP_DEPARTMENT_IX, merge join
			on d.department_id = e.department_id
			where d.department_id = 60

			/* Does not use nested loop without hint */
			select * from employees e join departments d # table access full EMPLOYEES, index full scan DEPT_ID_PK, merge join
			on d.department_id = e.department_id

			/* Using nested loop hint */
			select /*+ use_nl(d e) */ * from employees e join departments d # table access by rowid EMPLOYEES, index range scan EMP_DEPARTMENT_IX, nested loop
			on d.department_id = e.department_id

			/* Nested loop prefetching and double nested loops example */
			select e.employee_id, e.last_name, d.department_id, d.department_name # table access by rowid EMPLOYEES, table access full EMPLOYEES, index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loop
			from employees e join departments d
			on d.department_id = e.department_id
			where d.department_name like 'A%'
			
		Case 2 (Sort Merge Joins):
		
			/* sort merge join example */
			select * from employees e join departments d # index range scan EMP_NAME_IX, index full scan DEPT_ID_PK, sort, merge join
			on d.department_id = e.department_id
			where e.last_name like 'K%'

			/* Force it to use nested loop join */
			select /*+ use_nl(e d) */* from employees e join departments d # table access by rowid DEPARTMENTS, index unique scan DEPT_ID_PK, INDEX RANGE SCAN emp_name_ix, nested loop
			on d.department_id = e.department_id
			where e.last_name like 'K%'

			/* Another sort merge join example */
			select * from employees e join departments d # table access full EMPLOYEES, sort, index full scan DEPT_ID_PK, merge join
			on d.department_id = e.department_id
			where d.manager_id > 110;

			/* Equality operator prevented sort merge join */
			select * from employees e join departments d # table access by rowid EMPLOYEES, index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops
			on d.department_id = e.department_id
			where d.manager_id = 110

			/* Using sort merge join hint */
			select /*+ use_merge(e d) */* from employees e join departments d # table access full EMPLOYEES, sort, index full scan DEPT_ID_PK, table access by rowid DEPARTMENTS, merge join
			on d.department_id = e.department_id
			where d.manager_id = 110
			
		Case 3 (Hash Joins):
		
			grant select_catalog_role to hr;
			grant select any dictionary to hr;

			select * from employees e, departments d # table access full EMPLOYEES, table access by rowid EMPLOYEES, index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops
			where d.department_id = e.department_id
			and d.manager_id = 10

			select /*+ use_hash(d e) */* from employees e, departments d # table access full EMPLOYEES, DEPARTMENTS, hash join
			where d.department_id = e.department_id
			and d.manager_id = 110
			
		Case 4 (Cartesian Joins):
			
			select * from employees e, departments d # table access full EMPLOYEES, table access full DEPARTMENTS, merge join cartesian
			where d.manager_id = 110

			select * from customers, sales # table access SALES, sort, table access CUSTOMERS, merger join cartesian
			
		Case 5 (Equijoins & Nonequijoins):
		
			/* Equijoin example */
			select * from employees e, departments d # table access full EMPLOYEES, sort join, index full scan DEPT_ID_PK, merge join
			where e.department_id = d.department_id

			/* Nonequijoin examample */
			select * from employees e, jobs j # table access full EMPLOYEES, sort join, table accces full JOBS, sort join, merge join
			where e.salary between j.min_salary and j.max_salary
			
		Case 6 (Outer Joins):
		
			select * from employees e right outer join departments d # table access full EMPLOYEES, sort join, index full scan DEPT_ID_PK, table access by rowid DEPARTMENTS, merge join
			using(department_id)

			select * from departments d left outer join employees e # table access full EMPLOYEES, sort join, index full scan DEPT_ID_PK, table access by rowid DEPARTMENTS, merge join
			using(department_id)

			select * from employees e left outer join departments d # table access full EMPLOYEES, DEPARTMENTS, hash join right outer
			using(department_id)

			select * from departments d right outer join employees e # table access full EMPLOYEES, DEPARTMENTS, hash join right outer
			using(department_id)

			select /*+ use_merge(e d) */* from employees e left outer join departments d # table access full DEPARTMENTS, sort join, table access full EMPLOYEES, sort join, merge join outer
			using(department_id)

			select /*+ use_nl(e d) */* from employees e left outer join departments d # index unique scan DEPT_ID_PK, table access by rowid DEPARTMENTS, table access full EMPLOYEES, nested loops outer
			using(department_id)

			select /*+ use_nl(d e) */* from employees e right outer join departments d # index range scan EMP_dEPARTMENT_IX, table access by index rowid batched EMPLOYEES, table access full DEPARTMENTS, nested loops
			using(department_id)

			select * from employees e full outer join departments d # table access full EMPLOYEES, DEPARTMENTS, hash join full outer
			using(department_id)

			select * from employees e, departments d # table access full EMPLOYEES, DEPARTMENTS, hash join right outer
			where e.department_id = d.department_id(+)

			select * from employees e, departments d
			where e.department_id(+) = d.department_id(+)

			select * from employees e left outer join departments d # index full scan DEPT_ID_PK, merge join outer, table access full EMPLOYEES, DEPARTMENTS, HASH JOIN RIGHT OUTER, UNION-ALL, SORT UNIQUE
			using(department_id)
			union
			select * from employees e right outer join departments d
			using(department_id)
			
		Case 7 (Semijoins):
		
			select * from departments d where exists # index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops semi
				(select 1 from employees e where d.department_id = e.department_id)
				
			select * from departments d where department_id in # index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops semi
				(select department_id from employees e where d.department_id = e.department_id)
				
			select * from employees e where exists # table access full EMPLOYEES
				(select 1 from departments d where d.department_id = e.department_id)
				
		Case 8 (Antijoins):
		
			select * from departments d where department_id not in # index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loop anti
				(select department_id from employees e where d.department_id = e.department_id)
				
			select * from departments d where not exists # index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops anti
				(select 1 from employees e where d.department_id = e.department_id)
				
			select /*+ hash_aj */* from departments d where not exists # index range scan EMP_DEPARTMENT_IX, table access full DEPARTMENTS, nested loops anti
				(select 1 from employees e where d.department_id = e.department_id)
				
			select * from departments d where not exists # index full scan EMP_DEPARTMENT_IX, table access full departments, hash join anti
				(select /*+ hash_aj */1 from employees e where d.department_id = e.department_id)
				
			select * from employees e where not exists # table access full EMPLOYEES
				(select 1 from departments d where d.department_id = e.department_id)